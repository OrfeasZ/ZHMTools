/*
 * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing.
 *
 * If you wish to regenerate this file because of a game update use the ZHMTools CodeGen tool:
 * https://github.com/OrfeasZ/ZHMTools/releases
 */

#include "ZHMGen.h"
#include "ZHMProperties.h"
#include "ZHMEnums.h"
#include <External/simdjson_helpers.h>

ZHMTypeInfo AnimationEventDataTypes_SBlend::TypeInfo = ZHMTypeInfo("AnimationEventDataTypes.SBlend", sizeof(AnimationEventDataTypes_SBlend), alignof(AnimationEventDataTypes_SBlend), AnimationEventDataTypes_SBlend::WriteJson, AnimationEventDataTypes_SBlend::WriteSimpleJson, AnimationEventDataTypes_SBlend::FromSimpleJson, AnimationEventDataTypes_SBlend::Serialize, AnimationEventDataTypes_SBlend::Equals);

void AnimationEventDataTypes_SBlend::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fBlendTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fBlendTime);
	p_Stream << "}";

	p_Stream << "}";
}

void AnimationEventDataTypes_SBlend::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fBlendTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fBlendTime);

	p_Stream << "}";
}

void AnimationEventDataTypes_SBlend::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AnimationEventDataTypes_SBlend s_Object {};

	s_Object.m_fBlendTime = simdjson::from_json_float32(p_Document["m_fBlendTime"]);

	*reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Target) = s_Object;
}

void AnimationEventDataTypes_SBlend::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Object);

}

bool AnimationEventDataTypes_SBlend::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationEventDataTypes_SBlend::operator==(const AnimationEventDataTypes_SBlend& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationEventDataTypes_SBlend>)
		return false;

	if (m_fBlendTime != p_Other.m_fBlendTime) return false;

	return true;
}

ZHMTypeInfo AnimationEventDataTypes_SLegacy::TypeInfo = ZHMTypeInfo("AnimationEventDataTypes.SLegacy", sizeof(AnimationEventDataTypes_SLegacy), alignof(AnimationEventDataTypes_SLegacy), AnimationEventDataTypes_SLegacy::WriteJson, AnimationEventDataTypes_SLegacy::WriteSimpleJson, AnimationEventDataTypes_SLegacy::FromSimpleJson, AnimationEventDataTypes_SLegacy::Serialize, AnimationEventDataTypes_SLegacy::Equals);

void AnimationEventDataTypes_SLegacy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << "}";

	p_Stream << "}";
}

void AnimationEventDataTypes_SLegacy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);

	p_Stream << "}";
}

void AnimationEventDataTypes_SLegacy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AnimationEventDataTypes_SLegacy s_Object {};

	s_Object.m_nEventID = simdjson::from_json_int32(p_Document["m_nEventID"]);

	*reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Target) = s_Object;
}

void AnimationEventDataTypes_SLegacy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Object);

}

bool AnimationEventDataTypes_SLegacy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationEventDataTypes_SLegacy::operator==(const AnimationEventDataTypes_SLegacy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationEventDataTypes_SLegacy>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;

	return true;
}

ZHMTypeInfo ZRuntimeResourceID::TypeInfo = ZHMTypeInfo("ZRuntimeResourceID", sizeof(ZRuntimeResourceID), alignof(ZRuntimeResourceID), ZRuntimeResourceID::WriteJson, ZRuntimeResourceID::WriteSimpleJson, ZRuntimeResourceID::FromSimpleJson, ZRuntimeResourceID::Serialize, ZRuntimeResourceID::Equals);

void ZRuntimeResourceID::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_IDHigh") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDHigh);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IDLow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDLow);
	p_Stream << "}";

	p_Stream << "}";
}

void ZRuntimeResourceID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_IDHigh") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDHigh);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IDLow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDLow);

	p_Stream << "}";
}

void ZRuntimeResourceID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRuntimeResourceID s_Object {};

	s_Object.m_IDHigh = simdjson::from_json_uint32(p_Document["m_IDHigh"]);

	s_Object.m_IDLow = simdjson::from_json_uint32(p_Document["m_IDLow"]);

	*reinterpret_cast<ZRuntimeResourceID*>(p_Target) = s_Object;
}

void ZRuntimeResourceID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Serializer.RegisterRuntimeResourceId(p_OwnOffset);
}

bool ZRuntimeResourceID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRuntimeResourceID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRuntimeResourceID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRuntimeResourceID::operator==(const ZRuntimeResourceID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRuntimeResourceID>)
		return false;

	if (m_IDHigh != p_Other.m_IDHigh) return false;
	if (m_IDLow != p_Other.m_IDLow) return false;

	return true;
}

ZHMTypeInfo AnimationTakeDataTypes_SGeneric::TypeInfo = ZHMTypeInfo("AnimationTakeDataTypes.SGeneric", sizeof(AnimationTakeDataTypes_SGeneric), alignof(AnimationTakeDataTypes_SGeneric), AnimationTakeDataTypes_SGeneric::WriteJson, AnimationTakeDataTypes_SGeneric::WriteSimpleJson, AnimationTakeDataTypes_SGeneric::FromSimpleJson, AnimationTakeDataTypes_SGeneric::Serialize, AnimationTakeDataTypes_SGeneric::Equals);

void AnimationTakeDataTypes_SGeneric::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fTest") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTest);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fResourceTest") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->m_fResourceTest, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void AnimationTakeDataTypes_SGeneric::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fTest") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTest);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fResourceTest") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->m_fResourceTest, p_Stream);

	p_Stream << "}";
}

void AnimationTakeDataTypes_SGeneric::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AnimationTakeDataTypes_SGeneric s_Object {};

	s_Object.m_fTest = simdjson::from_json_float32(p_Document["m_fTest"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["m_fResourceTest"], &s_Item);
		s_Object.m_fResourceTest = s_Item;
	}

	*reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Target) = s_Object;
}

void AnimationTakeDataTypes_SGeneric::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->m_fResourceTest, p_Serializer, p_OwnOffset + offsetof(AnimationTakeDataTypes_SGeneric, m_fResourceTest));
}

bool AnimationTakeDataTypes_SGeneric::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationTakeDataTypes_SGeneric::operator==(const AnimationTakeDataTypes_SGeneric& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationTakeDataTypes_SGeneric>)
		return false;

	if (m_fTest != p_Other.m_fTest) return false;
	if (m_fResourceTest != p_Other.m_fResourceTest) return false;

	return true;
}

ZHMTypeInfo BoneId::TypeInfo = ZHMTypeInfo("BoneId", sizeof(BoneId), alignof(BoneId), BoneId::WriteJson, BoneId::WriteSimpleJson, BoneId::FromSimpleJson, BoneId::Serialize, BoneId::Equals);

void BoneId::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void BoneId::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void BoneId::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	BoneId s_Object {};

	*reinterpret_cast<BoneId*>(p_Target) = s_Object;
}

void BoneId::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

}

bool BoneId::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<BoneId*>(p_Left);
	auto* s_Right = reinterpret_cast<BoneId*>(p_Right);

	return *s_Left == *s_Right;
}

bool BoneId::operator==(const BoneId& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<BoneId>)
		return false;


	return true;
}

ZHMTypeInfo IActor::TypeInfo = ZHMTypeInfo("IActor", sizeof(IActor), alignof(IActor), IActor::WriteJson, IActor::WriteSimpleJson, IActor::FromSimpleJson, IActor::Serialize, IActor::Equals);

void IActor::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IActor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IActor s_Object {};

	*reinterpret_cast<IActor*>(p_Target) = s_Object;
}

void IActor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);

}

bool IActor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActor*>(p_Left);
	auto* s_Right = reinterpret_cast<IActor*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActor::operator==(const IActor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActor>)
		return false;


	return true;
}

ZHMTypeInfo IActorProvider::TypeInfo = ZHMTypeInfo("IActorProvider", sizeof(IActorProvider), alignof(IActorProvider), IActorProvider::WriteJson, IActorProvider::WriteSimpleJson, IActorProvider::FromSimpleJson, IActorProvider::Serialize, IActorProvider::Equals);

void IActorProvider::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IActorProvider::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActorProvider::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IActorProvider s_Object {};

	*reinterpret_cast<IActorProvider*>(p_Target) = s_Object;
}

void IActorProvider::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);

}

bool IActorProvider::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActorProvider*>(p_Left);
	auto* s_Right = reinterpret_cast<IActorProvider*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActorProvider::operator==(const IActorProvider& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActorProvider>)
		return false;


	return true;
}

ZHMTypeInfo IActorProviderFilter::TypeInfo = ZHMTypeInfo("IActorProviderFilter", sizeof(IActorProviderFilter), alignof(IActorProviderFilter), IActorProviderFilter::WriteJson, IActorProviderFilter::WriteSimpleJson, IActorProviderFilter::FromSimpleJson, IActorProviderFilter::Serialize, IActorProviderFilter::Equals);

void IActorProviderFilter::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IActorProviderFilter::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActorProviderFilter::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IActorProviderFilter s_Object {};

	*reinterpret_cast<IActorProviderFilter*>(p_Target) = s_Object;
}

void IActorProviderFilter::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);

}

bool IActorProviderFilter::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActorProviderFilter*>(p_Left);
	auto* s_Right = reinterpret_cast<IActorProviderFilter*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActorProviderFilter::operator==(const IActorProviderFilter& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActorProviderFilter>)
		return false;


	return true;
}

ZHMTypeInfo IAnimPlayerEntity::TypeInfo = ZHMTypeInfo("IAnimPlayerEntity", sizeof(IAnimPlayerEntity), alignof(IAnimPlayerEntity), IAnimPlayerEntity::WriteJson, IAnimPlayerEntity::WriteSimpleJson, IAnimPlayerEntity::FromSimpleJson, IAnimPlayerEntity::Serialize, IAnimPlayerEntity::Equals);

void IAnimPlayerEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IAnimPlayerEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IAnimPlayerEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IAnimPlayerEntity s_Object {};

	*reinterpret_cast<IAnimPlayerEntity*>(p_Target) = s_Object;
}

void IAnimPlayerEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

}

bool IAnimPlayerEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IAnimPlayerEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IAnimPlayerEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IAnimPlayerEntity::operator==(const IAnimPlayerEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IAnimPlayerEntity>)
		return false;


	return true;
}

ZHMTypeInfo IAudioEmitter::TypeInfo = ZHMTypeInfo("IAudioEmitter", sizeof(IAudioEmitter), alignof(IAudioEmitter), IAudioEmitter::WriteJson, IAudioEmitter::WriteSimpleJson, IAudioEmitter::FromSimpleJson, IAudioEmitter::Serialize, IAudioEmitter::Equals);

void IAudioEmitter::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAudioEmitter*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IAudioEmitter::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAudioEmitter*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IAudioEmitter::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IAudioEmitter s_Object {};

	*reinterpret_cast<IAudioEmitter*>(p_Target) = s_Object;
}

void IAudioEmitter::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IAudioEmitter*>(p_Object);

}

bool IAudioEmitter::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IAudioEmitter*>(p_Left);
	auto* s_Right = reinterpret_cast<IAudioEmitter*>(p_Right);

	return *s_Left == *s_Right;
}

bool IAudioEmitter::operator==(const IAudioEmitter& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IAudioEmitter>)
		return false;


	return true;
}

ZHMTypeInfo IBodybagEntity::TypeInfo = ZHMTypeInfo("IBodybagEntity", sizeof(IBodybagEntity), alignof(IBodybagEntity), IBodybagEntity::WriteJson, IBodybagEntity::WriteSimpleJson, IBodybagEntity::FromSimpleJson, IBodybagEntity::Serialize, IBodybagEntity::Equals);

void IBodybagEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IBodybagEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBodybagEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBodybagEntity s_Object {};

	*reinterpret_cast<IBodybagEntity*>(p_Target) = s_Object;
}

void IBodybagEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);

}

bool IBodybagEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBodybagEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IBodybagEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBodybagEntity::operator==(const IBodybagEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBodybagEntity>)
		return false;


	return true;
}

ZHMTypeInfo IBoneAnimator::TypeInfo = ZHMTypeInfo("IBoneAnimator", sizeof(IBoneAnimator), alignof(IBoneAnimator), IBoneAnimator::WriteJson, IBoneAnimator::WriteSimpleJson, IBoneAnimator::FromSimpleJson, IBoneAnimator::Serialize, IBoneAnimator::Equals);

void IBoneAnimator::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IBoneAnimator::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBoneAnimator::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBoneAnimator s_Object {};

	*reinterpret_cast<IBoneAnimator*>(p_Target) = s_Object;
}

void IBoneAnimator::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

}

bool IBoneAnimator::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBoneAnimator*>(p_Left);
	auto* s_Right = reinterpret_cast<IBoneAnimator*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBoneAnimator::operator==(const IBoneAnimator& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBoneAnimator>)
		return false;


	return true;
}

ZHMTypeInfo IBoneCollidable::TypeInfo = ZHMTypeInfo("IBoneCollidable", sizeof(IBoneCollidable), alignof(IBoneCollidable), IBoneCollidable::WriteJson, IBoneCollidable::WriteSimpleJson, IBoneCollidable::FromSimpleJson, IBoneCollidable::Serialize, IBoneCollidable::Equals);

void IBoneCollidable::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IBoneCollidable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBoneCollidable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBoneCollidable s_Object {};

	*reinterpret_cast<IBoneCollidable*>(p_Target) = s_Object;
}

void IBoneCollidable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

}

bool IBoneCollidable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBoneCollidable*>(p_Left);
	auto* s_Right = reinterpret_cast<IBoneCollidable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBoneCollidable::operator==(const IBoneCollidable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBoneCollidable>)
		return false;


	return true;
}

ZHMTypeInfo IBulletImpactListener::TypeInfo = ZHMTypeInfo("IBulletImpactListener", sizeof(IBulletImpactListener), alignof(IBulletImpactListener), IBulletImpactListener::WriteJson, IBulletImpactListener::WriteSimpleJson, IBulletImpactListener::FromSimpleJson, IBulletImpactListener::Serialize, IBulletImpactListener::Equals);

void IBulletImpactListener::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IBulletImpactListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBulletImpactListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBulletImpactListener s_Object {};

	*reinterpret_cast<IBulletImpactListener*>(p_Target) = s_Object;
}

void IBulletImpactListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);

}

bool IBulletImpactListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBulletImpactListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IBulletImpactListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBulletImpactListener::operator==(const IBulletImpactListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBulletImpactListener>)
		return false;


	return true;
}

ZHMTypeInfo IComponentInterface::TypeInfo = ZHMTypeInfo("IComponentInterface", sizeof(IComponentInterface), alignof(IComponentInterface), IComponentInterface::WriteJson, IComponentInterface::WriteSimpleJson, IComponentInterface::FromSimpleJson, IComponentInterface::Serialize, IComponentInterface::Equals);

void IComponentInterface::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IComponentInterface::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IComponentInterface::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IComponentInterface s_Object {};

	*reinterpret_cast<IComponentInterface*>(p_Target) = s_Object;
}

void IComponentInterface::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

}

bool IComponentInterface::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IComponentInterface*>(p_Left);
	auto* s_Right = reinterpret_cast<IComponentInterface*>(p_Right);

	return *s_Left == *s_Right;
}

bool IComponentInterface::operator==(const IComponentInterface& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IComponentInterface>)
		return false;


	return true;
}

ZHMTypeInfo IContractEvaluationContextListener::TypeInfo = ZHMTypeInfo("IContractEvaluationContextListener", sizeof(IContractEvaluationContextListener), alignof(IContractEvaluationContextListener), IContractEvaluationContextListener::WriteJson, IContractEvaluationContextListener::WriteSimpleJson, IContractEvaluationContextListener::FromSimpleJson, IContractEvaluationContextListener::Serialize, IContractEvaluationContextListener::Equals);

void IContractEvaluationContextListener::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IContractEvaluationContextListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IContractEvaluationContextListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IContractEvaluationContextListener s_Object {};

	*reinterpret_cast<IContractEvaluationContextListener*>(p_Target) = s_Object;
}

void IContractEvaluationContextListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);

}

bool IContractEvaluationContextListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractEvaluationContextListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractEvaluationContextListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractEvaluationContextListener::operator==(const IContractEvaluationContextListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractEvaluationContextListener>)
		return false;


	return true;
}

ZHMTypeInfo IContractObjective::TypeInfo = ZHMTypeInfo("IContractObjective", sizeof(IContractObjective), alignof(IContractObjective), IContractObjective::WriteJson, IContractObjective::WriteSimpleJson, IContractObjective::FromSimpleJson, IContractObjective::Serialize, IContractObjective::Equals);

void IContractObjective::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IContractObjective::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IContractObjective::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IContractObjective s_Object {};

	*reinterpret_cast<IContractObjective*>(p_Target) = s_Object;
}

void IContractObjective::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);

}

bool IContractObjective::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractObjective*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractObjective*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractObjective::operator==(const IContractObjective& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractObjective>)
		return false;


	return true;
}

ZHMTypeInfo ZGuid::TypeInfo = ZHMTypeInfo("ZGuid", sizeof(ZGuid), alignof(ZGuid), ZGuid::WriteJson, ZGuid::WriteSimpleJson, ZGuid::FromSimpleJson, ZGuid::Serialize, ZGuid::Equals);

void ZGuid::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("_a") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_a);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_b") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_b);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_c") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_c);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_d") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_d);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_e") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_e);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_f") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_f);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_g") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_g);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_h") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_h);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_i") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_i);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_j") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_j);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_k") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->_k);
	p_Stream << "}";

	p_Stream << "}";
}

void ZGuid::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("_a") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_a);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_b);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_c") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_c);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_d") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_d);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_e") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_e);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_f") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_f);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_h") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_h);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_i") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_i);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_j") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_j);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_k") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_k);

	p_Stream << "}";
}

void ZGuid::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGuid s_Object {};

	s_Object._a = simdjson::from_json_uint32(p_Document["_a"]);

	s_Object._b = simdjson::from_json_uint16(p_Document["_b"]);

	s_Object._c = simdjson::from_json_uint16(p_Document["_c"]);

	s_Object._d = simdjson::from_json_uint8(p_Document["_d"]);

	s_Object._e = simdjson::from_json_uint8(p_Document["_e"]);

	s_Object._f = simdjson::from_json_uint8(p_Document["_f"]);

	s_Object._g = simdjson::from_json_uint8(p_Document["_g"]);

	s_Object._h = simdjson::from_json_uint8(p_Document["_h"]);

	s_Object._i = simdjson::from_json_uint8(p_Document["_i"]);

	s_Object._j = simdjson::from_json_uint8(p_Document["_j"]);

	s_Object._k = simdjson::from_json_uint8(p_Document["_k"]);

	*reinterpret_cast<ZGuid*>(p_Target) = s_Object;
}

void ZGuid::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);

}

bool ZGuid::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGuid*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGuid*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGuid::operator==(const ZGuid& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGuid>)
		return false;

	if (_a != p_Other._a) return false;
	if (_b != p_Other._b) return false;
	if (_c != p_Other._c) return false;
	if (_d != p_Other._d) return false;
	if (_e != p_Other._e) return false;
	if (_f != p_Other._f) return false;
	if (_g != p_Other._g) return false;
	if (_h != p_Other._h) return false;
	if (_i != p_Other._i) return false;
	if (_j != p_Other._j) return false;
	if (_k != p_Other._k) return false;

	return true;
}

ZHMTypeInfo IContractObjective_STargetCondition::TypeInfo = ZHMTypeInfo("IContractObjective.STargetCondition", sizeof(IContractObjective_STargetCondition), alignof(IContractObjective_STargetCondition), IContractObjective_STargetCondition::WriteJson, IContractObjective_STargetCondition::WriteSimpleJson, IContractObjective_STargetCondition::FromSimpleJson, IContractObjective_STargetCondition::Serialize, IContractObjective_STargetCondition::Equals);

void IContractObjective_STargetCondition::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractObjective_STargetCondition*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repositoryId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->repositoryId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("hardCondition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->hardCondition);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGuid") << ",\"$val\":";
	ZGuid::WriteJson(&s_Object->objectiveId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sKillMethod") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sKillMethod);
	p_Stream << "}";

	p_Stream << "}";
}

void IContractObjective_STargetCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractObjective_STargetCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repositoryId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->repositoryId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("hardCondition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->hardCondition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveId") << ":";
	ZGuid::WriteSimpleJson(&s_Object->objectiveId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sKillMethod") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sKillMethod);

	p_Stream << "}";
}

void IContractObjective_STargetCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IContractObjective_STargetCondition s_Object {};

	s_Object.type = std::string_view(p_Document["type"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["repositoryId"], &s_Item);
		s_Object.repositoryId = s_Item;
	}

	s_Object.hardCondition = simdjson::from_json_bool(p_Document["hardCondition"]);

	{
		ZGuid s_Item {};
		ZGuid::FromSimpleJson(p_Document["objectiveId"], &s_Item);
		s_Object.objectiveId = s_Item;
	}

	s_Object.sKillMethod = std::string_view(p_Document["sKillMethod"]);

	*reinterpret_cast<IContractObjective_STargetCondition*>(p_Target) = s_Object;
}

void IContractObjective_STargetCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractObjective_STargetCondition*>(p_Object);

	ZString::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(IContractObjective_STargetCondition, type));
	ZRepositoryID::Serialize(&s_Object->repositoryId, p_Serializer, p_OwnOffset + offsetof(IContractObjective_STargetCondition, repositoryId));
	ZGuid::Serialize(&s_Object->objectiveId, p_Serializer, p_OwnOffset + offsetof(IContractObjective_STargetCondition, objectiveId));
	ZString::Serialize(&s_Object->sKillMethod, p_Serializer, p_OwnOffset + offsetof(IContractObjective_STargetCondition, sKillMethod));
}

bool IContractObjective_STargetCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractObjective_STargetCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractObjective_STargetCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractObjective_STargetCondition::operator==(const IContractObjective_STargetCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractObjective_STargetCondition>)
		return false;

	if (type != p_Other.type) return false;
	if (repositoryId != p_Other.repositoryId) return false;
	if (hardCondition != p_Other.hardCondition) return false;
	if (objectiveId != p_Other.objectiveId) return false;
	if (sKillMethod != p_Other.sKillMethod) return false;

	return true;
}

ZHMTypeInfo IEscortOutSituation::TypeInfo = ZHMTypeInfo("IEscortOutSituation", sizeof(IEscortOutSituation), alignof(IEscortOutSituation), IEscortOutSituation::WriteJson, IEscortOutSituation::WriteSimpleJson, IEscortOutSituation::FromSimpleJson, IEscortOutSituation::Serialize, IEscortOutSituation::Equals);

void IEscortOutSituation::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IEscortOutSituation::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IEscortOutSituation::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IEscortOutSituation s_Object {};

	*reinterpret_cast<IEscortOutSituation*>(p_Target) = s_Object;
}

void IEscortOutSituation::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);

}

bool IEscortOutSituation::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IEscortOutSituation*>(p_Left);
	auto* s_Right = reinterpret_cast<IEscortOutSituation*>(p_Right);

	return *s_Left == *s_Right;
}

bool IEscortOutSituation::operator==(const IEscortOutSituation& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IEscortOutSituation>)
		return false;


	return true;
}

ZHMTypeInfo IEventConsumerCollection::TypeInfo = ZHMTypeInfo("IEventConsumerCollection", sizeof(IEventConsumerCollection), alignof(IEventConsumerCollection), IEventConsumerCollection::WriteJson, IEventConsumerCollection::WriteSimpleJson, IEventConsumerCollection::FromSimpleJson, IEventConsumerCollection::Serialize, IEventConsumerCollection::Equals);

void IEventConsumerCollection::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IEventConsumerCollection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IEventConsumerCollection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IEventConsumerCollection s_Object {};

	*reinterpret_cast<IEventConsumerCollection*>(p_Target) = s_Object;
}

void IEventConsumerCollection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

}

bool IEventConsumerCollection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IEventConsumerCollection*>(p_Left);
	auto* s_Right = reinterpret_cast<IEventConsumerCollection*>(p_Right);

	return *s_Left == *s_Right;
}

bool IEventConsumerCollection::operator==(const IEventConsumerCollection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IEventConsumerCollection>)
		return false;


	return true;
}

ZHMTypeInfo IFreeCameraControl::TypeInfo = ZHMTypeInfo("IFreeCameraControl", sizeof(IFreeCameraControl), alignof(IFreeCameraControl), IFreeCameraControl::WriteJson, IFreeCameraControl::WriteSimpleJson, IFreeCameraControl::FromSimpleJson, IFreeCameraControl::Serialize, IFreeCameraControl::Equals);

void IFreeCameraControl::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IFreeCameraControl::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IFreeCameraControl::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IFreeCameraControl s_Object {};

	*reinterpret_cast<IFreeCameraControl*>(p_Target) = s_Object;
}

void IFreeCameraControl::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);

}

bool IFreeCameraControl::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IFreeCameraControl*>(p_Left);
	auto* s_Right = reinterpret_cast<IFreeCameraControl*>(p_Right);

	return *s_Left == *s_Right;
}

bool IFreeCameraControl::operator==(const IFreeCameraControl& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IFreeCameraControl>)
		return false;


	return true;
}

ZHMTypeInfo IHM5Door::TypeInfo = ZHMTypeInfo("IHM5Door", sizeof(IHM5Door), alignof(IHM5Door), IHM5Door::WriteJson, IHM5Door::WriteSimpleJson, IHM5Door::FromSimpleJson, IHM5Door::Serialize, IHM5Door::Equals);

void IHM5Door::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IHM5Door::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHM5Door::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IHM5Door s_Object {};

	*reinterpret_cast<IHM5Door*>(p_Target) = s_Object;
}

void IHM5Door::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);

}

bool IHM5Door::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHM5Door*>(p_Left);
	auto* s_Right = reinterpret_cast<IHM5Door*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHM5Door::operator==(const IHM5Door& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHM5Door>)
		return false;


	return true;
}

ZHMTypeInfo IHM5WeaponInventory::TypeInfo = ZHMTypeInfo("IHM5WeaponInventory", sizeof(IHM5WeaponInventory), alignof(IHM5WeaponInventory), IHM5WeaponInventory::WriteJson, IHM5WeaponInventory::WriteSimpleJson, IHM5WeaponInventory::FromSimpleJson, IHM5WeaponInventory::Serialize, IHM5WeaponInventory::Equals);

void IHM5WeaponInventory::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IHM5WeaponInventory::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHM5WeaponInventory::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IHM5WeaponInventory s_Object {};

	*reinterpret_cast<IHM5WeaponInventory*>(p_Target) = s_Object;
}

void IHM5WeaponInventory::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

}

bool IHM5WeaponInventory::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHM5WeaponInventory*>(p_Left);
	auto* s_Right = reinterpret_cast<IHM5WeaponInventory*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHM5WeaponInventory::operator==(const IHM5WeaponInventory& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHM5WeaponInventory>)
		return false;


	return true;
}

ZHMTypeInfo IHumanBody::TypeInfo = ZHMTypeInfo("IHumanBody", sizeof(IHumanBody), alignof(IHumanBody), IHumanBody::WriteJson, IHumanBody::WriteSimpleJson, IHumanBody::FromSimpleJson, IHumanBody::Serialize, IHumanBody::Equals);

void IHumanBody::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IHumanBody::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHumanBody::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IHumanBody s_Object {};

	*reinterpret_cast<IHumanBody*>(p_Target) = s_Object;
}

void IHumanBody::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);

}

bool IHumanBody::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHumanBody*>(p_Left);
	auto* s_Right = reinterpret_cast<IHumanBody*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHumanBody::operator==(const IHumanBody& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHumanBody>)
		return false;


	return true;
}

ZHMTypeInfo IMetricValue::TypeInfo = ZHMTypeInfo("IMetricValue", sizeof(IMetricValue), alignof(IMetricValue), IMetricValue::WriteJson, IMetricValue::WriteSimpleJson, IMetricValue::FromSimpleJson, IMetricValue::Serialize, IMetricValue::Equals);

void IMetricValue::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IMetricValue::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMetricValue::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMetricValue s_Object {};

	*reinterpret_cast<IMetricValue*>(p_Target) = s_Object;
}

void IMetricValue::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);

}

bool IMetricValue::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMetricValue*>(p_Left);
	auto* s_Right = reinterpret_cast<IMetricValue*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMetricValue::operator==(const IMetricValue& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMetricValue>)
		return false;


	return true;
}

ZHMTypeInfo IMorphemeCutSequenceAnimatable::TypeInfo = ZHMTypeInfo("IMorphemeCutSequenceAnimatable", sizeof(IMorphemeCutSequenceAnimatable), alignof(IMorphemeCutSequenceAnimatable), IMorphemeCutSequenceAnimatable::WriteJson, IMorphemeCutSequenceAnimatable::WriteSimpleJson, IMorphemeCutSequenceAnimatable::FromSimpleJson, IMorphemeCutSequenceAnimatable::Serialize, IMorphemeCutSequenceAnimatable::Equals);

void IMorphemeCutSequenceAnimatable::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IMorphemeCutSequenceAnimatable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeCutSequenceAnimatable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMorphemeCutSequenceAnimatable s_Object {};

	*reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Target) = s_Object;
}

void IMorphemeCutSequenceAnimatable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

}

bool IMorphemeCutSequenceAnimatable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeCutSequenceAnimatable::operator==(const IMorphemeCutSequenceAnimatable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeCutSequenceAnimatable>)
		return false;


	return true;
}

ZHMTypeInfo IMorphemeCutSequenceAnimationEntity::TypeInfo = ZHMTypeInfo("IMorphemeCutSequenceAnimationEntity", sizeof(IMorphemeCutSequenceAnimationEntity), alignof(IMorphemeCutSequenceAnimationEntity), IMorphemeCutSequenceAnimationEntity::WriteJson, IMorphemeCutSequenceAnimationEntity::WriteSimpleJson, IMorphemeCutSequenceAnimationEntity::FromSimpleJson, IMorphemeCutSequenceAnimationEntity::Serialize, IMorphemeCutSequenceAnimationEntity::Equals);

void IMorphemeCutSequenceAnimationEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IMorphemeCutSequenceAnimationEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeCutSequenceAnimationEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMorphemeCutSequenceAnimationEntity s_Object {};

	*reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Target) = s_Object;
}

void IMorphemeCutSequenceAnimationEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);

}

bool IMorphemeCutSequenceAnimationEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeCutSequenceAnimationEntity::operator==(const IMorphemeCutSequenceAnimationEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeCutSequenceAnimationEntity>)
		return false;


	return true;
}

ZHMTypeInfo IMorphemeEventConsumer::TypeInfo = ZHMTypeInfo("IMorphemeEventConsumer", sizeof(IMorphemeEventConsumer), alignof(IMorphemeEventConsumer), IMorphemeEventConsumer::WriteJson, IMorphemeEventConsumer::WriteSimpleJson, IMorphemeEventConsumer::FromSimpleJson, IMorphemeEventConsumer::Serialize, IMorphemeEventConsumer::Equals);

void IMorphemeEventConsumer::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IMorphemeEventConsumer::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeEventConsumer::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMorphemeEventConsumer s_Object {};

	*reinterpret_cast<IMorphemeEventConsumer*>(p_Target) = s_Object;
}

void IMorphemeEventConsumer::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

}

bool IMorphemeEventConsumer::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeEventConsumer*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeEventConsumer*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeEventConsumer::operator==(const IMorphemeEventConsumer& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeEventConsumer>)
		return false;


	return true;
}

ZHMTypeInfo IOnlineConfigurationListener::TypeInfo = ZHMTypeInfo("IOnlineConfigurationListener", sizeof(IOnlineConfigurationListener), alignof(IOnlineConfigurationListener), IOnlineConfigurationListener::WriteJson, IOnlineConfigurationListener::WriteSimpleJson, IOnlineConfigurationListener::FromSimpleJson, IOnlineConfigurationListener::Serialize, IOnlineConfigurationListener::Equals);

void IOnlineConfigurationListener::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IOnlineConfigurationListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IOnlineConfigurationListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IOnlineConfigurationListener s_Object {};

	*reinterpret_cast<IOnlineConfigurationListener*>(p_Target) = s_Object;
}

void IOnlineConfigurationListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);

}

bool IOnlineConfigurationListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IOnlineConfigurationListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IOnlineConfigurationListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IOnlineConfigurationListener::operator==(const IOnlineConfigurationListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IOnlineConfigurationListener>)
		return false;


	return true;
}

ZHMTypeInfo IPureWaterReflectable::TypeInfo = ZHMTypeInfo("IPureWaterReflectable", sizeof(IPureWaterReflectable), alignof(IPureWaterReflectable), IPureWaterReflectable::WriteJson, IPureWaterReflectable::WriteSimpleJson, IPureWaterReflectable::FromSimpleJson, IPureWaterReflectable::Serialize, IPureWaterReflectable::Equals);

void IPureWaterReflectable::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IPureWaterReflectable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IPureWaterReflectable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IPureWaterReflectable s_Object {};

	*reinterpret_cast<IPureWaterReflectable*>(p_Target) = s_Object;
}

void IPureWaterReflectable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);

}

bool IPureWaterReflectable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IPureWaterReflectable*>(p_Left);
	auto* s_Right = reinterpret_cast<IPureWaterReflectable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IPureWaterReflectable::operator==(const IPureWaterReflectable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IPureWaterReflectable>)
		return false;


	return true;
}

ZHMTypeInfo IRenderCompositorEntity::TypeInfo = ZHMTypeInfo("IRenderCompositorEntity", sizeof(IRenderCompositorEntity), alignof(IRenderCompositorEntity), IRenderCompositorEntity::WriteJson, IRenderCompositorEntity::WriteSimpleJson, IRenderCompositorEntity::FromSimpleJson, IRenderCompositorEntity::Serialize, IRenderCompositorEntity::Equals);

void IRenderCompositorEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IRenderCompositorEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IRenderCompositorEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IRenderCompositorEntity s_Object {};

	*reinterpret_cast<IRenderCompositorEntity*>(p_Target) = s_Object;
}

void IRenderCompositorEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

}

bool IRenderCompositorEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IRenderCompositorEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IRenderCompositorEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IRenderCompositorEntity::operator==(const IRenderCompositorEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IRenderCompositorEntity>)
		return false;


	return true;
}

ZHMTypeInfo IRenderMaterialDescriptor::TypeInfo = ZHMTypeInfo("IRenderMaterialDescriptor", sizeof(IRenderMaterialDescriptor), alignof(IRenderMaterialDescriptor), IRenderMaterialDescriptor::WriteJson, IRenderMaterialDescriptor::WriteSimpleJson, IRenderMaterialDescriptor::FromSimpleJson, IRenderMaterialDescriptor::Serialize, IRenderMaterialDescriptor::Equals);

void IRenderMaterialDescriptor::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IRenderMaterialDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IRenderMaterialDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IRenderMaterialDescriptor s_Object {};

	*reinterpret_cast<IRenderMaterialDescriptor*>(p_Target) = s_Object;
}

void IRenderMaterialDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);

}

bool IRenderMaterialDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IRenderMaterialDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<IRenderMaterialDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool IRenderMaterialDescriptor::operator==(const IRenderMaterialDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IRenderMaterialDescriptor>)
		return false;


	return true;
}

ZHMTypeInfo ISequenceTarget::TypeInfo = ZHMTypeInfo("ISequenceTarget", sizeof(ISequenceTarget), alignof(ISequenceTarget), ISequenceTarget::WriteJson, ISequenceTarget::WriteSimpleJson, ISequenceTarget::FromSimpleJson, ISequenceTarget::Serialize, ISequenceTarget::Equals);

void ISequenceTarget::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ISequenceTarget::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISequenceTarget::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISequenceTarget s_Object {};

	*reinterpret_cast<ISequenceTarget*>(p_Target) = s_Object;
}

void ISequenceTarget::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);

}

bool ISequenceTarget::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISequenceTarget*>(p_Left);
	auto* s_Right = reinterpret_cast<ISequenceTarget*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISequenceTarget::operator==(const ISequenceTarget& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISequenceTarget>)
		return false;


	return true;
}

ZHMTypeInfo ISituation::TypeInfo = ZHMTypeInfo("ISituation", sizeof(ISituation), alignof(ISituation), ISituation::WriteJson, ISituation::WriteSimpleJson, ISituation::FromSimpleJson, ISituation::Serialize, ISituation::Equals);

void ISituation::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ISituation::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISituation::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISituation s_Object {};

	*reinterpret_cast<ISituation*>(p_Target) = s_Object;
}

void ISituation::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);

}

bool ISituation::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISituation*>(p_Left);
	auto* s_Right = reinterpret_cast<ISituation*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISituation::operator==(const ISituation& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISituation>)
		return false;


	return true;
}

ZHMTypeInfo ISoundMaterialDescriptor::TypeInfo = ZHMTypeInfo("ISoundMaterialDescriptor", sizeof(ISoundMaterialDescriptor), alignof(ISoundMaterialDescriptor), ISoundMaterialDescriptor::WriteJson, ISoundMaterialDescriptor::WriteSimpleJson, ISoundMaterialDescriptor::FromSimpleJson, ISoundMaterialDescriptor::Serialize, ISoundMaterialDescriptor::Equals);

void ISoundMaterialDescriptor::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ISoundMaterialDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISoundMaterialDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISoundMaterialDescriptor s_Object {};

	*reinterpret_cast<ISoundMaterialDescriptor*>(p_Target) = s_Object;
}

void ISoundMaterialDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);

}

bool ISoundMaterialDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISoundMaterialDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<ISoundMaterialDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISoundMaterialDescriptor::operator==(const ISoundMaterialDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISoundMaterialDescriptor>)
		return false;


	return true;
}

ZHMTypeInfo ITriggerListener::TypeInfo = ZHMTypeInfo("ITriggerListener", sizeof(ITriggerListener), alignof(ITriggerListener), ITriggerListener::WriteJson, ITriggerListener::WriteSimpleJson, ITriggerListener::FromSimpleJson, ITriggerListener::Serialize, ITriggerListener::Equals);

void ITriggerListener::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ITriggerListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ITriggerListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ITriggerListener s_Object {};

	*reinterpret_cast<ITriggerListener*>(p_Target) = s_Object;
}

void ITriggerListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

}

bool ITriggerListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ITriggerListener*>(p_Left);
	auto* s_Right = reinterpret_cast<ITriggerListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool ITriggerListener::operator==(const ITriggerListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ITriggerListener>)
		return false;


	return true;
}

ZHMTypeInfo IUIDataListener::TypeInfo = ZHMTypeInfo("IUIDataListener", sizeof(IUIDataListener), alignof(IUIDataListener), IUIDataListener::WriteJson, IUIDataListener::WriteSimpleJson, IUIDataListener::FromSimpleJson, IUIDataListener::Serialize, IUIDataListener::Equals);

void IUIDataListener::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IUIDataListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IUIDataListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IUIDataListener s_Object {};

	*reinterpret_cast<IUIDataListener*>(p_Target) = s_Object;
}

void IUIDataListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);

}

bool IUIDataListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IUIDataListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IUIDataListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IUIDataListener::operator==(const IUIDataListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IUIDataListener>)
		return false;


	return true;
}

ZHMTypeInfo IValueEntity::TypeInfo = ZHMTypeInfo("IValueEntity", sizeof(IValueEntity), alignof(IValueEntity), IValueEntity::WriteJson, IValueEntity::WriteSimpleJson, IValueEntity::FromSimpleJson, IValueEntity::Serialize, IValueEntity::Equals);

void IValueEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IValueEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IValueEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IValueEntity s_Object {};

	*reinterpret_cast<IValueEntity*>(p_Target) = s_Object;
}

void IValueEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

}

bool IValueEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IValueEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IValueEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IValueEntity::operator==(const IValueEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IValueEntity>)
		return false;


	return true;
}

ZHMTypeInfo IWorldMapMarker::TypeInfo = ZHMTypeInfo("IWorldMapMarker", sizeof(IWorldMapMarker), alignof(IWorldMapMarker), IWorldMapMarker::WriteJson, IWorldMapMarker::WriteSimpleJson, IWorldMapMarker::FromSimpleJson, IWorldMapMarker::Serialize, IWorldMapMarker::Equals);

void IWorldMapMarker::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void IWorldMapMarker::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IWorldMapMarker::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IWorldMapMarker s_Object {};

	*reinterpret_cast<IWorldMapMarker*>(p_Target) = s_Object;
}

void IWorldMapMarker::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);

}

bool IWorldMapMarker::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IWorldMapMarker*>(p_Left);
	auto* s_Right = reinterpret_cast<IWorldMapMarker*>(p_Right);

	return *s_Left == *s_Right;
}

bool IWorldMapMarker::operator==(const IWorldMapMarker& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IWorldMapMarker>)
		return false;


	return true;
}

ZHMTypeInfo S25DProjectionSettings::TypeInfo = ZHMTypeInfo("S25DProjectionSettings", sizeof(S25DProjectionSettings), alignof(S25DProjectionSettings), S25DProjectionSettings::WriteJson, S25DProjectionSettings::WriteSimpleJson, S25DProjectionSettings::FromSimpleJson, S25DProjectionSettings::Serialize, S25DProjectionSettings::Equals);

void S25DProjectionSettings::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("fNearDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fNearDistance);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fFarDistance);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearScale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fNearScale);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarScale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fFarScale);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScaleFactor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fScaleFactor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearAlpha") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fNearAlpha);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarAlpha") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fFarAlpha);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlphaFactor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fAlphaFactor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eViewportLock") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EViewportLock") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->eViewportLock)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EViewportLock", static_cast<int>(s_Object->eViewportLock))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fViewportGutter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fViewportGutter);
	p_Stream << "}";

	p_Stream << "}";
}

void S25DProjectionSettings::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fNearDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScaleFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fScaleFactor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlphaFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlphaFactor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eViewportLock") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EViewportLock", static_cast<int>(s_Object->eViewportLock)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fViewportGutter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fViewportGutter);

	p_Stream << "}";
}

void S25DProjectionSettings::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	S25DProjectionSettings s_Object {};

	s_Object.fNearDistance = simdjson::from_json_float32(p_Document["fNearDistance"]);

	s_Object.fFarDistance = simdjson::from_json_float32(p_Document["fFarDistance"]);

	s_Object.fNearScale = simdjson::from_json_float32(p_Document["fNearScale"]);

	s_Object.fFarScale = simdjson::from_json_float32(p_Document["fFarScale"]);

	s_Object.fScaleFactor = simdjson::from_json_float32(p_Document["fScaleFactor"]);

	s_Object.fNearAlpha = simdjson::from_json_float32(p_Document["fNearAlpha"]);

	s_Object.fFarAlpha = simdjson::from_json_float32(p_Document["fFarAlpha"]);

	s_Object.fAlphaFactor = simdjson::from_json_float32(p_Document["fAlphaFactor"]);

	s_Object.eViewportLock = static_cast<EViewportLock>(ZHMEnums::GetEnumValueByName("EViewportLock", std::string_view(p_Document["eViewportLock"])));

	s_Object.fViewportGutter = simdjson::from_json_float32(p_Document["fViewportGutter"]);

	*reinterpret_cast<S25DProjectionSettings*>(p_Target) = s_Object;
}

void S25DProjectionSettings::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);

}

bool S25DProjectionSettings::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<S25DProjectionSettings*>(p_Left);
	auto* s_Right = reinterpret_cast<S25DProjectionSettings*>(p_Right);

	return *s_Left == *s_Right;
}

bool S25DProjectionSettings::operator==(const S25DProjectionSettings& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<S25DProjectionSettings>)
		return false;

	if (fNearDistance != p_Other.fNearDistance) return false;
	if (fFarDistance != p_Other.fFarDistance) return false;
	if (fNearScale != p_Other.fNearScale) return false;
	if (fFarScale != p_Other.fFarScale) return false;
	if (fScaleFactor != p_Other.fScaleFactor) return false;
	if (fNearAlpha != p_Other.fNearAlpha) return false;
	if (fFarAlpha != p_Other.fFarAlpha) return false;
	if (fAlphaFactor != p_Other.fAlphaFactor) return false;
	if (eViewportLock != p_Other.eViewportLock) return false;
	if (fViewportGutter != p_Other.fViewportGutter) return false;

	return true;
}

ZHMTypeInfo S3rdPersonCameraSaveData::TypeInfo = ZHMTypeInfo("S3rdPersonCameraSaveData", sizeof(S3rdPersonCameraSaveData), alignof(S3rdPersonCameraSaveData), S3rdPersonCameraSaveData::WriteJson, S3rdPersonCameraSaveData::WriteSimpleJson, S3rdPersonCameraSaveData::FromSimpleJson, S3rdPersonCameraSaveData::Serialize, S3rdPersonCameraSaveData::Equals);

void S3rdPersonCameraSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fAngleYaw") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngleYaw);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnglePitch") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnglePitch);
	p_Stream << "}";

	p_Stream << "}";
}

void S3rdPersonCameraSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fAngleYaw") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngleYaw);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnglePitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnglePitch);

	p_Stream << "}";
}

void S3rdPersonCameraSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	S3rdPersonCameraSaveData s_Object {};

	s_Object.m_fAngleYaw = simdjson::from_json_float32(p_Document["m_fAngleYaw"]);

	s_Object.m_fAnglePitch = simdjson::from_json_float32(p_Document["m_fAnglePitch"]);

	*reinterpret_cast<S3rdPersonCameraSaveData*>(p_Target) = s_Object;
}

void S3rdPersonCameraSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);

}

bool S3rdPersonCameraSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool S3rdPersonCameraSaveData::operator==(const S3rdPersonCameraSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<S3rdPersonCameraSaveData>)
		return false;

	if (m_fAngleYaw != p_Other.m_fAngleYaw) return false;
	if (m_fAnglePitch != p_Other.m_fAnglePitch) return false;

	return true;
}

ZHMTypeInfo ZGameTime::TypeInfo = ZHMTypeInfo("ZGameTime", sizeof(ZGameTime), alignof(ZGameTime), ZGameTime::WriteJson, ZGameTime::WriteSimpleJson, ZGameTime::FromSimpleJson, ZGameTime::Serialize, ZGameTime::Equals);

void ZGameTime::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nTicks") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTicks);
	p_Stream << "}";

	p_Stream << "}";
}

void ZGameTime::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nTicks") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTicks);

	p_Stream << "}";
}

void ZGameTime::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGameTime s_Object {};

	s_Object.m_nTicks = simdjson::from_json_int64(p_Document["m_nTicks"]);

	*reinterpret_cast<ZGameTime*>(p_Target) = s_Object;
}

void ZGameTime::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

}

bool ZGameTime::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGameTime*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGameTime*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGameTime::operator==(const ZGameTime& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGameTime>)
		return false;

	if (m_nTicks != p_Other.m_nTicks) return false;

	return true;
}

ZHMTypeInfo SAIEventSaveData::TypeInfo = ZHMTypeInfo("SAIEventSaveData", sizeof(SAIEventSaveData), alignof(SAIEventSaveData), SAIEventSaveData::WriteJson, SAIEventSaveData::WriteSimpleJson, SAIEventSaveData::FromSimpleJson, SAIEventSaveData::Serialize, SAIEventSaveData::Equals);

void SAIEventSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAIEventType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHandled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHandled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_nStart, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEnd") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_nEnd, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SAIEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHandled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHandled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nEnd, p_Stream);

	p_Stream << "}";
}

void SAIEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIEventSaveData s_Object {};

	s_Object.m_eType = static_cast<EAIEventType>(ZHMEnums::GetEnumValueByName("EAIEventType", std::string_view(p_Document["m_eType"])));

	s_Object.m_bHandled = simdjson::from_json_bool(p_Document["m_bHandled"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nStart"], &s_Item);
		s_Object.m_nStart = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nEnd"], &s_Item);
		s_Object.m_nEnd = s_Item;
	}

	*reinterpret_cast<SAIEventSaveData*>(p_Target) = s_Object;
}

void SAIEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_nStart, p_Serializer, p_OwnOffset + offsetof(SAIEventSaveData, m_nStart));
	ZGameTime::Serialize(&s_Object->m_nEnd, p_Serializer, p_OwnOffset + offsetof(SAIEventSaveData, m_nEnd));
}

bool SAIEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIEventSaveData::operator==(const SAIEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIEventSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_bHandled != p_Other.m_bHandled) return false;
	if (m_nStart != p_Other.m_nStart) return false;
	if (m_nEnd != p_Other.m_nEnd) return false;

	return true;
}

ZHMTypeInfo SAIModifierServiceActorSaveData::TypeInfo = ZHMTypeInfo("SAIModifierServiceActorSaveData", sizeof(SAIModifierServiceActorSaveData), alignof(SAIModifierServiceActorSaveData), SAIModifierServiceActorSaveData::WriteJson, SAIModifierServiceActorSaveData::WriteSimpleJson, SAIModifierServiceActorSaveData::FromSimpleJson, SAIModifierServiceActorSaveData::Serialize, SAIModifierServiceActorSaveData::Equals);

void SAIModifierServiceActorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActorRef") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActorRef);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedsVolumeUpdate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedsVolumeUpdate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedsKnowledgeUpdate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedsKnowledgeUpdate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModVolume") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModVolume);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModBehavior") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModBehavior);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModRole") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModRole);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModOutfit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModOutfit);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModOverride") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModOverride);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModStatus") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModStatus);
	p_Stream << "}";

	p_Stream << "}";
}

void SAIModifierServiceActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActorRef") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActorRef);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedsVolumeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedsVolumeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedsKnowledgeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedsKnowledgeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModVolume") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModVolume);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModRole") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModRole);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModOutfit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModOutfit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModOverride") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModOverride);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModStatus") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModStatus);

	p_Stream << "}";
}

void SAIModifierServiceActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIModifierServiceActorSaveData s_Object {};

	s_Object.m_rActorRef = simdjson::from_json_uint32(p_Document["m_rActorRef"]);

	s_Object.m_bNeedsVolumeUpdate = simdjson::from_json_bool(p_Document["m_bNeedsVolumeUpdate"]);

	s_Object.m_bNeedsKnowledgeUpdate = simdjson::from_json_bool(p_Document["m_bNeedsKnowledgeUpdate"]);

	s_Object.m_uiModVolume = simdjson::from_json_uint32(p_Document["m_uiModVolume"]);

	s_Object.m_uiModBehavior = simdjson::from_json_uint32(p_Document["m_uiModBehavior"]);

	s_Object.m_uiModRole = simdjson::from_json_uint32(p_Document["m_uiModRole"]);

	s_Object.m_uiModItem = simdjson::from_json_uint32(p_Document["m_uiModItem"]);

	s_Object.m_uiModSituation = simdjson::from_json_uint32(p_Document["m_uiModSituation"]);

	s_Object.m_uiModOutfit = simdjson::from_json_uint32(p_Document["m_uiModOutfit"]);

	s_Object.m_uiModOverride = simdjson::from_json_uint32(p_Document["m_uiModOverride"]);

	s_Object.m_uiModStatus = simdjson::from_json_uint32(p_Document["m_uiModStatus"]);

	*reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Target) = s_Object;
}

void SAIModifierServiceActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);

}

bool SAIModifierServiceActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIModifierServiceActorSaveData::operator==(const SAIModifierServiceActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIModifierServiceActorSaveData>)
		return false;

	if (m_rActorRef != p_Other.m_rActorRef) return false;
	if (m_bNeedsVolumeUpdate != p_Other.m_bNeedsVolumeUpdate) return false;
	if (m_bNeedsKnowledgeUpdate != p_Other.m_bNeedsKnowledgeUpdate) return false;
	if (m_uiModVolume != p_Other.m_uiModVolume) return false;
	if (m_uiModBehavior != p_Other.m_uiModBehavior) return false;
	if (m_uiModRole != p_Other.m_uiModRole) return false;
	if (m_uiModItem != p_Other.m_uiModItem) return false;
	if (m_uiModSituation != p_Other.m_uiModSituation) return false;
	if (m_uiModOutfit != p_Other.m_uiModOutfit) return false;
	if (m_uiModOverride != p_Other.m_uiModOverride) return false;
	if (m_uiModStatus != p_Other.m_uiModStatus) return false;

	return true;
}

ZHMTypeInfo SAIModifierServiceSaveData::TypeInfo = ZHMTypeInfo("SAIModifierServiceSaveData", sizeof(SAIModifierServiceSaveData), alignof(SAIModifierServiceSaveData), SAIModifierServiceSaveData::WriteJson, SAIModifierServiceSaveData::WriteSimpleJson, SAIModifierServiceSaveData::FromSimpleJson, SAIModifierServiceSaveData::Serialize, SAIModifierServiceSaveData::Equals);

void SAIModifierServiceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bFullVolumeUpdate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFullVolumeUpdate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAIModifierServiceActorSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAIModifierServiceActorSaveData") << ",\"$val\":";
		SAIModifierServiceActorSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SAIModifierServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bFullVolumeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFullVolumeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		SAIModifierServiceActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAIModifierServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIModifierServiceSaveData s_Object {};

	s_Object.m_bFullVolumeUpdate = simdjson::from_json_bool(p_Document["m_bFullVolumeUpdate"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActors"])
	{
		SAIModifierServiceActorSaveData s_ArrayItem0;
		SAIModifierServiceActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActors.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SAIModifierServiceSaveData*>(p_Target) = s_Object;
}

void SAIModifierServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);

	TArray<SAIModifierServiceActorSaveData>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SAIModifierServiceSaveData, m_aActors));
}

bool SAIModifierServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIModifierServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIModifierServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIModifierServiceSaveData::operator==(const SAIModifierServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIModifierServiceSaveData>)
		return false;

	if (m_bFullVolumeUpdate != p_Other.m_bFullVolumeUpdate) return false;
	if (m_aActors != p_Other.m_aActors) return false;

	return true;
}

ZHMTypeInfo SAIPerceptibleEntitySaveData::TypeInfo = ZHMTypeInfo("SAIPerceptibleEntitySaveData", sizeof(SAIPerceptibleEntitySaveData), alignof(SAIPerceptibleEntitySaveData), SAIPerceptibleEntitySaveData::WriteJson, SAIPerceptibleEntitySaveData::WriteSimpleJson, SAIPerceptibleEntitySaveData::FromSimpleJson, SAIPerceptibleEntitySaveData::Serialize, SAIPerceptibleEntitySaveData::Equals);

void SAIPerceptibleEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bPerceptibleEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPerceptibleEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SAIPerceptibleEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPerceptibleEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPerceptibleEnabled);

	p_Stream << "}";
}

void SAIPerceptibleEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIPerceptibleEntitySaveData s_Object {};

	s_Object.m_bPerceptibleEnabled = simdjson::from_json_bool(p_Document["m_bPerceptibleEnabled"]);

	*reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Target) = s_Object;
}

void SAIPerceptibleEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);

}

bool SAIPerceptibleEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIPerceptibleEntitySaveData::operator==(const SAIPerceptibleEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIPerceptibleEntitySaveData>)
		return false;

	if (m_bPerceptibleEnabled != p_Other.m_bPerceptibleEnabled) return false;

	return true;
}

ZHMTypeInfo SAIVisionBlockerSaveData::TypeInfo = ZHMTypeInfo("SAIVisionBlockerSaveData", sizeof(SAIVisionBlockerSaveData), alignof(SAIVisionBlockerSaveData), SAIVisionBlockerSaveData::WriteJson, SAIVisionBlockerSaveData::WriteSimpleJson, SAIVisionBlockerSaveData::FromSimpleJson, SAIVisionBlockerSaveData::Serialize, SAIVisionBlockerSaveData::Equals);

void SAIVisionBlockerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SAIVisionBlockerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SAIVisionBlockerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIVisionBlockerSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SAIVisionBlockerSaveData*>(p_Target) = s_Object;
}

void SAIVisionBlockerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);

}

bool SAIVisionBlockerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIVisionBlockerSaveData::operator==(const SAIVisionBlockerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIVisionBlockerSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

ZHMTypeInfo SAccessoryItemSaveData::TypeInfo = ZHMTypeInfo("SAccessoryItemSaveData", sizeof(SAccessoryItemSaveData), alignof(SAccessoryItemSaveData), SAccessoryItemSaveData::WriteJson, SAccessoryItemSaveData::WriteSimpleJson, SAccessoryItemSaveData::FromSimpleJson, SAccessoryItemSaveData::Serialize, SAccessoryItemSaveData::Equals);

void SAccessoryItemSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBoneId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBoneId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttached") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttached);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);
	p_Stream << "}";

	p_Stream << "}";
}

void SAccessoryItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBoneId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBoneId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SAccessoryItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAccessoryItemSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_nBoneId = simdjson::from_json_uint32(p_Document["m_nBoneId"]);

	s_Object.m_bAttached = simdjson::from_json_bool(p_Document["m_bAttached"]);

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	*reinterpret_cast<SAccessoryItemSaveData*>(p_Target) = s_Object;
}

void SAccessoryItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);

}

bool SAccessoryItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAccessoryItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAccessoryItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAccessoryItemSaveData::operator==(const SAccessoryItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAccessoryItemSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_nBoneId != p_Other.m_nBoneId) return false;
	if (m_bAttached != p_Other.m_bAttached) return false;
	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

ZHMTypeInfo SActBehaviorEntitySaveData::TypeInfo = ZHMTypeInfo("SActBehaviorEntitySaveData", sizeof(SActBehaviorEntitySaveData), alignof(SActBehaviorEntitySaveData), SActBehaviorEntitySaveData::WriteJson, SActBehaviorEntitySaveData::WriteSimpleJson, SActBehaviorEntitySaveData::FromSimpleJson, SActBehaviorEntitySaveData::Serialize, SActBehaviorEntitySaveData::Equals);

void SActBehaviorEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bStartedSignalSent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedSignalSent);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReachedSignalSent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReachedSignalSent);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZActBehaviorEntity.EState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_nState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActStartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_ActStartTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SActBehaviorEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStartedSignalSent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedSignalSent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReachedSignalSent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReachedSignalSent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_ActStartTime, p_Stream);

	p_Stream << "}";
}

void SActBehaviorEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActBehaviorEntitySaveData s_Object {};

	s_Object.m_bStartedSignalSent = simdjson::from_json_bool(p_Document["m_bStartedSignalSent"]);

	s_Object.m_bReachedSignalSent = simdjson::from_json_bool(p_Document["m_bReachedSignalSent"]);

	s_Object.m_nState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_nState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_ActStartTime"], &s_Item);
		s_Object.m_ActStartTime = s_Item;
	}

	*reinterpret_cast<SActBehaviorEntitySaveData*>(p_Target) = s_Object;
}

void SActBehaviorEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_ActStartTime, p_Serializer, p_OwnOffset + offsetof(SActBehaviorEntitySaveData, m_ActStartTime));
}

bool SActBehaviorEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActBehaviorEntitySaveData::operator==(const SActBehaviorEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActBehaviorEntitySaveData>)
		return false;

	if (m_bStartedSignalSent != p_Other.m_bStartedSignalSent) return false;
	if (m_bReachedSignalSent != p_Other.m_bReachedSignalSent) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_ActStartTime != p_Other.m_ActStartTime) return false;

	return true;
}

ZHMTypeInfo float4::TypeInfo = ZHMTypeInfo("float4", sizeof(float4), alignof(float4), float4::WriteJson, float4::WriteSimpleJson, float4::FromSimpleJson, float4::Serialize, float4::Equals);

void float4::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->w);
	p_Stream << "}";

	p_Stream << "}";
}

void float4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void float4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	float4 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	s_Object.w = simdjson::from_json_float32(p_Document["w"]);

	*reinterpret_cast<float4*>(p_Target) = s_Object;
}

void float4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

}

bool float4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<float4*>(p_Left);
	auto* s_Right = reinterpret_cast<float4*>(p_Right);

	return *s_Left == *s_Right;
}

bool float4::operator==(const float4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<float4>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;
	if (w != p_Other.w) return false;

	return true;
}

ZHMTypeInfo SActOrderSaveData::TypeInfo = ZHMTypeInfo("SActOrderSaveData", sizeof(SActOrderSaveData), alignof(SActOrderSaveData), SActOrderSaveData::WriteJson, SActOrderSaveData::WriteSimpleJson, SActOrderSaveData::FromSimpleJson, SActOrderSaveData::Serialize, SActOrderSaveData::Equals);

void SActOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sAct") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAct);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_faceTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_faceTarget, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlendOutImmediatelyUponTimeout") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlendOutImmediatelyUponTimeout);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropCarriedItems") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropCarriedItems);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopCurrentActFast") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopCurrentActFast);
	p_Stream << "}";

	p_Stream << "}";
}

void SActOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_faceTarget") << ":";
	float4::WriteSimpleJson(&s_Object->m_faceTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlendOutImmediatelyUponTimeout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlendOutImmediatelyUponTimeout);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropCarriedItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropCarriedItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopCurrentActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopCurrentActFast);

	p_Stream << "}";
}

void SActOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActOrderSaveData s_Object {};

	s_Object.m_sAct = std::string_view(p_Document["m_sAct"]);

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object.m_rChildNetworkEntity = simdjson::from_json_uint32(p_Document["m_rChildNetworkEntity"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_faceTarget"], &s_Item);
		s_Object.m_faceTarget = s_Item;
	}

	s_Object.m_bBlendOutImmediatelyUponTimeout = simdjson::from_json_bool(p_Document["m_bBlendOutImmediatelyUponTimeout"]);

	s_Object.m_bDropCarriedItems = simdjson::from_json_bool(p_Document["m_bDropCarriedItems"]);

	s_Object.m_bStopCurrentActFast = simdjson::from_json_bool(p_Document["m_bStopCurrentActFast"]);

	*reinterpret_cast<SActOrderSaveData*>(p_Target) = s_Object;
}

void SActOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sAct, p_Serializer, p_OwnOffset + offsetof(SActOrderSaveData, m_sAct));
	float4::Serialize(&s_Object->m_faceTarget, p_Serializer, p_OwnOffset + offsetof(SActOrderSaveData, m_faceTarget));
}

bool SActOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActOrderSaveData::operator==(const SActOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActOrderSaveData>)
		return false;

	if (m_sAct != p_Other.m_sAct) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_rChildNetworkEntity != p_Other.m_rChildNetworkEntity) return false;
	if (m_faceTarget != p_Other.m_faceTarget) return false;
	if (m_bBlendOutImmediatelyUponTimeout != p_Other.m_bBlendOutImmediatelyUponTimeout) return false;
	if (m_bDropCarriedItems != p_Other.m_bDropCarriedItems) return false;
	if (m_bStopCurrentActFast != p_Other.m_bStopCurrentActFast) return false;

	return true;
}

ZHMTypeInfo SActionRadialArcDisplayInfo::TypeInfo = ZHMTypeInfo("SActionRadialArcDisplayInfo", sizeof(SActionRadialArcDisplayInfo), alignof(SActionRadialArcDisplayInfo), SActionRadialArcDisplayInfo::WriteJson, SActionRadialArcDisplayInfo::WriteSimpleJson, SActionRadialArcDisplayInfo::FromSimpleJson, SActionRadialArcDisplayInfo::Serialize, SActionRadialArcDisplayInfo::Equals);

void SActionRadialArcDisplayInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("hidden") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->hidden);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("locked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->locked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("illegal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->illegal);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << "}";

	p_Stream << "}";
}

void SActionRadialArcDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("hidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->hidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("locked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->locked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("illegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->illegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);

	p_Stream << "}";
}

void SActionRadialArcDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActionRadialArcDisplayInfo s_Object {};

	s_Object.hidden = simdjson::from_json_bool(p_Document["hidden"]);

	s_Object.locked = simdjson::from_json_bool(p_Document["locked"]);

	s_Object.active = simdjson::from_json_bool(p_Document["active"]);

	s_Object.illegal = simdjson::from_json_bool(p_Document["illegal"]);

	s_Object.icon = simdjson::from_json_int32(p_Document["icon"]);

	s_Object.label = std::string_view(p_Document["label"]);

	*reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Target) = s_Object;
}

void SActionRadialArcDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SActionRadialArcDisplayInfo, label));
}

bool SActionRadialArcDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActionRadialArcDisplayInfo::operator==(const SActionRadialArcDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActionRadialArcDisplayInfo>)
		return false;

	if (hidden != p_Other.hidden) return false;
	if (locked != p_Other.locked) return false;
	if (active != p_Other.active) return false;
	if (illegal != p_Other.illegal) return false;
	if (icon != p_Other.icon) return false;
	if (label != p_Other.label) return false;

	return true;
}

ZHMTypeInfo SActionRadialArcDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SActionRadialArcDisplayInfoArray_dummy", sizeof(SActionRadialArcDisplayInfoArray_dummy), alignof(SActionRadialArcDisplayInfoArray_dummy), SActionRadialArcDisplayInfoArray_dummy::WriteJson, SActionRadialArcDisplayInfoArray_dummy::WriteSimpleJson, SActionRadialArcDisplayInfoArray_dummy::FromSimpleJson, SActionRadialArcDisplayInfoArray_dummy::Serialize, SActionRadialArcDisplayInfoArray_dummy::Equals);

void SActionRadialArcDisplayInfoArray_dummy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActionRadialArcDisplayInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActionRadialArcDisplayInfo") << ",\"$val\":";
		SActionRadialArcDisplayInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActionRadialArcDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SActionRadialArcDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActionRadialArcDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActionRadialArcDisplayInfoArray_dummy s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["dummy"])
	{
		SActionRadialArcDisplayInfo s_ArrayItem0;
		SActionRadialArcDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Target) = s_Object;
}

void SActionRadialArcDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);

	TArray<SActionRadialArcDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SActionRadialArcDisplayInfoArray_dummy, dummy));
}

bool SActionRadialArcDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActionRadialArcDisplayInfoArray_dummy::operator==(const SActionRadialArcDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActionRadialArcDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

ZHMTypeInfo SActorAccessoryItemActionSaveData::TypeInfo = ZHMTypeInfo("SActorAccessoryItemActionSaveData", sizeof(SActorAccessoryItemActionSaveData), alignof(SActorAccessoryItemActionSaveData), SActorAccessoryItemActionSaveData::WriteJson, SActorAccessoryItemActionSaveData::WriteSimpleJson, SActorAccessoryItemActionSaveData::FromSimpleJson, SActorAccessoryItemActionSaveData::Serialize, SActorAccessoryItemActionSaveData::Equals);

void SActorAccessoryItemActionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorAccessoryItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorAccessoryItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorAccessoryItemActionSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Target) = s_Object;
}

void SActorAccessoryItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);

}

bool SActorAccessoryItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorAccessoryItemActionSaveData::operator==(const SActorAccessoryItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorAccessoryItemActionSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SActorAnimSetSaveData::TypeInfo = ZHMTypeInfo("SActorAnimSetSaveData", sizeof(SActorAnimSetSaveData), alignof(SActorAnimSetSaveData), SActorAnimSetSaveData::WriteJson, SActorAnimSetSaveData::WriteSimpleJson, SActorAnimSetSaveData::FromSimpleJson, SActorAnimSetSaveData::Serialize, SActorAnimSetSaveData::Equals);

void SActorAnimSetSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eAnimSet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAnimSetType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAnimSet)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetType", static_cast<int>(s_Object->m_eAnimSet))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCustomAnimationSet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCustomAnimationSet);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eVariationResourceMaxTension") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EGameTension") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eVariationResourceMaxTension)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eVariationResourceMaxTension))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eVariationResourceMaxEmotionState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorEmotionState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eVariationResourceMaxEmotionState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eVariationResourceMaxEmotionState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAnimSetEmotionState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAnimSetState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAnimSetEmotionState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetState", static_cast<int>(s_Object->m_eAnimSetEmotionState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePreCustomAnimSet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAnimSetType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_ePreCustomAnimSet)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetType", static_cast<int>(s_Object->m_ePreCustomAnimSet))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorAnimSetSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eAnimSet") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetType", static_cast<int>(s_Object->m_eAnimSet)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCustomAnimationSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCustomAnimationSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eVariationResourceMaxTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eVariationResourceMaxTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eVariationResourceMaxEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eVariationResourceMaxEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAnimSetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetState", static_cast<int>(s_Object->m_eAnimSetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePreCustomAnimSet") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetType", static_cast<int>(s_Object->m_ePreCustomAnimSet)));

	p_Stream << "}";
}

void SActorAnimSetSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorAnimSetSaveData s_Object {};

	s_Object.m_eAnimSet = static_cast<EAnimSetType>(ZHMEnums::GetEnumValueByName("EAnimSetType", std::string_view(p_Document["m_eAnimSet"])));

	s_Object.m_rCustomAnimationSet = simdjson::from_json_uint32(p_Document["m_rCustomAnimationSet"]);

	s_Object.m_eVariationResourceMaxTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eVariationResourceMaxTension"])));

	s_Object.m_eVariationResourceMaxEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eVariationResourceMaxEmotionState"])));

	s_Object.m_eAnimSetEmotionState = static_cast<EAnimSetState>(ZHMEnums::GetEnumValueByName("EAnimSetState", std::string_view(p_Document["m_eAnimSetEmotionState"])));

	s_Object.m_ePreCustomAnimSet = static_cast<EAnimSetType>(ZHMEnums::GetEnumValueByName("EAnimSetType", std::string_view(p_Document["m_ePreCustomAnimSet"])));

	*reinterpret_cast<SActorAnimSetSaveData*>(p_Target) = s_Object;
}

void SActorAnimSetSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);

}

bool SActorAnimSetSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorAnimSetSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorAnimSetSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorAnimSetSaveData::operator==(const SActorAnimSetSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorAnimSetSaveData>)
		return false;

	if (m_eAnimSet != p_Other.m_eAnimSet) return false;
	if (m_rCustomAnimationSet != p_Other.m_rCustomAnimationSet) return false;
	if (m_eVariationResourceMaxTension != p_Other.m_eVariationResourceMaxTension) return false;
	if (m_eVariationResourceMaxEmotionState != p_Other.m_eVariationResourceMaxEmotionState) return false;
	if (m_eAnimSetEmotionState != p_Other.m_eAnimSetEmotionState) return false;
	if (m_ePreCustomAnimSet != p_Other.m_ePreCustomAnimSet) return false;

	return true;
}

ZHMTypeInfo SActorBoneAttachSaveData::TypeInfo = ZHMTypeInfo("SActorBoneAttachSaveData", sizeof(SActorBoneAttachSaveData), alignof(SActorBoneAttachSaveData), SActorBoneAttachSaveData::WriteJson, SActorBoneAttachSaveData::WriteSimpleJson, SActorBoneAttachSaveData::FromSimpleJson, SActorBoneAttachSaveData::Serialize, SActorBoneAttachSaveData::Equals);

void SActorBoneAttachSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rAttachmentTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAttachmentTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAttached") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAttached);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorBoneAttachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rAttachmentTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAttachmentTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAttached);

	p_Stream << "}";
}

void SActorBoneAttachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorBoneAttachSaveData s_Object {};

	s_Object.m_rAttachmentTarget = simdjson::from_json_uint32(p_Document["m_rAttachmentTarget"]);

	s_Object.m_bIsAttached = simdjson::from_json_bool(p_Document["m_bIsAttached"]);

	*reinterpret_cast<SActorBoneAttachSaveData*>(p_Target) = s_Object;
}

void SActorBoneAttachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);

}

bool SActorBoneAttachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneAttachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneAttachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneAttachSaveData::operator==(const SActorBoneAttachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneAttachSaveData>)
		return false;

	if (m_rAttachmentTarget != p_Other.m_rAttachmentTarget) return false;
	if (m_bIsAttached != p_Other.m_bIsAttached) return false;

	return true;
}

ZHMTypeInfo SActorBoneAttachmentsSaveData::TypeInfo = ZHMTypeInfo("SActorBoneAttachmentsSaveData", sizeof(SActorBoneAttachmentsSaveData), alignof(SActorBoneAttachmentsSaveData), SActorBoneAttachmentsSaveData::WriteJson, SActorBoneAttachmentsSaveData::WriteSimpleJson, SActorBoneAttachmentsSaveData::FromSimpleJson, SActorBoneAttachmentsSaveData::Serialize, SActorBoneAttachmentsSaveData::Equals);

void SActorBoneAttachmentsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorBoneAttachSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorBoneAttachSaveData") << ",\"$val\":";
		SActorBoneAttachSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorBoneAttachmentsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorBoneAttachSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorBoneAttachmentsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorBoneAttachmentsSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SActorBoneAttachSaveData s_ArrayItem0;
		SActorBoneAttachSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Target) = s_Object;
}

void SActorBoneAttachmentsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorBoneAttachmentsSaveData, m_aEntities));
	TArray<SActorBoneAttachSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorBoneAttachmentsSaveData, m_aData));
}

bool SActorBoneAttachmentsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneAttachmentsSaveData::operator==(const SActorBoneAttachmentsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneAttachmentsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SVector4::TypeInfo = ZHMTypeInfo("SVector4", sizeof(SVector4), alignof(SVector4), SVector4::WriteJson, SVector4::WriteSimpleJson, SVector4::FromSimpleJson, SVector4::Serialize, SVector4::Equals);

void SVector4::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->w);
	p_Stream << "}";

	p_Stream << "}";
}

void SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector4 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	s_Object.w = simdjson::from_json_float32(p_Document["w"]);

	*reinterpret_cast<SVector4*>(p_Target) = s_Object;
}

void SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

}

bool SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector4::operator==(const SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector4>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;
	if (w != p_Other.w) return false;

	return true;
}

ZHMTypeInfo SActorBoneSaveData::TypeInfo = ZHMTypeInfo("SActorBoneSaveData", sizeof(SActorBoneSaveData), alignof(SActorBoneSaveData), SActorBoneSaveData::WriteJson, SActorBoneSaveData::WriteSimpleJson, SActorBoneSaveData::FromSimpleJson, SActorBoneSaveData::Serialize, SActorBoneSaveData::Equals);

void SActorBoneSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mTranslation, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SActorBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorBoneSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Item);
		s_Object.mQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Item);
		s_Object.mTranslation = s_Item;
	}

	*reinterpret_cast<SActorBoneSaveData*>(p_Target) = s_Object;
}

void SActorBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SActorBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SActorBoneSaveData, mTranslation));
}

bool SActorBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneSaveData::operator==(const SActorBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

ZHMTypeInfo SActorDamageControlSaveData::TypeInfo = ZHMTypeInfo("SActorDamageControlSaveData", sizeof(SActorDamageControlSaveData), alignof(SActorDamageControlSaveData), SActorDamageControlSaveData::WriteJson, SActorDamageControlSaveData::WriteSimpleJson, SActorDamageControlSaveData::FromSimpleJson, SActorDamageControlSaveData::Serialize, SActorDamageControlSaveData::Equals);

void SActorDamageControlSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDamageControlSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("bExplosive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bExplosive);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bProjectile") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bProjectile);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHeadshot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bHeadshot);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSniperShot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bSniperShot);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bThroughWall") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bThroughWall);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bKillByAccident") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bKillByAccident);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bWeaponSilenced") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bWeaponSilenced);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bLongRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bLongRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fTotalDamage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fTotalDamage);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fPacifyDamage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fPacifyDamage);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fSBDamage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fSBDamage);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nImpactBodyPart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nImpactBodyPart);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("maxDeathType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDeathType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->maxDeathType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathType", static_cast<int>(s_Object->maxDeathType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("maxDeathContext") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDeathContext") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->maxDeathContext)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathContext", static_cast<int>(s_Object->maxDeathContext))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rAccidentSetup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->rAccidentSetup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bFirearmPacifiesTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bFirearmPacifiesTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fHitsNumberTimeout") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fHitsNumberTimeout);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fHealthPercentTimeout") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fHealthPercentTimeout);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rSource") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->rSource);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_accuseUnconsciousOutfit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_accuseUnconsciousOutfit, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidAccuseUnconsciousOutfit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidAccuseUnconsciousOutfit);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eDeathSpeak") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSoundDefs.EDefinition") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->eDeathSpeak)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->eDeathSpeak))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDefaultDeathSound") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bDefaultDeathSound);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iEvents") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->iEvents);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAgilityElementUncosciousTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fAgilityElementUncosciousTime);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorDamageControlSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDamageControlSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("bExplosive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bExplosive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bProjectile") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bProjectile);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHeadshot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHeadshot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSniperShot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSniperShot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bThroughWall") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bThroughWall);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bKillByAccident") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bKillByAccident);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bWeaponSilenced") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bWeaponSilenced);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bLongRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bLongRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fTotalDamage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fTotalDamage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fPacifyDamage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fPacifyDamage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fSBDamage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fSBDamage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nImpactBodyPart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nImpactBodyPart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("maxDeathType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathType", static_cast<int>(s_Object->maxDeathType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("maxDeathContext") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathContext", static_cast<int>(s_Object->maxDeathContext)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rAccidentSetup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rAccidentSetup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bFirearmPacifiesTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bFirearmPacifiesTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fHitsNumberTimeout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fHitsNumberTimeout);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fHealthPercentTimeout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fHealthPercentTimeout);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rSource") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rSource);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_accuseUnconsciousOutfit") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_accuseUnconsciousOutfit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidAccuseUnconsciousOutfit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidAccuseUnconsciousOutfit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eDeathSpeak") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->eDeathSpeak)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDefaultDeathSound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDefaultDeathSound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iEvents") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iEvents);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAgilityElementUncosciousTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAgilityElementUncosciousTime);

	p_Stream << "}";
}

void SActorDamageControlSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorDamageControlSaveData s_Object {};

	s_Object.bExplosive = simdjson::from_json_bool(p_Document["bExplosive"]);

	s_Object.bProjectile = simdjson::from_json_bool(p_Document["bProjectile"]);

	s_Object.bHeadshot = simdjson::from_json_bool(p_Document["bHeadshot"]);

	s_Object.bSniperShot = simdjson::from_json_bool(p_Document["bSniperShot"]);

	s_Object.bThroughWall = simdjson::from_json_bool(p_Document["bThroughWall"]);

	s_Object.bKillByAccident = simdjson::from_json_bool(p_Document["bKillByAccident"]);

	s_Object.bWeaponSilenced = simdjson::from_json_bool(p_Document["bWeaponSilenced"]);

	s_Object.bLongRange = simdjson::from_json_bool(p_Document["bLongRange"]);

	s_Object.fTotalDamage = simdjson::from_json_float32(p_Document["fTotalDamage"]);

	s_Object.fPacifyDamage = simdjson::from_json_float32(p_Document["fPacifyDamage"]);

	s_Object.fSBDamage = simdjson::from_json_float32(p_Document["fSBDamage"]);

	s_Object.nImpactBodyPart = simdjson::from_json_int32(p_Document["nImpactBodyPart"]);

	s_Object.maxDeathType = static_cast<EDeathType>(ZHMEnums::GetEnumValueByName("EDeathType", std::string_view(p_Document["maxDeathType"])));

	s_Object.maxDeathContext = static_cast<EDeathContext>(ZHMEnums::GetEnumValueByName("EDeathContext", std::string_view(p_Document["maxDeathContext"])));

	s_Object.rAccidentSetup = simdjson::from_json_uint32(p_Document["rAccidentSetup"]);

	s_Object.bFirearmPacifiesTarget = simdjson::from_json_bool(p_Document["bFirearmPacifiesTarget"]);

	s_Object.fHitsNumberTimeout = simdjson::from_json_float32(p_Document["fHitsNumberTimeout"]);

	s_Object.fHealthPercentTimeout = simdjson::from_json_float32(p_Document["fHealthPercentTimeout"]);

	s_Object.rSource = simdjson::from_json_uint32(p_Document["rSource"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_accuseUnconsciousOutfit"], &s_Item);
		s_Object.m_accuseUnconsciousOutfit = s_Item;
	}

	s_Object.m_bValidAccuseUnconsciousOutfit = simdjson::from_json_bool(p_Document["m_bValidAccuseUnconsciousOutfit"]);

	s_Object.eDeathSpeak = static_cast<SActorSoundDefs_EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["eDeathSpeak"])));

	s_Object.bDefaultDeathSound = simdjson::from_json_bool(p_Document["bDefaultDeathSound"]);

	s_Object.iEvents = simdjson::from_json_int32(p_Document["iEvents"]);

	s_Object.fAgilityElementUncosciousTime = simdjson::from_json_float32(p_Document["fAgilityElementUncosciousTime"]);

	*reinterpret_cast<SActorDamageControlSaveData*>(p_Target) = s_Object;
}

void SActorDamageControlSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDamageControlSaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_accuseUnconsciousOutfit, p_Serializer, p_OwnOffset + offsetof(SActorDamageControlSaveData, m_accuseUnconsciousOutfit));
}

bool SActorDamageControlSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDamageControlSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDamageControlSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDamageControlSaveData::operator==(const SActorDamageControlSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDamageControlSaveData>)
		return false;

	if (bExplosive != p_Other.bExplosive) return false;
	if (bProjectile != p_Other.bProjectile) return false;
	if (bHeadshot != p_Other.bHeadshot) return false;
	if (bSniperShot != p_Other.bSniperShot) return false;
	if (bThroughWall != p_Other.bThroughWall) return false;
	if (bKillByAccident != p_Other.bKillByAccident) return false;
	if (bWeaponSilenced != p_Other.bWeaponSilenced) return false;
	if (bLongRange != p_Other.bLongRange) return false;
	if (fTotalDamage != p_Other.fTotalDamage) return false;
	if (fPacifyDamage != p_Other.fPacifyDamage) return false;
	if (fSBDamage != p_Other.fSBDamage) return false;
	if (nImpactBodyPart != p_Other.nImpactBodyPart) return false;
	if (maxDeathType != p_Other.maxDeathType) return false;
	if (maxDeathContext != p_Other.maxDeathContext) return false;
	if (rAccidentSetup != p_Other.rAccidentSetup) return false;
	if (bFirearmPacifiesTarget != p_Other.bFirearmPacifiesTarget) return false;
	if (fHitsNumberTimeout != p_Other.fHitsNumberTimeout) return false;
	if (fHealthPercentTimeout != p_Other.fHealthPercentTimeout) return false;
	if (rSource != p_Other.rSource) return false;
	if (m_accuseUnconsciousOutfit != p_Other.m_accuseUnconsciousOutfit) return false;
	if (m_bValidAccuseUnconsciousOutfit != p_Other.m_bValidAccuseUnconsciousOutfit) return false;
	if (eDeathSpeak != p_Other.eDeathSpeak) return false;
	if (bDefaultDeathSound != p_Other.bDefaultDeathSound) return false;
	if (iEvents != p_Other.iEvents) return false;
	if (fAgilityElementUncosciousTime != p_Other.fAgilityElementUncosciousTime) return false;

	return true;
}

ZHMTypeInfo SActorDynamicTemplateHandlerSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateHandlerSaveData", sizeof(SActorDynamicTemplateHandlerSaveData), alignof(SActorDynamicTemplateHandlerSaveData), SActorDynamicTemplateHandlerSaveData::WriteJson, SActorDynamicTemplateHandlerSaveData::WriteSimpleJson, SActorDynamicTemplateHandlerSaveData::FromSimpleJson, SActorDynamicTemplateHandlerSaveData::Serialize, SActorDynamicTemplateHandlerSaveData::Equals);

void SActorDynamicTemplateHandlerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSetpiece") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSetpiece);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorDynamicTemplateHandlerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSetpiece") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSetpiece);

	p_Stream << "}";
}

void SActorDynamicTemplateHandlerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorDynamicTemplateHandlerSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	s_Object.m_rSetpiece = simdjson::from_json_uint32(p_Document["m_rSetpiece"]);

	*reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Target) = s_Object;
}

void SActorDynamicTemplateHandlerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);

}

bool SActorDynamicTemplateHandlerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateHandlerSaveData::operator==(const SActorDynamicTemplateHandlerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateHandlerSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rItem != p_Other.m_rItem) return false;
	if (m_rSetpiece != p_Other.m_rSetpiece) return false;

	return true;
}

ZHMTypeInfo SActorDynamicTemplateManipulatorSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateManipulatorSaveData", sizeof(SActorDynamicTemplateManipulatorSaveData), alignof(SActorDynamicTemplateManipulatorSaveData), SActorDynamicTemplateManipulatorSaveData::WriteJson, SActorDynamicTemplateManipulatorSaveData::WriteSimpleJson, SActorDynamicTemplateManipulatorSaveData::FromSimpleJson, SActorDynamicTemplateManipulatorSaveData::Serialize, SActorDynamicTemplateManipulatorSaveData::Equals);

void SActorDynamicTemplateManipulatorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorDynamicTemplateManipulatorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorDynamicTemplateManipulatorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorDynamicTemplateManipulatorSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Target) = s_Object;
}

void SActorDynamicTemplateManipulatorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);

}

bool SActorDynamicTemplateManipulatorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateManipulatorSaveData::operator==(const SActorDynamicTemplateManipulatorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateManipulatorSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SActorDynamicTemplateSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateSaveData", sizeof(SActorDynamicTemplateSaveData), alignof(SActorDynamicTemplateSaveData), SActorDynamicTemplateSaveData::WriteJson, SActorDynamicTemplateSaveData::WriteSimpleJson, SActorDynamicTemplateSaveData::FromSimpleJson, SActorDynamicTemplateSaveData::Serialize, SActorDynamicTemplateSaveData::Equals);

void SActorDynamicTemplateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTensionLimit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EGameTension") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTensionLimit)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eTensionLimit))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionLimit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorEmotionState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eEmotionLimit)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionLimit))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeLimit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_nTimeLimit, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTensionRemoveLimit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EGameTension") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTensionRemoveLimit)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eTensionRemoveLimit))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionRemoveLimit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorEmotionState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eEmotionRemoveLimit)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionRemoveLimit))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeRemoveLimit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_nTimeRemoveLimit, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_resourceID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_resourceID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInstance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInstance);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorDynamicTemplateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTensionLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eTensionLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeLimit") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nTimeLimit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTensionRemoveLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eTensionRemoveLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionRemoveLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionRemoveLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeRemoveLimit") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nTimeRemoveLimit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_resourceID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_resourceID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInstance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInstance);

	p_Stream << "}";
}

void SActorDynamicTemplateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorDynamicTemplateSaveData s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	s_Object.m_eTensionLimit = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eTensionLimit"])));

	s_Object.m_eEmotionLimit = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eEmotionLimit"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nTimeLimit"], &s_Item);
		s_Object.m_nTimeLimit = s_Item;
	}

	s_Object.m_eTensionRemoveLimit = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eTensionRemoveLimit"])));

	s_Object.m_eEmotionRemoveLimit = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eEmotionRemoveLimit"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nTimeRemoveLimit"], &s_Item);
		s_Object.m_nTimeRemoveLimit = s_Item;
	}

	s_Object.m_resourceID = simdjson::from_json_int64(p_Document["m_resourceID"]);

	s_Object.m_rInstance = simdjson::from_json_uint32(p_Document["m_rInstance"]);

	*reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Target) = s_Object;
}

void SActorDynamicTemplateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_sName));
	ZGameTime::Serialize(&s_Object->m_nTimeLimit, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_nTimeLimit));
	ZGameTime::Serialize(&s_Object->m_nTimeRemoveLimit, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_nTimeRemoveLimit));
}

bool SActorDynamicTemplateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateSaveData::operator==(const SActorDynamicTemplateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateSaveData>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_eTensionLimit != p_Other.m_eTensionLimit) return false;
	if (m_eEmotionLimit != p_Other.m_eEmotionLimit) return false;
	if (m_nTimeLimit != p_Other.m_nTimeLimit) return false;
	if (m_eTensionRemoveLimit != p_Other.m_eTensionRemoveLimit) return false;
	if (m_eEmotionRemoveLimit != p_Other.m_eEmotionRemoveLimit) return false;
	if (m_nTimeRemoveLimit != p_Other.m_nTimeRemoveLimit) return false;
	if (m_resourceID != p_Other.m_resourceID) return false;
	if (m_rInstance != p_Other.m_rInstance) return false;

	return true;
}

ZHMTypeInfo SActorGoalSaveData::TypeInfo = ZHMTypeInfo("SActorGoalSaveData", sizeof(SActorGoalSaveData), alignof(SActorGoalSaveData), SActorGoalSaveData::WriteJson, SActorGoalSaveData::WriteSimpleJson, SActorGoalSaveData::FromSimpleJson, SActorGoalSaveData::Serialize, SActorGoalSaveData::Equals);

void SActorGoalSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aHandled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHandled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHandled[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aHandled.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIsCurrent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIsCurrent.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIsCurrent[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aIsCurrent.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fExpiredTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_fExpiredTime.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_fExpiredTime[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_fExpiredTime.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorGoalSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aHandled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHandled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHandled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aHandled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIsCurrent") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIsCurrent.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIsCurrent[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIsCurrent.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fExpiredTime") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_fExpiredTime.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_fExpiredTime[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_fExpiredTime.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorGoalSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorGoalSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_int32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aHandled"])
	{
		s_Object.m_aHandled.push_back(simdjson::from_json_bool(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aIsCurrent"])
	{
		s_Object.m_aIsCurrent.push_back(simdjson::from_json_bool(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_fExpiredTime"])
	{
		s_Object.m_fExpiredTime.push_back(simdjson::from_json_float32(s_Item0));
	}

	*reinterpret_cast<SActorGoalSaveData*>(p_Target) = s_Object;
}

void SActorGoalSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aEntities));
	TArray<bool>::Serialize(&s_Object->m_aHandled, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aHandled));
	TArray<bool>::Serialize(&s_Object->m_aIsCurrent, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aIsCurrent));
	TArray<float32>::Serialize(&s_Object->m_fExpiredTime, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_fExpiredTime));
}

bool SActorGoalSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorGoalSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorGoalSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorGoalSaveData::operator==(const SActorGoalSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorGoalSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aHandled != p_Other.m_aHandled) return false;
	if (m_aIsCurrent != p_Other.m_aIsCurrent) return false;
	if (m_fExpiredTime != p_Other.m_fExpiredTime) return false;

	return true;
}

ZHMTypeInfo SActorInventoryItemSaveData::TypeInfo = ZHMTypeInfo("SActorInventoryItemSaveData", sizeof(SActorInventoryItemSaveData), alignof(SActorInventoryItemSaveData), SActorInventoryItemSaveData::WriteJson, SActorInventoryItemSaveData::WriteSimpleJson, SActorInventoryItemSaveData::FromSimpleJson, SActorInventoryItemSaveData::Serialize, SActorInventoryItemSaveData::Equals);

void SActorInventoryItemSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAttachLocation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAttachLocation") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAttachLocation)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAttachLocation", static_cast<int>(s_Object->m_eAttachLocation))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMaxTension") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EGameTension") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eMaxTension)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eMaxTension))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeftHand") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeftHand);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeapon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeapon);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorInventoryItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAttachLocation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAttachLocation", static_cast<int>(s_Object->m_eAttachLocation)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMaxTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eMaxTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeftHand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeftHand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeapon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeapon);

	p_Stream << "}";
}

void SActorInventoryItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorInventoryItemSaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	s_Object.m_eAttachLocation = static_cast<EAttachLocation>(ZHMEnums::GetEnumValueByName("EAttachLocation", std::string_view(p_Document["m_eAttachLocation"])));

	s_Object.m_eMaxTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eMaxTension"])));

	s_Object.m_bLeftHand = simdjson::from_json_bool(p_Document["m_bLeftHand"]);

	s_Object.m_bWeapon = simdjson::from_json_bool(p_Document["m_bWeapon"]);

	*reinterpret_cast<SActorInventoryItemSaveData*>(p_Target) = s_Object;
}

void SActorInventoryItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);

}

bool SActorInventoryItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorInventoryItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorInventoryItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorInventoryItemSaveData::operator==(const SActorInventoryItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorInventoryItemSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;
	if (m_eAttachLocation != p_Other.m_eAttachLocation) return false;
	if (m_eMaxTension != p_Other.m_eMaxTension) return false;
	if (m_bLeftHand != p_Other.m_bLeftHand) return false;
	if (m_bWeapon != p_Other.m_bWeapon) return false;

	return true;
}

ZHMTypeInfo SActorInventorySaveData::TypeInfo = ZHMTypeInfo("SActorInventorySaveData", sizeof(SActorInventorySaveData), alignof(SActorInventorySaveData), SActorInventorySaveData::WriteJson, SActorInventorySaveData::WriteSimpleJson, SActorInventorySaveData::FromSimpleJson, SActorInventorySaveData::Serialize, SActorInventorySaveData::Equals);

void SActorInventorySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorInventoryItemSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorInventoryItemSaveData") << ",\"$val\":";
		SActorInventoryItemSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorInventorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		SActorInventoryItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorInventorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorInventorySaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aItems"])
	{
		SActorInventoryItemSaveData s_ArrayItem0;
		SActorInventoryItemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItems.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SActorInventorySaveData*>(p_Target) = s_Object;
}

void SActorInventorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);

	TArray<SActorInventoryItemSaveData>::Serialize(&s_Object->m_aItems, p_Serializer, p_OwnOffset + offsetof(SActorInventorySaveData, m_aItems));
}

bool SActorInventorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorInventorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorInventorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorInventorySaveData::operator==(const SActorInventorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorInventorySaveData>)
		return false;

	if (m_aItems != p_Other.m_aItems) return false;

	return true;
}

ZHMTypeInfo SActorItemActionSaveData::TypeInfo = ZHMTypeInfo("SActorItemActionSaveData", sizeof(SActorItemActionSaveData), alignof(SActorItemActionSaveData), SActorItemActionSaveData::WriteJson, SActorItemActionSaveData::WriteSimpleJson, SActorItemActionSaveData::FromSimpleJson, SActorItemActionSaveData::Serialize, SActorItemActionSaveData::Equals);

void SActorItemActionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SActorItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorItemActionSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SActorItemActionSaveData*>(p_Target) = s_Object;
}

void SActorItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);

}

bool SActorItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorItemActionSaveData::operator==(const SActorItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorItemActionSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

ZHMTypeInfo SActorKeywordProxySaveData::TypeInfo = ZHMTypeInfo("SActorKeywordProxySaveData", sizeof(SActorKeywordProxySaveData), alignof(SActorKeywordProxySaveData), SActorKeywordProxySaveData::WriteJson, SActorKeywordProxySaveData::WriteSimpleJson, SActorKeywordProxySaveData::FromSimpleJson, SActorKeywordProxySaveData::Serialize, SActorKeywordProxySaveData::Equals);

void SActorKeywordProxySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorKeywordProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorKeywordProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorKeywordProxySaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorKeywordProxySaveData*>(p_Target) = s_Object;
}

void SActorKeywordProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);

}

bool SActorKeywordProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorKeywordProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorKeywordProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorKeywordProxySaveData::operator==(const SActorKeywordProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorKeywordProxySaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SActorKeywordProxiesSaveData::TypeInfo = ZHMTypeInfo("SActorKeywordProxiesSaveData", sizeof(SActorKeywordProxiesSaveData), alignof(SActorKeywordProxiesSaveData), SActorKeywordProxiesSaveData::WriteJson, SActorKeywordProxiesSaveData::WriteSimpleJson, SActorKeywordProxiesSaveData::FromSimpleJson, SActorKeywordProxiesSaveData::Serialize, SActorKeywordProxiesSaveData::Equals);

void SActorKeywordProxiesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorKeywordProxySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorKeywordProxySaveData") << ",\"$val\":";
		SActorKeywordProxySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorKeywordProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorKeywordProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorKeywordProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorKeywordProxiesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SActorKeywordProxySaveData s_ArrayItem0;
		SActorKeywordProxySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Target) = s_Object;
}

void SActorKeywordProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorKeywordProxiesSaveData, m_aEntities));
	TArray<SActorKeywordProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorKeywordProxiesSaveData, m_aData));
}

bool SActorKeywordProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorKeywordProxiesSaveData::operator==(const SActorKeywordProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorKeywordProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SActorManagerReferencableData::TypeInfo = ZHMTypeInfo("SActorManagerReferencableData", sizeof(SActorManagerReferencableData), alignof(SActorManagerReferencableData), SActorManagerReferencableData::WriteJson, SActorManagerReferencableData::WriteSimpleJson, SActorManagerReferencableData::FromSimpleJson, SActorManagerReferencableData::Serialize, SActorManagerReferencableData::Equals);

void SActorManagerReferencableData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aSituationTypes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ESituationType>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSituationTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSituationTypes[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ESituationType") << ",\"$val\":";
		p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Item0)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationType", static_cast<int>(s_Item0))) << "}";
		p_Stream << "}";

		if (i < s_Object->m_aSituationTypes.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorManagerReferencableData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSituationTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSituationTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSituationTypes[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationType", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aSituationTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorManagerReferencableData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorManagerReferencableData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSituationTypes"])
	{
		s_Object.m_aSituationTypes.push_back(static_cast<ESituationType>(ZHMEnums::GetEnumValueByName("ESituationType", std::string_view(s_Item0))));
	}

	*reinterpret_cast<SActorManagerReferencableData*>(p_Target) = s_Object;
}

void SActorManagerReferencableData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);

	TArray<ESituationType>::Serialize(&s_Object->m_aSituationTypes, p_Serializer, p_OwnOffset + offsetof(SActorManagerReferencableData, m_aSituationTypes));
}

bool SActorManagerReferencableData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorManagerReferencableData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorManagerReferencableData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorManagerReferencableData::operator==(const SActorManagerReferencableData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorManagerReferencableData>)
		return false;

	if (m_aSituationTypes != p_Other.m_aSituationTypes) return false;

	return true;
}

ZHMTypeInfo SActorProviderApproachSaveData::TypeInfo = ZHMTypeInfo("SActorProviderApproachSaveData", sizeof(SActorProviderApproachSaveData), alignof(SActorProviderApproachSaveData), SActorProviderApproachSaveData::WriteJson, SActorProviderApproachSaveData::WriteSimpleJson, SActorProviderApproachSaveData::FromSimpleJson, SActorProviderApproachSaveData::Serialize, SActorProviderApproachSaveData::Equals);

void SActorProviderApproachSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rCastActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCastActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorProviderApproachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCastActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCastActor);

	p_Stream << "}";
}

void SActorProviderApproachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorProviderApproachSaveData s_Object {};

	s_Object.m_rCastActor = simdjson::from_json_uint32(p_Document["m_rCastActor"]);

	*reinterpret_cast<SActorProviderApproachSaveData*>(p_Target) = s_Object;
}

void SActorProviderApproachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);

}

bool SActorProviderApproachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProviderApproachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProviderApproachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProviderApproachSaveData::operator==(const SActorProviderApproachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProviderApproachSaveData>)
		return false;

	if (m_rCastActor != p_Other.m_rCastActor) return false;

	return true;
}

ZHMTypeInfo SActorProviderDirectSaveData::TypeInfo = ZHMTypeInfo("SActorProviderDirectSaveData", sizeof(SActorProviderDirectSaveData), alignof(SActorProviderDirectSaveData), SActorProviderDirectSaveData::WriteJson, SActorProviderDirectSaveData::WriteSimpleJson, SActorProviderDirectSaveData::FromSimpleJson, SActorProviderDirectSaveData::Serialize, SActorProviderDirectSaveData::Equals);

void SActorProviderDirectSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunning);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorProviderDirectSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunning);

	p_Stream << "}";
}

void SActorProviderDirectSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorProviderDirectSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActors"])
	{
		s_Object.m_aActors.push_back(simdjson::from_json_uint32(s_Item0));
	}

	s_Object.m_bRunning = simdjson::from_json_bool(p_Document["m_bRunning"]);

	*reinterpret_cast<SActorProviderDirectSaveData*>(p_Target) = s_Object;
}

void SActorProviderDirectSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SActorProviderDirectSaveData, m_aActors));
}

bool SActorProviderDirectSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProviderDirectSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProviderDirectSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProviderDirectSaveData::operator==(const SActorProviderDirectSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProviderDirectSaveData>)
		return false;

	if (m_aActors != p_Other.m_aActors) return false;
	if (m_bRunning != p_Other.m_bRunning) return false;

	return true;
}

ZHMTypeInfo SVector3::TypeInfo = ZHMTypeInfo("SVector3", sizeof(SVector3), alignof(SVector3), SVector3::WriteJson, SVector3::WriteSimpleJson, SVector3::FromSimpleJson, SVector3::Serialize, SVector3::Equals);

void SVector3::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << "}";

	p_Stream << "}";
}

void SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);

	p_Stream << "}";
}

void SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector3 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	*reinterpret_cast<SVector3*>(p_Target) = s_Object;
}

void SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

}

bool SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector3::operator==(const SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector3>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;

	return true;
}

ZHMTypeInfo SActorRagdollPoseSaveData::TypeInfo = ZHMTypeInfo("SActorRagdollPoseSaveData", sizeof(SActorRagdollPoseSaveData), alignof(SActorRagdollPoseSaveData), SActorRagdollPoseSaveData::WriteJson, SActorRagdollPoseSaveData::WriteSimpleJson, SActorRagdollPoseSaveData::FromSimpleJson, SActorRagdollPoseSaveData::Serialize, SActorRagdollPoseSaveData::Equals);

void SActorRagdollPoseSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vBodyVelocity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vBodyVelocity, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorBoneSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorBoneSaveData") << ",\"$val\":";
		SActorBoneSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneIndices") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneIndices[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aBoneIndices.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorRagdollPoseSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vBodyVelocity") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vBodyVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SActorBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBoneIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorRagdollPoseSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorRagdollPoseSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vBodyVelocity"], &s_Item);
		s_Object.m_vBodyVelocity = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBones"])
	{
		SActorBoneSaveData s_ArrayItem0;
		SActorBoneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBones.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBoneIndices"])
	{
		s_Object.m_aBoneIndices.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SActorRagdollPoseSaveData*>(p_Target) = s_Object;
}

void SActorRagdollPoseSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vBodyVelocity, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_vBodyVelocity));
	TArray<SActorBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_aBones));
	TArray<uint32>::Serialize(&s_Object->m_aBoneIndices, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_aBoneIndices));
}

bool SActorRagdollPoseSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorRagdollPoseSaveData::operator==(const SActorRagdollPoseSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorRagdollPoseSaveData>)
		return false;

	if (m_vBodyVelocity != p_Other.m_vBodyVelocity) return false;
	if (m_aBones != p_Other.m_aBones) return false;
	if (m_aBoneIndices != p_Other.m_aBoneIndices) return false;

	return true;
}

ZHMTypeInfo SEventHistorySaveData::TypeInfo = ZHMTypeInfo("SEventHistorySaveData", sizeof(SEventHistorySaveData), alignof(SEventHistorySaveData), SEventHistorySaveData::WriteJson, SEventHistorySaveData::WriteSimpleJson, SEventHistorySaveData::FromSimpleJson, SEventHistorySaveData::Serialize, SEventHistorySaveData::Equals);

void SEventHistorySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aOccurences") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZGameTime>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aOccurences.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aOccurences[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
		ZGameTime::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aOccurences.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SEventHistorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aOccurences") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aOccurences.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aOccurences[i];
		ZGameTime::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aOccurences.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEventHistorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEventHistorySaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aOccurences"])
	{
		ZGameTime s_ArrayItem0;
		ZGameTime::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aOccurences.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SEventHistorySaveData*>(p_Target) = s_Object;
}

void SEventHistorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);

	TArray<ZGameTime>::Serialize(&s_Object->m_aOccurences, p_Serializer, p_OwnOffset + offsetof(SEventHistorySaveData, m_aOccurences));
}

bool SEventHistorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventHistorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventHistorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventHistorySaveData::operator==(const SEventHistorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventHistorySaveData>)
		return false;

	if (m_aOccurences != p_Other.m_aOccurences) return false;

	return true;
}

ZHMTypeInfo SMatrix::TypeInfo = ZHMTypeInfo("SMatrix", sizeof(SMatrix), alignof(SMatrix), SMatrix::WriteJson, SMatrix::WriteSimpleJson, SMatrix::FromSimpleJson, SMatrix::Serialize, SMatrix::Equals);

void SMatrix::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("XAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->XAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->YAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->ZAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->Trans, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SMatrix::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	float4::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	float4::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	float4::WriteSimpleJson(&s_Object->ZAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	float4::WriteSimpleJson(&s_Object->Trans, p_Stream);

	p_Stream << "}";
}

void SMatrix::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["Trans"], &s_Item);
		s_Object.Trans = s_Item;
	}

	*reinterpret_cast<SMatrix*>(p_Target) = s_Object;
}

void SMatrix::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	float4::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, XAxis));
	float4::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, YAxis));
	float4::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, ZAxis));
	float4::Serialize(&s_Object->Trans, p_Serializer, p_OwnOffset + offsetof(SMatrix, Trans));
}

bool SMatrix::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix::operator==(const SMatrix& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;
	if (Trans != p_Other.Trans) return false;

	return true;
}

ZHMTypeInfo SKnownEntitySaveData::TypeInfo = ZHMTypeInfo("SKnownEntitySaveData", sizeof(SKnownEntitySaveData), alignof(SKnownEntitySaveData), SKnownEntitySaveData::WriteJson, SKnownEntitySaveData::WriteSimpleJson, SKnownEntitySaveData::FromSimpleJson, SKnownEntitySaveData::Serialize, SKnownEntitySaveData::Equals);

void SKnownEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nSharedIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSharedIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEvents") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAIEventSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEvents[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAIEventSaveData") << ",\"$val\":";
		SAIEventSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEvents.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBooleanEvents") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBooleanEvents);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBooleanEventsHandled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBooleanEventsHandled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_knownWorldMatrix") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMatrix") << ",\"$val\":";
	SMatrix::WriteJson(&s_Object->m_knownWorldMatrix, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWorldMatrixUpdate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastWorldMatrixUpdate, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGoals") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGoals);
	p_Stream << "}";

	p_Stream << "}";
}

void SKnownEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nSharedIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSharedIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEvents[i];
		SAIEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBooleanEvents") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBooleanEvents);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBooleanEventsHandled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBooleanEventsHandled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_knownWorldMatrix") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_knownWorldMatrix, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWorldMatrixUpdate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastWorldMatrixUpdate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGoals") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGoals);

	p_Stream << "}";
}

void SKnownEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SKnownEntitySaveData s_Object {};

	s_Object.m_nSharedIndex = simdjson::from_json_int32(p_Document["m_nSharedIndex"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEvents"])
	{
		SAIEventSaveData s_ArrayItem0;
		SAIEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEvents.push_back(s_ArrayItem0);
	}

	s_Object.m_nBooleanEvents = simdjson::from_json_uint32(p_Document["m_nBooleanEvents"]);

	s_Object.m_nBooleanEventsHandled = simdjson::from_json_uint32(p_Document["m_nBooleanEventsHandled"]);

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_knownWorldMatrix"], &s_Item);
		s_Object.m_knownWorldMatrix = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastWorldMatrixUpdate"], &s_Item);
		s_Object.m_tLastWorldMatrixUpdate = s_Item;
	}

	s_Object.m_nGoals = simdjson::from_json_uint16(p_Document["m_nGoals"]);

	*reinterpret_cast<SKnownEntitySaveData*>(p_Target) = s_Object;
}

void SKnownEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);

	TArray<SAIEventSaveData>::Serialize(&s_Object->m_aEvents, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_aEvents));
	SMatrix::Serialize(&s_Object->m_knownWorldMatrix, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_knownWorldMatrix));
	ZGameTime::Serialize(&s_Object->m_tLastWorldMatrixUpdate, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_tLastWorldMatrixUpdate));
}

bool SKnownEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKnownEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKnownEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKnownEntitySaveData::operator==(const SKnownEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKnownEntitySaveData>)
		return false;

	if (m_nSharedIndex != p_Other.m_nSharedIndex) return false;
	if (m_aEvents != p_Other.m_aEvents) return false;
	if (m_nBooleanEvents != p_Other.m_nBooleanEvents) return false;
	if (m_nBooleanEventsHandled != p_Other.m_nBooleanEventsHandled) return false;
	if (m_knownWorldMatrix != p_Other.m_knownWorldMatrix) return false;
	if (m_tLastWorldMatrixUpdate != p_Other.m_tLastWorldMatrixUpdate) return false;
	if (m_nGoals != p_Other.m_nGoals) return false;

	return true;
}

ZHMTypeInfo SKnowledgeSaveData::TypeInfo = ZHMTypeInfo("SKnowledgeSaveData", sizeof(SKnowledgeSaveData), alignof(SKnowledgeSaveData), SKnowledgeSaveData::WriteJson, SKnowledgeSaveData::WriteSimpleJson, SKnowledgeSaveData::FromSimpleJson, SKnowledgeSaveData::Serialize, SKnowledgeSaveData::Equals);

void SKnowledgeSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aKnownEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SKnownEntitySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKnownEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKnownEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SKnownEntitySaveData") << ",\"$val\":";
		SKnownEntitySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aKnownEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGoalKeys") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<EAIGoal>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGoalKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGoalKeys[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("EAIGoal") << ",\"$val\":";
		p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Item0)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIGoal", static_cast<int>(s_Item0))) << "}";
		p_Stream << "}";

		if (i < s_Object->m_aGoalKeys.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGoals") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<SActorGoalSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGoals.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGoals[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorGoalSaveData") << ",\"$val\":";
		SActorGoalSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aGoals.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMAttention") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMAttention);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMAttentionLastUpdate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMAttentionLastUpdate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMDisguiseAttention") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMDisguiseAttention);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMTrespassingAttention") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMTrespassingAttention);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMLastTrespassingAttentionMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMLastTrespassingAttentionMax);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTrespassingAttentionGain") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastTrespassingAttentionGain, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastAttentionEvaluate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastAttentionEvaluate, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMWeaponAttention") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMWeaponAttention);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMWeaponAttentionChange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMWeaponAttentionChange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGameTension") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EGameTension") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eGameTension)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eGameTension))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAmbientStartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tAmbientStartTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tExpiredAIModifierSuppressSocialGreeting") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tExpiredAIModifierSuppressSocialGreeting, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_behaviorModifiers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_behaviorModifiers);
	p_Stream << "}";

	p_Stream << "}";
}

void SKnowledgeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKnownEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKnownEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKnownEntities[i];
		SKnownEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aKnownEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGoalKeys") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGoalKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGoalKeys[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIGoal", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aGoalKeys.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGoals") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGoals.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGoals[i];
		SActorGoalSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGoals.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMAttentionLastUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMAttentionLastUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMDisguiseAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMDisguiseAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMTrespassingAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMTrespassingAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMLastTrespassingAttentionMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMLastTrespassingAttentionMax);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTrespassingAttentionGain") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTrespassingAttentionGain, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastAttentionEvaluate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastAttentionEvaluate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMWeaponAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMWeaponAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMWeaponAttentionChange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMWeaponAttentionChange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGameTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eGameTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAmbientStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAmbientStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tExpiredAIModifierSuppressSocialGreeting") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiredAIModifierSuppressSocialGreeting, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_behaviorModifiers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_behaviorModifiers);

	p_Stream << "}";
}

void SKnowledgeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SKnowledgeSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aKnownEntities"])
	{
		SKnownEntitySaveData s_ArrayItem0;
		SKnownEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aKnownEntities.push_back(s_ArrayItem0);
	}

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGoalKeys"])
	{
		s_Object.m_aGoalKeys[s_Index0] = static_cast<EAIGoal>(ZHMEnums::GetEnumValueByName("EAIGoal", std::string_view(s_Item0)));
		++s_Index0;
	}
	}

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGoals"])
	{
		SActorGoalSaveData s_ArrayItem0 {};
		SActorGoalSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGoals[s_Index0] = s_ArrayItem0;
		++s_Index0;
	}
	}

	s_Object.m_fHMAttention = simdjson::from_json_float32(p_Document["m_fHMAttention"]);

	s_Object.m_fHMAttentionLastUpdate = simdjson::from_json_float32(p_Document["m_fHMAttentionLastUpdate"]);

	s_Object.m_fHMDisguiseAttention = simdjson::from_json_float32(p_Document["m_fHMDisguiseAttention"]);

	s_Object.m_fHMTrespassingAttention = simdjson::from_json_float32(p_Document["m_fHMTrespassingAttention"]);

	s_Object.m_fHMLastTrespassingAttentionMax = simdjson::from_json_float32(p_Document["m_fHMLastTrespassingAttentionMax"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTrespassingAttentionGain"], &s_Item);
		s_Object.m_tLastTrespassingAttentionGain = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastAttentionEvaluate"], &s_Item);
		s_Object.m_tLastAttentionEvaluate = s_Item;
	}

	s_Object.m_fHMWeaponAttention = simdjson::from_json_float32(p_Document["m_fHMWeaponAttention"]);

	s_Object.m_fHMWeaponAttentionChange = simdjson::from_json_float32(p_Document["m_fHMWeaponAttentionChange"]);

	s_Object.m_eGameTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eGameTension"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tAmbientStartTime"], &s_Item);
		s_Object.m_tAmbientStartTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tExpiredAIModifierSuppressSocialGreeting"], &s_Item);
		s_Object.m_tExpiredAIModifierSuppressSocialGreeting = s_Item;
	}

	s_Object.m_behaviorModifiers = simdjson::from_json_uint32(p_Document["m_behaviorModifiers"]);

	*reinterpret_cast<SKnowledgeSaveData*>(p_Target) = s_Object;
}

void SKnowledgeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);

	TArray<SKnownEntitySaveData>::Serialize(&s_Object->m_aKnownEntities, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aKnownEntities));
	TFixedArray<EAIGoal, 31>::Serialize(&s_Object->m_aGoalKeys, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aGoalKeys));
	TFixedArray<SActorGoalSaveData, 31>::Serialize(&s_Object->m_aGoals, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aGoals));
	ZGameTime::Serialize(&s_Object->m_tLastTrespassingAttentionGain, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tLastTrespassingAttentionGain));
	ZGameTime::Serialize(&s_Object->m_tLastAttentionEvaluate, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tLastAttentionEvaluate));
	ZGameTime::Serialize(&s_Object->m_tAmbientStartTime, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tAmbientStartTime));
	ZGameTime::Serialize(&s_Object->m_tExpiredAIModifierSuppressSocialGreeting, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tExpiredAIModifierSuppressSocialGreeting));
}

bool SKnowledgeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKnowledgeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKnowledgeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKnowledgeSaveData::operator==(const SKnowledgeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKnowledgeSaveData>)
		return false;

	if (m_aKnownEntities != p_Other.m_aKnownEntities) return false;
	if (m_aGoalKeys != p_Other.m_aGoalKeys) return false;
	if (m_aGoals != p_Other.m_aGoals) return false;
	if (m_fHMAttention != p_Other.m_fHMAttention) return false;
	if (m_fHMAttentionLastUpdate != p_Other.m_fHMAttentionLastUpdate) return false;
	if (m_fHMDisguiseAttention != p_Other.m_fHMDisguiseAttention) return false;
	if (m_fHMTrespassingAttention != p_Other.m_fHMTrespassingAttention) return false;
	if (m_fHMLastTrespassingAttentionMax != p_Other.m_fHMLastTrespassingAttentionMax) return false;
	if (m_tLastTrespassingAttentionGain != p_Other.m_tLastTrespassingAttentionGain) return false;
	if (m_tLastAttentionEvaluate != p_Other.m_tLastAttentionEvaluate) return false;
	if (m_fHMWeaponAttention != p_Other.m_fHMWeaponAttention) return false;
	if (m_fHMWeaponAttentionChange != p_Other.m_fHMWeaponAttentionChange) return false;
	if (m_eGameTension != p_Other.m_eGameTension) return false;
	if (m_tAmbientStartTime != p_Other.m_tAmbientStartTime) return false;
	if (m_tExpiredAIModifierSuppressSocialGreeting != p_Other.m_tExpiredAIModifierSuppressSocialGreeting) return false;
	if (m_behaviorModifiers != p_Other.m_behaviorModifiers) return false;

	return true;
}

ZHMTypeInfo SLongTermMemorySaveData::TypeInfo = ZHMTypeInfo("SLongTermMemorySaveData", sizeof(SLongTermMemorySaveData), alignof(SLongTermMemorySaveData), SLongTermMemorySaveData::WriteJson, SLongTermMemorySaveData::WriteSimpleJson, SLongTermMemorySaveData::FromSimpleJson, SLongTermMemorySaveData::Serialize, SLongTermMemorySaveData::Equals);

void SLongTermMemorySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLongTermMemorySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sOutfit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_sOutfit, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Memory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_Memory);
	p_Stream << "}";

	p_Stream << "}";
}

void SLongTermMemorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLongTermMemorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sOutfit") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_sOutfit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Memory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_Memory);

	p_Stream << "}";
}

void SLongTermMemorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLongTermMemorySaveData s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_sOutfit"], &s_Item);
		s_Object.m_sOutfit = s_Item;
	}

	s_Object.m_Memory = simdjson::from_json_uint8(p_Document["m_Memory"]);

	*reinterpret_cast<SLongTermMemorySaveData*>(p_Target) = s_Object;
}

void SLongTermMemorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLongTermMemorySaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_sOutfit, p_Serializer, p_OwnOffset + offsetof(SLongTermMemorySaveData, m_sOutfit));
}

bool SLongTermMemorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLongTermMemorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLongTermMemorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLongTermMemorySaveData::operator==(const SLongTermMemorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLongTermMemorySaveData>)
		return false;

	if (m_sOutfit != p_Other.m_sOutfit) return false;
	if (m_Memory != p_Other.m_Memory) return false;

	return true;
}

ZHMTypeInfo SActorSaveData::TypeInfo = ZHMTypeInfo("SActorSaveData", sizeof(SActorSaveData), alignof(SActorSaveData), SActorSaveData::WriteJson, SActorSaveData::WriteSimpleJson, SActorSaveData::FromSimpleJson, SActorSaveData::Serialize, SActorSaveData::Equals);

void SActorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vQuaternion, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Inventory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorInventorySaveData") << ",\"$val\":";
	SActorInventorySaveData::WriteJson(&s_Object->m_Inventory, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AnimSet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorAnimSetSaveData") << ",\"$val\":";
	SActorAnimSetSaveData::WriteJson(&s_Object->m_AnimSet, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentBehaviorType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentBehaviorType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CurrentBehaviorState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_CurrentBehaviorState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCurrentBehaviorEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCurrentBehaviorEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCurrentBehaviorEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aCurrentBehaviorEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBehaviorEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBehaviorEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBehaviorEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aBehaviorEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_KnowledgeData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SKnowledgeSaveData") << ",\"$val\":";
	SKnowledgeSaveData::WriteJson(&s_Object->m_KnowledgeData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitRepositoryId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_OutfitRepositoryId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSequenceEndTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tSequenceEndTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorState", static_cast<int>(s_Object->m_nState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBodyContainerEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBodyContainerEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBodyContainerSlot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBodyContainerSlot);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorEmotionState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eEmotionState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCorpseBodybagEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCorpseBodybagEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDragBodybagEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDragBodybagEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorDamageControlData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorDamageControlSaveData") << ",\"$val\":";
	SActorDamageControlSaveData::WriteJson(&s_Object->m_ActorDamageControlData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AnimatedActorOrderData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_AnimatedActorOrderData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStepsFraction") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStepsFraction);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fZBeforeEnteringStairs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fZBeforeEnteringStairs);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicTemplates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorDynamicTemplateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicTemplates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorDynamicTemplateSaveData") << ",\"$val\":";
		SActorDynamicTemplateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aDynamicTemplates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeSinceLastGroan") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeSinceLastGroan);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sEndOrientation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMatrix") << ",\"$val\":";
	SMatrix::WriteJson(&s_Object->m_sEndOrientation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eOverrideSensorState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorAIState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eOverrideSensorState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorAIState", static_cast<int>(s_Object->m_eOverrideSensorState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDeathBehavior") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDeathBehavior") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eDeathBehavior)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathBehavior", static_cast<int>(s_Object->m_eDeathBehavior))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOverrideIndiciatorDrawDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOverrideIndiciatorDrawDistance);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bumpsHistory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SEventHistorySaveData") << ",\"$val\":";
	SEventHistorySaveData::WriteJson(&s_Object->m_bumpsHistory, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RagdollPose") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorRagdollPoseSaveData") << ",\"$val\":";
	SActorRagdollPoseSaveData::WriteJson(&s_Object->m_RagdollPose, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aLongTermMemorySaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SLongTermMemorySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aLongTermMemorySaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aLongTermMemorySaveData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SLongTermMemorySaveData") << ",\"$val\":";
		SLongTermMemorySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aLongTermMemorySaveData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNude") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNude);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActiveEnforcer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActiveEnforcer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPotentialEnforcer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPotentialEnforcer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDynamicEnforcer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDynamicEnforcer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCrowdCharacter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCrowdCharacter);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSnoring") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSnoring);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHiddenWithHitman") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHiddenWithHitman);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsWoozy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsWoozy);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSpreadingSickness") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSpreadingSickness);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlendingOrientation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlendingOrientation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMakeMainWeaponUndroppable") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMakeMainWeaponUndroppable);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponIsHidden") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponIsHidden);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegisteredForLT") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegisteredForLT);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKeepOverrideSensorStateAfterBeingUnconscious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKeepOverrideSensorStateAfterBeingUnconscious);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponReady") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponReady);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDynamicWeaponUnholstered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDynamicWeaponUnholstered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceInteractionGlow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceInteractionGlow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOutfitRuined") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOutfitRuined);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternion") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vQuaternion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Inventory") << ":";
	SActorInventorySaveData::WriteSimpleJson(&s_Object->m_Inventory, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AnimSet") << ":";
	SActorAnimSetSaveData::WriteSimpleJson(&s_Object->m_AnimSet, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentBehaviorType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentBehaviorType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CurrentBehaviorState") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CurrentBehaviorState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCurrentBehaviorEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCurrentBehaviorEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCurrentBehaviorEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCurrentBehaviorEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBehaviorEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBehaviorEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBehaviorEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBehaviorEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_KnowledgeData") << ":";
	SKnowledgeSaveData::WriteSimpleJson(&s_Object->m_KnowledgeData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitRepositoryId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_OutfitRepositoryId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSequenceEndTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tSequenceEndTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBodyContainerEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBodyContainerEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBodyContainerSlot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBodyContainerSlot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCorpseBodybagEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCorpseBodybagEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDragBodybagEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDragBodybagEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorDamageControlData") << ":";
	SActorDamageControlSaveData::WriteSimpleJson(&s_Object->m_ActorDamageControlData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AnimatedActorOrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_AnimatedActorOrderData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStepsFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStepsFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fZBeforeEnteringStairs") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fZBeforeEnteringStairs);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicTemplates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicTemplates[i];
		SActorDynamicTemplateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aDynamicTemplates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeSinceLastGroan") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeSinceLastGroan);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sEndOrientation") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_sEndOrientation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eOverrideSensorState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorAIState", static_cast<int>(s_Object->m_eOverrideSensorState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDeathBehavior") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathBehavior", static_cast<int>(s_Object->m_eDeathBehavior)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOverrideIndiciatorDrawDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOverrideIndiciatorDrawDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bumpsHistory") << ":";
	SEventHistorySaveData::WriteSimpleJson(&s_Object->m_bumpsHistory, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RagdollPose") << ":";
	SActorRagdollPoseSaveData::WriteSimpleJson(&s_Object->m_RagdollPose, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aLongTermMemorySaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aLongTermMemorySaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aLongTermMemorySaveData[i];
		SLongTermMemorySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aLongTermMemorySaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNude") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNude);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActiveEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActiveEnforcer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPotentialEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPotentialEnforcer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDynamicEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDynamicEnforcer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCrowdCharacter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCrowdCharacter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSnoring") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSnoring);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHiddenWithHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHiddenWithHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsWoozy") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsWoozy);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSpreadingSickness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSpreadingSickness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlendingOrientation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlendingOrientation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMakeMainWeaponUndroppable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMakeMainWeaponUndroppable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponIsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponIsHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegisteredForLT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegisteredForLT);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKeepOverrideSensorStateAfterBeingUnconscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKeepOverrideSensorStateAfterBeingUnconscious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponReady") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponReady);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDynamicWeaponUnholstered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDynamicWeaponUnholstered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceInteractionGlow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceInteractionGlow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOutfitRuined") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOutfitRuined);

	p_Stream << "}";
}

void SActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vQuaternion"], &s_Item);
		s_Object.m_vQuaternion = s_Item;
	}

	{
		SActorInventorySaveData s_Item {};
		SActorInventorySaveData::FromSimpleJson(p_Document["m_Inventory"], &s_Item);
		s_Object.m_Inventory = s_Item;
	}

	{
		SActorAnimSetSaveData s_Item {};
		SActorAnimSetSaveData::FromSimpleJson(p_Document["m_AnimSet"], &s_Item);
		s_Object.m_AnimSet = s_Item;
	}

	s_Object.m_nCurrentBehaviorType = simdjson::from_json_int32(p_Document["m_nCurrentBehaviorType"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CurrentBehaviorState"], &s_Item);
		s_Object.m_CurrentBehaviorState = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCurrentBehaviorEntities"])
	{
		s_Object.m_aCurrentBehaviorEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBehaviorEntities"])
	{
		s_Object.m_aBehaviorEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	{
		SKnowledgeSaveData s_Item {};
		SKnowledgeSaveData::FromSimpleJson(p_Document["m_KnowledgeData"], &s_Item);
		s_Object.m_KnowledgeData = s_Item;
	}

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_OutfitRepositoryId"], &s_Item);
		s_Object.m_OutfitRepositoryId = s_Item;
	}

	s_Object.m_nOutfitCharset = simdjson::from_json_int32(p_Document["m_nOutfitCharset"]);

	s_Object.m_nOutfitVariation = simdjson::from_json_int32(p_Document["m_nOutfitVariation"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tSequenceEndTime"], &s_Item);
		s_Object.m_tSequenceEndTime = s_Item;
	}

	s_Object.m_nState = static_cast<EActorState>(ZHMEnums::GetEnumValueByName("EActorState", std::string_view(p_Document["m_nState"])));

	s_Object.m_rBodyContainerEntity = simdjson::from_json_uint32(p_Document["m_rBodyContainerEntity"]);

	s_Object.m_nBodyContainerSlot = simdjson::from_json_int32(p_Document["m_nBodyContainerSlot"]);

	s_Object.m_eEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eEmotionState"])));

	s_Object.m_rCorpseBodybagEntity = simdjson::from_json_uint32(p_Document["m_rCorpseBodybagEntity"]);

	s_Object.m_rDragBodybagEntity = simdjson::from_json_uint32(p_Document["m_rDragBodybagEntity"]);

	{
		SActorDamageControlSaveData s_Item {};
		SActorDamageControlSaveData::FromSimpleJson(p_Document["m_ActorDamageControlData"], &s_Item);
		s_Object.m_ActorDamageControlData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_AnimatedActorOrderData"], &s_Item);
		s_Object.m_AnimatedActorOrderData = s_Item;
	}

	s_Object.m_fStepsFraction = simdjson::from_json_float32(p_Document["m_fStepsFraction"]);

	s_Object.m_fZBeforeEnteringStairs = simdjson::from_json_float32(p_Document["m_fZBeforeEnteringStairs"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aDynamicTemplates"])
	{
		SActorDynamicTemplateSaveData s_ArrayItem0;
		SActorDynamicTemplateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aDynamicTemplates.push_back(s_ArrayItem0);
	}

	s_Object.m_fTimeSinceLastGroan = simdjson::from_json_float32(p_Document["m_fTimeSinceLastGroan"]);

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_sEndOrientation"], &s_Item);
		s_Object.m_sEndOrientation = s_Item;
	}

	s_Object.m_eOverrideSensorState = static_cast<EActorAIState>(ZHMEnums::GetEnumValueByName("EActorAIState", std::string_view(p_Document["m_eOverrideSensorState"])));

	s_Object.m_eDeathBehavior = static_cast<EDeathBehavior>(ZHMEnums::GetEnumValueByName("EDeathBehavior", std::string_view(p_Document["m_eDeathBehavior"])));

	s_Object.m_fOverrideIndiciatorDrawDistance = simdjson::from_json_float32(p_Document["m_fOverrideIndiciatorDrawDistance"]);

	{
		SEventHistorySaveData s_Item {};
		SEventHistorySaveData::FromSimpleJson(p_Document["m_bumpsHistory"], &s_Item);
		s_Object.m_bumpsHistory = s_Item;
	}

	{
		SActorRagdollPoseSaveData s_Item {};
		SActorRagdollPoseSaveData::FromSimpleJson(p_Document["m_RagdollPose"], &s_Item);
		s_Object.m_RagdollPose = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aLongTermMemorySaveData"])
	{
		SLongTermMemorySaveData s_ArrayItem0;
		SLongTermMemorySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aLongTermMemorySaveData.push_back(s_ArrayItem0);
	}

	s_Object.m_bNude = simdjson::from_json_bool(p_Document["m_bNude"]);

	s_Object.m_bActiveEnforcer = simdjson::from_json_bool(p_Document["m_bActiveEnforcer"]);

	s_Object.m_bIsPotentialEnforcer = simdjson::from_json_bool(p_Document["m_bIsPotentialEnforcer"]);

	s_Object.m_bDynamicEnforcer = simdjson::from_json_bool(p_Document["m_bDynamicEnforcer"]);

	s_Object.m_bIsCrowdCharacter = simdjson::from_json_bool(p_Document["m_bIsCrowdCharacter"]);

	s_Object.m_bIsSnoring = simdjson::from_json_bool(p_Document["m_bIsSnoring"]);

	s_Object.m_bHiddenWithHitman = simdjson::from_json_bool(p_Document["m_bHiddenWithHitman"]);

	s_Object.m_bIsWoozy = simdjson::from_json_bool(p_Document["m_bIsWoozy"]);

	s_Object.m_bIsSpreadingSickness = simdjson::from_json_bool(p_Document["m_bIsSpreadingSickness"]);

	s_Object.m_bBlendingOrientation = simdjson::from_json_bool(p_Document["m_bBlendingOrientation"]);

	s_Object.m_bMakeMainWeaponUndroppable = simdjson::from_json_bool(p_Document["m_bMakeMainWeaponUndroppable"]);

	s_Object.m_bWeaponIsHidden = simdjson::from_json_bool(p_Document["m_bWeaponIsHidden"]);

	s_Object.m_bRegisteredForLT = simdjson::from_json_bool(p_Document["m_bRegisteredForLT"]);

	s_Object.m_bKeepOverrideSensorStateAfterBeingUnconscious = simdjson::from_json_bool(p_Document["m_bKeepOverrideSensorStateAfterBeingUnconscious"]);

	s_Object.m_bWeaponReady = simdjson::from_json_bool(p_Document["m_bWeaponReady"]);

	s_Object.m_bDynamicWeaponUnholstered = simdjson::from_json_bool(p_Document["m_bDynamicWeaponUnholstered"]);

	s_Object.m_bForceInteractionGlow = simdjson::from_json_bool(p_Document["m_bForceInteractionGlow"]);

	s_Object.m_bIsOutfitRuined = simdjson::from_json_bool(p_Document["m_bIsOutfitRuined"]);

	*reinterpret_cast<SActorSaveData*>(p_Target) = s_Object;
}

void SActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vQuaternion, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_vQuaternion));
	SActorInventorySaveData::Serialize(&s_Object->m_Inventory, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_Inventory));
	SActorAnimSetSaveData::Serialize(&s_Object->m_AnimSet, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_AnimSet));
	ZVariant::Serialize(&s_Object->m_CurrentBehaviorState, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_CurrentBehaviorState));
	TArray<uint32>::Serialize(&s_Object->m_aCurrentBehaviorEntities, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_aCurrentBehaviorEntities));
	TArray<uint32>::Serialize(&s_Object->m_aBehaviorEntities, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_aBehaviorEntities));
	SKnowledgeSaveData::Serialize(&s_Object->m_KnowledgeData, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_KnowledgeData));
	ZRepositoryID::Serialize(&s_Object->m_OutfitRepositoryId, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_OutfitRepositoryId));
	ZGameTime::Serialize(&s_Object->m_tSequenceEndTime, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_tSequenceEndTime));
	SActorDamageControlSaveData::Serialize(&s_Object->m_ActorDamageControlData, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_ActorDamageControlData));
	ZVariant::Serialize(&s_Object->m_AnimatedActorOrderData, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_AnimatedActorOrderData));
	TArray<SActorDynamicTemplateSaveData>::Serialize(&s_Object->m_aDynamicTemplates, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_aDynamicTemplates));
	SMatrix::Serialize(&s_Object->m_sEndOrientation, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_sEndOrientation));
	SEventHistorySaveData::Serialize(&s_Object->m_bumpsHistory, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_bumpsHistory));
	SActorRagdollPoseSaveData::Serialize(&s_Object->m_RagdollPose, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_RagdollPose));
	TArray<SLongTermMemorySaveData>::Serialize(&s_Object->m_aLongTermMemorySaveData, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_aLongTermMemorySaveData));
}

bool SActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSaveData::operator==(const SActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSaveData>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vQuaternion != p_Other.m_vQuaternion) return false;
	if (m_Inventory != p_Other.m_Inventory) return false;
	if (m_AnimSet != p_Other.m_AnimSet) return false;
	if (m_nCurrentBehaviorType != p_Other.m_nCurrentBehaviorType) return false;
	if (m_CurrentBehaviorState != p_Other.m_CurrentBehaviorState) return false;
	if (m_aCurrentBehaviorEntities != p_Other.m_aCurrentBehaviorEntities) return false;
	if (m_aBehaviorEntities != p_Other.m_aBehaviorEntities) return false;
	if (m_KnowledgeData != p_Other.m_KnowledgeData) return false;
	if (m_OutfitRepositoryId != p_Other.m_OutfitRepositoryId) return false;
	if (m_nOutfitCharset != p_Other.m_nOutfitCharset) return false;
	if (m_nOutfitVariation != p_Other.m_nOutfitVariation) return false;
	if (m_tSequenceEndTime != p_Other.m_tSequenceEndTime) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_rBodyContainerEntity != p_Other.m_rBodyContainerEntity) return false;
	if (m_nBodyContainerSlot != p_Other.m_nBodyContainerSlot) return false;
	if (m_eEmotionState != p_Other.m_eEmotionState) return false;
	if (m_rCorpseBodybagEntity != p_Other.m_rCorpseBodybagEntity) return false;
	if (m_rDragBodybagEntity != p_Other.m_rDragBodybagEntity) return false;
	if (m_ActorDamageControlData != p_Other.m_ActorDamageControlData) return false;
	if (m_AnimatedActorOrderData != p_Other.m_AnimatedActorOrderData) return false;
	if (m_fStepsFraction != p_Other.m_fStepsFraction) return false;
	if (m_fZBeforeEnteringStairs != p_Other.m_fZBeforeEnteringStairs) return false;
	if (m_aDynamicTemplates != p_Other.m_aDynamicTemplates) return false;
	if (m_fTimeSinceLastGroan != p_Other.m_fTimeSinceLastGroan) return false;
	if (m_sEndOrientation != p_Other.m_sEndOrientation) return false;
	if (m_eOverrideSensorState != p_Other.m_eOverrideSensorState) return false;
	if (m_eDeathBehavior != p_Other.m_eDeathBehavior) return false;
	if (m_fOverrideIndiciatorDrawDistance != p_Other.m_fOverrideIndiciatorDrawDistance) return false;
	if (m_bumpsHistory != p_Other.m_bumpsHistory) return false;
	if (m_RagdollPose != p_Other.m_RagdollPose) return false;
	if (m_aLongTermMemorySaveData != p_Other.m_aLongTermMemorySaveData) return false;
	if (m_bNude != p_Other.m_bNude) return false;
	if (m_bActiveEnforcer != p_Other.m_bActiveEnforcer) return false;
	if (m_bIsPotentialEnforcer != p_Other.m_bIsPotentialEnforcer) return false;
	if (m_bDynamicEnforcer != p_Other.m_bDynamicEnforcer) return false;
	if (m_bIsCrowdCharacter != p_Other.m_bIsCrowdCharacter) return false;
	if (m_bIsSnoring != p_Other.m_bIsSnoring) return false;
	if (m_bHiddenWithHitman != p_Other.m_bHiddenWithHitman) return false;
	if (m_bIsWoozy != p_Other.m_bIsWoozy) return false;
	if (m_bIsSpreadingSickness != p_Other.m_bIsSpreadingSickness) return false;
	if (m_bBlendingOrientation != p_Other.m_bBlendingOrientation) return false;
	if (m_bMakeMainWeaponUndroppable != p_Other.m_bMakeMainWeaponUndroppable) return false;
	if (m_bWeaponIsHidden != p_Other.m_bWeaponIsHidden) return false;
	if (m_bRegisteredForLT != p_Other.m_bRegisteredForLT) return false;
	if (m_bKeepOverrideSensorStateAfterBeingUnconscious != p_Other.m_bKeepOverrideSensorStateAfterBeingUnconscious) return false;
	if (m_bWeaponReady != p_Other.m_bWeaponReady) return false;
	if (m_bDynamicWeaponUnholstered != p_Other.m_bDynamicWeaponUnholstered) return false;
	if (m_bForceInteractionGlow != p_Other.m_bForceInteractionGlow) return false;
	if (m_bIsOutfitRuined != p_Other.m_bIsOutfitRuined) return false;

	return true;
}

ZHMTypeInfo SEventSaveData::TypeInfo = ZHMTypeInfo("SEventSaveData", sizeof(SEventSaveData), alignof(SEventSaveData), SEventSaveData::WriteJson, SEventSaveData::WriteSimpleJson, SEventSaveData::FromSimpleJson, SEventSaveData::Serialize, SEventSaveData::Equals);

void SEventSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAISharedEventType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_nType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_nStart, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEnd") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_nEnd, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_nType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nEnd, p_Stream);

	p_Stream << "}";
}

void SEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEventSaveData s_Object {};

	s_Object.m_nType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_nType"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nStart"], &s_Item);
		s_Object.m_nStart = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nEnd"], &s_Item);
		s_Object.m_nEnd = s_Item;
	}

	*reinterpret_cast<SEventSaveData*>(p_Target) = s_Object;
}

void SEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_nStart, p_Serializer, p_OwnOffset + offsetof(SEventSaveData, m_nStart));
	ZGameTime::Serialize(&s_Object->m_nEnd, p_Serializer, p_OwnOffset + offsetof(SEventSaveData, m_nEnd));
}

bool SEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventSaveData::operator==(const SEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventSaveData>)
		return false;

	if (m_nType != p_Other.m_nType) return false;
	if (m_nStart != p_Other.m_nStart) return false;
	if (m_nEnd != p_Other.m_nEnd) return false;

	return true;
}

ZHMTypeInfo SSharedKnowledgeSaveData::TypeInfo = ZHMTypeInfo("SSharedKnowledgeSaveData", sizeof(SSharedKnowledgeSaveData), alignof(SSharedKnowledgeSaveData), SSharedKnowledgeSaveData::WriteJson, SSharedKnowledgeSaveData::WriteSimpleJson, SSharedKnowledgeSaveData::FromSimpleJson, SSharedKnowledgeSaveData::Serialize, SSharedKnowledgeSaveData::Equals);

void SSharedKnowledgeSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_OutfitId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActualMatrix") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMatrix") << ",\"$val\":";
	SMatrix::WriteJson(&s_Object->m_ActualMatrix, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPerceptible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPerceptible);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEvents") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEventSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEvents[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEventSaveData") << ",\"$val\":";
		SEventSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEvents.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SSharedKnowledgeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_OutfitId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActualMatrix") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_ActualMatrix, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPerceptible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPerceptible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEvents[i];
		SEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSharedKnowledgeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSharedKnowledgeSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_OutfitId"], &s_Item);
		s_Object.m_OutfitId = s_Item;
	}

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_ActualMatrix"], &s_Item);
		s_Object.m_ActualMatrix = s_Item;
	}

	s_Object.m_bIsPerceptible = simdjson::from_json_bool(p_Document["m_bIsPerceptible"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEvents"])
	{
		SEventSaveData s_ArrayItem0;
		SEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEvents.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SSharedKnowledgeSaveData*>(p_Target) = s_Object;
}

void SSharedKnowledgeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_OutfitId, p_Serializer, p_OwnOffset + offsetof(SSharedKnowledgeSaveData, m_OutfitId));
	SMatrix::Serialize(&s_Object->m_ActualMatrix, p_Serializer, p_OwnOffset + offsetof(SSharedKnowledgeSaveData, m_ActualMatrix));
	TArray<SEventSaveData>::Serialize(&s_Object->m_aEvents, p_Serializer, p_OwnOffset + offsetof(SSharedKnowledgeSaveData, m_aEvents));
}

bool SSharedKnowledgeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSharedKnowledgeSaveData::operator==(const SSharedKnowledgeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSharedKnowledgeSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_OutfitId != p_Other.m_OutfitId) return false;
	if (m_ActualMatrix != p_Other.m_ActualMatrix) return false;
	if (m_bIsPerceptible != p_Other.m_bIsPerceptible) return false;
	if (m_aEvents != p_Other.m_aEvents) return false;

	return true;
}

ZHMTypeInfo SSituationGroupSaveData::TypeInfo = ZHMTypeInfo("SSituationGroupSaveData", sizeof(SSituationGroupSaveData), alignof(SSituationGroupSaveData), SSituationGroupSaveData::WriteJson, SSituationGroupSaveData::WriteSimpleJson, SSituationGroupSaveData::FromSimpleJson, SSituationGroupSaveData::Serialize, SSituationGroupSaveData::Equals);

void SSituationGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sClassTypeName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sClassTypeName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_CustomData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SSituationGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sClassTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sClassTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationGroupSaveData s_Object {};

	s_Object.m_sClassTypeName = std::string_view(p_Document["m_sClassTypeName"]);

	s_Object.m_nSituation = simdjson::from_json_uint32(p_Document["m_nSituation"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActors"])
	{
		s_Object.m_aActors.push_back(simdjson::from_json_uint32(s_Item0));
	}

	s_Object.m_nGroupID = simdjson::from_json_int32(p_Document["m_nGroupID"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Item);
		s_Object.m_CustomData = s_Item;
	}

	*reinterpret_cast<SSituationGroupSaveData*>(p_Target) = s_Object;
}

void SSituationGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sClassTypeName, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_sClassTypeName));
	TArray<uint32>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_aActors));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_CustomData));
}

bool SSituationGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationGroupSaveData::operator==(const SSituationGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationGroupSaveData>)
		return false;

	if (m_sClassTypeName != p_Other.m_sClassTypeName) return false;
	if (m_nSituation != p_Other.m_nSituation) return false;
	if (m_aActors != p_Other.m_aActors) return false;
	if (m_nGroupID != p_Other.m_nGroupID) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

ZHMTypeInfo SSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SSituationMemberSaveData", sizeof(SSituationMemberSaveData), alignof(SSituationMemberSaveData), SSituationMemberSaveData::WriteJson, SSituationMemberSaveData::WriteSimpleJson, SSituationMemberSaveData::FromSimpleJson, SSituationMemberSaveData::Serialize, SSituationMemberSaveData::Equals);

void SSituationMemberSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eJoinReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ESituationJoinReason") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eJoinReason)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationJoinReason", static_cast<int>(s_Object->m_eJoinReason))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOrderValid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOrderValid);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OrderData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_OrderData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PendingOrderData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_PendingOrderData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDramaRole") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDramaRole);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_CustomData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eJoinReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationJoinReason", static_cast<int>(s_Object->m_eJoinReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOrderValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOrderValid);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_OrderData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PendingOrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_PendingOrderData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDramaRole") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDramaRole);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationMemberSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_eJoinReason = static_cast<ESituationJoinReason>(ZHMEnums::GetEnumValueByName("ESituationJoinReason", std::string_view(p_Document["m_eJoinReason"])));

	s_Object.m_bIsOrderValid = simdjson::from_json_bool(p_Document["m_bIsOrderValid"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_OrderData"], &s_Item);
		s_Object.m_OrderData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_PendingOrderData"], &s_Item);
		s_Object.m_PendingOrderData = s_Item;
	}

	s_Object.m_rDramaRole = simdjson::from_json_uint32(p_Document["m_rDramaRole"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Item);
		s_Object.m_CustomData = s_Item;
	}

	*reinterpret_cast<SSituationMemberSaveData*>(p_Target) = s_Object;
}

void SSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_OrderData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_OrderData));
	ZVariant::Serialize(&s_Object->m_PendingOrderData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_PendingOrderData));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_CustomData));
}

bool SSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationMemberSaveData::operator==(const SSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationMemberSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_eJoinReason != p_Other.m_eJoinReason) return false;
	if (m_bIsOrderValid != p_Other.m_bIsOrderValid) return false;
	if (m_OrderData != p_Other.m_OrderData) return false;
	if (m_PendingOrderData != p_Other.m_PendingOrderData) return false;
	if (m_rDramaRole != p_Other.m_rDramaRole) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

ZHMTypeInfo SSituationSaveData::TypeInfo = ZHMTypeInfo("SSituationSaveData", sizeof(SSituationSaveData), alignof(SSituationSaveData), SSituationSaveData::WriteJson, SSituationSaveData::WriteSimpleJson, SSituationSaveData::FromSimpleJson, SSituationSaveData::Serialize, SSituationSaveData::Equals);

void SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ESituationType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationType", static_cast<int>(s_Object->m_eType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetSharedEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetSharedEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_Data, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMemberData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSituationMemberSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMemberData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMemberData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSituationMemberSaveData") << ",\"$val\":";
		SSituationMemberSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aMemberData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGroupData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSituationGroupSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGroupData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGroupData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSituationGroupSaveData") << ",\"$val\":";
		SSituationGroupSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aGroupData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNextGroupID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNextGroupID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_situationStartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_situationStartTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationEnded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationEnded);
	p_Stream << "}";

	p_Stream << "}";
}

void SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetSharedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetSharedEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMemberData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMemberData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMemberData[i];
		SSituationMemberSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aMemberData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGroupData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGroupData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGroupData[i];
		SSituationGroupSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGroupData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNextGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNextGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_situationStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_situationStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationEnded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationEnded);

	p_Stream << "}";
}

void SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationSaveData s_Object {};

	s_Object.m_rSituation = simdjson::from_json_uint32(p_Document["m_rSituation"]);

	s_Object.m_eType = static_cast<ESituationType>(ZHMEnums::GetEnumValueByName("ESituationType", std::string_view(p_Document["m_eType"])));

	s_Object.m_nTargetSharedEntity = simdjson::from_json_int32(p_Document["m_nTargetSharedEntity"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Item);
		s_Object.m_Data = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aMemberData"])
	{
		SSituationMemberSaveData s_ArrayItem0;
		SSituationMemberSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aMemberData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGroupData"])
	{
		SSituationGroupSaveData s_ArrayItem0;
		SSituationGroupSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGroupData.push_back(s_ArrayItem0);
	}

	s_Object.m_nNextGroupID = simdjson::from_json_int32(p_Document["m_nNextGroupID"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_situationStartTime"], &s_Item);
		s_Object.m_situationStartTime = s_Item;
	}

	s_Object.m_bSituationEnded = simdjson::from_json_bool(p_Document["m_bSituationEnded"]);

	*reinterpret_cast<SSituationSaveData*>(p_Target) = s_Object;
}

void SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_Data));
	TArray<SSituationMemberSaveData>::Serialize(&s_Object->m_aMemberData, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_aMemberData));
	TArray<SSituationGroupSaveData>::Serialize(&s_Object->m_aGroupData, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_aGroupData));
	ZGameTime::Serialize(&s_Object->m_situationStartTime, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_situationStartTime));
}

bool SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationSaveData::operator==(const SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationSaveData>)
		return false;

	if (m_rSituation != p_Other.m_rSituation) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_nTargetSharedEntity != p_Other.m_nTargetSharedEntity) return false;
	if (m_Data != p_Other.m_Data) return false;
	if (m_aMemberData != p_Other.m_aMemberData) return false;
	if (m_aGroupData != p_Other.m_aGroupData) return false;
	if (m_nNextGroupID != p_Other.m_nNextGroupID) return false;
	if (m_situationStartTime != p_Other.m_situationStartTime) return false;
	if (m_bSituationEnded != p_Other.m_bSituationEnded) return false;

	return true;
}

ZHMTypeInfo SActorManagerSaveData::TypeInfo = ZHMTypeInfo("SActorManagerSaveData", sizeof(SActorManagerSaveData), alignof(SActorManagerSaveData), SActorManagerSaveData::WriteJson, SActorManagerSaveData::WriteSimpleJson, SActorManagerSaveData::FromSimpleJson, SActorManagerSaveData::Serialize, SActorManagerSaveData::Equals);

void SActorManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aSharedKnowledgeSaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSharedKnowledgeSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSharedKnowledgeSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSharedKnowledgeSaveData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSharedKnowledgeSaveData") << ",\"$val\":";
		SSharedKnowledgeSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aSharedKnowledgeSaveData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentHitman") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentHitman);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSituations") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSituationSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSituations.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSituations[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSituationSaveData") << ",\"$val\":";
		SSituationSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aSituations.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSaveData") << ",\"$val\":";
		SActorSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aActorData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorProviders") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorProviders.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorProviders[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aActorProviders.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorProvidersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorProviderDirectSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorProvidersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorProvidersData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorProviderDirectSaveData") << ",\"$val\":";
		SActorProviderDirectSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aActorProvidersData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorApproachProviders") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorApproachProviders.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorApproachProviders[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aActorApproachProviders.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorApproachProvidersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorProviderApproachSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorApproachProvidersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorApproachProvidersData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorProviderApproachSaveData") << ",\"$val\":";
		SActorProviderApproachSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aActorApproachProvidersData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BodySensorData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_BodySensorData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CrimeSceneServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_CrimeSceneServiceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CrowdServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_CrowdServiceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CuriousEventServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_CuriousEventServiceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GetHelpServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_GetHelpServiceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DynamicEnforcerServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_DynamicEnforcerServiceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AIModifierServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_AIModifierServiceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LockdownManagerData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_LockdownManagerData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DangerousAreaServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_DangerousAreaServiceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TargetTrackingServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_TargetTrackingServiceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ManHuntServiceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_ManHuntServiceData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSharedKnowledgeSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSharedKnowledgeSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSharedKnowledgeSaveData[i];
		SSharedKnowledgeSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSharedKnowledgeSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSituations") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSituations.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSituations[i];
		SSituationSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSituations.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorData[i];
		SActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorProviders") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorProviders.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorProviders[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActorProviders.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorProvidersData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorProvidersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorProvidersData[i];
		SActorProviderDirectSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorProvidersData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorApproachProviders") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorApproachProviders.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorApproachProviders[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActorApproachProviders.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorApproachProvidersData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorApproachProvidersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorApproachProvidersData[i];
		SActorProviderApproachSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorApproachProvidersData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BodySensorData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_BodySensorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CrimeSceneServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CrimeSceneServiceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CrowdServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CrowdServiceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CuriousEventServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CuriousEventServiceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GetHelpServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_GetHelpServiceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DynamicEnforcerServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_DynamicEnforcerServiceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AIModifierServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_AIModifierServiceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LockdownManagerData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_LockdownManagerData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DangerousAreaServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_DangerousAreaServiceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TargetTrackingServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_TargetTrackingServiceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ManHuntServiceData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_ManHuntServiceData, p_Stream);

	p_Stream << "}";
}

void SActorManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorManagerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSharedKnowledgeSaveData"])
	{
		SSharedKnowledgeSaveData s_ArrayItem0;
		SSharedKnowledgeSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSharedKnowledgeSaveData.push_back(s_ArrayItem0);
	}

	s_Object.m_nCurrentHitman = simdjson::from_json_int32(p_Document["m_nCurrentHitman"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSituations"])
	{
		SSituationSaveData s_ArrayItem0;
		SSituationSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSituations.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActors"])
	{
		s_Object.m_aActors.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActorData"])
	{
		SActorSaveData s_ArrayItem0;
		SActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActorProviders"])
	{
		s_Object.m_aActorProviders.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActorProvidersData"])
	{
		SActorProviderDirectSaveData s_ArrayItem0;
		SActorProviderDirectSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorProvidersData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActorApproachProviders"])
	{
		s_Object.m_aActorApproachProviders.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActorApproachProvidersData"])
	{
		SActorProviderApproachSaveData s_ArrayItem0;
		SActorProviderApproachSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorApproachProvidersData.push_back(s_ArrayItem0);
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_BodySensorData"], &s_Item);
		s_Object.m_BodySensorData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CrimeSceneServiceData"], &s_Item);
		s_Object.m_CrimeSceneServiceData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CrowdServiceData"], &s_Item);
		s_Object.m_CrowdServiceData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CuriousEventServiceData"], &s_Item);
		s_Object.m_CuriousEventServiceData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_GetHelpServiceData"], &s_Item);
		s_Object.m_GetHelpServiceData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_DynamicEnforcerServiceData"], &s_Item);
		s_Object.m_DynamicEnforcerServiceData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_AIModifierServiceData"], &s_Item);
		s_Object.m_AIModifierServiceData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_LockdownManagerData"], &s_Item);
		s_Object.m_LockdownManagerData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_DangerousAreaServiceData"], &s_Item);
		s_Object.m_DangerousAreaServiceData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_TargetTrackingServiceData"], &s_Item);
		s_Object.m_TargetTrackingServiceData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_ManHuntServiceData"], &s_Item);
		s_Object.m_ManHuntServiceData = s_Item;
	}

	*reinterpret_cast<SActorManagerSaveData*>(p_Target) = s_Object;
}

void SActorManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorManagerSaveData*>(p_Object);

	TArray<SSharedKnowledgeSaveData>::Serialize(&s_Object->m_aSharedKnowledgeSaveData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_aSharedKnowledgeSaveData));
	TArray<SSituationSaveData>::Serialize(&s_Object->m_aSituations, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_aSituations));
	TArray<uint32>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_aActors));
	TArray<SActorSaveData>::Serialize(&s_Object->m_aActorData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_aActorData));
	TArray<uint32>::Serialize(&s_Object->m_aActorProviders, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_aActorProviders));
	TArray<SActorProviderDirectSaveData>::Serialize(&s_Object->m_aActorProvidersData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_aActorProvidersData));
	TArray<uint32>::Serialize(&s_Object->m_aActorApproachProviders, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_aActorApproachProviders));
	TArray<SActorProviderApproachSaveData>::Serialize(&s_Object->m_aActorApproachProvidersData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_aActorApproachProvidersData));
	ZVariant::Serialize(&s_Object->m_BodySensorData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_BodySensorData));
	ZVariant::Serialize(&s_Object->m_CrimeSceneServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_CrimeSceneServiceData));
	ZVariant::Serialize(&s_Object->m_CrowdServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_CrowdServiceData));
	ZVariant::Serialize(&s_Object->m_CuriousEventServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_CuriousEventServiceData));
	ZVariant::Serialize(&s_Object->m_GetHelpServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_GetHelpServiceData));
	ZVariant::Serialize(&s_Object->m_DynamicEnforcerServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_DynamicEnforcerServiceData));
	ZVariant::Serialize(&s_Object->m_AIModifierServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_AIModifierServiceData));
	ZVariant::Serialize(&s_Object->m_LockdownManagerData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_LockdownManagerData));
	ZVariant::Serialize(&s_Object->m_DangerousAreaServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_DangerousAreaServiceData));
	ZVariant::Serialize(&s_Object->m_TargetTrackingServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_TargetTrackingServiceData));
	ZVariant::Serialize(&s_Object->m_ManHuntServiceData, p_Serializer, p_OwnOffset + offsetof(SActorManagerSaveData, m_ManHuntServiceData));
}

bool SActorManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorManagerSaveData::operator==(const SActorManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorManagerSaveData>)
		return false;

	if (m_aSharedKnowledgeSaveData != p_Other.m_aSharedKnowledgeSaveData) return false;
	if (m_nCurrentHitman != p_Other.m_nCurrentHitman) return false;
	if (m_aSituations != p_Other.m_aSituations) return false;
	if (m_aActors != p_Other.m_aActors) return false;
	if (m_aActorData != p_Other.m_aActorData) return false;
	if (m_aActorProviders != p_Other.m_aActorProviders) return false;
	if (m_aActorProvidersData != p_Other.m_aActorProvidersData) return false;
	if (m_aActorApproachProviders != p_Other.m_aActorApproachProviders) return false;
	if (m_aActorApproachProvidersData != p_Other.m_aActorApproachProvidersData) return false;
	if (m_BodySensorData != p_Other.m_BodySensorData) return false;
	if (m_CrimeSceneServiceData != p_Other.m_CrimeSceneServiceData) return false;
	if (m_CrowdServiceData != p_Other.m_CrowdServiceData) return false;
	if (m_CuriousEventServiceData != p_Other.m_CuriousEventServiceData) return false;
	if (m_GetHelpServiceData != p_Other.m_GetHelpServiceData) return false;
	if (m_DynamicEnforcerServiceData != p_Other.m_DynamicEnforcerServiceData) return false;
	if (m_AIModifierServiceData != p_Other.m_AIModifierServiceData) return false;
	if (m_LockdownManagerData != p_Other.m_LockdownManagerData) return false;
	if (m_DangerousAreaServiceData != p_Other.m_DangerousAreaServiceData) return false;
	if (m_TargetTrackingServiceData != p_Other.m_TargetTrackingServiceData) return false;
	if (m_ManHuntServiceData != p_Other.m_ManHuntServiceData) return false;

	return true;
}

ZHMTypeInfo SActorProxySaveData::TypeInfo = ZHMTypeInfo("SActorProxySaveData", sizeof(SActorProxySaveData), alignof(SActorProxySaveData), SActorProxySaveData::WriteJson, SActorProxySaveData::WriteSimpleJson, SActorProxySaveData::FromSimpleJson, SActorProxySaveData::Serialize, SActorProxySaveData::Equals);

void SActorProxySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorProxySaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorProxySaveData*>(p_Target) = s_Object;
}

void SActorProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);

}

bool SActorProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProxySaveData::operator==(const SActorProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProxySaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SActorProxiesSaveData::TypeInfo = ZHMTypeInfo("SActorProxiesSaveData", sizeof(SActorProxiesSaveData), alignof(SActorProxiesSaveData), SActorProxiesSaveData::WriteJson, SActorProxiesSaveData::WriteSimpleJson, SActorProxiesSaveData::FromSimpleJson, SActorProxiesSaveData::Serialize, SActorProxiesSaveData::Equals);

void SActorProxiesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorProxySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorProxySaveData") << ",\"$val\":";
		SActorProxySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorProxiesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SActorProxySaveData s_ArrayItem0;
		SActorProxySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SActorProxiesSaveData*>(p_Target) = s_Object;
}

void SActorProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorProxiesSaveData, m_aEntities));
	TArray<SActorProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorProxiesSaveData, m_aData));
}

bool SActorProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProxiesSaveData::operator==(const SActorProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SActorSoundDefs::TypeInfo = ZHMTypeInfo("SActorSoundDefs", sizeof(SActorSoundDefs), alignof(SActorSoundDefs), SActorSoundDefs::WriteJson, SActorSoundDefs::WriteSimpleJson, SActorSoundDefs::FromSimpleJson, SActorSoundDefs::Serialize, SActorSoundDefs::Equals);

void SActorSoundDefs::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SActorSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SActorSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSoundDefs s_Object {};

	*reinterpret_cast<SActorSoundDefs*>(p_Target) = s_Object;
}

void SActorSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

}

bool SActorSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSoundDefs::operator==(const SActorSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSoundDefs>)
		return false;


	return true;
}

ZHMTypeInfo SActorSpreadControllerCandidateSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadControllerCandidateSaveData", sizeof(SActorSpreadControllerCandidateSaveData), alignof(SActorSpreadControllerCandidateSaveData), SActorSpreadControllerCandidateSaveData::WriteJson, SActorSpreadControllerCandidateSaveData::WriteSimpleJson, SActorSpreadControllerCandidateSaveData::FromSimpleJson, SActorSpreadControllerCandidateSaveData::Serialize, SActorSpreadControllerCandidateSaveData::Equals);

void SActorSpreadControllerCandidateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_CandidateActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_CandidateActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CandidateTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_CandidateTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidCandidate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidCandidate);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorSpreadControllerCandidateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CandidateActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CandidateActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CandidateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_CandidateTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidCandidate);

	p_Stream << "}";
}

void SActorSpreadControllerCandidateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSpreadControllerCandidateSaveData s_Object {};

	s_Object.m_CandidateActor = simdjson::from_json_uint32(p_Document["m_CandidateActor"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_CandidateTime"], &s_Item);
		s_Object.m_CandidateTime = s_Item;
	}

	s_Object.m_bValidCandidate = simdjson::from_json_bool(p_Document["m_bValidCandidate"]);

	*reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Target) = s_Object;
}

void SActorSpreadControllerCandidateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_CandidateTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerCandidateSaveData, m_CandidateTime));
}

bool SActorSpreadControllerCandidateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadControllerCandidateSaveData::operator==(const SActorSpreadControllerCandidateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadControllerCandidateSaveData>)
		return false;

	if (m_CandidateActor != p_Other.m_CandidateActor) return false;
	if (m_CandidateTime != p_Other.m_CandidateTime) return false;
	if (m_bValidCandidate != p_Other.m_bValidCandidate) return false;

	return true;
}

ZHMTypeInfo SActorSpreadControllerSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadControllerSaveData", sizeof(SActorSpreadControllerSaveData), alignof(SActorSpreadControllerSaveData), SActorSpreadControllerSaveData::WriteJson, SActorSpreadControllerSaveData::WriteSimpleJson, SActorSpreadControllerSaveData::FromSimpleJson, SActorSpreadControllerSaveData::Serialize, SActorSpreadControllerSaveData::Equals);

void SActorSpreadControllerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aSpreadingActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpreadingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpreadingActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aSpreadingActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSpreadingActorsAddedTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZGameTime>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpreadingActorsAddedTime.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpreadingActorsAddedTime[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
		ZGameTime::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aSpreadingActorsAddedTime.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aNewCandidates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aNewCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aNewCandidates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aNewCandidates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorSpreadControllerCandidateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSpreadControllerCandidateSaveData") << ",\"$val\":";
		SActorSpreadControllerCandidateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpreadingActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpreadingActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentActorIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentActorIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerCheckEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerCheckEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerSpreading") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerSpreading);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerIsValidCandidate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerIsValidCandidate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerIsCandidate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerIsCandidate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PlayerCandidateTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_PlayerCandidateTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorSpreadControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSpreadingActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpreadingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpreadingActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSpreadingActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSpreadingActorsAddedTime") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpreadingActorsAddedTime.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpreadingActorsAddedTime[i];
		ZGameTime::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSpreadingActorsAddedTime.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aNewCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aNewCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aNewCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aNewCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		SActorSpreadControllerCandidateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpreadingActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpreadingActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentActorIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerCheckEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerCheckEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerSpreading") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerSpreading);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerIsValidCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerIsValidCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerIsCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerIsCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PlayerCandidateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_PlayerCandidateTime, p_Stream);

	p_Stream << "}";
}

void SActorSpreadControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSpreadControllerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSpreadingActors"])
	{
		s_Object.m_aSpreadingActors.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSpreadingActorsAddedTime"])
	{
		ZGameTime s_ArrayItem0;
		ZGameTime::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSpreadingActorsAddedTime.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aNewCandidates"])
	{
		s_Object.m_aNewCandidates.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCandidates"])
	{
		SActorSpreadControllerCandidateSaveData s_ArrayItem0;
		SActorSpreadControllerCandidateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aCandidates.push_back(s_ArrayItem0);
	}

	s_Object.m_rCurrentSpreadingActor = simdjson::from_json_uint32(p_Document["m_rCurrentSpreadingActor"]);

	s_Object.m_nCurrentActorIndex = simdjson::from_json_uint32(p_Document["m_nCurrentActorIndex"]);

	s_Object.m_bPlayerCheckEnabled = simdjson::from_json_bool(p_Document["m_bPlayerCheckEnabled"]);

	s_Object.m_bPlayerSpreading = simdjson::from_json_bool(p_Document["m_bPlayerSpreading"]);

	s_Object.m_bPlayerIsValidCandidate = simdjson::from_json_bool(p_Document["m_bPlayerIsValidCandidate"]);

	s_Object.m_bPlayerIsCandidate = simdjson::from_json_bool(p_Document["m_bPlayerIsCandidate"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_PlayerCandidateTime"], &s_Item);
		s_Object.m_PlayerCandidateTime = s_Item;
	}

	*reinterpret_cast<SActorSpreadControllerSaveData*>(p_Target) = s_Object;
}

void SActorSpreadControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aSpreadingActors, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aSpreadingActors));
	TArray<ZGameTime>::Serialize(&s_Object->m_aSpreadingActorsAddedTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aSpreadingActorsAddedTime));
	TArray<uint32>::Serialize(&s_Object->m_aNewCandidates, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aNewCandidates));
	TArray<SActorSpreadControllerCandidateSaveData>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aCandidates));
	ZGameTime::Serialize(&s_Object->m_PlayerCandidateTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_PlayerCandidateTime));
}

bool SActorSpreadControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadControllerSaveData::operator==(const SActorSpreadControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadControllerSaveData>)
		return false;

	if (m_aSpreadingActors != p_Other.m_aSpreadingActors) return false;
	if (m_aSpreadingActorsAddedTime != p_Other.m_aSpreadingActorsAddedTime) return false;
	if (m_aNewCandidates != p_Other.m_aNewCandidates) return false;
	if (m_aCandidates != p_Other.m_aCandidates) return false;
	if (m_rCurrentSpreadingActor != p_Other.m_rCurrentSpreadingActor) return false;
	if (m_nCurrentActorIndex != p_Other.m_nCurrentActorIndex) return false;
	if (m_bPlayerCheckEnabled != p_Other.m_bPlayerCheckEnabled) return false;
	if (m_bPlayerSpreading != p_Other.m_bPlayerSpreading) return false;
	if (m_bPlayerIsValidCandidate != p_Other.m_bPlayerIsValidCandidate) return false;
	if (m_bPlayerIsCandidate != p_Other.m_bPlayerIsCandidate) return false;
	if (m_PlayerCandidateTime != p_Other.m_PlayerCandidateTime) return false;

	return true;
}

ZHMTypeInfo SActorSpreadTransitionOperatorMaterialActorSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadTransitionOperatorMaterialActorSaveData", sizeof(SActorSpreadTransitionOperatorMaterialActorSaveData), alignof(SActorSpreadTransitionOperatorMaterialActorSaveData), SActorSpreadTransitionOperatorMaterialActorSaveData::WriteJson, SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson, SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson, SActorSpreadTransitionOperatorMaterialActorSaveData::Serialize, SActorSpreadTransitionOperatorMaterialActorSaveData::Equals);

void SActorSpreadTransitionOperatorMaterialActorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_Actor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_Actor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpacity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpacity);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Actor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_Actor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpacity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpacity);

	p_Stream << "}";
}

void SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSpreadTransitionOperatorMaterialActorSaveData s_Object {};

	s_Object.m_Actor = simdjson::from_json_uint32(p_Document["m_Actor"]);

	s_Object.m_fOpacity = simdjson::from_json_float32(p_Document["m_fOpacity"]);

	*reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Target) = s_Object;
}

void SActorSpreadTransitionOperatorMaterialActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);

}

bool SActorSpreadTransitionOperatorMaterialActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadTransitionOperatorMaterialActorSaveData::operator==(const SActorSpreadTransitionOperatorMaterialActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadTransitionOperatorMaterialActorSaveData>)
		return false;

	if (m_Actor != p_Other.m_Actor) return false;
	if (m_fOpacity != p_Other.m_fOpacity) return false;

	return true;
}

ZHMTypeInfo SActorSpreadTransitionOperatorMaterialSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadTransitionOperatorMaterialSaveData", sizeof(SActorSpreadTransitionOperatorMaterialSaveData), alignof(SActorSpreadTransitionOperatorMaterialSaveData), SActorSpreadTransitionOperatorMaterialSaveData::WriteJson, SActorSpreadTransitionOperatorMaterialSaveData::WriteSimpleJson, SActorSpreadTransitionOperatorMaterialSaveData::FromSimpleJson, SActorSpreadTransitionOperatorMaterialSaveData::Serialize, SActorSpreadTransitionOperatorMaterialSaveData::Equals);

void SActorSpreadTransitionOperatorMaterialSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aActorMaterialOverrides") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorSpreadTransitionOperatorMaterialActorSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorMaterialOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorMaterialOverrides[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSpreadTransitionOperatorMaterialActorSaveData") << ",\"$val\":";
		SActorSpreadTransitionOperatorMaterialActorSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aActorMaterialOverrides.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorSpreadTransitionOperatorMaterialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aActorMaterialOverrides") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorMaterialOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorMaterialOverrides[i];
		SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorMaterialOverrides.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorSpreadTransitionOperatorMaterialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSpreadTransitionOperatorMaterialSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActorMaterialOverrides"])
	{
		SActorSpreadTransitionOperatorMaterialActorSaveData s_ArrayItem0;
		SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorMaterialOverrides.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Target) = s_Object;
}

void SActorSpreadTransitionOperatorMaterialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);

	TArray<SActorSpreadTransitionOperatorMaterialActorSaveData>::Serialize(&s_Object->m_aActorMaterialOverrides, p_Serializer, p_OwnOffset + offsetof(SActorSpreadTransitionOperatorMaterialSaveData, m_aActorMaterialOverrides));
}

bool SActorSpreadTransitionOperatorMaterialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadTransitionOperatorMaterialSaveData::operator==(const SActorSpreadTransitionOperatorMaterialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadTransitionOperatorMaterialSaveData>)
		return false;

	if (m_aActorMaterialOverrides != p_Other.m_aActorMaterialOverrides) return false;

	return true;
}

ZHMTypeInfo SActorStandInSaveData::TypeInfo = ZHMTypeInfo("SActorStandInSaveData", sizeof(SActorStandInSaveData), alignof(SActorStandInSaveData), SActorStandInSaveData::WriteJson, SActorStandInSaveData::WriteSimpleJson, SActorStandInSaveData::FromSimpleJson, SActorStandInSaveData::Serialize, SActorStandInSaveData::Equals);

void SActorStandInSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorStandInSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorStandInSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorStandInSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorStandInSaveData*>(p_Target) = s_Object;
}

void SActorStandInSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);

}

bool SActorStandInSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorStandInSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorStandInSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorStandInSaveData::operator==(const SActorStandInSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorStandInSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SActorStandInEntitiesSaveData::TypeInfo = ZHMTypeInfo("SActorStandInEntitiesSaveData", sizeof(SActorStandInEntitiesSaveData), alignof(SActorStandInEntitiesSaveData), SActorStandInEntitiesSaveData::WriteJson, SActorStandInEntitiesSaveData::WriteSimpleJson, SActorStandInEntitiesSaveData::FromSimpleJson, SActorStandInEntitiesSaveData::Serialize, SActorStandInEntitiesSaveData::Equals);

void SActorStandInEntitiesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorStandInSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorStandInSaveData") << ",\"$val\":";
		SActorStandInSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorStandInEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorStandInSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorStandInEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorStandInEntitiesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SActorStandInSaveData s_ArrayItem0;
		SActorStandInSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Target) = s_Object;
}

void SActorStandInEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorStandInEntitiesSaveData, m_aEntities));
	TArray<SActorStandInSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorStandInEntitiesSaveData, m_aData));
}

bool SActorStandInEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorStandInEntitiesSaveData::operator==(const SActorStandInEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorStandInEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SActorTagSaveData::TypeInfo = ZHMTypeInfo("SActorTagSaveData", sizeof(SActorTagSaveData), alignof(SActorTagSaveData), SActorTagSaveData::WriteJson, SActorTagSaveData::WriteSimpleJson, SActorTagSaveData::FromSimpleJson, SActorTagSaveData::Serialize, SActorTagSaveData::Equals);

void SActorTagSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bSeen") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSeen);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTagged") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTagged);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rActorRef") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActorRef);
	p_Stream << "}";

	p_Stream << "}";
}

void SActorTagSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSeen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSeen);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTagged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTagged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rActorRef") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActorRef);

	p_Stream << "}";
}

void SActorTagSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorTagSaveData s_Object {};

	s_Object.m_bSeen = simdjson::from_json_bool(p_Document["m_bSeen"]);

	s_Object.m_bTagged = simdjson::from_json_bool(p_Document["m_bTagged"]);

	s_Object.m_rActorRef = simdjson::from_json_uint32(p_Document["m_rActorRef"]);

	*reinterpret_cast<SActorTagSaveData*>(p_Target) = s_Object;
}

void SActorTagSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);

}

bool SActorTagSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorTagSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorTagSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorTagSaveData::operator==(const SActorTagSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorTagSaveData>)
		return false;

	if (m_bSeen != p_Other.m_bSeen) return false;
	if (m_bTagged != p_Other.m_bTagged) return false;
	if (m_rActorRef != p_Other.m_rActorRef) return false;

	return true;
}

ZHMTypeInfo SActorTagManagerSaveData::TypeInfo = ZHMTypeInfo("SActorTagManagerSaveData", sizeof(SActorTagManagerSaveData), alignof(SActorTagManagerSaveData), SActorTagManagerSaveData::WriteJson, SActorTagManagerSaveData::WriteSimpleJson, SActorTagManagerSaveData::FromSimpleJson, SActorTagManagerSaveData::Serialize, SActorTagManagerSaveData::Equals);

void SActorTagManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bContractsCreationMode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContractsCreationMode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTagCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTagCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxTagCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxTagCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTaggingEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTaggingEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorTagData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SActorTagSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorTagData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorTagData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorTagSaveData") << ",\"$val\":";
		SActorTagSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aActorTagData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SActorTagManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bContractsCreationMode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContractsCreationMode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTagCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTagCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxTagCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxTagCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTaggingEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTaggingEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorTagData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorTagData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorTagData[i];
		SActorTagSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorTagData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorTagManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorTagManagerSaveData s_Object {};

	s_Object.m_bContractsCreationMode = simdjson::from_json_bool(p_Document["m_bContractsCreationMode"]);

	s_Object.m_nTagCount = simdjson::from_json_int32(p_Document["m_nTagCount"]);

	s_Object.m_nMaxTagCount = simdjson::from_json_int32(p_Document["m_nMaxTagCount"]);

	s_Object.m_bTaggingEnabled = simdjson::from_json_bool(p_Document["m_bTaggingEnabled"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActorTagData"])
	{
		SActorTagSaveData s_ArrayItem0;
		SActorTagSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorTagData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SActorTagManagerSaveData*>(p_Target) = s_Object;
}

void SActorTagManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);

	TArray<SActorTagSaveData>::Serialize(&s_Object->m_aActorTagData, p_Serializer, p_OwnOffset + offsetof(SActorTagManagerSaveData, m_aActorTagData));
}

bool SActorTagManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorTagManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorTagManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorTagManagerSaveData::operator==(const SActorTagManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorTagManagerSaveData>)
		return false;

	if (m_bContractsCreationMode != p_Other.m_bContractsCreationMode) return false;
	if (m_nTagCount != p_Other.m_nTagCount) return false;
	if (m_nMaxTagCount != p_Other.m_nMaxTagCount) return false;
	if (m_bTaggingEnabled != p_Other.m_bTaggingEnabled) return false;
	if (m_aActorTagData != p_Other.m_aActorTagData) return false;

	return true;
}

ZHMTypeInfo SAgencyPickupInfo::TypeInfo = ZHMTypeInfo("SAgencyPickupInfo", sizeof(SAgencyPickupInfo), alignof(SAgencyPickupInfo), SAgencyPickupInfo::WriteJson, SAgencyPickupInfo::WriteSimpleJson, SAgencyPickupInfo::FromSimpleJson, SAgencyPickupInfo::Serialize, SAgencyPickupInfo::Equals);

void SAgencyPickupInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAgencyPickupInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_AgencyPickupId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_AgencyPickupId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aItemIds") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZRepositoryID>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemIds[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
		ZRepositoryID::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aItemIds.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aModifierIds") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZRepositoryID>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aModifierIds[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
		ZRepositoryID::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aModifierIds.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SAgencyPickupInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAgencyPickupInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_AgencyPickupId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_AgencyPickupId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aItemIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItemIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aModifierIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aModifierIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aModifierIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAgencyPickupInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAgencyPickupInfo s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_AgencyPickupId"], &s_Item);
		s_Object.m_AgencyPickupId = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aItemIds"])
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItemIds.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aModifierIds"])
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aModifierIds.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SAgencyPickupInfo*>(p_Target) = s_Object;
}

void SAgencyPickupInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAgencyPickupInfo*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_AgencyPickupId, p_Serializer, p_OwnOffset + offsetof(SAgencyPickupInfo, m_AgencyPickupId));
	TArray<ZRepositoryID>::Serialize(&s_Object->m_aItemIds, p_Serializer, p_OwnOffset + offsetof(SAgencyPickupInfo, m_aItemIds));
	TArray<ZRepositoryID>::Serialize(&s_Object->m_aModifierIds, p_Serializer, p_OwnOffset + offsetof(SAgencyPickupInfo, m_aModifierIds));
}

bool SAgencyPickupInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAgencyPickupInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SAgencyPickupInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAgencyPickupInfo::operator==(const SAgencyPickupInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAgencyPickupInfo>)
		return false;

	if (m_AgencyPickupId != p_Other.m_AgencyPickupId) return false;
	if (m_aItemIds != p_Other.m_aItemIds) return false;
	if (m_aModifierIds != p_Other.m_aModifierIds) return false;

	return true;
}

ZHMTypeInfo SAgitatedBystanderOrderSaveData::TypeInfo = ZHMTypeInfo("SAgitatedBystanderOrderSaveData", sizeof(SAgitatedBystanderOrderSaveData), alignof(SAgitatedBystanderOrderSaveData), SAgitatedBystanderOrderSaveData::WriteJson, SAgitatedBystanderOrderSaveData::WriteSimpleJson, SAgitatedBystanderOrderSaveData::FromSimpleJson, SAgitatedBystanderOrderSaveData::Serialize, SAgitatedBystanderOrderSaveData::Equals);

void SAgitatedBystanderOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rBystanderPoint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBystanderPoint);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCover") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vCover, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCoverDir") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vCoverDir, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SAgitatedBystanderOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rBystanderPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBystanderPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCover") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCover, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCoverDir") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCoverDir, p_Stream);

	p_Stream << "}";
}

void SAgitatedBystanderOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAgitatedBystanderOrderSaveData s_Object {};

	s_Object.m_rBystanderPoint = simdjson::from_json_uint32(p_Document["m_rBystanderPoint"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vCover"], &s_Item);
		s_Object.m_vCover = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vCoverDir"], &s_Item);
		s_Object.m_vCoverDir = s_Item;
	}

	*reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Target) = s_Object;
}

void SAgitatedBystanderOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vCover, p_Serializer, p_OwnOffset + offsetof(SAgitatedBystanderOrderSaveData, m_vCover));
	float4::Serialize(&s_Object->m_vCoverDir, p_Serializer, p_OwnOffset + offsetof(SAgitatedBystanderOrderSaveData, m_vCoverDir));
}

bool SAgitatedBystanderOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAgitatedBystanderOrderSaveData::operator==(const SAgitatedBystanderOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAgitatedBystanderOrderSaveData>)
		return false;

	if (m_rBystanderPoint != p_Other.m_rBystanderPoint) return false;
	if (m_vCover != p_Other.m_vCover) return false;
	if (m_vCoverDir != p_Other.m_vCoverDir) return false;

	return true;
}

ZHMTypeInfo SBoneTransformSaveData::TypeInfo = ZHMTypeInfo("SBoneTransformSaveData", sizeof(SBoneTransformSaveData), alignof(SBoneTransformSaveData), SBoneTransformSaveData::WriteJson, SBoneTransformSaveData::WriteSimpleJson, SBoneTransformSaveData::FromSimpleJson, SBoneTransformSaveData::Serialize, SBoneTransformSaveData::Equals);

void SBoneTransformSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mTranslation, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SBoneTransformSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SBoneTransformSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBoneTransformSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Item);
		s_Object.mQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Item);
		s_Object.mTranslation = s_Item;
	}

	*reinterpret_cast<SBoneTransformSaveData*>(p_Target) = s_Object;
}

void SBoneTransformSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SBoneTransformSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SBoneTransformSaveData, mTranslation));
}

bool SBoneTransformSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneTransformSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneTransformSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneTransformSaveData::operator==(const SBoneTransformSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneTransformSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

ZHMTypeInfo SAnimPlayerSaveData::TypeInfo = ZHMTypeInfo("SAnimPlayerSaveData", sizeof(SAnimPlayerSaveData), alignof(SAnimPlayerSaveData), SAnimPlayerSaveData::WriteJson, SAnimPlayerSaveData::WriteSimpleJson, SAnimPlayerSaveData::FromSimpleJson, SAnimPlayerSaveData::Serialize, SAnimPlayerSaveData::Equals);

void SAnimPlayerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("mTrajectoryQuaterion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mTrajectoryQuaterion, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTrajectoryTranslation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mTrajectoryTranslation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBoneTransformSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBoneTransformSaveData") << ",\"$val\":";
		SBoneTransformSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SAnimPlayerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mTrajectoryQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTrajectoryQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTrajectoryTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTrajectoryTranslation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SBoneTransformSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAnimPlayerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimPlayerSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTrajectoryQuaterion"], &s_Item);
		s_Object.mTrajectoryQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTrajectoryTranslation"], &s_Item);
		s_Object.mTrajectoryTranslation = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBones"])
	{
		SBoneTransformSaveData s_ArrayItem0;
		SBoneTransformSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBones.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SAnimPlayerSaveData*>(p_Target) = s_Object;
}

void SAnimPlayerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mTrajectoryQuaterion, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, mTrajectoryQuaterion));
	SVector4::Serialize(&s_Object->mTrajectoryTranslation, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, mTrajectoryTranslation));
	TArray<SBoneTransformSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, m_aBones));
}

bool SAnimPlayerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimPlayerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimPlayerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimPlayerSaveData::operator==(const SAnimPlayerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimPlayerSaveData>)
		return false;

	if (mTrajectoryQuaterion != p_Other.mTrajectoryQuaterion) return false;
	if (mTrajectoryTranslation != p_Other.mTrajectoryTranslation) return false;
	if (m_aBones != p_Other.m_aBones) return false;

	return true;
}

ZHMTypeInfo SAnimatedActorActOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorActOrderSaveData", sizeof(SAnimatedActorActOrderSaveData), alignof(SAnimatedActorActOrderSaveData), SAnimatedActorActOrderSaveData::WriteJson, SAnimatedActorActOrderSaveData::WriteSimpleJson, SAnimatedActorActOrderSaveData::FromSimpleJson, SAnimatedActorActOrderSaveData::Serialize, SAnimatedActorActOrderSaveData::Equals);

void SAnimatedActorActOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bOverrideExistingAct") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOverrideExistingAct);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nForcedAnimationNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nForcedAnimationNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkAct") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkAct);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vOriginPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginQuaternion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vOriginQuaternion, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SAnimatedActorActOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bOverrideExistingAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOverrideExistingAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nForcedAnimationNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nForcedAnimationNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vOriginPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginQuaternion") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vOriginQuaternion, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorActOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorActOrderSaveData s_Object {};

	s_Object.m_bOverrideExistingAct = simdjson::from_json_bool(p_Document["m_bOverrideExistingAct"]);

	s_Object.m_nForcedAnimationNode = simdjson::from_json_uint32(p_Document["m_nForcedAnimationNode"]);

	s_Object.m_rChildNetworkAct = simdjson::from_json_uint32(p_Document["m_rChildNetworkAct"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vOriginPosition"], &s_Item);
		s_Object.m_vOriginPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vOriginQuaternion"], &s_Item);
		s_Object.m_vOriginQuaternion = s_Item;
	}

	*reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorActOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vOriginPosition, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorActOrderSaveData, m_vOriginPosition));
	SVector4::Serialize(&s_Object->m_vOriginQuaternion, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorActOrderSaveData, m_vOriginQuaternion));
}

bool SAnimatedActorActOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorActOrderSaveData::operator==(const SAnimatedActorActOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorActOrderSaveData>)
		return false;

	if (m_bOverrideExistingAct != p_Other.m_bOverrideExistingAct) return false;
	if (m_nForcedAnimationNode != p_Other.m_nForcedAnimationNode) return false;
	if (m_rChildNetworkAct != p_Other.m_rChildNetworkAct) return false;
	if (m_vOriginPosition != p_Other.m_vOriginPosition) return false;
	if (m_vOriginQuaternion != p_Other.m_vOriginQuaternion) return false;

	return true;
}

ZHMTypeInfo SAnimatedActorMoveOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorMoveOrderSaveData", sizeof(SAnimatedActorMoveOrderSaveData), alignof(SAnimatedActorMoveOrderSaveData), SAnimatedActorMoveOrderSaveData::WriteJson, SAnimatedActorMoveOrderSaveData::WriteSimpleJson, SAnimatedActorMoveOrderSaveData::FromSimpleJson, SAnimatedActorMoveOrderSaveData::Serialize, SAnimatedActorMoveOrderSaveData::Equals);

void SAnimatedActorMoveOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bPrecisePositioning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPrecisePositioning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPreciseOrientation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPreciseOrientation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreEndCollision") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreEndCollision);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForcedEnpointSet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForcedEnpointSet);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStopMoveDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStopMoveDistance);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vWaypoint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vWaypoint, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vFacingDirection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vFacingDirection, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SAnimatedActorMoveOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPrecisePositioning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPrecisePositioning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPreciseOrientation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPreciseOrientation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreEndCollision") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreEndCollision);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForcedEnpointSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForcedEnpointSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStopMoveDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStopMoveDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vWaypoint") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vWaypoint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vFacingDirection") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFacingDirection, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorMoveOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorMoveOrderSaveData s_Object {};

	s_Object.m_bPrecisePositioning = simdjson::from_json_bool(p_Document["m_bPrecisePositioning"]);

	s_Object.m_bPreciseOrientation = simdjson::from_json_bool(p_Document["m_bPreciseOrientation"]);

	s_Object.m_bIgnoreEndCollision = simdjson::from_json_bool(p_Document["m_bIgnoreEndCollision"]);

	s_Object.m_bForcedEnpointSet = simdjson::from_json_bool(p_Document["m_bForcedEnpointSet"]);

	s_Object.m_fStopMoveDistance = simdjson::from_json_float32(p_Document["m_fStopMoveDistance"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vWaypoint"], &s_Item);
		s_Object.m_vWaypoint = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vFacingDirection"], &s_Item);
		s_Object.m_vFacingDirection = s_Item;
	}

	*reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorMoveOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vWaypoint, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorMoveOrderSaveData, m_vWaypoint));
	SVector3::Serialize(&s_Object->m_vFacingDirection, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorMoveOrderSaveData, m_vFacingDirection));
}

bool SAnimatedActorMoveOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorMoveOrderSaveData::operator==(const SAnimatedActorMoveOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorMoveOrderSaveData>)
		return false;

	if (m_bPrecisePositioning != p_Other.m_bPrecisePositioning) return false;
	if (m_bPreciseOrientation != p_Other.m_bPreciseOrientation) return false;
	if (m_bIgnoreEndCollision != p_Other.m_bIgnoreEndCollision) return false;
	if (m_bForcedEnpointSet != p_Other.m_bForcedEnpointSet) return false;
	if (m_fStopMoveDistance != p_Other.m_fStopMoveDistance) return false;
	if (m_vWaypoint != p_Other.m_vWaypoint) return false;
	if (m_vFacingDirection != p_Other.m_vFacingDirection) return false;

	return true;
}

ZHMTypeInfo SAnimatedActorOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorOrderSaveData", sizeof(SAnimatedActorOrderSaveData), alignof(SAnimatedActorOrderSaveData), SAnimatedActorOrderSaveData::WriteJson, SAnimatedActorOrderSaveData::WriteSimpleJson, SAnimatedActorOrderSaveData::FromSimpleJson, SAnimatedActorOrderSaveData::Serialize, SAnimatedActorOrderSaveData::Equals);

void SAnimatedActorOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eOrderType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorAnimationOrder") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eOrderType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorAnimationOrder", static_cast<int>(s_Object->m_eOrderType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OrderData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_OrderData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SAnimatedActorOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eOrderType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorAnimationOrder", static_cast<int>(s_Object->m_eOrderType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_OrderData, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorOrderSaveData s_Object {};

	s_Object.m_eOrderType = static_cast<EActorAnimationOrder>(ZHMEnums::GetEnumValueByName("EActorAnimationOrder", std::string_view(p_Document["m_eOrderType"])));

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_OrderData"], &s_Item);
		s_Object.m_OrderData = s_Item;
	}

	*reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_OrderData, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorOrderSaveData, m_OrderData));
}

bool SAnimatedActorOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorOrderSaveData::operator==(const SAnimatedActorOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorOrderSaveData>)
		return false;

	if (m_eOrderType != p_Other.m_eOrderType) return false;
	if (m_OrderData != p_Other.m_OrderData) return false;

	return true;
}

ZHMTypeInfo SAnimatedActorReactOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorReactOrderSaveData", sizeof(SAnimatedActorReactOrderSaveData), alignof(SAnimatedActorReactOrderSaveData), SAnimatedActorReactOrderSaveData::WriteJson, SAnimatedActorReactOrderSaveData::WriteSimpleJson, SAnimatedActorReactOrderSaveData::FromSimpleJson, SAnimatedActorReactOrderSaveData::Serialize, SAnimatedActorReactOrderSaveData::Equals);

void SAnimatedActorReactOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vFaceTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vFaceTarget, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLookAtTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vLookAtTarget, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetEmotionState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorEmotionState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_targetEmotionState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_targetEmotionState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadbody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadbody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bExplosion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bExplosion);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTrespassing") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTrespassing);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropCarriedItems") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropCarriedItems);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFaceTargetSet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFaceTargetSet);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLookAtTargetSet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAtTargetSet);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sAct") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAct);
	p_Stream << "}";

	p_Stream << "}";
}

void SAnimatedActorReactOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vFaceTarget") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFaceTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLookAtTarget") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLookAtTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_targetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadbody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadbody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bExplosion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bExplosion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropCarriedItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropCarriedItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFaceTargetSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFaceTargetSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLookAtTargetSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAtTargetSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAct);

	p_Stream << "}";
}

void SAnimatedActorReactOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorReactOrderSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vFaceTarget"], &s_Item);
		s_Object.m_vFaceTarget = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLookAtTarget"], &s_Item);
		s_Object.m_vLookAtTarget = s_Item;
	}

	s_Object.m_rChildNetworkEntity = simdjson::from_json_uint32(p_Document["m_rChildNetworkEntity"]);

	s_Object.m_targetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_targetEmotionState"])));

	s_Object.m_bDeadbody = simdjson::from_json_bool(p_Document["m_bDeadbody"]);

	s_Object.m_bExplosion = simdjson::from_json_bool(p_Document["m_bExplosion"]);

	s_Object.m_bTrespassing = simdjson::from_json_bool(p_Document["m_bTrespassing"]);

	s_Object.m_bDropCarriedItems = simdjson::from_json_bool(p_Document["m_bDropCarriedItems"]);

	s_Object.m_bFaceTargetSet = simdjson::from_json_bool(p_Document["m_bFaceTargetSet"]);

	s_Object.m_bLookAtTargetSet = simdjson::from_json_bool(p_Document["m_bLookAtTargetSet"]);

	s_Object.m_sAct = std::string_view(p_Document["m_sAct"]);

	*reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorReactOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vFaceTarget, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_vFaceTarget));
	SVector3::Serialize(&s_Object->m_vLookAtTarget, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_vLookAtTarget));
	ZString::Serialize(&s_Object->m_sAct, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_sAct));
}

bool SAnimatedActorReactOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorReactOrderSaveData::operator==(const SAnimatedActorReactOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorReactOrderSaveData>)
		return false;

	if (m_vFaceTarget != p_Other.m_vFaceTarget) return false;
	if (m_vLookAtTarget != p_Other.m_vLookAtTarget) return false;
	if (m_rChildNetworkEntity != p_Other.m_rChildNetworkEntity) return false;
	if (m_targetEmotionState != p_Other.m_targetEmotionState) return false;
	if (m_bDeadbody != p_Other.m_bDeadbody) return false;
	if (m_bExplosion != p_Other.m_bExplosion) return false;
	if (m_bTrespassing != p_Other.m_bTrespassing) return false;
	if (m_bDropCarriedItems != p_Other.m_bDropCarriedItems) return false;
	if (m_bFaceTargetSet != p_Other.m_bFaceTargetSet) return false;
	if (m_bLookAtTargetSet != p_Other.m_bLookAtTargetSet) return false;
	if (m_sAct != p_Other.m_sAct) return false;

	return true;
}

ZHMTypeInfo SAnimatedActorStandOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorStandOrderSaveData", sizeof(SAnimatedActorStandOrderSaveData), alignof(SAnimatedActorStandOrderSaveData), SAnimatedActorStandOrderSaveData::WriteJson, SAnimatedActorStandOrderSaveData::WriteSimpleJson, SAnimatedActorStandOrderSaveData::FromSimpleJson, SAnimatedActorStandOrderSaveData::Serialize, SAnimatedActorStandOrderSaveData::Equals);

void SAnimatedActorStandOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vFacingDirection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vFacingDirection, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SAnimatedActorStandOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vFacingDirection") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFacingDirection, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorStandOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorStandOrderSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vFacingDirection"], &s_Item);
		s_Object.m_vFacingDirection = s_Item;
	}

	*reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorStandOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vFacingDirection, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorStandOrderSaveData, m_vFacingDirection));
}

bool SAnimatedActorStandOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorStandOrderSaveData::operator==(const SAnimatedActorStandOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorStandOrderSaveData>)
		return false;

	if (m_vFacingDirection != p_Other.m_vFacingDirection) return false;

	return true;
}

ZHMTypeInfo SAttentionHUDUIElement::TypeInfo = ZHMTypeInfo("SAttentionHUDUIElement", sizeof(SAttentionHUDUIElement), alignof(SAttentionHUDUIElement), SAttentionHUDUIElement::WriteJson, SAttentionHUDUIElement::WriteSimpleJson, SAttentionHUDUIElement::FromSimpleJson, SAttentionHUDUIElement::Serialize, SAttentionHUDUIElement::Equals);

void SAttentionHUDUIElement::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("fAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAttention") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fAttention);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlpha") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fAlpha);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fRadius") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fRadius);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nColor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nColor);
	p_Stream << "}";

	p_Stream << "}";
}

void SAttentionHUDUIElement::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fRadius);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nColor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColor);

	p_Stream << "}";
}

void SAttentionHUDUIElement::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAttentionHUDUIElement s_Object {};

	s_Object.fAngle = simdjson::from_json_float32(p_Document["fAngle"]);

	s_Object.fAttention = simdjson::from_json_float32(p_Document["fAttention"]);

	s_Object.fAlpha = simdjson::from_json_float32(p_Document["fAlpha"]);

	s_Object.fRadius = simdjson::from_json_float32(p_Document["fRadius"]);

	s_Object.nColor = simdjson::from_json_int32(p_Document["nColor"]);

	*reinterpret_cast<SAttentionHUDUIElement*>(p_Target) = s_Object;
}

void SAttentionHUDUIElement::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);

}

bool SAttentionHUDUIElement::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAttentionHUDUIElement*>(p_Left);
	auto* s_Right = reinterpret_cast<SAttentionHUDUIElement*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAttentionHUDUIElement::operator==(const SAttentionHUDUIElement& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAttentionHUDUIElement>)
		return false;

	if (fAngle != p_Other.fAngle) return false;
	if (fAttention != p_Other.fAttention) return false;
	if (fAlpha != p_Other.fAlpha) return false;
	if (fRadius != p_Other.fRadius) return false;
	if (nColor != p_Other.nColor) return false;

	return true;
}

ZHMTypeInfo SAttentionHUDUIElementArray_Dummy::TypeInfo = ZHMTypeInfo("SAttentionHUDUIElementArray_Dummy", sizeof(SAttentionHUDUIElementArray_Dummy), alignof(SAttentionHUDUIElementArray_Dummy), SAttentionHUDUIElementArray_Dummy::WriteJson, SAttentionHUDUIElementArray_Dummy::WriteSimpleJson, SAttentionHUDUIElementArray_Dummy::FromSimpleJson, SAttentionHUDUIElementArray_Dummy::Serialize, SAttentionHUDUIElementArray_Dummy::Equals);

void SAttentionHUDUIElementArray_Dummy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAttentionHUDUIElement>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAttentionHUDUIElement") << ",\"$val\":";
		SAttentionHUDUIElement::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SAttentionHUDUIElementArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SAttentionHUDUIElement::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAttentionHUDUIElementArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAttentionHUDUIElementArray_Dummy s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["dummy"])
	{
		SAttentionHUDUIElement s_ArrayItem0;
		SAttentionHUDUIElement::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Target) = s_Object;
}

void SAttentionHUDUIElementArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);

	TArray<SAttentionHUDUIElement>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SAttentionHUDUIElementArray_Dummy, dummy));
}

bool SAttentionHUDUIElementArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAttentionHUDUIElementArray_Dummy::operator==(const SAttentionHUDUIElementArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAttentionHUDUIElementArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

ZHMTypeInfo SAudioEmitterEventSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterEventSaveData", sizeof(SAudioEmitterEventSaveData), alignof(SAudioEmitterEventSaveData), SAudioEmitterEventSaveData::WriteJson, SAudioEmitterEventSaveData::WriteSimpleJson, SAudioEmitterEventSaveData::FromSimpleJson, SAudioEmitterEventSaveData::Serialize, SAudioEmitterEventSaveData::Equals);

void SAudioEmitterEventSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEventId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFlags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFlags);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEventSender") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEventSender);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSeekPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSeekPosition);
	p_Stream << "}";

	p_Stream << "}";
}

void SAudioEmitterEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEventSender") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEventSender);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSeekPosition);

	p_Stream << "}";
}

void SAudioEmitterEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterEventSaveData s_Object {};

	s_Object.m_nEventId = simdjson::from_json_uint32(p_Document["m_nEventId"]);

	s_Object.m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	s_Object.m_nFlags = simdjson::from_json_uint32(p_Document["m_nFlags"]);

	s_Object.m_rEventSender = simdjson::from_json_uint32(p_Document["m_rEventSender"]);

	s_Object.m_nSeekPosition = simdjson::from_json_int32(p_Document["m_nSeekPosition"]);

	*reinterpret_cast<SAudioEmitterEventSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);

}

bool SAudioEmitterEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterEventSaveData::operator==(const SAudioEmitterEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterEventSaveData>)
		return false;

	if (m_nEventId != p_Other.m_nEventId) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;
	if (m_nFlags != p_Other.m_nFlags) return false;
	if (m_rEventSender != p_Other.m_rEventSender) return false;
	if (m_nSeekPosition != p_Other.m_nSeekPosition) return false;

	return true;
}

ZHMTypeInfo SAudioEmitterRTPCSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterRTPCSaveData", sizeof(SAudioEmitterRTPCSaveData), alignof(SAudioEmitterRTPCSaveData), SAudioEmitterRTPCSaveData::WriteJson, SAudioEmitterRTPCSaveData::WriteSimpleJson, SAudioEmitterRTPCSaveData::FromSimpleJson, SAudioEmitterRTPCSaveData::Serialize, SAudioEmitterRTPCSaveData::Equals);

void SAudioEmitterRTPCSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nParamId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nParamId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fValue);
	p_Stream << "}";

	p_Stream << "}";
}

void SAudioEmitterRTPCSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nParamId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nParamId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fValue);

	p_Stream << "}";
}

void SAudioEmitterRTPCSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterRTPCSaveData s_Object {};

	s_Object.m_nParamId = simdjson::from_json_uint32(p_Document["m_nParamId"]);

	s_Object.m_fValue = simdjson::from_json_float32(p_Document["m_fValue"]);

	*reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterRTPCSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);

}

bool SAudioEmitterRTPCSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterRTPCSaveData::operator==(const SAudioEmitterRTPCSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterRTPCSaveData>)
		return false;

	if (m_nParamId != p_Other.m_nParamId) return false;
	if (m_fValue != p_Other.m_fValue) return false;

	return true;
}

ZHMTypeInfo SAudioEmitterSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterSaveData", sizeof(SAudioEmitterSaveData), alignof(SAudioEmitterSaveData), SAudioEmitterSaveData::WriteJson, SAudioEmitterSaveData::WriteSimpleJson, SAudioEmitterSaveData::FromSimpleJson, SAudioEmitterSaveData::Serialize, SAudioEmitterSaveData::Equals);

void SAudioEmitterSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEmitter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEmitter);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfEvents") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfEvents);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfRTPCs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfRTPCs);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfSwitches") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfSwitches);
	p_Stream << "}";

	p_Stream << "}";
}

void SAudioEmitterSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEmitter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEmitter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfEvents") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfEvents);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfRTPCs") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfRTPCs);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfSwitches") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfSwitches);

	p_Stream << "}";
}

void SAudioEmitterSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterSaveData s_Object {};

	s_Object.m_rEmitter = simdjson::from_json_uint32(p_Document["m_rEmitter"]);

	s_Object.m_nNumberOfEvents = simdjson::from_json_uint32(p_Document["m_nNumberOfEvents"]);

	s_Object.m_nNumberOfRTPCs = simdjson::from_json_uint32(p_Document["m_nNumberOfRTPCs"]);

	s_Object.m_nNumberOfSwitches = simdjson::from_json_uint32(p_Document["m_nNumberOfSwitches"]);

	*reinterpret_cast<SAudioEmitterSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);

}

bool SAudioEmitterSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterSaveData::operator==(const SAudioEmitterSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterSaveData>)
		return false;

	if (m_rEmitter != p_Other.m_rEmitter) return false;
	if (m_nNumberOfEvents != p_Other.m_nNumberOfEvents) return false;
	if (m_nNumberOfRTPCs != p_Other.m_nNumberOfRTPCs) return false;
	if (m_nNumberOfSwitches != p_Other.m_nNumberOfSwitches) return false;

	return true;
}

ZHMTypeInfo SAudioEmitterStateSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterStateSaveData", sizeof(SAudioEmitterStateSaveData), alignof(SAudioEmitterStateSaveData), SAudioEmitterStateSaveData::WriteJson, SAudioEmitterStateSaveData::WriteSimpleJson, SAudioEmitterStateSaveData::FromSimpleJson, SAudioEmitterStateSaveData::Serialize, SAudioEmitterStateSaveData::Equals);

void SAudioEmitterStateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nGroupId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStateId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStateId);
	p_Stream << "}";

	p_Stream << "}";
}

void SAudioEmitterStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nGroupId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStateId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStateId);

	p_Stream << "}";
}

void SAudioEmitterStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterStateSaveData s_Object {};

	s_Object.m_nGroupId = simdjson::from_json_uint32(p_Document["m_nGroupId"]);

	s_Object.m_nStateId = simdjson::from_json_uint32(p_Document["m_nStateId"]);

	*reinterpret_cast<SAudioEmitterStateSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);

}

bool SAudioEmitterStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterStateSaveData::operator==(const SAudioEmitterStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterStateSaveData>)
		return false;

	if (m_nGroupId != p_Other.m_nGroupId) return false;
	if (m_nStateId != p_Other.m_nStateId) return false;

	return true;
}

ZHMTypeInfo SAudioEmitterSwitchSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterSwitchSaveData", sizeof(SAudioEmitterSwitchSaveData), alignof(SAudioEmitterSwitchSaveData), SAudioEmitterSwitchSaveData::WriteJson, SAudioEmitterSwitchSaveData::WriteSimpleJson, SAudioEmitterSwitchSaveData::FromSimpleJson, SAudioEmitterSwitchSaveData::Serialize, SAudioEmitterSwitchSaveData::Equals);

void SAudioEmitterSwitchSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nGroupId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStateId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStateId);
	p_Stream << "}";

	p_Stream << "}";
}

void SAudioEmitterSwitchSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nGroupId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStateId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStateId);

	p_Stream << "}";
}

void SAudioEmitterSwitchSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterSwitchSaveData s_Object {};

	s_Object.m_nGroupId = simdjson::from_json_uint32(p_Document["m_nGroupId"]);

	s_Object.m_nStateId = simdjson::from_json_uint32(p_Document["m_nStateId"]);

	*reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterSwitchSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);

}

bool SAudioEmitterSwitchSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterSwitchSaveData::operator==(const SAudioEmitterSwitchSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterSwitchSaveData>)
		return false;

	if (m_nGroupId != p_Other.m_nGroupId) return false;
	if (m_nStateId != p_Other.m_nStateId) return false;

	return true;
}

ZHMTypeInfo SAudioEventData::TypeInfo = ZHMTypeInfo("SAudioEventData", sizeof(SAudioEventData), alignof(SAudioEventData), SAudioEventData::WriteJson, SAudioEventData::WriteSimpleJson, SAudioEventData::FromSimpleJson, SAudioEventData::Serialize, SAudioEventData::Equals);

void SAudioEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_EmitterID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_EmitterID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_EventID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_EventID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PlayingID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_PlayingID);
	p_Stream << "}";

	p_Stream << "}";
}

void SAudioEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EmitterID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_EmitterID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_EventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_EventID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PlayingID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_PlayingID);

	p_Stream << "}";
}

void SAudioEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEventData s_Object {};

	s_Object.m_EmitterID = simdjson::from_json_uint64(p_Document["m_EmitterID"]);

	s_Object.m_EventID = simdjson::from_json_uint32(p_Document["m_EventID"]);

	s_Object.m_PlayingID = simdjson::from_json_uint32(p_Document["m_PlayingID"]);

	*reinterpret_cast<SAudioEventData*>(p_Target) = s_Object;
}

void SAudioEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEventData*>(p_Object);

}

bool SAudioEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEventData::operator==(const SAudioEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEventData>)
		return false;

	if (m_EmitterID != p_Other.m_EmitterID) return false;
	if (m_EventID != p_Other.m_EventID) return false;
	if (m_PlayingID != p_Other.m_PlayingID) return false;

	return true;
}

ZHMTypeInfo SAudioSaveData::TypeInfo = ZHMTypeInfo("SAudioSaveData", sizeof(SAudioSaveData), alignof(SAudioSaveData), SAudioSaveData::WriteJson, SAudioSaveData::WriteSimpleJson, SAudioSaveData::FromSimpleJson, SAudioSaveData::Serialize, SAudioSaveData::Equals);

void SAudioSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEmitters") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAudioEmitterSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitters.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitters[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAudioEmitterSaveData") << ",\"$val\":";
		SAudioEmitterSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEmitters.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterEvents") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAudioEmitterEventSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterEvents[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAudioEmitterEventSaveData") << ",\"$val\":";
		SAudioEmitterEventSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEmitterEvents.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterRTPCs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAudioEmitterRTPCSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterRTPCs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterRTPCs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAudioEmitterRTPCSaveData") << ",\"$val\":";
		SAudioEmitterRTPCSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEmitterRTPCs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterSwitches") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAudioEmitterSwitchSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterSwitches.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterSwitches[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAudioEmitterSwitchSaveData") << ",\"$val\":";
		SAudioEmitterSwitchSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEmitterSwitches.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGlobalStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAudioEmitterStateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGlobalStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGlobalStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAudioEmitterStateSaveData") << ",\"$val\":";
		SAudioEmitterStateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aGlobalStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGlobalRTPCs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SAudioEmitterRTPCSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGlobalRTPCs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGlobalRTPCs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SAudioEmitterRTPCSaveData") << ",\"$val\":";
		SAudioEmitterRTPCSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aGlobalRTPCs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEventsEnabledAfterInit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEventsEnabledAfterInit.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEventsEnabledAfterInit[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEventsEnabledAfterInit.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SAudioSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEmitters") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitters.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitters[i];
		SAudioEmitterSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitters.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterEvents[i];
		SAudioEmitterEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterRTPCs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterRTPCs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterRTPCs[i];
		SAudioEmitterRTPCSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterRTPCs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterSwitches") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterSwitches.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterSwitches[i];
		SAudioEmitterSwitchSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterSwitches.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGlobalStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGlobalStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGlobalStates[i];
		SAudioEmitterStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGlobalStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGlobalRTPCs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGlobalRTPCs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGlobalRTPCs[i];
		SAudioEmitterRTPCSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGlobalRTPCs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEventsEnabledAfterInit") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEventsEnabledAfterInit.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEventsEnabledAfterInit[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEventsEnabledAfterInit.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAudioSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEmitters"])
	{
		SAudioEmitterSaveData s_ArrayItem0;
		SAudioEmitterSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEmitters.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEmitterEvents"])
	{
		SAudioEmitterEventSaveData s_ArrayItem0;
		SAudioEmitterEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEmitterEvents.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEmitterRTPCs"])
	{
		SAudioEmitterRTPCSaveData s_ArrayItem0;
		SAudioEmitterRTPCSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEmitterRTPCs.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEmitterSwitches"])
	{
		SAudioEmitterSwitchSaveData s_ArrayItem0;
		SAudioEmitterSwitchSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEmitterSwitches.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGlobalStates"])
	{
		SAudioEmitterStateSaveData s_ArrayItem0;
		SAudioEmitterStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGlobalStates.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGlobalRTPCs"])
	{
		SAudioEmitterRTPCSaveData s_ArrayItem0;
		SAudioEmitterRTPCSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGlobalRTPCs.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEventsEnabledAfterInit"])
	{
		s_Object.m_aEventsEnabledAfterInit.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SAudioSaveData*>(p_Target) = s_Object;
}

void SAudioSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);

	TArray<SAudioEmitterSaveData>::Serialize(&s_Object->m_aEmitters, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitters));
	TArray<SAudioEmitterEventSaveData>::Serialize(&s_Object->m_aEmitterEvents, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterEvents));
	TArray<SAudioEmitterRTPCSaveData>::Serialize(&s_Object->m_aEmitterRTPCs, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterRTPCs));
	TArray<SAudioEmitterSwitchSaveData>::Serialize(&s_Object->m_aEmitterSwitches, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterSwitches));
	TArray<SAudioEmitterStateSaveData>::Serialize(&s_Object->m_aGlobalStates, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aGlobalStates));
	TArray<SAudioEmitterRTPCSaveData>::Serialize(&s_Object->m_aGlobalRTPCs, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aGlobalRTPCs));
	TArray<uint32>::Serialize(&s_Object->m_aEventsEnabledAfterInit, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEventsEnabledAfterInit));
}

bool SAudioSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioSaveData::operator==(const SAudioSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioSaveData>)
		return false;

	if (m_aEmitters != p_Other.m_aEmitters) return false;
	if (m_aEmitterEvents != p_Other.m_aEmitterEvents) return false;
	if (m_aEmitterRTPCs != p_Other.m_aEmitterRTPCs) return false;
	if (m_aEmitterSwitches != p_Other.m_aEmitterSwitches) return false;
	if (m_aGlobalStates != p_Other.m_aGlobalStates) return false;
	if (m_aGlobalRTPCs != p_Other.m_aGlobalRTPCs) return false;
	if (m_aEventsEnabledAfterInit != p_Other.m_aEventsEnabledAfterInit) return false;

	return true;
}

ZHMTypeInfo SFSMSaveData::TypeInfo = ZHMTypeInfo("SFSMSaveData", sizeof(SFSMSaveData), alignof(SFSMSaveData), SFSMSaveData::WriteJson, SFSMSaveData::WriteSimpleJson, SFSMSaveData::FromSimpleJson, SFSMSaveData::Serialize, SFSMSaveData::Equals);

void SFSMSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eStateStatus") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EFSMStateStatus") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eStateStatus)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EFSMStateStatus", static_cast<int>(s_Object->m_eStateStatus))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_state);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_prevState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_prevState);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tCurrentStateEnterTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tCurrentStateEnterTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SFSMSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eStateStatus") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EFSMStateStatus", static_cast<int>(s_Object->m_eStateStatus)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_state);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_prevState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_prevState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tCurrentStateEnterTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tCurrentStateEnterTime, p_Stream);

	p_Stream << "}";
}

void SFSMSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFSMSaveData s_Object {};

	s_Object.m_eStateStatus = static_cast<EFSMStateStatus>(ZHMEnums::GetEnumValueByName("EFSMStateStatus", std::string_view(p_Document["m_eStateStatus"])));

	s_Object.m_state = simdjson::from_json_int32(p_Document["m_state"]);

	s_Object.m_prevState = simdjson::from_json_int32(p_Document["m_prevState"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tCurrentStateEnterTime"], &s_Item);
		s_Object.m_tCurrentStateEnterTime = s_Item;
	}

	*reinterpret_cast<SFSMSaveData*>(p_Target) = s_Object;
}

void SFSMSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tCurrentStateEnterTime, p_Serializer, p_OwnOffset + offsetof(SFSMSaveData, m_tCurrentStateEnterTime));
}

bool SFSMSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFSMSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFSMSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFSMSaveData::operator==(const SFSMSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFSMSaveData>)
		return false;

	if (m_eStateStatus != p_Other.m_eStateStatus) return false;
	if (m_state != p_Other.m_state) return false;
	if (m_prevState != p_Other.m_prevState) return false;
	if (m_tCurrentStateEnterTime != p_Other.m_tCurrentStateEnterTime) return false;

	return true;
}

ZHMTypeInfo SAvoidDangerousAreaGroupSaveData::TypeInfo = ZHMTypeInfo("SAvoidDangerousAreaGroupSaveData", sizeof(SAvoidDangerousAreaGroupSaveData), alignof(SAvoidDangerousAreaGroupSaveData), SAvoidDangerousAreaGroupSaveData::WriteJson, SAvoidDangerousAreaGroupSaveData::WriteSimpleJson, SAvoidDangerousAreaGroupSaveData::FromSimpleJson, SAvoidDangerousAreaGroupSaveData::Serialize, SAvoidDangerousAreaGroupSaveData::Equals);

void SAvoidDangerousAreaGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDangerousArea") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDangerousArea);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDestinationPoint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vDestinationPoint, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iGridId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iGridId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitUntilDangerEnds") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitUntilDangerEnds);
	p_Stream << "}";

	p_Stream << "}";
}

void SAvoidDangerousAreaGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDangerousArea") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDangerousArea);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDestinationPoint") << ":";
	float4::WriteSimpleJson(&s_Object->m_vDestinationPoint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iGridId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iGridId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitUntilDangerEnds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitUntilDangerEnds);

	p_Stream << "}";
}

void SAvoidDangerousAreaGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAvoidDangerousAreaGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_rDangerousArea = simdjson::from_json_uint32(p_Document["m_rDangerousArea"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vDestinationPoint"], &s_Item);
		s_Object.m_vDestinationPoint = s_Item;
	}

	s_Object.m_iGridId = simdjson::from_json_int32(p_Document["m_iGridId"]);

	s_Object.m_bWaitUntilDangerEnds = simdjson::from_json_bool(p_Document["m_bWaitUntilDangerEnds"]);

	*reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Target) = s_Object;
}

void SAvoidDangerousAreaGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SAvoidDangerousAreaGroupSaveData, m_fsmState));
	float4::Serialize(&s_Object->m_vDestinationPoint, p_Serializer, p_OwnOffset + offsetof(SAvoidDangerousAreaGroupSaveData, m_vDestinationPoint));
}

bool SAvoidDangerousAreaGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAvoidDangerousAreaGroupSaveData::operator==(const SAvoidDangerousAreaGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAvoidDangerousAreaGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rDangerousArea != p_Other.m_rDangerousArea) return false;
	if (m_vDestinationPoint != p_Other.m_vDestinationPoint) return false;
	if (m_iGridId != p_Other.m_iGridId) return false;
	if (m_bWaitUntilDangerEnds != p_Other.m_bWaitUntilDangerEnds) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeEntityReference::TypeInfo = ZHMTypeInfo("SBehaviorTreeEntityReference", sizeof(SBehaviorTreeEntityReference), alignof(SBehaviorTreeEntityReference), SBehaviorTreeEntityReference::WriteJson, SBehaviorTreeEntityReference::WriteSimpleJson, SBehaviorTreeEntityReference::FromSimpleJson, SBehaviorTreeEntityReference::Serialize, SBehaviorTreeEntityReference::Equals);

void SBehaviorTreeEntityReference::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bList") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bList);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeEntityReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bList") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bList);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);

	p_Stream << "}";
}

void SBehaviorTreeEntityReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEntityReference s_Object {};

	s_Object.m_bList = simdjson::from_json_bool(p_Document["m_bList"]);

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	*reinterpret_cast<SBehaviorTreeEntityReference*>(p_Target) = s_Object;
}

void SBehaviorTreeEntityReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEntityReference, m_sName));
}

bool SBehaviorTreeEntityReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEntityReference::operator==(const SBehaviorTreeEntityReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEntityReference>)
		return false;

	if (m_bList != p_Other.m_bList) return false;
	if (m_sName != p_Other.m_sName) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeEvaluationLogEntry::TypeInfo = ZHMTypeInfo("SBehaviorTreeEvaluationLogEntry", sizeof(SBehaviorTreeEvaluationLogEntry), alignof(SBehaviorTreeEvaluationLogEntry), SBehaviorTreeEvaluationLogEntry::WriteJson, SBehaviorTreeEvaluationLogEntry::WriteSimpleJson, SBehaviorTreeEvaluationLogEntry::FromSimpleJson, SBehaviorTreeEvaluationLogEntry::Serialize, SBehaviorTreeEvaluationLogEntry::Equals);

void SBehaviorTreeEvaluationLogEntry::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nBehaviorTreeIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBehaviorTreeIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nConditionOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nConditionOffset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bResult") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bResult);
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLogEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nBehaviorTreeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBehaviorTreeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nConditionOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nConditionOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bResult") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bResult);

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLogEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEvaluationLogEntry s_Object {};

	s_Object.m_nBehaviorTreeIndex = simdjson::from_json_uint32(p_Document["m_nBehaviorTreeIndex"]);

	s_Object.m_nConditionOffset = simdjson::from_json_uint64(p_Document["m_nConditionOffset"]);

	s_Object.m_bResult = simdjson::from_json_bool(p_Document["m_bResult"]);

	*reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Target) = s_Object;
}

void SBehaviorTreeEvaluationLogEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

}

bool SBehaviorTreeEvaluationLogEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEvaluationLogEntry::operator==(const SBehaviorTreeEvaluationLogEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEvaluationLogEntry>)
		return false;

	if (m_nBehaviorTreeIndex != p_Other.m_nBehaviorTreeIndex) return false;
	if (m_nConditionOffset != p_Other.m_nConditionOffset) return false;
	if (m_bResult != p_Other.m_bResult) return false;

	return true;
}

ZHMTypeInfo ZResourceID::TypeInfo = ZHMTypeInfo("ZResourceID", sizeof(ZResourceID), alignof(ZResourceID), ZResourceID::WriteJson, ZResourceID::WriteSimpleJson, ZResourceID::FromSimpleJson, ZResourceID::Serialize, ZResourceID::Equals);

void ZResourceID::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_uri") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_uri);
	p_Stream << "}";

	p_Stream << "}";
}

void ZResourceID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_uri") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uri);

	p_Stream << "}";
}

void ZResourceID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZResourceID s_Object {};

	s_Object.m_uri = std::string_view(p_Document["m_uri"]);

	*reinterpret_cast<ZResourceID*>(p_Target) = s_Object;
}

void ZResourceID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	ZString::Serialize(&s_Object->m_uri, p_Serializer, p_OwnOffset + offsetof(ZResourceID, m_uri));
}

bool ZResourceID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZResourceID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZResourceID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZResourceID::operator==(const ZResourceID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZResourceID>)
		return false;

	if (m_uri != p_Other.m_uri) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeEvaluationLog::TypeInfo = ZHMTypeInfo("SBehaviorTreeEvaluationLog", sizeof(SBehaviorTreeEvaluationLog), alignof(SBehaviorTreeEvaluationLog), SBehaviorTreeEvaluationLog::WriteJson, SBehaviorTreeEvaluationLog::WriteSimpleJson, SBehaviorTreeEvaluationLog::FromSimpleJson, SBehaviorTreeEvaluationLog::Serialize, SBehaviorTreeEvaluationLog::Equals);

void SBehaviorTreeEvaluationLog::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_BehaviorTrees") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZResourceID>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_BehaviorTrees.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_BehaviorTrees[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourceID") << ",\"$val\":";
		ZResourceID::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_BehaviorTrees.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Entries") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBehaviorTreeEvaluationLogEntry>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Entries.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Entries[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBehaviorTreeEvaluationLogEntry") << ",\"$val\":";
		SBehaviorTreeEvaluationLogEntry::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_Entries.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLog::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_BehaviorTrees") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_BehaviorTrees.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_BehaviorTrees[i];
		ZResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_BehaviorTrees.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Entries") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Entries.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Entries[i];
		SBehaviorTreeEvaluationLogEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_Entries.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLog::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEvaluationLog s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_BehaviorTrees"])
	{
		ZResourceID s_ArrayItem0;
		ZResourceID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_BehaviorTrees.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_Entries"])
	{
		SBehaviorTreeEvaluationLogEntry s_ArrayItem0;
		SBehaviorTreeEvaluationLogEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_Entries.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Target) = s_Object;
}

void SBehaviorTreeEvaluationLog::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	TArray<ZResourceID>::Serialize(&s_Object->m_BehaviorTrees, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEvaluationLog, m_BehaviorTrees));
	TArray<SBehaviorTreeEvaluationLogEntry>::Serialize(&s_Object->m_Entries, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEvaluationLog, m_Entries));
}

bool SBehaviorTreeEvaluationLog::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEvaluationLog::operator==(const SBehaviorTreeEvaluationLog& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEvaluationLog>)
		return false;

	if (m_BehaviorTrees != p_Other.m_BehaviorTrees) return false;
	if (m_Entries != p_Other.m_Entries) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeInputPinCondition::TypeInfo = ZHMTypeInfo("SBehaviorTreeInputPinCondition", sizeof(SBehaviorTreeInputPinCondition), alignof(SBehaviorTreeInputPinCondition), SBehaviorTreeInputPinCondition::WriteJson, SBehaviorTreeInputPinCondition::WriteSimpleJson, SBehaviorTreeInputPinCondition::FromSimpleJson, SBehaviorTreeInputPinCondition::Serialize, SBehaviorTreeInputPinCondition::Equals);

void SBehaviorTreeInputPinCondition::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeInputPinCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);

	p_Stream << "}";
}

void SBehaviorTreeInputPinCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeInputPinCondition s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	*reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Target) = s_Object;
}

void SBehaviorTreeInputPinCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInputPinCondition, m_sName));
}

bool SBehaviorTreeInputPinCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeInputPinCondition::operator==(const SBehaviorTreeInputPinCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeInputPinCondition>)
		return false;

	if (m_sName != p_Other.m_sName) return false;

	return true;
}

ZHMTypeInfo SBehaviorTreeInfo::TypeInfo = ZHMTypeInfo("SBehaviorTreeInfo", sizeof(SBehaviorTreeInfo), alignof(SBehaviorTreeInfo), SBehaviorTreeInfo::WriteJson, SBehaviorTreeInfo::WriteSimpleJson, SBehaviorTreeInfo::FromSimpleJson, SBehaviorTreeInfo::Serialize, SBehaviorTreeInfo::Equals);

void SBehaviorTreeInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_references") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBehaviorTreeEntityReference>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_references.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_references[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBehaviorTreeEntityReference") << ",\"$val\":";
		SBehaviorTreeEntityReference::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_references.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_inputPinConditions") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBehaviorTreeInputPinCondition>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_inputPinConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_inputPinConditions[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBehaviorTreeInputPinCondition") << ",\"$val\":";
		SBehaviorTreeInputPinCondition::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_inputPinConditions.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SBehaviorTreeInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_references") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_references.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_references[i];
		SBehaviorTreeEntityReference::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_references.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_inputPinConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_inputPinConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_inputPinConditions[i];
		SBehaviorTreeInputPinCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_inputPinConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBehaviorTreeInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeInfo s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_references"])
	{
		SBehaviorTreeEntityReference s_ArrayItem0;
		SBehaviorTreeEntityReference::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_references.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_inputPinConditions"])
	{
		SBehaviorTreeInputPinCondition s_ArrayItem0;
		SBehaviorTreeInputPinCondition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_inputPinConditions.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SBehaviorTreeInfo*>(p_Target) = s_Object;
}

void SBehaviorTreeInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	TArray<SBehaviorTreeEntityReference>::Serialize(&s_Object->m_references, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInfo, m_references));
	TArray<SBehaviorTreeInputPinCondition>::Serialize(&s_Object->m_inputPinConditions, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInfo, m_inputPinConditions));
}

bool SBehaviorTreeInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeInfo::operator==(const SBehaviorTreeInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeInfo>)
		return false;

	if (m_references != p_Other.m_references) return false;
	if (m_inputPinConditions != p_Other.m_inputPinConditions) return false;

	return true;
}

ZHMTypeInfo SBlobsConfigResourceEntry::TypeInfo = ZHMTypeInfo("SBlobsConfigResourceEntry", sizeof(SBlobsConfigResourceEntry), alignof(SBlobsConfigResourceEntry), SBlobsConfigResourceEntry::WriteJson, SBlobsConfigResourceEntry::WriteSimpleJson, SBlobsConfigResourceEntry::FromSimpleJson, SBlobsConfigResourceEntry::Serialize, SBlobsConfigResourceEntry::Equals);

void SBlobsConfigResourceEntry::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("Id") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->Id);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("BlobRid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->BlobRid, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SBlobsConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("BlobRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->BlobRid, p_Stream);

	p_Stream << "}";
}

void SBlobsConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBlobsConfigResourceEntry s_Object {};

	s_Object.Id = std::string_view(p_Document["Id"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["BlobRid"], &s_Item);
		s_Object.BlobRid = s_Item;
	}

	*reinterpret_cast<SBlobsConfigResourceEntry*>(p_Target) = s_Object;
}

void SBlobsConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Id, p_Serializer, p_OwnOffset + offsetof(SBlobsConfigResourceEntry, Id));
	ZRuntimeResourceID::Serialize(&s_Object->BlobRid, p_Serializer, p_OwnOffset + offsetof(SBlobsConfigResourceEntry, BlobRid));
}

bool SBlobsConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBlobsConfigResourceEntry::operator==(const SBlobsConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBlobsConfigResourceEntry>)
		return false;

	if (Id != p_Other.Id) return false;
	if (BlobRid != p_Other.BlobRid) return false;

	return true;
}

ZHMTypeInfo SBodyContainerSaveData::TypeInfo = ZHMTypeInfo("SBodyContainerSaveData", sizeof(SBodyContainerSaveData), alignof(SBodyContainerSaveData), SBodyContainerSaveData::WriteJson, SBodyContainerSaveData::WriteSimpleJson, SBodyContainerSaveData::FromSimpleJson, SBodyContainerSaveData::Serialize, SBodyContainerSaveData::Equals);

void SBodyContainerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eBCState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5BodyContainer.EBCState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eBCState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5BodyContainer.EBCState", static_cast<int>(s_Object->m_eBCState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLidAutoCloseTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLidAutoCloseTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLidOpenFraction") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLidOpenFraction);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrameUpdateActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrameUpdateActive);
	p_Stream << "}";

	p_Stream << "}";
}

void SBodyContainerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eBCState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5BodyContainer.EBCState", static_cast<int>(s_Object->m_eBCState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLidAutoCloseTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLidAutoCloseTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLidOpenFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLidOpenFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrameUpdateActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrameUpdateActive);

	p_Stream << "}";
}

void SBodyContainerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodyContainerSaveData s_Object {};

	s_Object.m_eBCState = static_cast<ZHM5BodyContainer_EBCState>(ZHMEnums::GetEnumValueByName("ZHM5BodyContainer.EBCState", std::string_view(p_Document["m_eBCState"])));

	s_Object.m_fLidAutoCloseTime = simdjson::from_json_float32(p_Document["m_fLidAutoCloseTime"]);

	s_Object.m_fLidOpenFraction = simdjson::from_json_float32(p_Document["m_fLidOpenFraction"]);

	s_Object.m_bFrameUpdateActive = simdjson::from_json_bool(p_Document["m_bFrameUpdateActive"]);

	*reinterpret_cast<SBodyContainerSaveData*>(p_Target) = s_Object;
}

void SBodyContainerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);

}

bool SBodyContainerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyContainerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyContainerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyContainerSaveData::operator==(const SBodyContainerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyContainerSaveData>)
		return false;

	if (m_eBCState != p_Other.m_eBCState) return false;
	if (m_fLidAutoCloseTime != p_Other.m_fLidAutoCloseTime) return false;
	if (m_fLidOpenFraction != p_Other.m_fLidOpenFraction) return false;
	if (m_bFrameUpdateActive != p_Other.m_bFrameUpdateActive) return false;

	return true;
}

ZHMTypeInfo SBodyContainersSaveData::TypeInfo = ZHMTypeInfo("SBodyContainersSaveData", sizeof(SBodyContainersSaveData), alignof(SBodyContainersSaveData), SBodyContainersSaveData::WriteJson, SBodyContainersSaveData::WriteSimpleJson, SBodyContainersSaveData::FromSimpleJson, SBodyContainersSaveData::Serialize, SBodyContainersSaveData::Equals);

void SBodyContainersSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBodyContainerSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBodyContainerSaveData") << ",\"$val\":";
		SBodyContainerSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SBodyContainersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SBodyContainerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBodyContainersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodyContainersSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SBodyContainerSaveData s_ArrayItem0;
		SBodyContainerSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SBodyContainersSaveData*>(p_Target) = s_Object;
}

void SBodyContainersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SBodyContainersSaveData, m_aEntities));
	TArray<SBodyContainerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SBodyContainersSaveData, m_aData));
}

bool SBodyContainersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyContainersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyContainersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyContainersSaveData::operator==(const SBodyContainersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyContainersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SBodyPartDamageMultipliers::TypeInfo = ZHMTypeInfo("SBodyPartDamageMultipliers", sizeof(SBodyPartDamageMultipliers), alignof(SBodyPartDamageMultipliers), SBodyPartDamageMultipliers::WriteJson, SBodyPartDamageMultipliers::WriteSimpleJson, SBodyPartDamageMultipliers::FromSimpleJson, SBodyPartDamageMultipliers::Serialize, SBodyPartDamageMultipliers::Equals);

void SBodyPartDamageMultipliers::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fHeadDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeadDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fArmDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fArmDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLArmDamageScalar") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLArmDamageScalar);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRArmDamageScalar") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRArmDamageScalar);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHandDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHandDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLHandDamageScalar") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLHandDamageScalar);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRHandDamageScalar") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRHandDamageScalar);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLegDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLegDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLLegDamageScalar") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLLegDamageScalar);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRLegDamageScalar") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRLegDamageScalar);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTorsoDamageMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTorsoDamageMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bApplyLeftRightScalars") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bApplyLeftRightScalars);
	p_Stream << "}";

	p_Stream << "}";
}

void SBodyPartDamageMultipliers::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fHeadDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeadDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fArmDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fArmDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLArmDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLArmDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRArmDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRArmDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHandDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHandDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLHandDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLHandDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRHandDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRHandDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLegDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLegDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLLegDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLLegDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRLegDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRLegDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTorsoDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTorsoDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bApplyLeftRightScalars") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bApplyLeftRightScalars);

	p_Stream << "}";
}

void SBodyPartDamageMultipliers::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodyPartDamageMultipliers s_Object {};

	s_Object.m_fHeadDamageMultiplier = simdjson::from_json_float32(p_Document["m_fHeadDamageMultiplier"]);

	s_Object.m_fFaceDamageMultiplier = simdjson::from_json_float32(p_Document["m_fFaceDamageMultiplier"]);

	s_Object.m_fArmDamageMultiplier = simdjson::from_json_float32(p_Document["m_fArmDamageMultiplier"]);

	s_Object.m_fLArmDamageScalar = simdjson::from_json_float32(p_Document["m_fLArmDamageScalar"]);

	s_Object.m_fRArmDamageScalar = simdjson::from_json_float32(p_Document["m_fRArmDamageScalar"]);

	s_Object.m_fHandDamageMultiplier = simdjson::from_json_float32(p_Document["m_fHandDamageMultiplier"]);

	s_Object.m_fLHandDamageScalar = simdjson::from_json_float32(p_Document["m_fLHandDamageScalar"]);

	s_Object.m_fRHandDamageScalar = simdjson::from_json_float32(p_Document["m_fRHandDamageScalar"]);

	s_Object.m_fLegDamageMultiplier = simdjson::from_json_float32(p_Document["m_fLegDamageMultiplier"]);

	s_Object.m_fLLegDamageScalar = simdjson::from_json_float32(p_Document["m_fLLegDamageScalar"]);

	s_Object.m_fRLegDamageScalar = simdjson::from_json_float32(p_Document["m_fRLegDamageScalar"]);

	s_Object.m_fTorsoDamageMultiplier = simdjson::from_json_float32(p_Document["m_fTorsoDamageMultiplier"]);

	s_Object.m_bApplyLeftRightScalars = simdjson::from_json_bool(p_Document["m_bApplyLeftRightScalars"]);

	*reinterpret_cast<SBodyPartDamageMultipliers*>(p_Target) = s_Object;
}

void SBodyPartDamageMultipliers::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

}

bool SBodyPartDamageMultipliers::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyPartDamageMultipliers::operator==(const SBodyPartDamageMultipliers& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyPartDamageMultipliers>)
		return false;

	if (m_fHeadDamageMultiplier != p_Other.m_fHeadDamageMultiplier) return false;
	if (m_fFaceDamageMultiplier != p_Other.m_fFaceDamageMultiplier) return false;
	if (m_fArmDamageMultiplier != p_Other.m_fArmDamageMultiplier) return false;
	if (m_fLArmDamageScalar != p_Other.m_fLArmDamageScalar) return false;
	if (m_fRArmDamageScalar != p_Other.m_fRArmDamageScalar) return false;
	if (m_fHandDamageMultiplier != p_Other.m_fHandDamageMultiplier) return false;
	if (m_fLHandDamageScalar != p_Other.m_fLHandDamageScalar) return false;
	if (m_fRHandDamageScalar != p_Other.m_fRHandDamageScalar) return false;
	if (m_fLegDamageMultiplier != p_Other.m_fLegDamageMultiplier) return false;
	if (m_fLLegDamageScalar != p_Other.m_fLLegDamageScalar) return false;
	if (m_fRLegDamageScalar != p_Other.m_fRLegDamageScalar) return false;
	if (m_fTorsoDamageMultiplier != p_Other.m_fTorsoDamageMultiplier) return false;
	if (m_bApplyLeftRightScalars != p_Other.m_bApplyLeftRightScalars) return false;

	return true;
}

ZHMTypeInfo SBodybagBoneSaveData::TypeInfo = ZHMTypeInfo("SBodybagBoneSaveData", sizeof(SBodybagBoneSaveData), alignof(SBodybagBoneSaveData), SBodybagBoneSaveData::WriteJson, SBodybagBoneSaveData::WriteSimpleJson, SBodybagBoneSaveData::FromSimpleJson, SBodybagBoneSaveData::Serialize, SBodybagBoneSaveData::Equals);

void SBodybagBoneSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mTranslation, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SBodybagBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SBodybagBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodybagBoneSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Item);
		s_Object.mQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Item);
		s_Object.mTranslation = s_Item;
	}

	*reinterpret_cast<SBodybagBoneSaveData*>(p_Target) = s_Object;
}

void SBodybagBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SBodybagBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SBodybagBoneSaveData, mTranslation));
}

bool SBodybagBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodybagBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodybagBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodybagBoneSaveData::operator==(const SBodybagBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodybagBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

ZHMTypeInfo SBodybagSaveData::TypeInfo = ZHMTypeInfo("SBodybagSaveData", sizeof(SBodybagSaveData), alignof(SBodybagSaveData), SBodybagSaveData::WriteJson, SBodybagSaveData::WriteSimpleJson, SBodybagSaveData::FromSimpleJson, SBodybagSaveData::Serialize, SBodybagSaveData::Equals);

void SBodybagSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vLinkedPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vLinkedPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLinkedQuaternionRotation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vLinkedQuaternionRotation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBodybagBoneSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBodybagBoneSaveData") << ",\"$val\":";
		SBodybagBoneSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneIndices") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneIndices[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aBoneIndices.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDeadActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDeadActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SBodybagSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vLinkedPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLinkedPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLinkedQuaternionRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vLinkedQuaternionRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SBodybagBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBoneIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDeadActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDeadActor);

	p_Stream << "}";
}

void SBodybagSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodybagSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLinkedPosition"], &s_Item);
		s_Object.m_vLinkedPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vLinkedQuaternionRotation"], &s_Item);
		s_Object.m_vLinkedQuaternionRotation = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBones"])
	{
		SBodybagBoneSaveData s_ArrayItem0;
		SBodybagBoneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBones.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBoneIndices"])
	{
		s_Object.m_aBoneIndices.push_back(simdjson::from_json_uint32(s_Item0));
	}

	s_Object.m_rDeadActor = simdjson::from_json_uint32(p_Document["m_rDeadActor"]);

	*reinterpret_cast<SBodybagSaveData*>(p_Target) = s_Object;
}

void SBodybagSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLinkedPosition, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_vLinkedPosition));
	SVector4::Serialize(&s_Object->m_vLinkedQuaternionRotation, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_vLinkedQuaternionRotation));
	TArray<SBodybagBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_aBones));
	TArray<uint32>::Serialize(&s_Object->m_aBoneIndices, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_aBoneIndices));
}

bool SBodybagSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodybagSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodybagSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodybagSaveData::operator==(const SBodybagSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodybagSaveData>)
		return false;

	if (m_vLinkedPosition != p_Other.m_vLinkedPosition) return false;
	if (m_vLinkedQuaternionRotation != p_Other.m_vLinkedQuaternionRotation) return false;
	if (m_aBones != p_Other.m_aBones) return false;
	if (m_aBoneIndices != p_Other.m_aBoneIndices) return false;
	if (m_rDeadActor != p_Other.m_rDeadActor) return false;

	return true;
}

ZHMTypeInfo SBoneAttachSaveData::TypeInfo = ZHMTypeInfo("SBoneAttachSaveData", sizeof(SBoneAttachSaveData), alignof(SBoneAttachSaveData), SBoneAttachSaveData::WriteJson, SBoneAttachSaveData::WriteSimpleJson, SBoneAttachSaveData::FromSimpleJson, SBoneAttachSaveData::Serialize, SBoneAttachSaveData::Equals);

void SBoneAttachSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAttached") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAttached);
	p_Stream << "}";

	p_Stream << "}";
}

void SBoneAttachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAttached);

	p_Stream << "}";
}

void SBoneAttachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBoneAttachSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_bIsAttached = simdjson::from_json_bool(p_Document["m_bIsAttached"]);

	*reinterpret_cast<SBoneAttachSaveData*>(p_Target) = s_Object;
}

void SBoneAttachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);

}

bool SBoneAttachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneAttachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneAttachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneAttachSaveData::operator==(const SBoneAttachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneAttachSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsAttached != p_Other.m_bIsAttached) return false;

	return true;
}

ZHMTypeInfo SBoneScalesList::TypeInfo = ZHMTypeInfo("SBoneScalesList", sizeof(SBoneScalesList), alignof(SBoneScalesList), SBoneScalesList::WriteJson, SBoneScalesList::WriteSimpleJson, SBoneScalesList::FromSimpleJson, SBoneScalesList::Serialize, SBoneScalesList::Equals);

void SBoneScalesList::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aBoneScales") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SVector3>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneScales.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneScales[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
		SVector3::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aBoneScales.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SBoneScalesList::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBoneScales") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneScales.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneScales[i];
		SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBoneScales.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBoneScalesList::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBoneScalesList s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBoneScales"])
	{
		SVector3 s_ArrayItem0;
		SVector3::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBoneScales.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SBoneScalesList*>(p_Target) = s_Object;
}

void SBoneScalesList::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	TArray<SVector3>::Serialize(&s_Object->m_aBoneScales, p_Serializer, p_OwnOffset + offsetof(SBoneScalesList, m_aBoneScales));
}

bool SBoneScalesList::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneScalesList*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneScalesList*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneScalesList::operator==(const SBoneScalesList& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneScalesList>)
		return false;

	if (m_aBoneScales != p_Other.m_aBoneScales) return false;

	return true;
}

ZHMTypeInfo SCamBone::TypeInfo = ZHMTypeInfo("SCamBone", sizeof(SCamBone), alignof(SCamBone), SCamBone::WriteJson, SCamBone::WriteSimpleJson, SCamBone::FromSimpleJson, SCamBone::Serialize, SCamBone::Equals);

void SCamBone::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eBoneId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("BoneId.Enum") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eBoneId)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("BoneId.Enum", static_cast<int>(s_Object->m_eBoneId))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fWeight") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWeight);
	p_Stream << "}";

	p_Stream << "}";
}

void SCamBone::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eBoneId") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("BoneId.Enum", static_cast<int>(s_Object->m_eBoneId)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWeight);

	p_Stream << "}";
}

void SCamBone::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCamBone s_Object {};

	s_Object.m_eBoneId = static_cast<BoneId_Enum>(ZHMEnums::GetEnumValueByName("BoneId.Enum", std::string_view(p_Document["m_eBoneId"])));

	s_Object.m_fWeight = simdjson::from_json_float32(p_Document["m_fWeight"]);

	*reinterpret_cast<SCamBone*>(p_Target) = s_Object;
}

void SCamBone::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);

}

bool SCamBone::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCamBone*>(p_Left);
	auto* s_Right = reinterpret_cast<SCamBone*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCamBone::operator==(const SCamBone& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCamBone>)
		return false;

	if (m_eBoneId != p_Other.m_eBoneId) return false;
	if (m_fWeight != p_Other.m_fWeight) return false;

	return true;
}

ZHMTypeInfo SCautiousBackupGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousBackupGroupSaveData", sizeof(SCautiousBackupGroupSaveData), alignof(SCautiousBackupGroupSaveData), SCautiousBackupGroupSaveData::WriteJson, SCautiousBackupGroupSaveData::WriteSimpleJson, SCautiousBackupGroupSaveData::FromSimpleJson, SCautiousBackupGroupSaveData::Serialize, SCautiousBackupGroupSaveData::Equals);

void SCautiousBackupGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eGroupState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZCautiousBackupGroup.EGroupState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eGroupState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousBackupGroup.EGroupState", static_cast<int>(s_Object->m_eGroupState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetNodeIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetNodeIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pCandidate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCandidate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aReservedApproachNodeIndices") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aReservedApproachNodeIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aReservedApproachNodeIndices[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aReservedApproachNodeIndices.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStart, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SCautiousBackupGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eGroupState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousBackupGroup.EGroupState", static_cast<int>(s_Object->m_eGroupState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aReservedApproachNodeIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aReservedApproachNodeIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aReservedApproachNodeIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aReservedApproachNodeIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);

	p_Stream << "}";
}

void SCautiousBackupGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousBackupGroupSaveData s_Object {};

	s_Object.m_eGroupState = static_cast<ZCautiousBackupGroup_EGroupState>(ZHMEnums::GetEnumValueByName("ZCautiousBackupGroup.EGroupState", std::string_view(p_Document["m_eGroupState"])));

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_nTargetNodeIndex = simdjson::from_json_uint16(p_Document["m_nTargetNodeIndex"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCandidates"])
	{
		s_Object.m_aCandidates.push_back(simdjson::from_json_uint32(s_Item0));
	}

	s_Object.m_pCandidate = simdjson::from_json_uint32(p_Document["m_pCandidate"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aReservedApproachNodeIndices"])
	{
		s_Object.m_aReservedApproachNodeIndices.push_back(simdjson::from_json_uint16(s_Item0));
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Item);
		s_Object.m_tStart = s_Item;
	}

	*reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Target) = s_Object;
}

void SCautiousBackupGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_aCandidates));
	TArray<uint16>::Serialize(&s_Object->m_aReservedApproachNodeIndices, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_aReservedApproachNodeIndices));
	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_tStart));
}

bool SCautiousBackupGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousBackupGroupSaveData::operator==(const SCautiousBackupGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousBackupGroupSaveData>)
		return false;

	if (m_eGroupState != p_Other.m_eGroupState) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_nTargetNodeIndex != p_Other.m_nTargetNodeIndex) return false;
	if (m_aCandidates != p_Other.m_aCandidates) return false;
	if (m_pCandidate != p_Other.m_pCandidate) return false;
	if (m_aReservedApproachNodeIndices != p_Other.m_aReservedApproachNodeIndices) return false;
	if (m_tStart != p_Other.m_tStart) return false;

	return true;
}

ZHMTypeInfo SCautiousHuntSaveData::TypeInfo = ZHMTypeInfo("SCautiousHuntSaveData", sizeof(SCautiousHuntSaveData), alignof(SCautiousHuntSaveData), SCautiousHuntSaveData::WriteJson, SCautiousHuntSaveData::WriteSimpleJson, SCautiousHuntSaveData::FromSimpleJson, SCautiousHuntSaveData::Serialize, SCautiousHuntSaveData::Equals);

void SCautiousHuntSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAnnounceHuntCoolDown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tAnnounceHuntCoolDown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAnnouncedHunt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tAnnouncedHunt, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tShareHuntTargetCoolDown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tShareHuntTargetCoolDown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnounceHunt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnounceHunt);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnouncedHunt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnouncedHunt);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayAnnouncementDialog") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayAnnouncementDialog);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHuntTargetKnownKiller") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHuntTargetKnownKiller);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSharedHuntTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSharedHuntTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetBlamed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetBlamed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRuleActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRuleActive);
	p_Stream << "}";

	p_Stream << "}";
}

void SCautiousHuntSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAnnounceHuntCoolDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAnnounceHuntCoolDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAnnouncedHunt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAnnouncedHunt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tShareHuntTargetCoolDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tShareHuntTargetCoolDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnounceHunt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnounceHunt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnouncedHunt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnouncedHunt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayAnnouncementDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayAnnouncementDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHuntTargetKnownKiller") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHuntTargetKnownKiller);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSharedHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSharedHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetBlamed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetBlamed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRuleActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRuleActive);

	p_Stream << "}";
}

void SCautiousHuntSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousHuntSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tAnnounceHuntCoolDown"], &s_Item);
		s_Object.m_tAnnounceHuntCoolDown = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tAnnouncedHunt"], &s_Item);
		s_Object.m_tAnnouncedHunt = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tShareHuntTargetCoolDown"], &s_Item);
		s_Object.m_tShareHuntTargetCoolDown = s_Item;
	}

	s_Object.m_bAnnounceHunt = simdjson::from_json_bool(p_Document["m_bAnnounceHunt"]);

	s_Object.m_bAnnouncedHunt = simdjson::from_json_bool(p_Document["m_bAnnouncedHunt"]);

	s_Object.m_bPlayAnnouncementDialog = simdjson::from_json_bool(p_Document["m_bPlayAnnouncementDialog"]);

	s_Object.m_bHuntTargetKnownKiller = simdjson::from_json_bool(p_Document["m_bHuntTargetKnownKiller"]);

	s_Object.m_bSharedHuntTarget = simdjson::from_json_bool(p_Document["m_bSharedHuntTarget"]);

	s_Object.m_bTargetBlamed = simdjson::from_json_bool(p_Document["m_bTargetBlamed"]);

	s_Object.m_bRuleActive = simdjson::from_json_bool(p_Document["m_bRuleActive"]);

	*reinterpret_cast<SCautiousHuntSaveData*>(p_Target) = s_Object;
}

void SCautiousHuntSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tAnnounceHuntCoolDown, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tAnnounceHuntCoolDown));
	ZGameTime::Serialize(&s_Object->m_tAnnouncedHunt, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tAnnouncedHunt));
	ZGameTime::Serialize(&s_Object->m_tShareHuntTargetCoolDown, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tShareHuntTargetCoolDown));
}

bool SCautiousHuntSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousHuntSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousHuntSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousHuntSaveData::operator==(const SCautiousHuntSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousHuntSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tAnnounceHuntCoolDown != p_Other.m_tAnnounceHuntCoolDown) return false;
	if (m_tAnnouncedHunt != p_Other.m_tAnnouncedHunt) return false;
	if (m_tShareHuntTargetCoolDown != p_Other.m_tShareHuntTargetCoolDown) return false;
	if (m_bAnnounceHunt != p_Other.m_bAnnounceHunt) return false;
	if (m_bAnnouncedHunt != p_Other.m_bAnnouncedHunt) return false;
	if (m_bPlayAnnouncementDialog != p_Other.m_bPlayAnnouncementDialog) return false;
	if (m_bHuntTargetKnownKiller != p_Other.m_bHuntTargetKnownKiller) return false;
	if (m_bSharedHuntTarget != p_Other.m_bSharedHuntTarget) return false;
	if (m_bTargetBlamed != p_Other.m_bTargetBlamed) return false;
	if (m_bRuleActive != p_Other.m_bRuleActive) return false;

	return true;
}

ZHMTypeInfo SExactCompressedGridFloatField::TypeInfo = ZHMTypeInfo("SExactCompressedGridFloatField", sizeof(SExactCompressedGridFloatField), alignof(SExactCompressedGridFloatField), SExactCompressedGridFloatField::WriteJson, SExactCompressedGridFloatField::WriteSimpleJson, SExactCompressedGridFloatField::FromSimpleJson, SExactCompressedGridFloatField::Serialize, SExactCompressedGridFloatField::Equals);

void SExactCompressedGridFloatField::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFieldSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFieldSize);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCRC") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCRC);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SExactCompressedGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFieldSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFieldSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCRC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCRC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SExactCompressedGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExactCompressedGridFloatField s_Object {};

	s_Object.m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	s_Object.m_nFieldSize = simdjson::from_json_uint32(p_Document["m_nFieldSize"]);

	s_Object.m_nGridCRC = simdjson::from_json_uint32(p_Document["m_nGridCRC"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aIndices"])
	{
		s_Object.m_aIndices.push_back(simdjson::from_json_uint16(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aValues"])
	{
		s_Object.m_aValues.push_back(simdjson::from_json_float32(s_Item0));
	}

	*reinterpret_cast<SExactCompressedGridFloatField*>(p_Target) = s_Object;
}

void SExactCompressedGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_aIndices, p_Serializer, p_OwnOffset + offsetof(SExactCompressedGridFloatField, m_aIndices));
	TArray<float32>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SExactCompressedGridFloatField, m_aValues));
}

bool SExactCompressedGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExactCompressedGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<SExactCompressedGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExactCompressedGridFloatField::operator==(const SExactCompressedGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExactCompressedGridFloatField>)
		return false;

	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_nFieldSize != p_Other.m_nFieldSize) return false;
	if (m_nGridCRC != p_Other.m_nGridCRC) return false;
	if (m_aIndices != p_Other.m_aIndices) return false;
	if (m_aValues != p_Other.m_aValues) return false;

	return true;
}

ZHMTypeInfo SCautiousInvestigateGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousInvestigateGroupSaveData", sizeof(SCautiousInvestigateGroupSaveData), alignof(SCautiousInvestigateGroupSaveData), SCautiousInvestigateGroupSaveData::WriteJson, SCautiousInvestigateGroupSaveData::WriteSimpleJson, SCautiousInvestigateGroupSaveData::FromSimpleJson, SCautiousInvestigateGroupSaveData::Serialize, SCautiousInvestigateGroupSaveData::Equals);

void SCautiousInvestigateGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_tGroupStarted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tGroupStarted, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_type)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLeaderApproachNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLeaderApproachNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAssistantApproachNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAssistantApproachNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eApproachOrderState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZCautiousInvestigateGroup.EApproachOrderState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eApproachOrderState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousInvestigateGroup.EApproachOrderState", static_cast<int>(s_Object->m_eApproachOrderState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmAssistantState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmAssistantState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUsingRecurringDialog") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUsingRecurringDialog);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStartedInvestigateDialog") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedInvestigateDialog);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDelayInvestigateDialog") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDelayInvestigateDialog);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReservedOccupancy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReservedOccupancy);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSilentInvestigation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSilentInvestigation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInvestigateDeadBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInvestigateDeadBody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMultipleBodies") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMultipleBodies);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCheckSuspects") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCheckSuspects);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_investigateArea") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_investigateArea, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetDistanceField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SExactCompressedGridFloatField") << ",\"$val\":";
	SExactCompressedGridFloatField::WriteJson(&s_Object->m_targetDistanceField, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetLOSField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SExactCompressedGridFloatField") << ",\"$val\":";
	SExactCompressedGridFloatField::WriteJson(&s_Object->m_targetLOSField, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidTargetDistanceField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidTargetDistanceField);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidTargetLOSField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidTargetLOSField);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceAcknowledge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceAcknowledge);
	p_Stream << "}";

	p_Stream << "}";
}

void SCautiousInvestigateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tGroupStarted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGroupStarted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLeaderApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLeaderApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAssistantApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAssistantApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eApproachOrderState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousInvestigateGroup.EApproachOrderState", static_cast<int>(s_Object->m_eApproachOrderState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmAssistantState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmAssistantState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUsingRecurringDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUsingRecurringDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStartedInvestigateDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedInvestigateDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDelayInvestigateDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDelayInvestigateDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReservedOccupancy") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReservedOccupancy);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSilentInvestigation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSilentInvestigation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInvestigateDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInvestigateDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMultipleBodies") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMultipleBodies);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCheckSuspects") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCheckSuspects);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_investigateArea") << ":";
	float4::WriteSimpleJson(&s_Object->m_investigateArea, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetDistanceField") << ":";
	SExactCompressedGridFloatField::WriteSimpleJson(&s_Object->m_targetDistanceField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetLOSField") << ":";
	SExactCompressedGridFloatField::WriteSimpleJson(&s_Object->m_targetLOSField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidTargetDistanceField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidTargetDistanceField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidTargetLOSField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidTargetLOSField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceAcknowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceAcknowledge);

	p_Stream << "}";
}

void SCautiousInvestigateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousInvestigateGroupSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tGroupStarted"], &s_Item);
		s_Object.m_tGroupStarted = s_Item;
	}

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object.m_nLeaderApproachNode = simdjson::from_json_int32(p_Document["m_nLeaderApproachNode"]);

	s_Object.m_nAssistantApproachNode = simdjson::from_json_int32(p_Document["m_nAssistantApproachNode"]);

	s_Object.m_eApproachOrderState = static_cast<ZCautiousInvestigateGroup_EApproachOrderState>(ZHMEnums::GetEnumValueByName("ZCautiousInvestigateGroup.EApproachOrderState", std::string_view(p_Document["m_eApproachOrderState"])));

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmAssistantState"], &s_Item);
		s_Object.m_fsmAssistantState = s_Item;
	}

	s_Object.m_bUsingRecurringDialog = simdjson::from_json_bool(p_Document["m_bUsingRecurringDialog"]);

	s_Object.m_bStartedInvestigateDialog = simdjson::from_json_bool(p_Document["m_bStartedInvestigateDialog"]);

	s_Object.m_bDelayInvestigateDialog = simdjson::from_json_bool(p_Document["m_bDelayInvestigateDialog"]);

	s_Object.m_bReservedOccupancy = simdjson::from_json_bool(p_Document["m_bReservedOccupancy"]);

	s_Object.m_bSilentInvestigation = simdjson::from_json_bool(p_Document["m_bSilentInvestigation"]);

	s_Object.m_bInvestigateDeadBody = simdjson::from_json_bool(p_Document["m_bInvestigateDeadBody"]);

	s_Object.m_bMultipleBodies = simdjson::from_json_bool(p_Document["m_bMultipleBodies"]);

	s_Object.m_bCheckSuspects = simdjson::from_json_bool(p_Document["m_bCheckSuspects"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_investigateArea"], &s_Item);
		s_Object.m_investigateArea = s_Item;
	}

	{
		SExactCompressedGridFloatField s_Item {};
		SExactCompressedGridFloatField::FromSimpleJson(p_Document["m_targetDistanceField"], &s_Item);
		s_Object.m_targetDistanceField = s_Item;
	}

	{
		SExactCompressedGridFloatField s_Item {};
		SExactCompressedGridFloatField::FromSimpleJson(p_Document["m_targetLOSField"], &s_Item);
		s_Object.m_targetLOSField = s_Item;
	}

	s_Object.m_bValidTargetDistanceField = simdjson::from_json_bool(p_Document["m_bValidTargetDistanceField"]);

	s_Object.m_bValidTargetLOSField = simdjson::from_json_bool(p_Document["m_bValidTargetLOSField"]);

	s_Object.m_bForceAcknowledge = simdjson::from_json_bool(p_Document["m_bForceAcknowledge"]);

	*reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Target) = s_Object;
}

void SCautiousInvestigateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGroupStarted, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_tGroupStarted));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_fsmState));
	SFSMSaveData::Serialize(&s_Object->m_fsmAssistantState, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_fsmAssistantState));
	float4::Serialize(&s_Object->m_investigateArea, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_investigateArea));
	SExactCompressedGridFloatField::Serialize(&s_Object->m_targetDistanceField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_targetDistanceField));
	SExactCompressedGridFloatField::Serialize(&s_Object->m_targetLOSField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_targetLOSField));
}

bool SCautiousInvestigateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousInvestigateGroupSaveData::operator==(const SCautiousInvestigateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousInvestigateGroupSaveData>)
		return false;

	if (m_tGroupStarted != p_Other.m_tGroupStarted) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_nLeaderApproachNode != p_Other.m_nLeaderApproachNode) return false;
	if (m_nAssistantApproachNode != p_Other.m_nAssistantApproachNode) return false;
	if (m_eApproachOrderState != p_Other.m_eApproachOrderState) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_fsmAssistantState != p_Other.m_fsmAssistantState) return false;
	if (m_bUsingRecurringDialog != p_Other.m_bUsingRecurringDialog) return false;
	if (m_bStartedInvestigateDialog != p_Other.m_bStartedInvestigateDialog) return false;
	if (m_bDelayInvestigateDialog != p_Other.m_bDelayInvestigateDialog) return false;
	if (m_bReservedOccupancy != p_Other.m_bReservedOccupancy) return false;
	if (m_bSilentInvestigation != p_Other.m_bSilentInvestigation) return false;
	if (m_bInvestigateDeadBody != p_Other.m_bInvestigateDeadBody) return false;
	if (m_bMultipleBodies != p_Other.m_bMultipleBodies) return false;
	if (m_bCheckSuspects != p_Other.m_bCheckSuspects) return false;
	if (m_investigateArea != p_Other.m_investigateArea) return false;
	if (m_targetDistanceField != p_Other.m_targetDistanceField) return false;
	if (m_targetLOSField != p_Other.m_targetLOSField) return false;
	if (m_bValidTargetDistanceField != p_Other.m_bValidTargetDistanceField) return false;
	if (m_bValidTargetLOSField != p_Other.m_bValidTargetLOSField) return false;
	if (m_bForceAcknowledge != p_Other.m_bForceAcknowledge) return false;

	return true;
}

ZHMTypeInfo SCompressedGridFloatField::TypeInfo = ZHMTypeInfo("SCompressedGridFloatField", sizeof(SCompressedGridFloatField), alignof(SCompressedGridFloatField), SCompressedGridFloatField::WriteJson, SCompressedGridFloatField::WriteSimpleJson, SCompressedGridFloatField::FromSimpleJson, SCompressedGridFloatField::Serialize, SCompressedGridFloatField::Equals);

void SCompressedGridFloatField::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsSparse") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSparse);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFieldSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFieldSize);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCRC") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCRC);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCompressedGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsSparse") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSparse);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFieldSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFieldSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCRC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCRC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCompressedGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCompressedGridFloatField s_Object {};

	s_Object.m_bIsSparse = simdjson::from_json_bool(p_Document["m_bIsSparse"]);

	s_Object.m_nFieldSize = simdjson::from_json_uint32(p_Document["m_nFieldSize"]);

	s_Object.m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	s_Object.m_nGridCRC = simdjson::from_json_uint32(p_Document["m_nGridCRC"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aIndices"])
	{
		s_Object.m_aIndices.push_back(simdjson::from_json_uint16(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aValues"])
	{
		s_Object.m_aValues.push_back(simdjson::from_json_uint8(s_Item0));
	}

	*reinterpret_cast<SCompressedGridFloatField*>(p_Target) = s_Object;
}

void SCompressedGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_aIndices, p_Serializer, p_OwnOffset + offsetof(SCompressedGridFloatField, m_aIndices));
	TArray<uint8>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SCompressedGridFloatField, m_aValues));
}

bool SCompressedGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCompressedGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<SCompressedGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCompressedGridFloatField::operator==(const SCompressedGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCompressedGridFloatField>)
		return false;

	if (m_bIsSparse != p_Other.m_bIsSparse) return false;
	if (m_nFieldSize != p_Other.m_nFieldSize) return false;
	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_nGridCRC != p_Other.m_nGridCRC) return false;
	if (m_aIndices != p_Other.m_aIndices) return false;
	if (m_aValues != p_Other.m_aValues) return false;

	return true;
}

ZHMTypeInfo SDisturbanceSaveData::TypeInfo = ZHMTypeInfo("SDisturbanceSaveData", sizeof(SDisturbanceSaveData), alignof(SDisturbanceSaveData), SDisturbanceSaveData::WriteJson, SDisturbanceSaveData::WriteSimpleJson, SDisturbanceSaveData::FromSimpleJson, SDisturbanceSaveData::Serialize, SDisturbanceSaveData::Equals);

void SDisturbanceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_object") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_object);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_type)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ECautiousDisturbanceState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_state)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECautiousDisturbanceState", static_cast<int>(s_Object->m_state))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_started") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_started, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockOnHitmanPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockOnHitmanPosition);
	p_Stream << "}";

	p_Stream << "}";
}

void SDisturbanceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_object") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_object);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECautiousDisturbanceState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_started") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_started, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockOnHitmanPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockOnHitmanPosition);

	p_Stream << "}";
}

void SDisturbanceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDisturbanceSaveData s_Object {};

	s_Object.m_object = simdjson::from_json_int32(p_Document["m_object"]);

	s_Object.m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object.m_state = static_cast<ECautiousDisturbanceState>(ZHMEnums::GetEnumValueByName("ECautiousDisturbanceState", std::string_view(p_Document["m_state"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_started"], &s_Item);
		s_Object.m_started = s_Item;
	}

	s_Object.m_pInvestigateGroup = simdjson::from_json_int32(p_Document["m_pInvestigateGroup"]);

	s_Object.m_bLockOnHitmanPosition = simdjson::from_json_bool(p_Document["m_bLockOnHitmanPosition"]);

	*reinterpret_cast<SDisturbanceSaveData*>(p_Target) = s_Object;
}

void SDisturbanceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_started, p_Serializer, p_OwnOffset + offsetof(SDisturbanceSaveData, m_started));
}

bool SDisturbanceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDisturbanceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDisturbanceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDisturbanceSaveData::operator==(const SDisturbanceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDisturbanceSaveData>)
		return false;

	if (m_object != p_Other.m_object) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_state != p_Other.m_state) return false;
	if (m_started != p_Other.m_started) return false;
	if (m_pInvestigateGroup != p_Other.m_pInvestigateGroup) return false;
	if (m_bLockOnHitmanPosition != p_Other.m_bLockOnHitmanPosition) return false;

	return true;
}

ZHMTypeInfo ZInvestigateCautiousSituation_SStateData::TypeInfo = ZHMTypeInfo("ZInvestigateCautiousSituation.SStateData", sizeof(ZInvestigateCautiousSituation_SStateData), alignof(ZInvestigateCautiousSituation_SStateData), ZInvestigateCautiousSituation_SStateData::WriteJson, ZInvestigateCautiousSituation_SStateData::WriteSimpleJson, ZInvestigateCautiousSituation_SStateData::FromSimpleJson, ZInvestigateCautiousSituation_SStateData::Serialize, ZInvestigateCautiousSituation_SStateData::Equals);

void ZInvestigateCautiousSituation_SStateData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInvestigateCautiousSituation.ESituationState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_state)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateCautiousSituation.ESituationState", static_cast<int>(s_Object->m_state))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eBystanderState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInvestigateCautiousSituation.EBystanderState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eBystanderState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateCautiousSituation.EBystanderState", static_cast<int>(s_Object->m_eBystanderState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInvestigationEnded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastInvestigationEnded, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastApproachOrder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastApproachOrder, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastBackupGroupEnded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastBackupGroupEnded, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastHunt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastHunt, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHuntTargetLastUpdate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tHuntTargetLastUpdate, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNewHuntTargetTimer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tNewHuntTargetTimer, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCombatAge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCombatAge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownZoneDisturbanceAdded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownZoneDisturbanceAdded);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownFalseAlarm") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownFalseAlarm);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownGracePeriod") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownGracePeriod);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHMInGuardDisguise") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHMInGuardDisguise);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrisked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrisked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnouncedFrisk") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnouncedFrisk);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReasonToFrisk") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReasonToFrisk);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneHasBeenInCombat") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneHasBeenInCombat);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInvestigationGroupActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInvestigationGroupActive);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandDownGuards") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandDownGuards);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStandDownDelay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStandDownDelay, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMostSevereDisturbance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eMostSevereDisturbance)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eMostSevereDisturbance))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDiscoveredDeadBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDiscoveredDeadBody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDiscoveredPacifiedBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDiscoveredPacifiedBody);
	p_Stream << "}";

	p_Stream << "}";
}

void ZInvestigateCautiousSituation_SStateData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateCautiousSituation.ESituationState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eBystanderState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateCautiousSituation.EBystanderState", static_cast<int>(s_Object->m_eBystanderState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInvestigationEnded") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInvestigationEnded, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastApproachOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastApproachOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastBackupGroupEnded") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastBackupGroupEnded, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastHunt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastHunt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHuntTargetLastUpdate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tHuntTargetLastUpdate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNewHuntTargetTimer") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNewHuntTargetTimer, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCombatAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCombatAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownZoneDisturbanceAdded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownZoneDisturbanceAdded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownFalseAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownFalseAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownGracePeriod") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownGracePeriod);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHMInGuardDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHMInGuardDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrisked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrisked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnouncedFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnouncedFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReasonToFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReasonToFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneHasBeenInCombat") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneHasBeenInCombat);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInvestigationGroupActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInvestigationGroupActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandDownGuards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandDownGuards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStandDownDelay") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStandDownDelay, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMostSevereDisturbance") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eMostSevereDisturbance)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDiscoveredDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDiscoveredDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDiscoveredPacifiedBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDiscoveredPacifiedBody);

	p_Stream << "}";
}

void ZInvestigateCautiousSituation_SStateData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInvestigateCautiousSituation_SStateData s_Object {};

	s_Object.m_state = static_cast<ZInvestigateCautiousSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZInvestigateCautiousSituation.ESituationState", std::string_view(p_Document["m_state"])));

	s_Object.m_eBystanderState = static_cast<ZInvestigateCautiousSituation_EBystanderState>(ZHMEnums::GetEnumValueByName("ZInvestigateCautiousSituation.EBystanderState", std::string_view(p_Document["m_eBystanderState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastInvestigationEnded"], &s_Item);
		s_Object.m_tLastInvestigationEnded = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastApproachOrder"], &s_Item);
		s_Object.m_tLastApproachOrder = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastBackupGroupEnded"], &s_Item);
		s_Object.m_tLastBackupGroupEnded = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastHunt"], &s_Item);
		s_Object.m_tLastHunt = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tHuntTargetLastUpdate"], &s_Item);
		s_Object.m_tHuntTargetLastUpdate = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tNewHuntTargetTimer"], &s_Item);
		s_Object.m_tNewHuntTargetTimer = s_Item;
	}

	s_Object.m_fCombatAge = simdjson::from_json_float32(p_Document["m_fCombatAge"]);

	s_Object.m_bLockdownZoneDisturbanceAdded = simdjson::from_json_bool(p_Document["m_bLockdownZoneDisturbanceAdded"]);

	s_Object.m_bLockdownSituation = simdjson::from_json_bool(p_Document["m_bLockdownSituation"]);

	s_Object.m_bLockdownFalseAlarm = simdjson::from_json_bool(p_Document["m_bLockdownFalseAlarm"]);

	s_Object.m_bLockdownGracePeriod = simdjson::from_json_bool(p_Document["m_bLockdownGracePeriod"]);

	s_Object.m_bHMInGuardDisguise = simdjson::from_json_bool(p_Document["m_bHMInGuardDisguise"]);

	s_Object.m_bFrisked = simdjson::from_json_bool(p_Document["m_bFrisked"]);

	s_Object.m_bAnnouncedFrisk = simdjson::from_json_bool(p_Document["m_bAnnouncedFrisk"]);

	s_Object.m_bReasonToFrisk = simdjson::from_json_bool(p_Document["m_bReasonToFrisk"]);

	s_Object.m_bSomeoneHasBeenInCombat = simdjson::from_json_bool(p_Document["m_bSomeoneHasBeenInCombat"]);

	s_Object.m_bInvestigationGroupActive = simdjson::from_json_bool(p_Document["m_bInvestigationGroupActive"]);

	s_Object.m_bStandDownGuards = simdjson::from_json_bool(p_Document["m_bStandDownGuards"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStandDownDelay"], &s_Item);
		s_Object.m_tStandDownDelay = s_Item;
	}

	s_Object.m_eMostSevereDisturbance = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eMostSevereDisturbance"])));

	s_Object.m_bDiscoveredDeadBody = simdjson::from_json_bool(p_Document["m_bDiscoveredDeadBody"]);

	s_Object.m_bDiscoveredPacifiedBody = simdjson::from_json_bool(p_Document["m_bDiscoveredPacifiedBody"]);

	*reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Target) = s_Object;
}

void ZInvestigateCautiousSituation_SStateData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastInvestigationEnded, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastInvestigationEnded));
	ZGameTime::Serialize(&s_Object->m_tLastApproachOrder, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastApproachOrder));
	ZGameTime::Serialize(&s_Object->m_tLastBackupGroupEnded, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastBackupGroupEnded));
	ZGameTime::Serialize(&s_Object->m_tLastHunt, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastHunt));
	ZGameTime::Serialize(&s_Object->m_tHuntTargetLastUpdate, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tHuntTargetLastUpdate));
	ZGameTime::Serialize(&s_Object->m_tNewHuntTargetTimer, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tNewHuntTargetTimer));
	ZGameTime::Serialize(&s_Object->m_tStandDownDelay, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tStandDownDelay));
}

bool ZInvestigateCautiousSituation_SStateData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateCautiousSituation_SStateData::operator==(const ZInvestigateCautiousSituation_SStateData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateCautiousSituation_SStateData>)
		return false;

	if (m_state != p_Other.m_state) return false;
	if (m_eBystanderState != p_Other.m_eBystanderState) return false;
	if (m_tLastInvestigationEnded != p_Other.m_tLastInvestigationEnded) return false;
	if (m_tLastApproachOrder != p_Other.m_tLastApproachOrder) return false;
	if (m_tLastBackupGroupEnded != p_Other.m_tLastBackupGroupEnded) return false;
	if (m_tLastHunt != p_Other.m_tLastHunt) return false;
	if (m_tHuntTargetLastUpdate != p_Other.m_tHuntTargetLastUpdate) return false;
	if (m_tNewHuntTargetTimer != p_Other.m_tNewHuntTargetTimer) return false;
	if (m_fCombatAge != p_Other.m_fCombatAge) return false;
	if (m_bLockdownZoneDisturbanceAdded != p_Other.m_bLockdownZoneDisturbanceAdded) return false;
	if (m_bLockdownSituation != p_Other.m_bLockdownSituation) return false;
	if (m_bLockdownFalseAlarm != p_Other.m_bLockdownFalseAlarm) return false;
	if (m_bLockdownGracePeriod != p_Other.m_bLockdownGracePeriod) return false;
	if (m_bHMInGuardDisguise != p_Other.m_bHMInGuardDisguise) return false;
	if (m_bFrisked != p_Other.m_bFrisked) return false;
	if (m_bAnnouncedFrisk != p_Other.m_bAnnouncedFrisk) return false;
	if (m_bReasonToFrisk != p_Other.m_bReasonToFrisk) return false;
	if (m_bSomeoneHasBeenInCombat != p_Other.m_bSomeoneHasBeenInCombat) return false;
	if (m_bInvestigationGroupActive != p_Other.m_bInvestigationGroupActive) return false;
	if (m_bStandDownGuards != p_Other.m_bStandDownGuards) return false;
	if (m_tStandDownDelay != p_Other.m_tStandDownDelay) return false;
	if (m_eMostSevereDisturbance != p_Other.m_eMostSevereDisturbance) return false;
	if (m_bDiscoveredDeadBody != p_Other.m_bDiscoveredDeadBody) return false;
	if (m_bDiscoveredPacifiedBody != p_Other.m_bDiscoveredPacifiedBody) return false;

	return true;
}

ZHMTypeInfo SCautiousInvestigateSituationSaveData::TypeInfo = ZHMTypeInfo("SCautiousInvestigateSituationSaveData", sizeof(SCautiousInvestigateSituationSaveData), alignof(SCautiousInvestigateSituationSaveData), SCautiousInvestigateSituationSaveData::WriteJson, SCautiousInvestigateSituationSaveData::WriteSimpleJson, SCautiousInvestigateSituationSaveData::FromSimpleJson, SCautiousInvestigateSituationSaveData::Serialize, SCautiousInvestigateSituationSaveData::Equals);

void SCautiousInvestigateSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_StateData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInvestigateCautiousSituation.SStateData") << ",\"$val\":";
	ZInvestigateCautiousSituation_SStateData::WriteJson(&s_Object->m_StateData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pBackupGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pBackupGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rTriggerAlarmGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTriggerAlarmGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_cautiousVIPGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cautiousVIPGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cautiousVIPGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_cautiousVIPGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_friskGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_friskGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_friskGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_friskGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tFriskCooldown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tFriskCooldown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tFriskGroupEnd") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tFriskGroupEnd, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tRecoverUnconsciousGroupEnd") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tRecoverUnconsciousGroupEnd, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nHuntTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHuntTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGuardMembers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGuardMembers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGuardMembers[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aGuardMembers.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_disturbances") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SDisturbanceSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_disturbances.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_disturbances[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SDisturbanceSaveData") << ",\"$val\":";
		SDisturbanceSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_disturbances.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidDisturbanceField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidDisturbanceField);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_disturbanceField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SCompressedGridFloatField") << ",\"$val\":";
	SCompressedGridFloatField::WriteJson(&s_Object->m_disturbanceField, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_recoverUnconsciousGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_recoverUnconsciousGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspendSearchOnInitialGetHelpGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspendSearchOnInitialGetHelpGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastArrestReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_lastArrestReason)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastArrestReason))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastStaticArrestReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_lastStaticArrestReason)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastStaticArrestReason))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastStaticCombatReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_lastStaticCombatReason)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastStaticCombatReason))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnyGunshotDisturbance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnyGunshotDisturbance);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadBodyMassiveReported") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadBodyMassiveReported);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadBodiesDiscovered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadBodiesDiscovered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadCrowdBodiesDiscovered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadCrowdBodiesDiscovered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicEnforceEventsForSearchers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<EAISharedEventType>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicEnforceEventsForSearchers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicEnforceEventsForSearchers[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("EAISharedEventType") << ",\"$val\":";
		p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Item0)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Item0))) << "}";
		p_Stream << "}";

		if (i < s_Object->m_aDynamicEnforceEventsForSearchers.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastIdleStanddown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastIdleStanddown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_cautiousHuntData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SCautiousHuntSaveData") << ",\"$val\":";
	SCautiousHuntSaveData::WriteJson(&s_Object->m_cautiousHuntData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SCautiousInvestigateSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_StateData") << ":";
	ZInvestigateCautiousSituation_SStateData::WriteSimpleJson(&s_Object->m_StateData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pBackupGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pBackupGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rTriggerAlarmGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTriggerAlarmGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_cautiousVIPGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cautiousVIPGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cautiousVIPGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_cautiousVIPGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_friskGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_friskGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_friskGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_friskGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tFriskCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tFriskCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tFriskGroupEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tFriskGroupEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tRecoverUnconsciousGroupEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tRecoverUnconsciousGroupEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGuardMembers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGuardMembers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGuardMembers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aGuardMembers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_disturbances") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_disturbances.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_disturbances[i];
		SDisturbanceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_disturbances.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidDisturbanceField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidDisturbanceField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_disturbanceField") << ":";
	SCompressedGridFloatField::WriteSimpleJson(&s_Object->m_disturbanceField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_recoverUnconsciousGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_recoverUnconsciousGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspendSearchOnInitialGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspendSearchOnInitialGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastStaticArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastStaticArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastStaticCombatReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastStaticCombatReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnyGunshotDisturbance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnyGunshotDisturbance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadBodyMassiveReported") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadBodyMassiveReported);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadBodiesDiscovered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadBodiesDiscovered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadCrowdBodiesDiscovered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadCrowdBodiesDiscovered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicEnforceEventsForSearchers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicEnforceEventsForSearchers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicEnforceEventsForSearchers[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aDynamicEnforceEventsForSearchers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastIdleStanddown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastIdleStanddown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_cautiousHuntData") << ":";
	SCautiousHuntSaveData::WriteSimpleJson(&s_Object->m_cautiousHuntData, p_Stream);

	p_Stream << "}";
}

void SCautiousInvestigateSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousInvestigateSituationSaveData s_Object {};

	{
		ZInvestigateCautiousSituation_SStateData s_Item {};
		ZInvestigateCautiousSituation_SStateData::FromSimpleJson(p_Document["m_StateData"], &s_Item);
		s_Object.m_StateData = s_Item;
	}

	s_Object.m_pGetHelpGroup = simdjson::from_json_int32(p_Document["m_pGetHelpGroup"]);

	s_Object.m_pBackupGroup = simdjson::from_json_int32(p_Document["m_pBackupGroup"]);

	s_Object.m_rTriggerAlarmGroup = simdjson::from_json_int32(p_Document["m_rTriggerAlarmGroup"]);

	s_Object.m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_cautiousVIPGroups"])
	{
		s_Object.m_cautiousVIPGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_friskGroups"])
	{
		s_Object.m_friskGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tFriskCooldown"], &s_Item);
		s_Object.m_tFriskCooldown = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tFriskGroupEnd"], &s_Item);
		s_Object.m_tFriskGroupEnd = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tRecoverUnconsciousGroupEnd"], &s_Item);
		s_Object.m_tRecoverUnconsciousGroupEnd = s_Item;
	}

	s_Object.m_nHuntTarget = simdjson::from_json_int32(p_Document["m_nHuntTarget"]);

	s_Object.m_rZone = simdjson::from_json_uint32(p_Document["m_rZone"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGuardMembers"])
	{
		s_Object.m_aGuardMembers.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_disturbances"])
	{
		SDisturbanceSaveData s_ArrayItem0;
		SDisturbanceSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_disturbances.push_back(s_ArrayItem0);
	}

	s_Object.m_bValidDisturbanceField = simdjson::from_json_bool(p_Document["m_bValidDisturbanceField"]);

	{
		SCompressedGridFloatField s_Item {};
		SCompressedGridFloatField::FromSimpleJson(p_Document["m_disturbanceField"], &s_Item);
		s_Object.m_disturbanceField = s_Item;
	}

	s_Object.m_recoverUnconsciousGroup = simdjson::from_json_int32(p_Document["m_recoverUnconsciousGroup"]);

	s_Object.m_bSuspendSearchOnInitialGetHelpGroup = simdjson::from_json_bool(p_Document["m_bSuspendSearchOnInitialGetHelpGroup"]);

	s_Object.m_lastArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastArrestReason"])));

	s_Object.m_lastStaticArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastStaticArrestReason"])));

	s_Object.m_lastStaticCombatReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastStaticCombatReason"])));

	s_Object.m_bAnyGunshotDisturbance = simdjson::from_json_bool(p_Document["m_bAnyGunshotDisturbance"]);

	s_Object.m_deadBodyMassiveReported = simdjson::from_json_bool(p_Document["m_deadBodyMassiveReported"]);

	s_Object.m_deadBodiesDiscovered = simdjson::from_json_int32(p_Document["m_deadBodiesDiscovered"]);

	s_Object.m_deadCrowdBodiesDiscovered = simdjson::from_json_int32(p_Document["m_deadCrowdBodiesDiscovered"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aDynamicEnforceEventsForSearchers"])
	{
		s_Object.m_aDynamicEnforceEventsForSearchers.push_back(static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(s_Item0))));
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastIdleStanddown"], &s_Item);
		s_Object.m_tLastIdleStanddown = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAvoidDangerGroups"])
	{
		s_Object.m_aAvoidDangerGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	{
		SCautiousHuntSaveData s_Item {};
		SCautiousHuntSaveData::FromSimpleJson(p_Document["m_cautiousHuntData"], &s_Item);
		s_Object.m_cautiousHuntData = s_Item;
	}

	*reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Target) = s_Object;
}

void SCautiousInvestigateSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);

	ZInvestigateCautiousSituation_SStateData::Serialize(&s_Object->m_StateData, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_StateData));
	TArray<int32>::Serialize(&s_Object->m_cautiousVIPGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_cautiousVIPGroups));
	TArray<int32>::Serialize(&s_Object->m_friskGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_friskGroups));
	ZGameTime::Serialize(&s_Object->m_tFriskCooldown, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tFriskCooldown));
	ZGameTime::Serialize(&s_Object->m_tFriskGroupEnd, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tFriskGroupEnd));
	ZGameTime::Serialize(&s_Object->m_tRecoverUnconsciousGroupEnd, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tRecoverUnconsciousGroupEnd));
	TArray<uint32>::Serialize(&s_Object->m_aGuardMembers, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aGuardMembers));
	TArray<SDisturbanceSaveData>::Serialize(&s_Object->m_disturbances, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_disturbances));
	SCompressedGridFloatField::Serialize(&s_Object->m_disturbanceField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_disturbanceField));
	TArray<EAISharedEventType>::Serialize(&s_Object->m_aDynamicEnforceEventsForSearchers, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aDynamicEnforceEventsForSearchers));
	ZGameTime::Serialize(&s_Object->m_tLastIdleStanddown, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tLastIdleStanddown));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aAvoidDangerGroups));
	SCautiousHuntSaveData::Serialize(&s_Object->m_cautiousHuntData, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_cautiousHuntData));
}

bool SCautiousInvestigateSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousInvestigateSituationSaveData::operator==(const SCautiousInvestigateSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousInvestigateSituationSaveData>)
		return false;

	if (m_StateData != p_Other.m_StateData) return false;
	if (m_pGetHelpGroup != p_Other.m_pGetHelpGroup) return false;
	if (m_pBackupGroup != p_Other.m_pBackupGroup) return false;
	if (m_rTriggerAlarmGroup != p_Other.m_rTriggerAlarmGroup) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_cautiousVIPGroups != p_Other.m_cautiousVIPGroups) return false;
	if (m_friskGroups != p_Other.m_friskGroups) return false;
	if (m_tFriskCooldown != p_Other.m_tFriskCooldown) return false;
	if (m_tFriskGroupEnd != p_Other.m_tFriskGroupEnd) return false;
	if (m_tRecoverUnconsciousGroupEnd != p_Other.m_tRecoverUnconsciousGroupEnd) return false;
	if (m_nHuntTarget != p_Other.m_nHuntTarget) return false;
	if (m_rZone != p_Other.m_rZone) return false;
	if (m_aGuardMembers != p_Other.m_aGuardMembers) return false;
	if (m_disturbances != p_Other.m_disturbances) return false;
	if (m_bValidDisturbanceField != p_Other.m_bValidDisturbanceField) return false;
	if (m_disturbanceField != p_Other.m_disturbanceField) return false;
	if (m_recoverUnconsciousGroup != p_Other.m_recoverUnconsciousGroup) return false;
	if (m_bSuspendSearchOnInitialGetHelpGroup != p_Other.m_bSuspendSearchOnInitialGetHelpGroup) return false;
	if (m_lastArrestReason != p_Other.m_lastArrestReason) return false;
	if (m_lastStaticArrestReason != p_Other.m_lastStaticArrestReason) return false;
	if (m_lastStaticCombatReason != p_Other.m_lastStaticCombatReason) return false;
	if (m_bAnyGunshotDisturbance != p_Other.m_bAnyGunshotDisturbance) return false;
	if (m_deadBodyMassiveReported != p_Other.m_deadBodyMassiveReported) return false;
	if (m_deadBodiesDiscovered != p_Other.m_deadBodiesDiscovered) return false;
	if (m_deadCrowdBodiesDiscovered != p_Other.m_deadCrowdBodiesDiscovered) return false;
	if (m_aDynamicEnforceEventsForSearchers != p_Other.m_aDynamicEnforceEventsForSearchers) return false;
	if (m_tLastIdleStanddown != p_Other.m_tLastIdleStanddown) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;
	if (m_cautiousHuntData != p_Other.m_cautiousHuntData) return false;

	return true;
}

ZHMTypeInfo SCautiousSearchGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousSearchGroupSaveData", sizeof(SCautiousSearchGroupSaveData), alignof(SCautiousSearchGroupSaveData), SCautiousSearchGroupSaveData::WriteJson, SCautiousSearchGroupSaveData::WriteSimpleJson, SCautiousSearchGroupSaveData::FromSimpleJson, SCautiousSearchGroupSaveData::Serialize, SCautiousSearchGroupSaveData::Equals);

void SCautiousSearchGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_searchNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_searchNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assistantApproachNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_assistantApproachNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGroupState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZCautiousSearchGroup.ESearchGroupState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eGroupState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousSearchGroup.ESearchGroupState", static_cast<int>(s_Object->m_eGroupState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAssistantState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZCautiousSearchGroup.EAssistantState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAssistantState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousSearchGroup.EAssistantState", static_cast<int>(s_Object->m_eAssistantState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << "}";

	p_Stream << "}";
}

void SCautiousSearchGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_searchNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_searchNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assistantApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_assistantApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGroupState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousSearchGroup.ESearchGroupState", static_cast<int>(s_Object->m_eGroupState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAssistantState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousSearchGroup.EAssistantState", static_cast<int>(s_Object->m_eAssistantState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);

	p_Stream << "}";
}

void SCautiousSearchGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousSearchGroupSaveData s_Object {};

	s_Object.m_searchNode = simdjson::from_json_uint16(p_Document["m_searchNode"]);

	s_Object.m_assistantApproachNode = simdjson::from_json_uint16(p_Document["m_assistantApproachNode"]);

	s_Object.m_eGroupState = static_cast<ZCautiousSearchGroup_ESearchGroupState>(ZHMEnums::GetEnumValueByName("ZCautiousSearchGroup.ESearchGroupState", std::string_view(p_Document["m_eGroupState"])));

	s_Object.m_eAssistantState = static_cast<ZCautiousSearchGroup_EAssistantState>(ZHMEnums::GetEnumValueByName("ZCautiousSearchGroup.EAssistantState", std::string_view(p_Document["m_eAssistantState"])));

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	*reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Target) = s_Object;
}

void SCautiousSearchGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);

}

bool SCautiousSearchGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousSearchGroupSaveData::operator==(const SCautiousSearchGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousSearchGroupSaveData>)
		return false;

	if (m_searchNode != p_Other.m_searchNode) return false;
	if (m_assistantApproachNode != p_Other.m_assistantApproachNode) return false;
	if (m_eGroupState != p_Other.m_eGroupState) return false;
	if (m_eAssistantState != p_Other.m_eAssistantState) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;

	return true;
}

ZHMTypeInfo SCautiousSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SCautiousSituationMemberSaveData", sizeof(SCautiousSituationMemberSaveData), alignof(SCautiousSituationMemberSaveData), SCautiousSituationMemberSaveData::WriteJson, SCautiousSituationMemberSaveData::WriteSimpleJson, SCautiousSituationMemberSaveData::FromSimpleJson, SCautiousSituationMemberSaveData::Serialize, SCautiousSituationMemberSaveData::Equals);

void SCautiousSituationMemberSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_tLastDisturbance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastDisturbance, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSearchCalc") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastSearchCalc, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInfluenceCalc") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastInfluenceCalc, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSearchCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastSearchCompleted, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInvestigationCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastInvestigationCompleted, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTimeIdling") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tTimeIdling, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGuardDutyPoint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuardDutyPoint);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBulletImpactsHeard") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletImpactsHeard);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointSubIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointSubIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBanterCandidate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBanterCandidate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCivOccupant") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCivOccupant);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRecievingNewHuntTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRecievingNewHuntTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownEnforcer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownEnforcer);
	p_Stream << "}";

	p_Stream << "}";
}

void SCautiousSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tLastDisturbance") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastDisturbance, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSearchCalc") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSearchCalc, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInfluenceCalc") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInfluenceCalc, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSearchCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSearchCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInvestigationCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInvestigationCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTimeIdling") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tTimeIdling, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGuardDutyPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuardDutyPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBulletImpactsHeard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletImpactsHeard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointSubIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointSubIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBanterCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBanterCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCivOccupant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCivOccupant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRecievingNewHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRecievingNewHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownEnforcer);

	p_Stream << "}";
}

void SCautiousSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousSituationMemberSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastDisturbance"], &s_Item);
		s_Object.m_tLastDisturbance = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastSearchCalc"], &s_Item);
		s_Object.m_tLastSearchCalc = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastInfluenceCalc"], &s_Item);
		s_Object.m_tLastInfluenceCalc = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastSearchCompleted"], &s_Item);
		s_Object.m_tLastSearchCompleted = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastInvestigationCompleted"], &s_Item);
		s_Object.m_tLastInvestigationCompleted = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tTimeIdling"], &s_Item);
		s_Object.m_tTimeIdling = s_Item;
	}

	s_Object.m_pGuardDutyPoint = simdjson::from_json_uint32(p_Document["m_pGuardDutyPoint"]);

	s_Object.m_nBulletImpactsHeard = simdjson::from_json_int32(p_Document["m_nBulletImpactsHeard"]);

	s_Object.m_nPatrolWaypointIndex = simdjson::from_json_int32(p_Document["m_nPatrolWaypointIndex"]);

	s_Object.m_nPatrolWaypointSubIndex = simdjson::from_json_uint32(p_Document["m_nPatrolWaypointSubIndex"]);

	s_Object.m_bBanterCandidate = simdjson::from_json_bool(p_Document["m_bBanterCandidate"]);

	s_Object.m_bCivOccupant = simdjson::from_json_bool(p_Document["m_bCivOccupant"]);

	s_Object.m_bRecievingNewHuntTarget = simdjson::from_json_bool(p_Document["m_bRecievingNewHuntTarget"]);

	s_Object.m_bLockdownEnforcer = simdjson::from_json_bool(p_Document["m_bLockdownEnforcer"]);

	*reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Target) = s_Object;
}

void SCautiousSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastDisturbance, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastDisturbance));
	ZGameTime::Serialize(&s_Object->m_tLastSearchCalc, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastSearchCalc));
	ZGameTime::Serialize(&s_Object->m_tLastInfluenceCalc, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastInfluenceCalc));
	ZGameTime::Serialize(&s_Object->m_tLastSearchCompleted, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastSearchCompleted));
	ZGameTime::Serialize(&s_Object->m_tLastInvestigationCompleted, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastInvestigationCompleted));
	ZGameTime::Serialize(&s_Object->m_tTimeIdling, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tTimeIdling));
}

bool SCautiousSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousSituationMemberSaveData::operator==(const SCautiousSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousSituationMemberSaveData>)
		return false;

	if (m_tLastDisturbance != p_Other.m_tLastDisturbance) return false;
	if (m_tLastSearchCalc != p_Other.m_tLastSearchCalc) return false;
	if (m_tLastInfluenceCalc != p_Other.m_tLastInfluenceCalc) return false;
	if (m_tLastSearchCompleted != p_Other.m_tLastSearchCompleted) return false;
	if (m_tLastInvestigationCompleted != p_Other.m_tLastInvestigationCompleted) return false;
	if (m_tTimeIdling != p_Other.m_tTimeIdling) return false;
	if (m_pGuardDutyPoint != p_Other.m_pGuardDutyPoint) return false;
	if (m_nBulletImpactsHeard != p_Other.m_nBulletImpactsHeard) return false;
	if (m_nPatrolWaypointIndex != p_Other.m_nPatrolWaypointIndex) return false;
	if (m_nPatrolWaypointSubIndex != p_Other.m_nPatrolWaypointSubIndex) return false;
	if (m_bBanterCandidate != p_Other.m_bBanterCandidate) return false;
	if (m_bCivOccupant != p_Other.m_bCivOccupant) return false;
	if (m_bRecievingNewHuntTarget != p_Other.m_bRecievingNewHuntTarget) return false;
	if (m_bLockdownEnforcer != p_Other.m_bLockdownEnforcer) return false;

	return true;
}

ZHMTypeInfo SCautiousVIPGroupState::TypeInfo = ZHMTypeInfo("SCautiousVIPGroupState", sizeof(SCautiousVIPGroupState), alignof(SCautiousVIPGroupState), SCautiousVIPGroupState::WriteJson, SCautiousVIPGroupState::WriteSimpleJson, SCautiousVIPGroupState::FromSimpleJson, SCautiousVIPGroupState::Serialize, SCautiousVIPGroupState::Equals);

void SCautiousVIPGroupState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_tMove") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tMove, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SCautiousVIPGroupState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tMove") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tMove, p_Stream);

	p_Stream << "}";
}

void SCautiousVIPGroupState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousVIPGroupState s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tMove"], &s_Item);
		s_Object.m_tMove = s_Item;
	}

	*reinterpret_cast<SCautiousVIPGroupState*>(p_Target) = s_Object;
}

void SCautiousVIPGroupState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tMove, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupState, m_tMove));
}

bool SCautiousVIPGroupState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousVIPGroupState*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousVIPGroupState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousVIPGroupState::operator==(const SCautiousVIPGroupState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousVIPGroupState>)
		return false;

	if (m_tMove != p_Other.m_tMove) return false;

	return true;
}

ZHMTypeInfo SCautiousVIPGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousVIPGroupSaveData", sizeof(SCautiousVIPGroupSaveData), alignof(SCautiousVIPGroupSaveData), SCautiousVIPGroupSaveData::WriteJson, SCautiousVIPGroupSaveData::WriteSimpleJson, SCautiousVIPGroupSaveData::FromSimpleJson, SCautiousVIPGroupSaveData::Serialize, SCautiousVIPGroupSaveData::Equals);

void SCautiousVIPGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vip") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_vip);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_stateData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SCautiousVIPGroupState") << ",\"$val\":";
	SCautiousVIPGroupState::WriteJson(&s_Object->m_stateData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vipTargetNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_vipTargetNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_occupancyNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_occupancyNode);
	p_Stream << "}";

	p_Stream << "}";
}

void SCautiousVIPGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_vip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_stateData") << ":";
	SCautiousVIPGroupState::WriteSimpleJson(&s_Object->m_stateData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vipTargetNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_vipTargetNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_occupancyNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_occupancyNode);

	p_Stream << "}";
}

void SCautiousVIPGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousVIPGroupSaveData s_Object {};

	s_Object.m_vip = simdjson::from_json_uint32(p_Document["m_vip"]);

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		SCautiousVIPGroupState s_Item {};
		SCautiousVIPGroupState::FromSimpleJson(p_Document["m_stateData"], &s_Item);
		s_Object.m_stateData = s_Item;
	}

	s_Object.m_vipTargetNode = simdjson::from_json_int32(p_Document["m_vipTargetNode"]);

	s_Object.m_occupancyNode = simdjson::from_json_int32(p_Document["m_occupancyNode"]);

	*reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Target) = s_Object;
}

void SCautiousVIPGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupSaveData, m_fsmState));
	SCautiousVIPGroupState::Serialize(&s_Object->m_stateData, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupSaveData, m_stateData));
}

bool SCautiousVIPGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousVIPGroupSaveData::operator==(const SCautiousVIPGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousVIPGroupSaveData>)
		return false;

	if (m_vip != p_Other.m_vip) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_stateData != p_Other.m_stateData) return false;
	if (m_vipTargetNode != p_Other.m_vipTargetNode) return false;
	if (m_occupancyNode != p_Other.m_occupancyNode) return false;

	return true;
}

ZHMTypeInfo SChairSaveData::TypeInfo = ZHMTypeInfo("SChairSaveData", sizeof(SChairSaveData), alignof(SChairSaveData), SChairSaveData::WriteJson, SChairSaveData::WriteSimpleJson, SChairSaveData::FromSimpleJson, SChairSaveData::Serialize, SChairSaveData::Equals);

void SChairSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttached") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttached);
	p_Stream << "}";

	p_Stream << "}";
}

void SChairSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttached);

	p_Stream << "}";
}

void SChairSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SChairSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_bAttached = simdjson::from_json_bool(p_Document["m_bAttached"]);

	*reinterpret_cast<SChairSaveData*>(p_Target) = s_Object;
}

void SChairSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);

}

bool SChairSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChairSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChairSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChairSaveData::operator==(const SChairSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChairSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_bAttached != p_Other.m_bAttached) return false;

	return true;
}

ZHMTypeInfo ZDynamicObject::TypeInfo = ZHMTypeInfo("ZDynamicObject", sizeof(ZDynamicObject), alignof(ZDynamicObject), ZDynamicObject::WriteJson, ZDynamicObject::WriteSimpleJson, ZDynamicObject::FromSimpleJson, ZDynamicObject::Serialize, ZDynamicObject::Equals);

void ZDynamicObject::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_value") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_value, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void ZDynamicObject::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_value, p_Stream);

	p_Stream << "}";
}

void ZDynamicObject::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDynamicObject s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_value"], &s_Item);
		s_Object.m_value = s_Item;
	}

	*reinterpret_cast<ZDynamicObject*>(p_Target) = s_Object;
}

void ZDynamicObject::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);

	ZVariant::Serialize(&s_Object->m_value, p_Serializer, p_OwnOffset + offsetof(ZDynamicObject, m_value));
}

bool ZDynamicObject::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDynamicObject*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDynamicObject*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDynamicObject::operator==(const ZDynamicObject& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDynamicObject>)
		return false;

	if (m_value != p_Other.m_value) return false;

	return true;
}

ZHMTypeInfo SChallengeSaveData::TypeInfo = ZHMTypeInfo("SChallengeSaveData", sizeof(SChallengeSaveData), alignof(SChallengeSaveData), SChallengeSaveData::WriteJson, SChallengeSaveData::WriteSimpleJson, SChallengeSaveData::FromSimpleJson, SChallengeSaveData::Serialize, SChallengeSaveData::Equals);

void SChallengeSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_State, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SChallengeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_State, p_Stream);

	p_Stream << "}";
}

void SChallengeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SChallengeSaveData s_Object {};

	s_Object.m_sId = std::string_view(p_Document["m_sId"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	*reinterpret_cast<SChallengeSaveData*>(p_Target) = s_Object;
}

void SChallengeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sId, p_Serializer, p_OwnOffset + offsetof(SChallengeSaveData, m_sId));
	ZDynamicObject::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(SChallengeSaveData, m_State));
}

bool SChallengeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChallengeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChallengeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChallengeSaveData::operator==(const SChallengeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChallengeSaveData>)
		return false;

	if (m_sId != p_Other.m_sId) return false;
	if (m_State != p_Other.m_State) return false;

	return true;
}

ZHMTypeInfo SChallengesSaveData::TypeInfo = ZHMTypeInfo("SChallengesSaveData", sizeof(SChallengesSaveData), alignof(SChallengesSaveData), SChallengesSaveData::WriteJson, SChallengesSaveData::WriteSimpleJson, SChallengesSaveData::FromSimpleJson, SChallengesSaveData::Serialize, SChallengesSaveData::Equals);

void SChallengesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_mChallengeStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SChallengeSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_mChallengeStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_mChallengeStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SChallengeSaveData") << ",\"$val\":";
		SChallengeSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_mChallengeStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SChallengesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_mChallengeStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_mChallengeStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_mChallengeStates[i];
		SChallengeSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_mChallengeStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SChallengesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SChallengesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_mChallengeStates"])
	{
		SChallengeSaveData s_ArrayItem0;
		SChallengeSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_mChallengeStates.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SChallengesSaveData*>(p_Target) = s_Object;
}

void SChallengesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);

	TArray<SChallengeSaveData>::Serialize(&s_Object->m_mChallengeStates, p_Serializer, p_OwnOffset + offsetof(SChallengesSaveData, m_mChallengeStates));
}

bool SChallengesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChallengesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChallengesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChallengesSaveData::operator==(const SChallengesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChallengesSaveData>)
		return false;

	if (m_mChallengeStates != p_Other.m_mChallengeStates) return false;

	return true;
}

ZHMTypeInfo SCharacterSpeakEntitySaveData::TypeInfo = ZHMTypeInfo("SCharacterSpeakEntitySaveData", sizeof(SCharacterSpeakEntitySaveData), alignof(SCharacterSpeakEntitySaveData), SCharacterSpeakEntitySaveData::WriteJson, SCharacterSpeakEntitySaveData::WriteSimpleJson, SCharacterSpeakEntitySaveData::FromSimpleJson, SCharacterSpeakEntitySaveData::Serialize, SCharacterSpeakEntitySaveData::Equals);

void SCharacterSpeakEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fSeekPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSeekPosition);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWereSubtitlesSeen") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWereSubtitlesSeen);
	p_Stream << "}";

	p_Stream << "}";
}

void SCharacterSpeakEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSeekPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWereSubtitlesSeen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWereSubtitlesSeen);

	p_Stream << "}";
}

void SCharacterSpeakEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCharacterSpeakEntitySaveData s_Object {};

	s_Object.m_fSeekPosition = simdjson::from_json_float32(p_Document["m_fSeekPosition"]);

	s_Object.m_bWereSubtitlesSeen = simdjson::from_json_bool(p_Document["m_bWereSubtitlesSeen"]);

	*reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Target) = s_Object;
}

void SCharacterSpeakEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);

}

bool SCharacterSpeakEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCharacterSpeakEntitySaveData::operator==(const SCharacterSpeakEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCharacterSpeakEntitySaveData>)
		return false;

	if (m_fSeekPosition != p_Other.m_fSeekPosition) return false;
	if (m_bWereSubtitlesSeen != p_Other.m_bWereSubtitlesSeen) return false;

	return true;
}

ZHMTypeInfo SCheckLastPositionGroupSaveData::TypeInfo = ZHMTypeInfo("SCheckLastPositionGroupSaveData", sizeof(SCheckLastPositionGroupSaveData), alignof(SCheckLastPositionGroupSaveData), SCheckLastPositionGroupSaveData::WriteJson, SCheckLastPositionGroupSaveData::WriteSimpleJson, SCheckLastPositionGroupSaveData::FromSimpleJson, SCheckLastPositionGroupSaveData::Serialize, SCheckLastPositionGroupSaveData::Equals);

void SCheckLastPositionGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLeaderTargetNodeIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLeaderTargetNodeIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderOrderAssigned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderOrderAssigned);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAssistantOrderAssigned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAssistantOrderAssigned);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSearchCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchCompleted);
	p_Stream << "}";

	p_Stream << "}";
}

void SCheckLastPositionGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLeaderTargetNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLeaderTargetNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAssistantOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAssistantOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSearchCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchCompleted);

	p_Stream << "}";
}

void SCheckLastPositionGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCheckLastPositionGroupSaveData s_Object {};

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object.m_nLeaderTargetNodeIndex = simdjson::from_json_uint16(p_Document["m_nLeaderTargetNodeIndex"]);

	s_Object.m_bLeaderOrderAssigned = simdjson::from_json_bool(p_Document["m_bLeaderOrderAssigned"]);

	s_Object.m_bAssistantOrderAssigned = simdjson::from_json_bool(p_Document["m_bAssistantOrderAssigned"]);

	s_Object.m_bSearchCompleted = simdjson::from_json_bool(p_Document["m_bSearchCompleted"]);

	*reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Target) = s_Object;
}

void SCheckLastPositionGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);

}

bool SCheckLastPositionGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCheckLastPositionGroupSaveData::operator==(const SCheckLastPositionGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCheckLastPositionGroupSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_nLeaderTargetNodeIndex != p_Other.m_nLeaderTargetNodeIndex) return false;
	if (m_bLeaderOrderAssigned != p_Other.m_bLeaderOrderAssigned) return false;
	if (m_bAssistantOrderAssigned != p_Other.m_bAssistantOrderAssigned) return false;
	if (m_bSearchCompleted != p_Other.m_bSearchCompleted) return false;

	return true;
}

ZHMTypeInfo SClothBundleSaveData::TypeInfo = ZHMTypeInfo("SClothBundleSaveData", sizeof(SClothBundleSaveData), alignof(SClothBundleSaveData), SClothBundleSaveData::WriteJson, SClothBundleSaveData::WriteSimpleJson, SClothBundleSaveData::FromSimpleJson, SClothBundleSaveData::Serialize, SClothBundleSaveData::Equals);

void SClothBundleSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothBundleSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vQuaternion, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_OutfitID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSpawnedByHitman") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bSpawnedByHitman);
	p_Stream << "}";

	p_Stream << "}";
}

void SClothBundleSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothBundleSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternion") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vQuaternion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_OutfitID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSpawnedByHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSpawnedByHitman);

	p_Stream << "}";
}

void SClothBundleSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SClothBundleSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vQuaternion"], &s_Item);
		s_Object.m_vQuaternion = s_Item;
	}

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_OutfitID"], &s_Item);
		s_Object.m_OutfitID = s_Item;
	}

	s_Object.m_nOutfitVariation = simdjson::from_json_int32(p_Document["m_nOutfitVariation"]);

	s_Object.m_nOutfitCharset = simdjson::from_json_int32(p_Document["m_nOutfitCharset"]);

	s_Object.bSpawnedByHitman = simdjson::from_json_bool(p_Document["bSpawnedByHitman"]);

	*reinterpret_cast<SClothBundleSaveData*>(p_Target) = s_Object;
}

void SClothBundleSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothBundleSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SClothBundleSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vQuaternion, p_Serializer, p_OwnOffset + offsetof(SClothBundleSaveData, m_vQuaternion));
	ZRepositoryID::Serialize(&s_Object->m_OutfitID, p_Serializer, p_OwnOffset + offsetof(SClothBundleSaveData, m_OutfitID));
}

bool SClothBundleSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothBundleSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothBundleSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothBundleSaveData::operator==(const SClothBundleSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothBundleSaveData>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vQuaternion != p_Other.m_vQuaternion) return false;
	if (m_OutfitID != p_Other.m_OutfitID) return false;
	if (m_nOutfitVariation != p_Other.m_nOutfitVariation) return false;
	if (m_nOutfitCharset != p_Other.m_nOutfitCharset) return false;
	if (bSpawnedByHitman != p_Other.bSpawnedByHitman) return false;

	return true;
}

ZHMTypeInfo SClothBundleSpawnSaveData::TypeInfo = ZHMTypeInfo("SClothBundleSpawnSaveData", sizeof(SClothBundleSpawnSaveData), alignof(SClothBundleSpawnSaveData), SClothBundleSpawnSaveData::WriteJson, SClothBundleSpawnSaveData::WriteSimpleJson, SClothBundleSpawnSaveData::FromSimpleJson, SClothBundleSpawnSaveData::Serialize, SClothBundleSpawnSaveData::Equals);

void SClothBundleSpawnSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rClothbundle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rClothbundle);
	p_Stream << "}";

	p_Stream << "}";
}

void SClothBundleSpawnSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rClothbundle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rClothbundle);

	p_Stream << "}";
}

void SClothBundleSpawnSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SClothBundleSpawnSaveData s_Object {};

	s_Object.m_rClothbundle = simdjson::from_json_uint32(p_Document["m_rClothbundle"]);

	*reinterpret_cast<SClothBundleSpawnSaveData*>(p_Target) = s_Object;
}

void SClothBundleSpawnSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);

}

bool SClothBundleSpawnSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothBundleSpawnSaveData::operator==(const SClothBundleSpawnSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothBundleSpawnSaveData>)
		return false;

	if (m_rClothbundle != p_Other.m_rClothbundle) return false;

	return true;
}

ZHMTypeInfo SClothVertex::TypeInfo = ZHMTypeInfo("SClothVertex", sizeof(SClothVertex), alignof(SClothVertex), SClothVertex::WriteJson, SClothVertex::WriteSimpleJson, SClothVertex::FromSimpleJson, SClothVertex::Serialize, SClothVertex::Equals);

void SClothVertex::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nColumn") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColumn);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRow);
	p_Stream << "}";

	p_Stream << "}";
}

void SClothVertex::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nColumn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColumn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRow);

	p_Stream << "}";
}

void SClothVertex::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SClothVertex s_Object {};

	s_Object.m_nColumn = simdjson::from_json_uint16(p_Document["m_nColumn"]);

	s_Object.m_nRow = simdjson::from_json_uint16(p_Document["m_nRow"]);

	*reinterpret_cast<SClothVertex*>(p_Target) = s_Object;
}

void SClothVertex::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);

}

bool SClothVertex::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothVertex*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothVertex*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothVertex::operator==(const SClothVertex& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothVertex>)
		return false;

	if (m_nColumn != p_Other.m_nColumn) return false;
	if (m_nRow != p_Other.m_nRow) return false;

	return true;
}

ZHMTypeInfo SClothWireEntitySaveData::TypeInfo = ZHMTypeInfo("SClothWireEntitySaveData", sizeof(SClothWireEntitySaveData), alignof(SClothWireEntitySaveData), SClothWireEntitySaveData::WriteJson, SClothWireEntitySaveData::WriteSimpleJson, SClothWireEntitySaveData::FromSimpleJson, SClothWireEntitySaveData::Serialize, SClothWireEntitySaveData::Equals);

void SClothWireEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fWireLength") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWireLength);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttachToAnchorTransform") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttachToAnchorTransform);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSimulationEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSimulationEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SClothWireEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fWireLength") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWireLength);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttachToAnchorTransform") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttachToAnchorTransform);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSimulationEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSimulationEnabled);

	p_Stream << "}";
}

void SClothWireEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SClothWireEntitySaveData s_Object {};

	s_Object.m_fWireLength = simdjson::from_json_float32(p_Document["m_fWireLength"]);

	s_Object.m_bAttachToAnchorTransform = simdjson::from_json_bool(p_Document["m_bAttachToAnchorTransform"]);

	s_Object.m_bSimulationEnabled = simdjson::from_json_bool(p_Document["m_bSimulationEnabled"]);

	*reinterpret_cast<SClothWireEntitySaveData*>(p_Target) = s_Object;
}

void SClothWireEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);

}

bool SClothWireEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothWireEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothWireEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothWireEntitySaveData::operator==(const SClothWireEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothWireEntitySaveData>)
		return false;

	if (m_fWireLength != p_Other.m_fWireLength) return false;
	if (m_bAttachToAnchorTransform != p_Other.m_bAttachToAnchorTransform) return false;
	if (m_bSimulationEnabled != p_Other.m_bSimulationEnabled) return false;

	return true;
}

ZHMTypeInfo SCollidingParticle::TypeInfo = ZHMTypeInfo("SCollidingParticle", sizeof(SCollidingParticle), alignof(SCollidingParticle), SCollidingParticle::WriteJson, SCollidingParticle::WriteSimpleJson, SCollidingParticle::FromSimpleJson, SCollidingParticle::Serialize, SCollidingParticle::Equals);

void SCollidingParticle::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vNewVelocity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vNewVelocity, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nColor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSize);
	p_Stream << "}";

	p_Stream << "}";
}

void SCollidingParticle::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vNewVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_vNewVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nColor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSize);

	p_Stream << "}";
}

void SCollidingParticle::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCollidingParticle s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vVelocity"], &s_Item);
		s_Object.m_vVelocity = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vNewVelocity"], &s_Item);
		s_Object.m_vNewVelocity = s_Item;
	}

	s_Object.m_nColor = simdjson::from_json_uint32(p_Document["m_nColor"]);

	s_Object.m_fSize = simdjson::from_json_float32(p_Document["m_fSize"]);

	*reinterpret_cast<SCollidingParticle*>(p_Target) = s_Object;
}

void SCollidingParticle::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vPosition));
	float4::Serialize(&s_Object->m_vVelocity, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vVelocity));
	float4::Serialize(&s_Object->m_vNewVelocity, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vNewVelocity));
}

bool SCollidingParticle::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollidingParticle*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollidingParticle*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollidingParticle::operator==(const SCollidingParticle& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollidingParticle>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vVelocity != p_Other.m_vVelocity) return false;
	if (m_vNewVelocity != p_Other.m_vNewVelocity) return false;
	if (m_nColor != p_Other.m_nColor) return false;
	if (m_fSize != p_Other.m_fSize) return false;

	return true;
}

ZHMTypeInfo SCollisionControllerAspectSaveData::TypeInfo = ZHMTypeInfo("SCollisionControllerAspectSaveData", sizeof(SCollisionControllerAspectSaveData), alignof(SCollisionControllerAspectSaveData), SCollisionControllerAspectSaveData::WriteJson, SCollisionControllerAspectSaveData::WriteSimpleJson, SCollisionControllerAspectSaveData::FromSimpleJson, SCollisionControllerAspectSaveData::Serialize, SCollisionControllerAspectSaveData::Equals);

void SCollisionControllerAspectSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bCollideHitman") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollideHitman);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCollideCamera") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollideCamera);
	p_Stream << "}";

	p_Stream << "}";
}

void SCollisionControllerAspectSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bCollideHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollideHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCollideCamera") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollideCamera);

	p_Stream << "}";
}

void SCollisionControllerAspectSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCollisionControllerAspectSaveData s_Object {};

	s_Object.m_bCollideHitman = simdjson::from_json_bool(p_Document["m_bCollideHitman"]);

	s_Object.m_bCollideCamera = simdjson::from_json_bool(p_Document["m_bCollideCamera"]);

	*reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Target) = s_Object;
}

void SCollisionControllerAspectSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);

}

bool SCollisionControllerAspectSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollisionControllerAspectSaveData::operator==(const SCollisionControllerAspectSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollisionControllerAspectSaveData>)
		return false;

	if (m_bCollideHitman != p_Other.m_bCollideHitman) return false;
	if (m_bCollideCamera != p_Other.m_bCollideCamera) return false;

	return true;
}

ZHMTypeInfo SCollisionControllerAspectsSaveData::TypeInfo = ZHMTypeInfo("SCollisionControllerAspectsSaveData", sizeof(SCollisionControllerAspectsSaveData), alignof(SCollisionControllerAspectsSaveData), SCollisionControllerAspectsSaveData::WriteJson, SCollisionControllerAspectsSaveData::WriteSimpleJson, SCollisionControllerAspectsSaveData::FromSimpleJson, SCollisionControllerAspectsSaveData::Serialize, SCollisionControllerAspectsSaveData::Equals);

void SCollisionControllerAspectsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCollisionControllerAspectSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCollisionControllerAspectSaveData") << ",\"$val\":";
		SCollisionControllerAspectSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCollisionControllerAspectsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SCollisionControllerAspectSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCollisionControllerAspectsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCollisionControllerAspectsSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SCollisionControllerAspectSaveData s_ArrayItem0;
		SCollisionControllerAspectSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Target) = s_Object;
}

void SCollisionControllerAspectsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SCollisionControllerAspectsSaveData, m_aEntities));
	TArray<SCollisionControllerAspectSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SCollisionControllerAspectsSaveData, m_aData));
}

bool SCollisionControllerAspectsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollisionControllerAspectsSaveData::operator==(const SCollisionControllerAspectsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollisionControllerAspectsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SColorRGB::TypeInfo = ZHMTypeInfo("SColorRGB", sizeof(SColorRGB), alignof(SColorRGB), SColorRGB::WriteJson, SColorRGB::WriteSimpleJson, SColorRGB::FromSimpleJson, SColorRGB::Serialize, SColorRGB::Equals);

void SColorRGB::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->b);
	p_Stream << "}";

	p_Stream << "}";
}

void SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->b);

	p_Stream << "}";
}

void SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SColorRGB s_Object {};

	s_Object.r = simdjson::from_json_float32(p_Document["r"]);

	s_Object.g = simdjson::from_json_float32(p_Document["g"]);

	s_Object.b = simdjson::from_json_float32(p_Document["b"]);

	*reinterpret_cast<SColorRGB*>(p_Target) = s_Object;
}

void SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

}

bool SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGB::operator==(const SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGB>)
		return false;

	if (r != p_Other.r) return false;
	if (g != p_Other.g) return false;
	if (b != p_Other.b) return false;

	return true;
}

ZHMTypeInfo SColorRGBA::TypeInfo = ZHMTypeInfo("SColorRGBA", sizeof(SColorRGBA), alignof(SColorRGBA), SColorRGBA::WriteJson, SColorRGBA::WriteSimpleJson, SColorRGBA::FromSimpleJson, SColorRGBA::Serialize, SColorRGBA::Equals);

void SColorRGBA::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->b);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("a") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->a);
	p_Stream << "}";

	p_Stream << "}";
}

void SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->b);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("a") << ":";
	p_Stream << simdjson::as_json_string(s_Object->a);

	p_Stream << "}";
}

void SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SColorRGBA s_Object {};

	s_Object.r = simdjson::from_json_float32(p_Document["r"]);

	s_Object.g = simdjson::from_json_float32(p_Document["g"]);

	s_Object.b = simdjson::from_json_float32(p_Document["b"]);

	s_Object.a = simdjson::from_json_float32(p_Document["a"]);

	*reinterpret_cast<SColorRGBA*>(p_Target) = s_Object;
}

void SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

}

bool SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGBA::operator==(const SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGBA>)
		return false;

	if (r != p_Other.r) return false;
	if (g != p_Other.g) return false;
	if (b != p_Other.b) return false;
	if (a != p_Other.a) return false;

	return true;
}

ZHMTypeInfo SColorRGBSaveData::TypeInfo = ZHMTypeInfo("SColorRGBSaveData", sizeof(SColorRGBSaveData), alignof(SColorRGBSaveData), SColorRGBSaveData::WriteJson, SColorRGBSaveData::WriteSimpleJson, SColorRGBSaveData::FromSimpleJson, SColorRGBSaveData::Serialize, SColorRGBSaveData::Equals);

void SColorRGBSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SColorRGB>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGB") << ",\"$val\":";
		SColorRGB::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SColorRGBSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SColorRGB::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SColorRGBSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SColorRGBSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SColorRGB s_ArrayItem0;
		SColorRGB::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SColorRGBSaveData*>(p_Target) = s_Object;
}

void SColorRGBSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SColorRGBSaveData, m_aEntities));
	TArray<SColorRGB>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SColorRGBSaveData, m_aData));
}

bool SColorRGBSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGBSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGBSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGBSaveData::operator==(const SColorRGBSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGBSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SCombatOrderSaveData::TypeInfo = ZHMTypeInfo("SCombatOrderSaveData", sizeof(SCombatOrderSaveData), alignof(SCombatOrderSaveData), SCombatOrderSaveData::WriteJson, SCombatOrderSaveData::WriteSimpleJson, SCombatOrderSaveData::FromSimpleJson, SCombatOrderSaveData::Serialize, SCombatOrderSaveData::Equals);

void SCombatOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vPos") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPos, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_coverPlane") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_coverPlane);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInteraction") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInteraction);
	p_Stream << "}";

	p_Stream << "}";
}

void SCombatOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPos") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPos, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_coverPlane") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_coverPlane);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInteraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInteraction);

	p_Stream << "}";
}

void SCombatOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCombatOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPos"], &s_Item);
		s_Object.m_vPos = s_Item;
	}

	s_Object.m_coverPlane = simdjson::from_json_uint32(p_Document["m_coverPlane"]);

	s_Object.m_rInteraction = simdjson::from_json_uint32(p_Document["m_rInteraction"]);

	*reinterpret_cast<SCombatOrderSaveData*>(p_Target) = s_Object;
}

void SCombatOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPos, p_Serializer, p_OwnOffset + offsetof(SCombatOrderSaveData, m_vPos));
}

bool SCombatOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatOrderSaveData::operator==(const SCombatOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatOrderSaveData>)
		return false;

	if (m_vPos != p_Other.m_vPos) return false;
	if (m_coverPlane != p_Other.m_coverPlane) return false;
	if (m_rInteraction != p_Other.m_rInteraction) return false;

	return true;
}

ZHMTypeInfo SCombatSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SCombatSituationMemberSaveData", sizeof(SCombatSituationMemberSaveData), alignof(SCombatSituationMemberSaveData), SCombatSituationMemberSaveData::WriteJson, SCombatSituationMemberSaveData::WriteSimpleJson, SCombatSituationMemberSaveData::FromSimpleJson, SCombatSituationMemberSaveData::Serialize, SCombatSituationMemberSaveData::Equals);

void SCombatSituationMemberSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_tAggressiveModeTimer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tAggressiveModeTimer, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceTargetMoved") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceTargetMoved);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceFieldValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceFieldValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_civilianJoinReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_civilianJoinReason)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_civilianJoinReason))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPreferredToFire") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPreferredToFire);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsReinforcing") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsReinforcing);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDialogPreventShooting") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDialogPreventShooting);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanFlee") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanFlee);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCantFleeNoPath") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCantFleeNoPath);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReportedToGuard") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReportedToGuard);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandAndShoot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandAndShoot);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAggressiveMode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAggressiveMode);
	p_Stream << "}";

	p_Stream << "}";
}

void SCombatSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tAggressiveModeTimer") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAggressiveModeTimer, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceTargetMoved") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceTargetMoved);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceFieldValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceFieldValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_civilianJoinReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_civilianJoinReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPreferredToFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPreferredToFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsReinforcing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsReinforcing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDialogPreventShooting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDialogPreventShooting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanFlee") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanFlee);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCantFleeNoPath") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCantFleeNoPath);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReportedToGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReportedToGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandAndShoot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandAndShoot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAggressiveMode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAggressiveMode);

	p_Stream << "}";
}

void SCombatSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCombatSituationMemberSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tAggressiveModeTimer"], &s_Item);
		s_Object.m_tAggressiveModeTimer = s_Item;
	}

	s_Object.m_fDistanceTargetMoved = simdjson::from_json_float32(p_Document["m_fDistanceTargetMoved"]);

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_fDistanceFieldValue = simdjson::from_json_float32(p_Document["m_fDistanceFieldValue"]);

	s_Object.m_civilianJoinReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_civilianJoinReason"])));

	s_Object.m_bIsPreferredToFire = simdjson::from_json_bool(p_Document["m_bIsPreferredToFire"]);

	s_Object.m_bIsReinforcing = simdjson::from_json_bool(p_Document["m_bIsReinforcing"]);

	s_Object.m_bDialogPreventShooting = simdjson::from_json_bool(p_Document["m_bDialogPreventShooting"]);

	s_Object.m_bCanFlee = simdjson::from_json_bool(p_Document["m_bCanFlee"]);

	s_Object.m_bCantFleeNoPath = simdjson::from_json_bool(p_Document["m_bCantFleeNoPath"]);

	s_Object.m_bReportedToGuard = simdjson::from_json_bool(p_Document["m_bReportedToGuard"]);

	s_Object.m_bStandAndShoot = simdjson::from_json_bool(p_Document["m_bStandAndShoot"]);

	s_Object.m_bAggressiveMode = simdjson::from_json_bool(p_Document["m_bAggressiveMode"]);

	*reinterpret_cast<SCombatSituationMemberSaveData*>(p_Target) = s_Object;
}

void SCombatSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tAggressiveModeTimer, p_Serializer, p_OwnOffset + offsetof(SCombatSituationMemberSaveData, m_tAggressiveModeTimer));
}

bool SCombatSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatSituationMemberSaveData::operator==(const SCombatSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatSituationMemberSaveData>)
		return false;

	if (m_tAggressiveModeTimer != p_Other.m_tAggressiveModeTimer) return false;
	if (m_fDistanceTargetMoved != p_Other.m_fDistanceTargetMoved) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_fDistanceFieldValue != p_Other.m_fDistanceFieldValue) return false;
	if (m_civilianJoinReason != p_Other.m_civilianJoinReason) return false;
	if (m_bIsPreferredToFire != p_Other.m_bIsPreferredToFire) return false;
	if (m_bIsReinforcing != p_Other.m_bIsReinforcing) return false;
	if (m_bDialogPreventShooting != p_Other.m_bDialogPreventShooting) return false;
	if (m_bCanFlee != p_Other.m_bCanFlee) return false;
	if (m_bCantFleeNoPath != p_Other.m_bCantFleeNoPath) return false;
	if (m_bReportedToGuard != p_Other.m_bReportedToGuard) return false;
	if (m_bStandAndShoot != p_Other.m_bStandAndShoot) return false;
	if (m_bAggressiveMode != p_Other.m_bAggressiveMode) return false;

	return true;
}

ZHMTypeInfo SCombatZoneEntitySaveData::TypeInfo = ZHMTypeInfo("SCombatZoneEntitySaveData", sizeof(SCombatZoneEntitySaveData), alignof(SCombatZoneEntitySaveData), SCombatZoneEntitySaveData::WriteJson, SCombatZoneEntitySaveData::WriteSimpleJson, SCombatZoneEntitySaveData::FromSimpleJson, SCombatZoneEntitySaveData::Serialize, SCombatZoneEntitySaveData::Equals);

void SCombatZoneEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsInLockdown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInLockdown);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFalseAlarm") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFalseAlarm);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ECombatZoneState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECombatZoneState", static_cast<int>(s_Object->m_nState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLockdownTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLockdownTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTriggerTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tTriggerTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEngageTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tEngageTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SCombatZoneEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInLockdown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInLockdown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFalseAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFalseAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECombatZoneState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLockdownTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLockdownTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTriggerTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tTriggerTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEngageTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEngageTime, p_Stream);

	p_Stream << "}";
}

void SCombatZoneEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCombatZoneEntitySaveData s_Object {};

	s_Object.m_bIsInLockdown = simdjson::from_json_bool(p_Document["m_bIsInLockdown"]);

	s_Object.m_bIsFalseAlarm = simdjson::from_json_bool(p_Document["m_bIsFalseAlarm"]);

	s_Object.m_nState = static_cast<ECombatZoneState>(ZHMEnums::GetEnumValueByName("ECombatZoneState", std::string_view(p_Document["m_nState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLockdownTime"], &s_Item);
		s_Object.m_tLockdownTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tTriggerTime"], &s_Item);
		s_Object.m_tTriggerTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tEngageTime"], &s_Item);
		s_Object.m_tEngageTime = s_Item;
	}

	*reinterpret_cast<SCombatZoneEntitySaveData*>(p_Target) = s_Object;
}

void SCombatZoneEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLockdownTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tLockdownTime));
	ZGameTime::Serialize(&s_Object->m_tTriggerTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tTriggerTime));
	ZGameTime::Serialize(&s_Object->m_tEngageTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tEngageTime));
}

bool SCombatZoneEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatZoneEntitySaveData::operator==(const SCombatZoneEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatZoneEntitySaveData>)
		return false;

	if (m_bIsInLockdown != p_Other.m_bIsInLockdown) return false;
	if (m_bIsFalseAlarm != p_Other.m_bIsFalseAlarm) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_tLockdownTime != p_Other.m_tLockdownTime) return false;
	if (m_tTriggerTime != p_Other.m_tTriggerTime) return false;
	if (m_tEngageTime != p_Other.m_tEngageTime) return false;

	return true;
}

ZHMTypeInfo ZBehaviorTreeVariable::TypeInfo = ZHMTypeInfo("ZBehaviorTreeVariable", sizeof(ZBehaviorTreeVariable), alignof(ZBehaviorTreeVariable), ZBehaviorTreeVariable::WriteJson, ZBehaviorTreeVariable::WriteSimpleJson, ZBehaviorTreeVariable::FromSimpleJson, ZBehaviorTreeVariable::Serialize, ZBehaviorTreeVariable::Equals);

void ZBehaviorTreeVariable::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZBehaviorTreeVariable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZBehaviorTreeVariable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZBehaviorTreeVariable s_Object {};

	*reinterpret_cast<ZBehaviorTreeVariable*>(p_Target) = s_Object;
}

void ZBehaviorTreeVariable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

}

bool ZBehaviorTreeVariable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZBehaviorTreeVariable*>(p_Left);
	auto* s_Right = reinterpret_cast<ZBehaviorTreeVariable*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZBehaviorTreeVariable::operator==(const ZBehaviorTreeVariable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZBehaviorTreeVariable>)
		return false;


	return true;
}

ZHMTypeInfo SConditionBase::TypeInfo = ZHMTypeInfo("SConditionBase", sizeof(SConditionBase), alignof(SConditionBase), SConditionBase::WriteJson, SConditionBase::WriteSimpleJson, SConditionBase::FromSimpleJson, SConditionBase::Serialize, SConditionBase::Equals);

void SConditionBase::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("eConditionType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ECompiledConditionType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->eConditionType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECompiledConditionType", static_cast<int>(s_Object->eConditionType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nConditionModifiers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nConditionModifiers);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("assignTo") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZBehaviorTreeVariable") << ",\"$val\":";
	ZBehaviorTreeVariable::WriteJson(&s_Object->assignTo, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SConditionBase::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("eConditionType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECompiledConditionType", static_cast<int>(s_Object->eConditionType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nConditionModifiers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nConditionModifiers);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("assignTo") << ":";
	ZBehaviorTreeVariable::WriteSimpleJson(&s_Object->assignTo, p_Stream);

	p_Stream << "}";
}

void SConditionBase::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SConditionBase s_Object {};

	s_Object.eConditionType = static_cast<ECompiledConditionType>(ZHMEnums::GetEnumValueByName("ECompiledConditionType", std::string_view(p_Document["eConditionType"])));

	s_Object.nConditionModifiers = simdjson::from_json_uint32(p_Document["nConditionModifiers"]);

	{
		ZBehaviorTreeVariable s_Item {};
		ZBehaviorTreeVariable::FromSimpleJson(p_Document["assignTo"], &s_Item);
		s_Object.assignTo = s_Item;
	}

	*reinterpret_cast<SConditionBase*>(p_Target) = s_Object;
}

void SConditionBase::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	ZBehaviorTreeVariable::Serialize(&s_Object->assignTo, p_Serializer, p_OwnOffset + offsetof(SConditionBase, assignTo));
}

bool SConditionBase::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConditionBase*>(p_Left);
	auto* s_Right = reinterpret_cast<SConditionBase*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConditionBase::operator==(const SConditionBase& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConditionBase>)
		return false;

	if (eConditionType != p_Other.eConditionType) return false;
	if (nConditionModifiers != p_Other.nConditionModifiers) return false;
	if (assignTo != p_Other.assignTo) return false;

	return true;
}

ZHMTypeInfo SConditionalTimerEntitySaveData::TypeInfo = ZHMTypeInfo("SConditionalTimerEntitySaveData", sizeof(SConditionalTimerEntitySaveData), alignof(SConditionalTimerEntitySaveData), SConditionalTimerEntitySaveData::WriteJson, SConditionalTimerEntitySaveData::WriteSimpleJson, SConditionalTimerEntitySaveData::FromSimpleJson, SConditionalTimerEntitySaveData::Serialize, SConditionalTimerEntitySaveData::Equals);

void SConditionalTimerEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRemaining") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRemaining);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValue);
	p_Stream << "}";

	p_Stream << "}";
}

void SConditionalTimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValue);

	p_Stream << "}";
}

void SConditionalTimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SConditionalTimerEntitySaveData s_Object {};

	s_Object.m_nInterval = simdjson::from_json_int32(p_Document["m_nInterval"]);

	s_Object.m_nRemaining = simdjson::from_json_int32(p_Document["m_nRemaining"]);

	s_Object.m_bValue = simdjson::from_json_bool(p_Document["m_bValue"]);

	*reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Target) = s_Object;
}

void SConditionalTimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);

}

bool SConditionalTimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConditionalTimerEntitySaveData::operator==(const SConditionalTimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConditionalTimerEntitySaveData>)
		return false;

	if (m_nInterval != p_Other.m_nInterval) return false;
	if (m_nRemaining != p_Other.m_nRemaining) return false;
	if (m_bValue != p_Other.m_bValue) return false;

	return true;
}

ZHMTypeInfo SContextActionSaveData::TypeInfo = ZHMTypeInfo("SContextActionSaveData", sizeof(SContextActionSaveData), alignof(SContextActionSaveData), SContextActionSaveData::WriteJson, SContextActionSaveData::WriteSimpleJson, SContextActionSaveData::FromSimpleJson, SContextActionSaveData::Serialize, SContextActionSaveData::Equals);

void SContextActionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldShow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldShow);
	p_Stream << "}";

	p_Stream << "}";
}

void SContextActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldShow);

	p_Stream << "}";
}

void SContextActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContextActionSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bTriggered = simdjson::from_json_bool(p_Document["m_bTriggered"]);

	s_Object.m_bShouldShow = simdjson::from_json_bool(p_Document["m_bShouldShow"]);

	*reinterpret_cast<SContextActionSaveData*>(p_Target) = s_Object;
}

void SContextActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);

}

bool SContextActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContextActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContextActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContextActionSaveData::operator==(const SContextActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContextActionSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bTriggered != p_Other.m_bTriggered) return false;
	if (m_bShouldShow != p_Other.m_bShouldShow) return false;

	return true;
}

ZHMTypeInfo SContractConfigResourceEntry::TypeInfo = ZHMTypeInfo("SContractConfigResourceEntry", sizeof(SContractConfigResourceEntry), alignof(SContractConfigResourceEntry), SContractConfigResourceEntry::WriteJson, SContractConfigResourceEntry::WriteSimpleJson, SContractConfigResourceEntry::FromSimpleJson, SContractConfigResourceEntry::Serialize, SContractConfigResourceEntry::Equals);

void SContractConfigResourceEntry::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("Id") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->Id);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ContractRid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->ContractRid, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SContractConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ContractRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->ContractRid, p_Stream);

	p_Stream << "}";
}

void SContractConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractConfigResourceEntry s_Object {};

	s_Object.Id = std::string_view(p_Document["Id"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["ContractRid"], &s_Item);
		s_Object.ContractRid = s_Item;
	}

	*reinterpret_cast<SContractConfigResourceEntry*>(p_Target) = s_Object;
}

void SContractConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Id, p_Serializer, p_OwnOffset + offsetof(SContractConfigResourceEntry, Id));
	ZRuntimeResourceID::Serialize(&s_Object->ContractRid, p_Serializer, p_OwnOffset + offsetof(SContractConfigResourceEntry, ContractRid));
}

bool SContractConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractConfigResourceEntry::operator==(const SContractConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractConfigResourceEntry>)
		return false;

	if (Id != p_Other.Id) return false;
	if (ContractRid != p_Other.ContractRid) return false;

	return true;
}

ZHMTypeInfo SContractObjectiveHudHintEntitySaveData::TypeInfo = ZHMTypeInfo("SContractObjectiveHudHintEntitySaveData", sizeof(SContractObjectiveHudHintEntitySaveData), alignof(SContractObjectiveHudHintEntitySaveData), SContractObjectiveHudHintEntitySaveData::WriteJson, SContractObjectiveHudHintEntitySaveData::WriteSimpleJson, SContractObjectiveHudHintEntitySaveData::FromSimpleJson, SContractObjectiveHudHintEntitySaveData::Serialize, SContractObjectiveHudHintEntitySaveData::Equals);

void SContractObjectiveHudHintEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);
	p_Stream << "}";

	p_Stream << "}";
}

void SContractObjectiveHudHintEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SContractObjectiveHudHintEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractObjectiveHudHintEntitySaveData s_Object {};

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	*reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Target) = s_Object;
}

void SContractObjectiveHudHintEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);

}

bool SContractObjectiveHudHintEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractObjectiveHudHintEntitySaveData::operator==(const SContractObjectiveHudHintEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractObjectiveHudHintEntitySaveData>)
		return false;

	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

ZHMTypeInfo SContractObjectiveSaveData::TypeInfo = ZHMTypeInfo("SContractObjectiveSaveData", sizeof(SContractObjectiveSaveData), alignof(SContractObjectiveSaveData), SContractObjectiveSaveData::WriteJson, SContractObjectiveSaveData::WriteSimpleJson, SContractObjectiveSaveData::FromSimpleJson, SContractObjectiveSaveData::Serialize, SContractObjectiveSaveData::Equals);

void SContractObjectiveSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_Id") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGuid") << ",\"$val\":";
	ZGuid::WriteJson(&s_Object->m_Id, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("IContractObjective.Category") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eCategory)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Category", static_cast<int>(s_Object->m_eCategory))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompleted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFailed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFailed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsHidden") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsHidden);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sSuccessEventName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sSuccessEventName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SuccessEventValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_SuccessEventValues, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sFailedEventName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sFailedEventName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_FailedEventValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_FailedEventValues, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sResetEventName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sResetEventName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ResetEventValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_ResetEventValues, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_sBriefingText, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLongBriefingText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_sLongBriefingText, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sHUDText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_sHUDText, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iRepeatSuccess") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iRepeatSuccess);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iRepeatFailed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iRepeatFailed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iCurrentSuccess") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCurrentSuccess);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iCurrentFailed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCurrentFailed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationCondition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_ActivationCondition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_ActivationValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateActivationOnCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateActivationOnCompleted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisplayAsKill") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisplayAsKill);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreIfInactive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreIfInactive);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowInHud") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowInHud);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCombinedDisplayInHud") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCombinedDisplayInHud);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnInactive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_OnInactive, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_OnActive, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExits") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_aExits, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectiveType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectiveType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBriefingName);
	p_Stream << "}";

	p_Stream << "}";
}

void SContractObjectiveSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Id") << ":";
	ZGuid::WriteSimpleJson(&s_Object->m_Id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCategory") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Category", static_cast<int>(s_Object->m_eCategory)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sSuccessEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sSuccessEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SuccessEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_SuccessEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sFailedEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sFailedEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_FailedEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_FailedEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sResetEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sResetEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ResetEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_ResetEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLongBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sLongBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sHUDText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sHUDText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iRepeatSuccess") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iRepeatSuccess);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iRepeatFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iRepeatFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iCurrentSuccess") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCurrentSuccess);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iCurrentFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCurrentFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationCondition") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_ActivationCondition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_ActivationValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateActivationOnCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateActivationOnCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisplayAsKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisplayAsKill);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreIfInactive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreIfInactive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCombinedDisplayInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCombinedDisplayInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnInactive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnInactive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnActive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnActive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExits") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_aExits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectiveType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectiveType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBriefingName);

	p_Stream << "}";
}

void SContractObjectiveSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractObjectiveSaveData s_Object {};

	{
		ZGuid s_Item {};
		ZGuid::FromSimpleJson(p_Document["m_Id"], &s_Item);
		s_Object.m_Id = s_Item;
	}

	s_Object.m_sText = std::string_view(p_Document["m_sText"]);

	s_Object.m_eCategory = static_cast<IContractObjective_Category>(ZHMEnums::GetEnumValueByName("IContractObjective.Category", std::string_view(p_Document["m_eCategory"])));

	s_Object.m_bCompleted = simdjson::from_json_bool(p_Document["m_bCompleted"]);

	s_Object.m_bFailed = simdjson::from_json_bool(p_Document["m_bFailed"]);

	s_Object.m_bIsHidden = simdjson::from_json_bool(p_Document["m_bIsHidden"]);

	s_Object.m_sSuccessEventName = std::string_view(p_Document["m_sSuccessEventName"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_SuccessEventValues"], &s_Item);
		s_Object.m_SuccessEventValues = s_Item;
	}

	s_Object.m_sFailedEventName = std::string_view(p_Document["m_sFailedEventName"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_FailedEventValues"], &s_Item);
		s_Object.m_FailedEventValues = s_Item;
	}

	s_Object.m_sResetEventName = std::string_view(p_Document["m_sResetEventName"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_ResetEventValues"], &s_Item);
		s_Object.m_ResetEventValues = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sBriefingText"], &s_Item);
		s_Object.m_sBriefingText = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sLongBriefingText"], &s_Item);
		s_Object.m_sLongBriefingText = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sHUDText"], &s_Item);
		s_Object.m_sHUDText = s_Item;
	}

	s_Object.m_iRepeatSuccess = simdjson::from_json_int32(p_Document["m_iRepeatSuccess"]);

	s_Object.m_iRepeatFailed = simdjson::from_json_int32(p_Document["m_iRepeatFailed"]);

	s_Object.m_iCurrentSuccess = simdjson::from_json_int32(p_Document["m_iCurrentSuccess"]);

	s_Object.m_iCurrentFailed = simdjson::from_json_int32(p_Document["m_iCurrentFailed"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_ActivationCondition"], &s_Item);
		s_Object.m_ActivationCondition = s_Item;
	}

	s_Object.m_ActivationValue = simdjson::from_json_bool(p_Document["m_ActivationValue"]);

	s_Object.m_bUpdateActivationOnCompleted = simdjson::from_json_bool(p_Document["m_bUpdateActivationOnCompleted"]);

	s_Object.m_bDisplayAsKill = simdjson::from_json_bool(p_Document["m_bDisplayAsKill"]);

	s_Object.m_bIgnoreIfInactive = simdjson::from_json_bool(p_Document["m_bIgnoreIfInactive"]);

	s_Object.m_bShowInHud = simdjson::from_json_bool(p_Document["m_bShowInHud"]);

	s_Object.m_bCombinedDisplayInHud = simdjson::from_json_bool(p_Document["m_bCombinedDisplayInHud"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_OnInactive"], &s_Item);
		s_Object.m_OnInactive = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_OnActive"], &s_Item);
		s_Object.m_OnActive = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_aExits"], &s_Item);
		s_Object.m_aExits = s_Item;
	}

	s_Object.m_sImage = std::string_view(p_Document["m_sImage"]);

	s_Object.m_sObjectiveType = std::string_view(p_Document["m_sObjectiveType"]);

	s_Object.m_sBriefingName = std::string_view(p_Document["m_sBriefingName"]);

	*reinterpret_cast<SContractObjectiveSaveData*>(p_Target) = s_Object;
}

void SContractObjectiveSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);

	ZGuid::Serialize(&s_Object->m_Id, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_Id));
	ZString::Serialize(&s_Object->m_sText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sText));
	ZString::Serialize(&s_Object->m_sSuccessEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sSuccessEventName));
	ZDynamicObject::Serialize(&s_Object->m_SuccessEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_SuccessEventValues));
	ZString::Serialize(&s_Object->m_sFailedEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sFailedEventName));
	ZDynamicObject::Serialize(&s_Object->m_FailedEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_FailedEventValues));
	ZString::Serialize(&s_Object->m_sResetEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sResetEventName));
	ZDynamicObject::Serialize(&s_Object->m_ResetEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_ResetEventValues));
	ZDynamicObject::Serialize(&s_Object->m_sBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_sLongBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sLongBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_sHUDText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sHUDText));
	ZDynamicObject::Serialize(&s_Object->m_ActivationCondition, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_ActivationCondition));
	ZDynamicObject::Serialize(&s_Object->m_OnInactive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_OnInactive));
	ZDynamicObject::Serialize(&s_Object->m_OnActive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_OnActive));
	ZDynamicObject::Serialize(&s_Object->m_aExits, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_aExits));
	ZString::Serialize(&s_Object->m_sImage, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sImage));
	ZString::Serialize(&s_Object->m_sObjectiveType, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sObjectiveType));
	ZString::Serialize(&s_Object->m_sBriefingName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sBriefingName));
}

bool SContractObjectiveSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractObjectiveSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractObjectiveSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractObjectiveSaveData::operator==(const SContractObjectiveSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractObjectiveSaveData>)
		return false;

	if (m_Id != p_Other.m_Id) return false;
	if (m_sText != p_Other.m_sText) return false;
	if (m_eCategory != p_Other.m_eCategory) return false;
	if (m_bCompleted != p_Other.m_bCompleted) return false;
	if (m_bFailed != p_Other.m_bFailed) return false;
	if (m_bIsHidden != p_Other.m_bIsHidden) return false;
	if (m_sSuccessEventName != p_Other.m_sSuccessEventName) return false;
	if (m_SuccessEventValues != p_Other.m_SuccessEventValues) return false;
	if (m_sFailedEventName != p_Other.m_sFailedEventName) return false;
	if (m_FailedEventValues != p_Other.m_FailedEventValues) return false;
	if (m_sResetEventName != p_Other.m_sResetEventName) return false;
	if (m_ResetEventValues != p_Other.m_ResetEventValues) return false;
	if (m_sBriefingText != p_Other.m_sBriefingText) return false;
	if (m_sLongBriefingText != p_Other.m_sLongBriefingText) return false;
	if (m_sHUDText != p_Other.m_sHUDText) return false;
	if (m_iRepeatSuccess != p_Other.m_iRepeatSuccess) return false;
	if (m_iRepeatFailed != p_Other.m_iRepeatFailed) return false;
	if (m_iCurrentSuccess != p_Other.m_iCurrentSuccess) return false;
	if (m_iCurrentFailed != p_Other.m_iCurrentFailed) return false;
	if (m_ActivationCondition != p_Other.m_ActivationCondition) return false;
	if (m_ActivationValue != p_Other.m_ActivationValue) return false;
	if (m_bUpdateActivationOnCompleted != p_Other.m_bUpdateActivationOnCompleted) return false;
	if (m_bDisplayAsKill != p_Other.m_bDisplayAsKill) return false;
	if (m_bIgnoreIfInactive != p_Other.m_bIgnoreIfInactive) return false;
	if (m_bShowInHud != p_Other.m_bShowInHud) return false;
	if (m_bCombinedDisplayInHud != p_Other.m_bCombinedDisplayInHud) return false;
	if (m_OnInactive != p_Other.m_OnInactive) return false;
	if (m_OnActive != p_Other.m_OnActive) return false;
	if (m_aExits != p_Other.m_aExits) return false;
	if (m_sImage != p_Other.m_sImage) return false;
	if (m_sObjectiveType != p_Other.m_sObjectiveType) return false;
	if (m_sBriefingName != p_Other.m_sBriefingName) return false;

	return true;
}

ZHMTypeInfo SContractObjectiveStateMachineSaveData::TypeInfo = ZHMTypeInfo("SContractObjectiveStateMachineSaveData", sizeof(SContractObjectiveStateMachineSaveData), alignof(SContractObjectiveStateMachineSaveData), SContractObjectiveStateMachineSaveData::WriteJson, SContractObjectiveStateMachineSaveData::WriteSimpleJson, SContractObjectiveStateMachineSaveData::FromSimpleJson, SContractObjectiveStateMachineSaveData::Serialize, SContractObjectiveStateMachineSaveData::Equals);

void SContractObjectiveStateMachineSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_Id") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGuid") << ",\"$val\":";
	ZGuid::WriteJson(&s_Object->m_Id, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("IContractObjective.Category") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eCategory)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Category", static_cast<int>(s_Object->m_eCategory))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_sBriefingText, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLongBriefingText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_sLongBriefingText, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_State, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Definition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_Definition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTargets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_aTargets, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetsHidden") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetsHidden);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HUDTmpl") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_HUDTmpl, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationCondition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_ActivationCondition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivationValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivationValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateActivationOnCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateActivationOnCompleted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnInactive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_OnInactive, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_OnActive, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExits") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->m_aExits, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_timerEndTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_timerEndTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTimerHasJustStarted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTimerHasJustStarted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTimerHasJustStopped") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTimerHasJustStopped);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsActiveTimerVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsActiveTimerVisible);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisplayAsKill") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisplayAsKill);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreIfInactive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreIfInactive);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowInHud") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowInHud);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCombinedDisplayInHud") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCombinedDisplayInHud);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCounterVisibleInTile") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCounterVisibleInTile);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTargetConditions") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<IContractObjective.STargetCondition>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTargetConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTargetConditions[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("IContractObjective.STargetCondition") << ",\"$val\":";
		IContractObjective_STargetCondition::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aTargetConditions.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectiveType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectiveType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBriefingName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObjectivesCounterCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObjectivesCounterCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectivesCounterHeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectivesCounterHeader);
	p_Stream << "}";

	p_Stream << "}";
}

void SContractObjectiveStateMachineSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Id") << ":";
	ZGuid::WriteSimpleJson(&s_Object->m_Id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCategory") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Category", static_cast<int>(s_Object->m_eCategory)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLongBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sLongBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Definition") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_Definition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTargets") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_aTargets, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetsHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HUDTmpl") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_HUDTmpl, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationCondition") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_ActivationCondition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivationValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivationValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateActivationOnCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateActivationOnCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnInactive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnInactive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnActive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnActive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExits") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_aExits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_timerEndTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_timerEndTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTimerHasJustStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTimerHasJustStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTimerHasJustStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTimerHasJustStopped);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsActiveTimerVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsActiveTimerVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisplayAsKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisplayAsKill);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreIfInactive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreIfInactive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCombinedDisplayInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCombinedDisplayInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCounterVisibleInTile") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCounterVisibleInTile);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTargetConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTargetConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTargetConditions[i];
		IContractObjective_STargetCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTargetConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectiveType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectiveType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBriefingName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObjectivesCounterCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObjectivesCounterCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectivesCounterHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectivesCounterHeader);

	p_Stream << "}";
}

void SContractObjectiveStateMachineSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractObjectiveStateMachineSaveData s_Object {};

	{
		ZGuid s_Item {};
		ZGuid::FromSimpleJson(p_Document["m_Id"], &s_Item);
		s_Object.m_Id = s_Item;
	}

	s_Object.m_eCategory = static_cast<IContractObjective_Category>(ZHMEnums::GetEnumValueByName("IContractObjective.Category", std::string_view(p_Document["m_eCategory"])));

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sBriefingText"], &s_Item);
		s_Object.m_sBriefingText = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sLongBriefingText"], &s_Item);
		s_Object.m_sLongBriefingText = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_Definition"], &s_Item);
		s_Object.m_Definition = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_aTargets"], &s_Item);
		s_Object.m_aTargets = s_Item;
	}

	s_Object.m_bTargetsHidden = simdjson::from_json_bool(p_Document["m_bTargetsHidden"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_HUDTmpl"], &s_Item);
		s_Object.m_HUDTmpl = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_ActivationCondition"], &s_Item);
		s_Object.m_ActivationCondition = s_Item;
	}

	s_Object.m_bActivationValue = simdjson::from_json_bool(p_Document["m_bActivationValue"]);

	s_Object.m_bUpdateActivationOnCompleted = simdjson::from_json_bool(p_Document["m_bUpdateActivationOnCompleted"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_OnInactive"], &s_Item);
		s_Object.m_OnInactive = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_OnActive"], &s_Item);
		s_Object.m_OnActive = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_aExits"], &s_Item);
		s_Object.m_aExits = s_Item;
	}

	s_Object.m_timerEndTime = simdjson::from_json_float64(p_Document["m_timerEndTime"]);

	s_Object.m_bTimerHasJustStarted = simdjson::from_json_bool(p_Document["m_bTimerHasJustStarted"]);

	s_Object.m_bTimerHasJustStopped = simdjson::from_json_bool(p_Document["m_bTimerHasJustStopped"]);

	s_Object.m_bIsActiveTimerVisible = simdjson::from_json_bool(p_Document["m_bIsActiveTimerVisible"]);

	s_Object.m_bDisplayAsKill = simdjson::from_json_bool(p_Document["m_bDisplayAsKill"]);

	s_Object.m_bIgnoreIfInactive = simdjson::from_json_bool(p_Document["m_bIgnoreIfInactive"]);

	s_Object.m_bShowInHud = simdjson::from_json_bool(p_Document["m_bShowInHud"]);

	s_Object.m_bCombinedDisplayInHud = simdjson::from_json_bool(p_Document["m_bCombinedDisplayInHud"]);

	s_Object.m_bIsCounterVisibleInTile = simdjson::from_json_bool(p_Document["m_bIsCounterVisibleInTile"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aTargetConditions"])
	{
		IContractObjective_STargetCondition s_ArrayItem0;
		IContractObjective_STargetCondition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTargetConditions.push_back(s_ArrayItem0);
	}

	s_Object.m_sImage = std::string_view(p_Document["m_sImage"]);

	s_Object.m_sObjectiveType = std::string_view(p_Document["m_sObjectiveType"]);

	s_Object.m_sBriefingName = std::string_view(p_Document["m_sBriefingName"]);

	s_Object.m_nObjectivesCounterCount = simdjson::from_json_int32(p_Document["m_nObjectivesCounterCount"]);

	s_Object.m_sObjectivesCounterHeader = std::string_view(p_Document["m_sObjectivesCounterHeader"]);

	*reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Target) = s_Object;
}

void SContractObjectiveStateMachineSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Object);

	ZGuid::Serialize(&s_Object->m_Id, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_Id));
	ZDynamicObject::Serialize(&s_Object->m_sBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_sLongBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sLongBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_State));
	ZDynamicObject::Serialize(&s_Object->m_Definition, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_Definition));
	ZDynamicObject::Serialize(&s_Object->m_aTargets, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_aTargets));
	ZDynamicObject::Serialize(&s_Object->m_HUDTmpl, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_HUDTmpl));
	ZDynamicObject::Serialize(&s_Object->m_ActivationCondition, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_ActivationCondition));
	ZDynamicObject::Serialize(&s_Object->m_OnInactive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_OnInactive));
	ZDynamicObject::Serialize(&s_Object->m_OnActive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_OnActive));
	ZDynamicObject::Serialize(&s_Object->m_aExits, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_aExits));
	TArray<IContractObjective_STargetCondition>::Serialize(&s_Object->m_aTargetConditions, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_aTargetConditions));
	ZString::Serialize(&s_Object->m_sImage, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sImage));
	ZString::Serialize(&s_Object->m_sObjectiveType, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sObjectiveType));
	ZString::Serialize(&s_Object->m_sBriefingName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sBriefingName));
	ZString::Serialize(&s_Object->m_sObjectivesCounterHeader, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sObjectivesCounterHeader));
}

bool SContractObjectiveStateMachineSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractObjectiveStateMachineSaveData::operator==(const SContractObjectiveStateMachineSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractObjectiveStateMachineSaveData>)
		return false;

	if (m_Id != p_Other.m_Id) return false;
	if (m_eCategory != p_Other.m_eCategory) return false;
	if (m_sBriefingText != p_Other.m_sBriefingText) return false;
	if (m_sLongBriefingText != p_Other.m_sLongBriefingText) return false;
	if (m_State != p_Other.m_State) return false;
	if (m_Definition != p_Other.m_Definition) return false;
	if (m_aTargets != p_Other.m_aTargets) return false;
	if (m_bTargetsHidden != p_Other.m_bTargetsHidden) return false;
	if (m_HUDTmpl != p_Other.m_HUDTmpl) return false;
	if (m_ActivationCondition != p_Other.m_ActivationCondition) return false;
	if (m_bActivationValue != p_Other.m_bActivationValue) return false;
	if (m_bUpdateActivationOnCompleted != p_Other.m_bUpdateActivationOnCompleted) return false;
	if (m_OnInactive != p_Other.m_OnInactive) return false;
	if (m_OnActive != p_Other.m_OnActive) return false;
	if (m_aExits != p_Other.m_aExits) return false;
	if (m_timerEndTime != p_Other.m_timerEndTime) return false;
	if (m_bTimerHasJustStarted != p_Other.m_bTimerHasJustStarted) return false;
	if (m_bTimerHasJustStopped != p_Other.m_bTimerHasJustStopped) return false;
	if (m_bIsActiveTimerVisible != p_Other.m_bIsActiveTimerVisible) return false;
	if (m_bDisplayAsKill != p_Other.m_bDisplayAsKill) return false;
	if (m_bIgnoreIfInactive != p_Other.m_bIgnoreIfInactive) return false;
	if (m_bShowInHud != p_Other.m_bShowInHud) return false;
	if (m_bCombinedDisplayInHud != p_Other.m_bCombinedDisplayInHud) return false;
	if (m_bIsCounterVisibleInTile != p_Other.m_bIsCounterVisibleInTile) return false;
	if (m_aTargetConditions != p_Other.m_aTargetConditions) return false;
	if (m_sImage != p_Other.m_sImage) return false;
	if (m_sObjectiveType != p_Other.m_sObjectiveType) return false;
	if (m_sBriefingName != p_Other.m_sBriefingName) return false;
	if (m_nObjectivesCounterCount != p_Other.m_nObjectivesCounterCount) return false;
	if (m_sObjectivesCounterHeader != p_Other.m_sObjectivesCounterHeader) return false;

	return true;
}

ZHMTypeInfo SEntityTemplateProperty::TypeInfo = ZHMTypeInfo("SEntityTemplateProperty", sizeof(SEntityTemplateProperty), alignof(SEntityTemplateProperty), SEntityTemplateProperty::WriteJson, SEntityTemplateProperty::WriteSimpleJson, SEntityTemplateProperty::FromSimpleJson, SEntityTemplateProperty::Serialize, SEntityTemplateProperty::Equals);

void SEntityTemplateProperty::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("nPropertyID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nPropertyID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->value, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplateProperty::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nPropertyID") << ":";
	{
		auto s_PropertyName = ZHMProperties::PropertyToString(s_Object->nPropertyID);

		if (s_PropertyName.size() == 0)
			p_Stream << simdjson::as_json_string(s_Object->nPropertyID);
		else
			p_Stream << simdjson::as_json_string(s_PropertyName);
	}
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->value, p_Stream);

	p_Stream << "}";
}

void SEntityTemplateProperty::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateProperty s_Object {};

	if (p_Document["nPropertyID"].type() == simdjson::ondemand::json_type::string)
		s_Object.nPropertyID = Hash::Crc32(std::string_view(p_Document["nPropertyID"]));
	else
		s_Object.nPropertyID = simdjson::from_json_uint32(p_Document["nPropertyID"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["value"], &s_Item);
		s_Object.value = s_Item;
	}

	*reinterpret_cast<SEntityTemplateProperty*>(p_Target) = s_Object;
}

void SEntityTemplateProperty::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	ZVariant::Serialize(&s_Object->value, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateProperty, value));
}

bool SEntityTemplateProperty::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateProperty*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateProperty*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateProperty::operator==(const SEntityTemplateProperty& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateProperty>)
		return false;

	if (nPropertyID != p_Other.nPropertyID) return false;
	if (value != p_Other.value) return false;

	return true;
}

ZHMTypeInfo SCppEntity::TypeInfo = ZHMTypeInfo("SCppEntity", sizeof(SCppEntity), alignof(SCppEntity), SCppEntity::WriteJson, SCppEntity::WriteSimpleJson, SCppEntity::FromSimpleJson, SCppEntity::Serialize, SCppEntity::Equals);

void SCppEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplateProperty>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateProperty") << ",\"$val\":";
		SEntityTemplateProperty::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCppEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntity s_Object {};

	s_Object.blueprintIndexInResourceHeader = simdjson::from_json_int32(p_Document["blueprintIndexInResourceHeader"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["propertyValues"])
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyValues.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCppEntity*>(p_Target) = s_Object;
}

void SCppEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(SCppEntity, propertyValues));
}

bool SCppEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntity::operator==(const SCppEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntity>)
		return false;

	if (blueprintIndexInResourceHeader != p_Other.blueprintIndexInResourceHeader) return false;
	if (propertyValues != p_Other.propertyValues) return false;

	return true;
}

ZHMTypeInfo SCppEntitySubsetInfo::TypeInfo = ZHMTypeInfo("SCppEntitySubsetInfo", sizeof(SCppEntitySubsetInfo), alignof(SCppEntitySubsetInfo), SCppEntitySubsetInfo::WriteJson, SCppEntitySubsetInfo::WriteSimpleJson, SCppEntitySubsetInfo::FromSimpleJson, SCppEntitySubsetInfo::Serialize, SCppEntitySubsetInfo::Equals);

void SCppEntitySubsetInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("name") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->name);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("flags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->flags);
	p_Stream << "}";

	p_Stream << "}";
}

void SCppEntitySubsetInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("name") << ":";
	p_Stream << simdjson::as_json_string(s_Object->name);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("flags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->flags);

	p_Stream << "}";
}

void SCppEntitySubsetInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntitySubsetInfo s_Object {};

	s_Object.name = std::string_view(p_Document["name"]);

	s_Object.flags = simdjson::from_json_uint32(p_Document["flags"]);

	*reinterpret_cast<SCppEntitySubsetInfo*>(p_Target) = s_Object;
}

void SCppEntitySubsetInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	ZString::Serialize(&s_Object->name, p_Serializer, p_OwnOffset + offsetof(SCppEntitySubsetInfo, name));
}

bool SCppEntitySubsetInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntitySubsetInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntitySubsetInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntitySubsetInfo::operator==(const SCppEntitySubsetInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntitySubsetInfo>)
		return false;

	if (name != p_Other.name) return false;
	if (flags != p_Other.flags) return false;

	return true;
}

ZHMTypeInfo SCppEntityBlueprint::TypeInfo = ZHMTypeInfo("SCppEntityBlueprint", sizeof(SCppEntityBlueprint), alignof(SCppEntityBlueprint), SCppEntityBlueprint::WriteJson, SCppEntityBlueprint::WriteSimpleJson, SCppEntityBlueprint::FromSimpleJson, SCppEntityBlueprint::Serialize, SCppEntityBlueprint::Equals);

void SCppEntityBlueprint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("typeName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TypeID") << ",\"$val\":";
	TypeID::WriteJson(&s_Object->typeName, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subsets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCppEntitySubsetInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->subsets[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCppEntitySubsetInfo") << ",\"$val\":";
		SCppEntitySubsetInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->subsets.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCppEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("typeName") << ":";
	TypeID::WriteSimpleJson(&s_Object->typeName, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->subsets[i];
		SCppEntitySubsetInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->subsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntityBlueprint s_Object {};

	{
		TypeID s_Item {};
		TypeID::FromSimpleJson(p_Document["typeName"], &s_Item);
		s_Object.typeName = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["subsets"])
	{
		SCppEntitySubsetInfo s_ArrayItem0;
		SCppEntitySubsetInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.subsets.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCppEntityBlueprint*>(p_Target) = s_Object;
}

void SCppEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	TypeID::Serialize(&s_Object->typeName, p_Serializer, p_OwnOffset + offsetof(SCppEntityBlueprint, typeName));
	TArray<SCppEntitySubsetInfo>::Serialize(&s_Object->subsets, p_Serializer, p_OwnOffset + offsetof(SCppEntityBlueprint, subsets));
}

bool SCppEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntityBlueprint::operator==(const SCppEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntityBlueprint>)
		return false;

	if (typeName != p_Other.typeName) return false;
	if (subsets != p_Other.subsets) return false;

	return true;
}

ZHMTypeInfo SCrimeSceneSaveData::TypeInfo = ZHMTypeInfo("SCrimeSceneSaveData", sizeof(SCrimeSceneSaveData), alignof(SCrimeSceneSaveData), SCrimeSceneSaveData::WriteJson, SCrimeSceneSaveData::WriteSimpleJson, SCrimeSceneSaveData::FromSimpleJson, SCrimeSceneSaveData::Serialize, SCrimeSceneSaveData::Equals);

void SCrimeSceneSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vPos") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPos, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStart, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSharedKnowledge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSharedKnowledge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMaxSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMaxSize);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspicionZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspicionZone);
	p_Stream << "}";

	p_Stream << "}";
}

void SCrimeSceneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPos") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPos, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSharedKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSharedKnowledge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMaxSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMaxSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspicionZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspicionZone);

	p_Stream << "}";
}

void SCrimeSceneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrimeSceneSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPos"], &s_Item);
		s_Object.m_vPos = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Item);
		s_Object.m_tStart = s_Item;
	}

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object.m_rSharedKnowledge = simdjson::from_json_int32(p_Document["m_rSharedKnowledge"]);

	s_Object.m_fMaxSize = simdjson::from_json_float32(p_Document["m_fMaxSize"]);

	s_Object.m_bSuspicionZone = simdjson::from_json_bool(p_Document["m_bSuspicionZone"]);

	*reinterpret_cast<SCrimeSceneSaveData*>(p_Target) = s_Object;
}

void SCrimeSceneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPos, p_Serializer, p_OwnOffset + offsetof(SCrimeSceneSaveData, m_vPos));
	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SCrimeSceneSaveData, m_tStart));
}

bool SCrimeSceneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrimeSceneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrimeSceneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrimeSceneSaveData::operator==(const SCrimeSceneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrimeSceneSaveData>)
		return false;

	if (m_vPos != p_Other.m_vPos) return false;
	if (m_tStart != p_Other.m_tStart) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_rSharedKnowledge != p_Other.m_rSharedKnowledge) return false;
	if (m_fMaxSize != p_Other.m_fMaxSize) return false;
	if (m_bSuspicionZone != p_Other.m_bSuspicionZone) return false;

	return true;
}

ZHMTypeInfo SCrimeSceneServiceSaveData::TypeInfo = ZHMTypeInfo("SCrimeSceneServiceSaveData", sizeof(SCrimeSceneServiceSaveData), alignof(SCrimeSceneServiceSaveData), SCrimeSceneServiceSaveData::WriteJson, SCrimeSceneServiceSaveData::WriteSimpleJson, SCrimeSceneServiceSaveData::FromSimpleJson, SCrimeSceneServiceSaveData::Serialize, SCrimeSceneServiceSaveData::Equals);

void SCrimeSceneServiceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aCrimeScenes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrimeSceneSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrimeScenes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrimeScenes[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrimeSceneSaveData") << ",\"$val\":";
		SCrimeSceneSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aCrimeScenes.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrimeSceneServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCrimeScenes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrimeScenes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrimeScenes[i];
		SCrimeSceneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCrimeScenes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrimeSceneServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrimeSceneServiceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCrimeScenes"])
	{
		SCrimeSceneSaveData s_ArrayItem0;
		SCrimeSceneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aCrimeScenes.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Target) = s_Object;
}

void SCrimeSceneServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Object);

	TArray<SCrimeSceneSaveData>::Serialize(&s_Object->m_aCrimeScenes, p_Serializer, p_OwnOffset + offsetof(SCrimeSceneServiceSaveData, m_aCrimeScenes));
}

bool SCrimeSceneServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrimeSceneServiceSaveData::operator==(const SCrimeSceneServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrimeSceneServiceSaveData>)
		return false;

	if (m_aCrimeScenes != p_Other.m_aCrimeScenes) return false;

	return true;
}

ZHMTypeInfo SCrowdActivitySaveData::TypeInfo = ZHMTypeInfo("SCrowdActivitySaveData", sizeof(SCrowdActivitySaveData), alignof(SCrowdActivitySaveData), SCrowdActivitySaveData::WriteJson, SCrowdActivitySaveData::WriteSimpleJson, SCrowdActivitySaveData::FromSimpleJson, SCrowdActivitySaveData::Serialize, SCrowdActivitySaveData::Equals);

void SCrowdActivitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGait") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EGait") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eGait)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_eGait))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxEnterDelaySec") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxEnterDelaySec);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxLeaveDelaySec") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxLeaveDelaySec);
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdActivitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGait") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_eGait)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxEnterDelaySec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxEnterDelaySec);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxLeaveDelaySec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxLeaveDelaySec);

	p_Stream << "}";
}

void SCrowdActivitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdActivitySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_eGait = static_cast<EGait>(ZHMEnums::GetEnumValueByName("EGait", std::string_view(p_Document["m_eGait"])));

	s_Object.m_nMaxEnterDelaySec = simdjson::from_json_float32(p_Document["m_nMaxEnterDelaySec"]);

	s_Object.m_nMaxLeaveDelaySec = simdjson::from_json_float32(p_Document["m_nMaxLeaveDelaySec"]);

	*reinterpret_cast<SCrowdActivitySaveData*>(p_Target) = s_Object;
}

void SCrowdActivitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);

}

bool SCrowdActivitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdActivitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdActivitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdActivitySaveData::operator==(const SCrowdActivitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdActivitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_eGait != p_Other.m_eGait) return false;
	if (m_nMaxEnterDelaySec != p_Other.m_nMaxEnterDelaySec) return false;
	if (m_nMaxLeaveDelaySec != p_Other.m_nMaxLeaveDelaySec) return false;

	return true;
}

ZHMTypeInfo SCrowdActorSaveData::TypeInfo = ZHMTypeInfo("SCrowdActorSaveData", sizeof(SCrowdActorSaveData), alignof(SCrowdActorSaveData), SCrowdActorSaveData::WriteJson, SCrowdActorSaveData::WriteSimpleJson, SCrowdActorSaveData::FromSimpleJson, SCrowdActorSaveData::Serialize, SCrowdActorSaveData::Equals);

void SCrowdActorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eWantedSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ESpeed") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eWantedSpeed)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESpeed", static_cast<int>(s_Object->m_eWantedSpeed))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eWantedGait") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EGait") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eWantedGait)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_eWantedGait))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAnimSourceID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAnimSourceID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAnimSourceIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAnimSourceIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vForward") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vForward, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpeed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMood") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("CrowdUtil.ECrowdActorMood") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eMood)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("CrowdUtil.ECrowdActorMood", static_cast<int>(s_Object->m_eMood))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eWantedSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESpeed", static_cast<int>(s_Object->m_eWantedSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eWantedGait") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_eWantedGait)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAnimSourceID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAnimSourceID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAnimSourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAnimSourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vForward") << ":";
	float4::WriteSimpleJson(&s_Object->m_vForward, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMood") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("CrowdUtil.ECrowdActorMood", static_cast<int>(s_Object->m_eMood)));

	p_Stream << "}";
}

void SCrowdActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdActorSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_eWantedSpeed = static_cast<ESpeed>(ZHMEnums::GetEnumValueByName("ESpeed", std::string_view(p_Document["m_eWantedSpeed"])));

	s_Object.m_eWantedGait = static_cast<EGait>(ZHMEnums::GetEnumValueByName("EGait", std::string_view(p_Document["m_eWantedGait"])));

	s_Object.m_nAnimSourceID = simdjson::from_json_uint32(p_Document["m_nAnimSourceID"]);

	s_Object.m_nAnimSourceIndex = simdjson::from_json_uint32(p_Document["m_nAnimSourceIndex"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vForward"], &s_Item);
		s_Object.m_vForward = s_Item;
	}

	s_Object.m_fSpeed = simdjson::from_json_float32(p_Document["m_fSpeed"]);

	s_Object.m_eMood = static_cast<CrowdUtil_ECrowdActorMood>(ZHMEnums::GetEnumValueByName("CrowdUtil.ECrowdActorMood", std::string_view(p_Document["m_eMood"])));

	*reinterpret_cast<SCrowdActorSaveData*>(p_Target) = s_Object;
}

void SCrowdActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SCrowdActorSaveData, m_vPosition));
	float4::Serialize(&s_Object->m_vForward, p_Serializer, p_OwnOffset + offsetof(SCrowdActorSaveData, m_vForward));
}

bool SCrowdActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdActorSaveData::operator==(const SCrowdActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdActorSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_eWantedSpeed != p_Other.m_eWantedSpeed) return false;
	if (m_eWantedGait != p_Other.m_eWantedGait) return false;
	if (m_nAnimSourceID != p_Other.m_nAnimSourceID) return false;
	if (m_nAnimSourceIndex != p_Other.m_nAnimSourceIndex) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vForward != p_Other.m_vForward) return false;
	if (m_fSpeed != p_Other.m_fSpeed) return false;
	if (m_eMood != p_Other.m_eMood) return false;

	return true;
}

ZHMTypeInfo SCrowdBodySaveData::TypeInfo = ZHMTypeInfo("SCrowdBodySaveData", sizeof(SCrowdBodySaveData), alignof(SCrowdBodySaveData), SCrowdBodySaveData::WriteJson, SCrowdBodySaveData::WriteSimpleJson, SCrowdBodySaveData::FromSimpleJson, SCrowdBodySaveData::Serialize, SCrowdBodySaveData::Equals);

void SCrowdBodySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pCorpseBodybagEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCorpseBodybagEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCrowdEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCrowdEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iActorIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iActorIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPerceptibleEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPerceptibleEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKnownBy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKnownBy.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKnownBy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aKnownBy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStart, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bManaged") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bManaged);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBagSharedKnowledge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBagSharedKnowledge);
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pCorpseBodybagEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCorpseBodybagEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCrowdEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCrowdEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iActorIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPerceptibleEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPerceptibleEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKnownBy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKnownBy.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKnownBy[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKnownBy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bManaged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bManaged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBagSharedKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBagSharedKnowledge);

	p_Stream << "}";
}

void SCrowdBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdBodySaveData s_Object {};

	s_Object.m_pCorpseBodybagEntity = simdjson::from_json_uint32(p_Document["m_pCorpseBodybagEntity"]);

	s_Object.m_rCrowdEntity = simdjson::from_json_uint32(p_Document["m_rCrowdEntity"]);

	s_Object.m_iActorIndex = simdjson::from_json_uint16(p_Document["m_iActorIndex"]);

	s_Object.m_rPerceptibleEntity = simdjson::from_json_uint32(p_Document["m_rPerceptibleEntity"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aKnownBy"])
	{
		s_Object.m_aKnownBy.push_back(simdjson::from_json_uint32(s_Item0));
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Item);
		s_Object.m_tStart = s_Item;
	}

	s_Object.m_bManaged = simdjson::from_json_bool(p_Document["m_bManaged"]);

	s_Object.m_rBagSharedKnowledge = simdjson::from_json_int32(p_Document["m_rBagSharedKnowledge"]);

	*reinterpret_cast<SCrowdBodySaveData*>(p_Target) = s_Object;
}

void SCrowdBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aKnownBy, p_Serializer, p_OwnOffset + offsetof(SCrowdBodySaveData, m_aKnownBy));
	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SCrowdBodySaveData, m_tStart));
}

bool SCrowdBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdBodySaveData::operator==(const SCrowdBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdBodySaveData>)
		return false;

	if (m_pCorpseBodybagEntity != p_Other.m_pCorpseBodybagEntity) return false;
	if (m_rCrowdEntity != p_Other.m_rCrowdEntity) return false;
	if (m_iActorIndex != p_Other.m_iActorIndex) return false;
	if (m_rPerceptibleEntity != p_Other.m_rPerceptibleEntity) return false;
	if (m_aKnownBy != p_Other.m_aKnownBy) return false;
	if (m_tStart != p_Other.m_tStart) return false;
	if (m_bManaged != p_Other.m_bManaged) return false;
	if (m_rBagSharedKnowledge != p_Other.m_rBagSharedKnowledge) return false;

	return true;
}

ZHMTypeInfo SCrowdCells::TypeInfo = ZHMTypeInfo("SCrowdCells", sizeof(SCrowdCells), alignof(SCrowdCells), SCrowdCells::WriteJson, SCrowdCells::WriteSimpleJson, SCrowdCells::FromSimpleJson, SCrowdCells::Serialize, SCrowdCells::Equals);

void SCrowdCells::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_cells") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cells.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cells[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_cells.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdCells::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_cells") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cells.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cells[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_cells.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdCells::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdCells s_Object {};

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_cells"])
	{
		s_Object.m_cells[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

	*reinterpret_cast<SCrowdCells*>(p_Target) = s_Object;
}

void SCrowdCells::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	TFixedArray<uint8, 128>::Serialize(&s_Object->m_cells, p_Serializer, p_OwnOffset + offsetof(SCrowdCells, m_cells));
}

bool SCrowdCells::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdCells*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdCells*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdCells::operator==(const SCrowdCells& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdCells>)
		return false;

	if (m_cells != p_Other.m_cells) return false;

	return true;
}

ZHMTypeInfo SCrowdPoseBoneSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseBoneSaveData", sizeof(SCrowdPoseBoneSaveData), alignof(SCrowdPoseBoneSaveData), SCrowdPoseBoneSaveData::WriteJson, SCrowdPoseBoneSaveData::WriteSimpleJson, SCrowdPoseBoneSaveData::FromSimpleJson, SCrowdPoseBoneSaveData::Serialize, SCrowdPoseBoneSaveData::Equals);

void SCrowdPoseBoneSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->mTranslation, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdPoseBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SCrowdPoseBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdPoseBoneSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Item);
		s_Object.mQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Item);
		s_Object.mTranslation = s_Item;
	}

	*reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Target) = s_Object;
}

void SCrowdPoseBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseBoneSaveData, mTranslation));
}

bool SCrowdPoseBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseBoneSaveData::operator==(const SCrowdPoseBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

ZHMTypeInfo SCrowdPoseSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseSaveData", sizeof(SCrowdPoseSaveData), alignof(SCrowdPoseSaveData), SCrowdPoseSaveData::WriteJson, SCrowdPoseSaveData::WriteSimpleJson, SCrowdPoseSaveData::FromSimpleJson, SCrowdPoseSaveData::Serialize, SCrowdPoseSaveData::Equals);

void SCrowdPoseSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdPoseBoneSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdPoseBoneSaveData") << ",\"$val\":";
		SCrowdPoseBoneSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdPoseSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SCrowdPoseBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdPoseSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdPoseSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBones"])
	{
		SCrowdPoseBoneSaveData s_ArrayItem0;
		SCrowdPoseBoneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBones.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCrowdPoseSaveData*>(p_Target) = s_Object;
}

void SCrowdPoseSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);

	TArray<SCrowdPoseBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseSaveData, m_aBones));
}

bool SCrowdPoseSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseSaveData::operator==(const SCrowdPoseSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseSaveData>)
		return false;

	if (m_aBones != p_Other.m_aBones) return false;

	return true;
}

ZHMTypeInfo SCrowdPoseCollectionSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseCollectionSaveData", sizeof(SCrowdPoseCollectionSaveData), alignof(SCrowdPoseCollectionSaveData), SCrowdPoseCollectionSaveData::WriteJson, SCrowdPoseCollectionSaveData::WriteSimpleJson, SCrowdPoseCollectionSaveData::FromSimpleJson, SCrowdPoseCollectionSaveData::Serialize, SCrowdPoseCollectionSaveData::Equals);

void SCrowdPoseCollectionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_id") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_id);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPoses") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdPoseSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPoses.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPoses[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdPoseSaveData") << ",\"$val\":";
		SCrowdPoseSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aPoses.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdPoseCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPoses") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPoses.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPoses[i];
		SCrowdPoseSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPoses.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdPoseCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdPoseCollectionSaveData s_Object {};

	s_Object.m_id = simdjson::from_json_uint64(p_Document["m_id"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aPoses"])
	{
		SCrowdPoseSaveData s_ArrayItem0;
		SCrowdPoseSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aPoses.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Target) = s_Object;
}

void SCrowdPoseCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);

	TArray<SCrowdPoseSaveData>::Serialize(&s_Object->m_aPoses, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseCollectionSaveData, m_aPoses));
}

bool SCrowdPoseCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseCollectionSaveData::operator==(const SCrowdPoseCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseCollectionSaveData>)
		return false;

	if (m_id != p_Other.m_id) return false;
	if (m_aPoses != p_Other.m_aPoses) return false;

	return true;
}

ZHMTypeInfo SCrowdDeadPoseRepositorySaveData::TypeInfo = ZHMTypeInfo("SCrowdDeadPoseRepositorySaveData", sizeof(SCrowdDeadPoseRepositorySaveData), alignof(SCrowdDeadPoseRepositorySaveData), SCrowdDeadPoseRepositorySaveData::WriteJson, SCrowdDeadPoseRepositorySaveData::WriteSimpleJson, SCrowdDeadPoseRepositorySaveData::FromSimpleJson, SCrowdDeadPoseRepositorySaveData::Serialize, SCrowdDeadPoseRepositorySaveData::Equals);

void SCrowdDeadPoseRepositorySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aPoseCollections") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdPoseCollectionSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPoseCollections.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPoseCollections[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdPoseCollectionSaveData") << ",\"$val\":";
		SCrowdPoseCollectionSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aPoseCollections.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdDeadPoseRepositorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aPoseCollections") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPoseCollections.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPoseCollections[i];
		SCrowdPoseCollectionSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPoseCollections.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdDeadPoseRepositorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdDeadPoseRepositorySaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aPoseCollections"])
	{
		SCrowdPoseCollectionSaveData s_ArrayItem0;
		SCrowdPoseCollectionSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aPoseCollections.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Target) = s_Object;
}

void SCrowdDeadPoseRepositorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);

	TArray<SCrowdPoseCollectionSaveData>::Serialize(&s_Object->m_aPoseCollections, p_Serializer, p_OwnOffset + offsetof(SCrowdDeadPoseRepositorySaveData, m_aPoseCollections));
}

bool SCrowdDeadPoseRepositorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdDeadPoseRepositorySaveData::operator==(const SCrowdDeadPoseRepositorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdDeadPoseRepositorySaveData>)
		return false;

	if (m_aPoseCollections != p_Other.m_aPoseCollections) return false;

	return true;
}

ZHMTypeInfo SRegionSaveData::TypeInfo = ZHMTypeInfo("SRegionSaveData", sizeof(SRegionSaveData), alignof(SRegionSaveData), SRegionSaveData::WriteJson, SRegionSaveData::WriteSimpleJson, SRegionSaveData::FromSimpleJson, SRegionSaveData::Serialize, SRegionSaveData::Equals);

void SRegionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("CrowdRegionType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("CrowdRegionType", static_cast<int>(s_Object->m_eType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCenter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vCenter, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDirection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDirection);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRadius") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRadius);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLifetime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLifetime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleActorIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleActorIndex);
	p_Stream << "}";

	p_Stream << "}";
}

void SRegionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("CrowdRegionType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCenter") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDirection") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDirection);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRadius);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLifetime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLifetime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleActorIndex);

	p_Stream << "}";
}

void SRegionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRegionSaveData s_Object {};

	s_Object.m_nIndex = simdjson::from_json_uint32(p_Document["m_nIndex"]);

	s_Object.m_eType = static_cast<CrowdRegionType>(ZHMEnums::GetEnumValueByName("CrowdRegionType", std::string_view(p_Document["m_eType"])));

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vCenter"], &s_Item);
		s_Object.m_vCenter = s_Item;
	}

	s_Object.m_nDirection = simdjson::from_json_float32(p_Document["m_nDirection"]);

	s_Object.m_nRadius = simdjson::from_json_float32(p_Document["m_nRadius"]);

	s_Object.m_nAngle = simdjson::from_json_uint32(p_Document["m_nAngle"]);

	s_Object.m_nLifetime = simdjson::from_json_float32(p_Document["m_nLifetime"]);

	s_Object.m_nAge = simdjson::from_json_float32(p_Document["m_nAge"]);

	s_Object.m_nGroupID = simdjson::from_json_uint8(p_Document["m_nGroupID"]);

	s_Object.m_nObstacleActorIndex = simdjson::from_json_int16(p_Document["m_nObstacleActorIndex"]);

	*reinterpret_cast<SRegionSaveData*>(p_Target) = s_Object;
}

void SRegionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vCenter, p_Serializer, p_OwnOffset + offsetof(SRegionSaveData, m_vCenter));
}

bool SRegionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRegionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRegionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRegionSaveData::operator==(const SRegionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRegionSaveData>)
		return false;

	if (m_nIndex != p_Other.m_nIndex) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_vCenter != p_Other.m_vCenter) return false;
	if (m_nDirection != p_Other.m_nDirection) return false;
	if (m_nRadius != p_Other.m_nRadius) return false;
	if (m_nAngle != p_Other.m_nAngle) return false;
	if (m_nLifetime != p_Other.m_nLifetime) return false;
	if (m_nAge != p_Other.m_nAge) return false;
	if (m_nGroupID != p_Other.m_nGroupID) return false;
	if (m_nObstacleActorIndex != p_Other.m_nObstacleActorIndex) return false;

	return true;
}

ZHMTypeInfo SCrowdEntitySaveData::TypeInfo = ZHMTypeInfo("SCrowdEntitySaveData", sizeof(SCrowdEntitySaveData), alignof(SCrowdEntitySaveData), SCrowdEntitySaveData::WriteJson, SCrowdEntitySaveData::WriteSimpleJson, SCrowdEntitySaveData::FromSimpleJson, SCrowdEntitySaveData::Serialize, SCrowdEntitySaveData::Equals);

void SCrowdEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_CrowdActorData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdActorSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CrowdActorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CrowdActorData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdActorSaveData") << ",\"$val\":";
		SCrowdActorSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_CrowdActorData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RegionData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SRegionSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_RegionData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_RegionData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SRegionSaveData") << ",\"$val\":";
		SRegionSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_RegionData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCrowdAmbient") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCrowdAmbient);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DeadPoseRepository") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdDeadPoseRepositorySaveData") << ",\"$val\":";
	SCrowdDeadPoseRepositorySaveData::WriteJson(&s_Object->m_DeadPoseRepository, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCrowdAiPoolActorsMale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrowdAiPoolActorsMale.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrowdAiPoolActorsMale[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aCrowdAiPoolActorsMale.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCrowdAiPoolActorsFemale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrowdAiPoolActorsFemale.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrowdAiPoolActorsFemale[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aCrowdAiPoolActorsFemale.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CrowdActorData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CrowdActorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CrowdActorData[i];
		SCrowdActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CrowdActorData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RegionData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_RegionData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_RegionData[i];
		SRegionSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_RegionData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCrowdAmbient") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCrowdAmbient);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DeadPoseRepository") << ":";
	SCrowdDeadPoseRepositorySaveData::WriteSimpleJson(&s_Object->m_DeadPoseRepository, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCrowdAiPoolActorsMale") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrowdAiPoolActorsMale.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrowdAiPoolActorsMale[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCrowdAiPoolActorsMale.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCrowdAiPoolActorsFemale") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrowdAiPoolActorsFemale.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrowdAiPoolActorsFemale[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCrowdAiPoolActorsFemale.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdEntitySaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_CrowdActorData"])
	{
		SCrowdActorSaveData s_ArrayItem0;
		SCrowdActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CrowdActorData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_RegionData"])
	{
		SRegionSaveData s_ArrayItem0;
		SRegionSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_RegionData.push_back(s_ArrayItem0);
	}

	s_Object.m_bIsCrowdAmbient = simdjson::from_json_bool(p_Document["m_bIsCrowdAmbient"]);

	{
		SCrowdDeadPoseRepositorySaveData s_Item {};
		SCrowdDeadPoseRepositorySaveData::FromSimpleJson(p_Document["m_DeadPoseRepository"], &s_Item);
		s_Object.m_DeadPoseRepository = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCrowdAiPoolActorsMale"])
	{
		s_Object.m_aCrowdAiPoolActorsMale.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCrowdAiPoolActorsFemale"])
	{
		s_Object.m_aCrowdAiPoolActorsFemale.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SCrowdEntitySaveData*>(p_Target) = s_Object;
}

void SCrowdEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);

	TArray<SCrowdActorSaveData>::Serialize(&s_Object->m_CrowdActorData, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_CrowdActorData));
	TArray<SRegionSaveData>::Serialize(&s_Object->m_RegionData, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_RegionData));
	SCrowdDeadPoseRepositorySaveData::Serialize(&s_Object->m_DeadPoseRepository, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_DeadPoseRepository));
	TArray<uint32>::Serialize(&s_Object->m_aCrowdAiPoolActorsMale, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_aCrowdAiPoolActorsMale));
	TArray<uint32>::Serialize(&s_Object->m_aCrowdAiPoolActorsFemale, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_aCrowdAiPoolActorsFemale));
}

bool SCrowdEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdEntitySaveData::operator==(const SCrowdEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdEntitySaveData>)
		return false;

	if (m_CrowdActorData != p_Other.m_CrowdActorData) return false;
	if (m_RegionData != p_Other.m_RegionData) return false;
	if (m_bIsCrowdAmbient != p_Other.m_bIsCrowdAmbient) return false;
	if (m_DeadPoseRepository != p_Other.m_DeadPoseRepository) return false;
	if (m_aCrowdAiPoolActorsMale != p_Other.m_aCrowdAiPoolActorsMale) return false;
	if (m_aCrowdAiPoolActorsFemale != p_Other.m_aCrowdAiPoolActorsFemale) return false;

	return true;
}

ZHMTypeInfo SCrowdFlowChannel::TypeInfo = ZHMTypeInfo("SCrowdFlowChannel", sizeof(SCrowdFlowChannel), alignof(SCrowdFlowChannel), SCrowdFlowChannel::WriteJson, SCrowdFlowChannel::WriteSimpleJson, SCrowdFlowChannel::FromSimpleJson, SCrowdFlowChannel::Serialize, SCrowdFlowChannel::Equals);

void SCrowdFlowChannel::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aFlowVectorIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowVectorIndex.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowVectorIndex[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aFlowVectorIndex.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowCost") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowCost.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowCost[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aFlowCost.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdFlowChannel::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aFlowVectorIndex") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowVectorIndex.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowVectorIndex[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFlowVectorIndex.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowCost") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowCost.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowCost[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFlowCost.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdFlowChannel::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdFlowChannel s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aFlowVectorIndex"])
	{
		s_Object.m_aFlowVectorIndex.push_back(simdjson::from_json_uint8(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aFlowCost"])
	{
		s_Object.m_aFlowCost.push_back(simdjson::from_json_uint16(s_Item0));
	}

	*reinterpret_cast<SCrowdFlowChannel*>(p_Target) = s_Object;
}

void SCrowdFlowChannel::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aFlowVectorIndex, p_Serializer, p_OwnOffset + offsetof(SCrowdFlowChannel, m_aFlowVectorIndex));
	TArray<uint16>::Serialize(&s_Object->m_aFlowCost, p_Serializer, p_OwnOffset + offsetof(SCrowdFlowChannel, m_aFlowCost));
}

bool SCrowdFlowChannel::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdFlowChannel*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdFlowChannel*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdFlowChannel::operator==(const SCrowdFlowChannel& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdFlowChannel>)
		return false;

	if (m_aFlowVectorIndex != p_Other.m_aFlowVectorIndex) return false;
	if (m_aFlowCost != p_Other.m_aFlowCost) return false;

	return true;
}

ZHMTypeInfo ZCrowdGridPoint::TypeInfo = ZHMTypeInfo("ZCrowdGridPoint", sizeof(ZCrowdGridPoint), alignof(ZCrowdGridPoint), ZCrowdGridPoint::WriteJson, ZCrowdGridPoint::WriteSimpleJson, ZCrowdGridPoint::FromSimpleJson, ZCrowdGridPoint::Serialize, ZCrowdGridPoint::Equals);

void ZCrowdGridPoint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nHeightOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHeightOffset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOnNavGrid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOnNavGrid);
	p_Stream << "}";

	p_Stream << "}";
}

void ZCrowdGridPoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nHeightOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHeightOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOnNavGrid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOnNavGrid);

	p_Stream << "}";
}

void ZCrowdGridPoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZCrowdGridPoint s_Object {};

	s_Object.m_nHeightOffset = simdjson::from_json_int16(p_Document["m_nHeightOffset"]);

	s_Object.m_nOnNavGrid = simdjson::from_json_uint8(p_Document["m_nOnNavGrid"]);

	*reinterpret_cast<ZCrowdGridPoint*>(p_Target) = s_Object;
}

void ZCrowdGridPoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

}

bool ZCrowdGridPoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCrowdGridPoint*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCrowdGridPoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCrowdGridPoint::operator==(const ZCrowdGridPoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCrowdGridPoint>)
		return false;

	if (m_nHeightOffset != p_Other.m_nHeightOffset) return false;
	if (m_nOnNavGrid != p_Other.m_nOnNavGrid) return false;

	return true;
}

ZHMTypeInfo SCrowdMapData::TypeInfo = ZHMTypeInfo("SCrowdMapData", sizeof(SCrowdMapData), alignof(SCrowdMapData), SCrowdMapData::WriteJson, SCrowdMapData::WriteSimpleJson, SCrowdMapData::FromSimpleJson, SCrowdMapData::Serialize, SCrowdMapData::Equals);

void SCrowdMapData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCellConsts") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vCellConsts, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeX") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeX);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeY") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeY);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeX") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeX);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeY") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeY);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GridMap") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZCrowdGridPoint>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_GridMap.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_GridMap[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZCrowdGridPoint") << ",\"$val\":";
		ZCrowdGridPoint::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_GridMap.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsScale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsScale);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsBias") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsBias);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellFlags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdCells>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellFlags.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellFlags[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdCells") << ",\"$val\":";
		SCrowdCells::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_CellFlags.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdCells>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdCells") << ",\"$val\":";
		SCrowdCells::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_CellGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupFlowStartChannel") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupFlowStartChannel);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowChannels") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdFlowChannel>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowChannels.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowChannels[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdFlowChannel") << ",\"$val\":";
		SCrowdFlowChannel::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aFlowChannels.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCellSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCellSize);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mObjectToWorld") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMatrix") << ",\"$val\":";
	SMatrix::WriteJson(&s_Object->m_mObjectToWorld, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vGlobalSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vGlobalSize, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridGeneratorOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridGeneratorOffset);
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdMapData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCellConsts") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vCellConsts, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GridMap") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_GridMap.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_GridMap[i];
		ZCrowdGridPoint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_GridMap.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsBias") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsBias);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellFlags") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellFlags.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellFlags[i];
		SCrowdCells::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CellFlags.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellGroups[i];
		SCrowdCells::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CellGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupFlowStartChannel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupFlowStartChannel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowChannels") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowChannels.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowChannels[i];
		SCrowdFlowChannel::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aFlowChannels.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCellSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCellSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mObjectToWorld") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mObjectToWorld, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vGlobalSize") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vGlobalSize, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridGeneratorOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridGeneratorOffset);

	p_Stream << "}";
}

void SCrowdMapData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdMapData s_Object {};

	s_Object.m_nVersion = simdjson::from_json_uint32(p_Document["m_nVersion"]);

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vCellConsts"], &s_Item);
		s_Object.m_vCellConsts = s_Item;
	}

	s_Object.m_nGridSizeX = simdjson::from_json_uint32(p_Document["m_nGridSizeX"]);

	s_Object.m_nGridSizeY = simdjson::from_json_uint32(p_Document["m_nGridSizeY"]);

	s_Object.m_nCellSizeX = simdjson::from_json_uint32(p_Document["m_nCellSizeX"]);

	s_Object.m_nCellSizeY = simdjson::from_json_uint32(p_Document["m_nCellSizeY"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_GridMap"])
	{
		ZCrowdGridPoint s_ArrayItem0;
		ZCrowdGridPoint::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_GridMap.push_back(s_ArrayItem0);
	}

	s_Object.m_fGridMapHeightOffsetsScale = simdjson::from_json_float32(p_Document["m_fGridMapHeightOffsetsScale"]);

	s_Object.m_fGridMapHeightOffsetsBias = simdjson::from_json_float32(p_Document["m_fGridMapHeightOffsetsBias"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_CellFlags"])
	{
		SCrowdCells s_ArrayItem0;
		SCrowdCells::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CellFlags.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_CellGroups"])
	{
		SCrowdCells s_ArrayItem0;
		SCrowdCells::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CellGroups.push_back(s_ArrayItem0);
	}

	s_Object.m_nGroupFlowStartChannel = simdjson::from_json_int32(p_Document["m_nGroupFlowStartChannel"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aFlowChannels"])
	{
		SCrowdFlowChannel s_ArrayItem0;
		SCrowdFlowChannel::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aFlowChannels.push_back(s_ArrayItem0);
	}

	s_Object.m_nGridCellSize = simdjson::from_json_float32(p_Document["m_nGridCellSize"]);

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_mObjectToWorld"], &s_Item);
		s_Object.m_mObjectToWorld = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vGlobalSize"], &s_Item);
		s_Object.m_vGlobalSize = s_Item;
	}

	s_Object.m_nGridGeneratorOffset = simdjson::from_json_float32(p_Document["m_nGridGeneratorOffset"]);

	*reinterpret_cast<SCrowdMapData*>(p_Target) = s_Object;
}

void SCrowdMapData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vCellConsts, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_vCellConsts));
	TArray<ZCrowdGridPoint>::Serialize(&s_Object->m_GridMap, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_GridMap));
	TArray<SCrowdCells>::Serialize(&s_Object->m_CellFlags, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_CellFlags));
	TArray<SCrowdCells>::Serialize(&s_Object->m_CellGroups, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_CellGroups));
	TArray<SCrowdFlowChannel>::Serialize(&s_Object->m_aFlowChannels, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_aFlowChannels));
	SMatrix::Serialize(&s_Object->m_mObjectToWorld, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_mObjectToWorld));
	SVector3::Serialize(&s_Object->m_vGlobalSize, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_vGlobalSize));
}

bool SCrowdMapData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdMapData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdMapData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdMapData::operator==(const SCrowdMapData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdMapData>)
		return false;

	if (m_nVersion != p_Other.m_nVersion) return false;
	if (m_vCellConsts != p_Other.m_vCellConsts) return false;
	if (m_nGridSizeX != p_Other.m_nGridSizeX) return false;
	if (m_nGridSizeY != p_Other.m_nGridSizeY) return false;
	if (m_nCellSizeX != p_Other.m_nCellSizeX) return false;
	if (m_nCellSizeY != p_Other.m_nCellSizeY) return false;
	if (m_GridMap != p_Other.m_GridMap) return false;
	if (m_fGridMapHeightOffsetsScale != p_Other.m_fGridMapHeightOffsetsScale) return false;
	if (m_fGridMapHeightOffsetsBias != p_Other.m_fGridMapHeightOffsetsBias) return false;
	if (m_CellFlags != p_Other.m_CellFlags) return false;
	if (m_CellGroups != p_Other.m_CellGroups) return false;
	if (m_nGroupFlowStartChannel != p_Other.m_nGroupFlowStartChannel) return false;
	if (m_aFlowChannels != p_Other.m_aFlowChannels) return false;
	if (m_nGridCellSize != p_Other.m_nGridCellSize) return false;
	if (m_mObjectToWorld != p_Other.m_mObjectToWorld) return false;
	if (m_vGlobalSize != p_Other.m_vGlobalSize) return false;
	if (m_nGridGeneratorOffset != p_Other.m_nGridGeneratorOffset) return false;

	return true;
}

ZHMTypeInfo SCrowdReactionSaveData::TypeInfo = ZHMTypeInfo("SCrowdReactionSaveData", sizeof(SCrowdReactionSaveData), alignof(SCrowdReactionSaveData), SCrowdReactionSaveData::WriteJson, SCrowdReactionSaveData::WriteSimpleJson, SCrowdReactionSaveData::FromSimpleJson, SCrowdReactionSaveData::Serialize, SCrowdReactionSaveData::Equals);

void SCrowdReactionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nNumPacify") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumPacify);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumShotsFired") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumShotsFired);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumDeaths") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumDeaths);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumScared") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumScared);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarzoneSpawned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarzoneSpawned);
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdReactionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nNumPacify") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumPacify);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumShotsFired") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumShotsFired);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumDeaths") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumDeaths);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumScared") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumScared);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarzoneSpawned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarzoneSpawned);

	p_Stream << "}";
}

void SCrowdReactionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdReactionSaveData s_Object {};

	s_Object.m_nNumPacify = simdjson::from_json_uint32(p_Document["m_nNumPacify"]);

	s_Object.m_nNumShotsFired = simdjson::from_json_uint32(p_Document["m_nNumShotsFired"]);

	s_Object.m_nNumDeaths = simdjson::from_json_uint32(p_Document["m_nNumDeaths"]);

	s_Object.m_nNumScared = simdjson::from_json_uint32(p_Document["m_nNumScared"]);

	s_Object.m_bWarzoneSpawned = simdjson::from_json_bool(p_Document["m_bWarzoneSpawned"]);

	*reinterpret_cast<SCrowdReactionSaveData*>(p_Target) = s_Object;
}

void SCrowdReactionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);

}

bool SCrowdReactionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdReactionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdReactionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdReactionSaveData::operator==(const SCrowdReactionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdReactionSaveData>)
		return false;

	if (m_nNumPacify != p_Other.m_nNumPacify) return false;
	if (m_nNumShotsFired != p_Other.m_nNumShotsFired) return false;
	if (m_nNumDeaths != p_Other.m_nNumDeaths) return false;
	if (m_nNumScared != p_Other.m_nNumScared) return false;
	if (m_bWarzoneSpawned != p_Other.m_bWarzoneSpawned) return false;

	return true;
}

ZHMTypeInfo SCrowdServiceSaveData::TypeInfo = ZHMTypeInfo("SCrowdServiceSaveData", sizeof(SCrowdServiceSaveData), alignof(SCrowdServiceSaveData), SCrowdServiceSaveData::WriteJson, SCrowdServiceSaveData::WriteSimpleJson, SCrowdServiceSaveData::FromSimpleJson, SCrowdServiceSaveData::Serialize, SCrowdServiceSaveData::Equals);

void SCrowdServiceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aDeadBodies") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCrowdBodySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDeadBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDeadBodies[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCrowdBodySaveData") << ",\"$val\":";
		SCrowdBodySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aDeadBodies.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCrowdServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aDeadBodies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDeadBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDeadBodies[i];
		SCrowdBodySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aDeadBodies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdServiceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aDeadBodies"])
	{
		SCrowdBodySaveData s_ArrayItem0;
		SCrowdBodySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aDeadBodies.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCrowdServiceSaveData*>(p_Target) = s_Object;
}

void SCrowdServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);

	TArray<SCrowdBodySaveData>::Serialize(&s_Object->m_aDeadBodies, p_Serializer, p_OwnOffset + offsetof(SCrowdServiceSaveData, m_aDeadBodies));
}

bool SCrowdServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdServiceSaveData::operator==(const SCrowdServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdServiceSaveData>)
		return false;

	if (m_aDeadBodies != p_Other.m_aDeadBodies) return false;

	return true;
}

ZHMTypeInfo SCuriousEventSaveData::TypeInfo = ZHMTypeInfo("SCuriousEventSaveData", sizeof(SCuriousEventSaveData), alignof(SCuriousEventSaveData), SCuriousEventSaveData::WriteJson, SCuriousEventSaveData::WriteSimpleJson, SCuriousEventSaveData::FromSimpleJson, SCuriousEventSaveData::Serialize, SCuriousEventSaveData::Equals);

void SCuriousEventSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_tExpiresAt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tExpiresAt, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nKnowledgeIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nKnowledgeIndex);
	p_Stream << "}";

	p_Stream << "}";
}

void SCuriousEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tExpiresAt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiresAt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nKnowledgeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nKnowledgeIndex);

	p_Stream << "}";
}

void SCuriousEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCuriousEventSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tExpiresAt"], &s_Item);
		s_Object.m_tExpiresAt = s_Item;
	}

	s_Object.m_nKnowledgeIndex = simdjson::from_json_int32(p_Document["m_nKnowledgeIndex"]);

	*reinterpret_cast<SCuriousEventSaveData*>(p_Target) = s_Object;
}

void SCuriousEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tExpiresAt, p_Serializer, p_OwnOffset + offsetof(SCuriousEventSaveData, m_tExpiresAt));
}

bool SCuriousEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousEventSaveData::operator==(const SCuriousEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousEventSaveData>)
		return false;

	if (m_tExpiresAt != p_Other.m_tExpiresAt) return false;
	if (m_nKnowledgeIndex != p_Other.m_nKnowledgeIndex) return false;

	return true;
}

ZHMTypeInfo SCuriousEventServiceSaveData::TypeInfo = ZHMTypeInfo("SCuriousEventServiceSaveData", sizeof(SCuriousEventServiceSaveData), alignof(SCuriousEventServiceSaveData), SCuriousEventServiceSaveData::WriteJson, SCuriousEventServiceSaveData::WriteSimpleJson, SCuriousEventServiceSaveData::FromSimpleJson, SCuriousEventServiceSaveData::Serialize, SCuriousEventServiceSaveData::Equals);

void SCuriousEventServiceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aCuriousEvents") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SCuriousEventSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCuriousEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCuriousEvents[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SCuriousEventSaveData") << ",\"$val\":";
		SCuriousEventSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aCuriousEvents.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SCuriousEventServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCuriousEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCuriousEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCuriousEvents[i];
		SCuriousEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCuriousEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCuriousEventServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCuriousEventServiceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCuriousEvents"])
	{
		SCuriousEventSaveData s_ArrayItem0;
		SCuriousEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aCuriousEvents.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SCuriousEventServiceSaveData*>(p_Target) = s_Object;
}

void SCuriousEventServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);

	TArray<SCuriousEventSaveData>::Serialize(&s_Object->m_aCuriousEvents, p_Serializer, p_OwnOffset + offsetof(SCuriousEventServiceSaveData, m_aCuriousEvents));
}

bool SCuriousEventServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousEventServiceSaveData::operator==(const SCuriousEventServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousEventServiceSaveData>)
		return false;

	if (m_aCuriousEvents != p_Other.m_aCuriousEvents) return false;

	return true;
}

ZHMTypeInfo SCuriousInvestigateGroupSaveData::TypeInfo = ZHMTypeInfo("SCuriousInvestigateGroupSaveData", sizeof(SCuriousInvestigateGroupSaveData), alignof(SCuriousInvestigateGroupSaveData), SCuriousInvestigateGroupSaveData::WriteJson, SCuriousInvestigateGroupSaveData::WriteSimpleJson, SCuriousInvestigateGroupSaveData::FromSimpleJson, SCuriousInvestigateGroupSaveData::Serialize, SCuriousInvestigateGroupSaveData::Equals);

void SCuriousInvestigateGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nInvestigationId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInvestigationId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EInvestigationType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_type)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInvestigationType", static_cast<int>(s_Object->m_type))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pTempLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pTempLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pSecondary") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pSecondary);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EInvestigationState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_state)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInvestigationState", static_cast<int>(s_Object->m_state))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStartTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tResolveStartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tResolveStartTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarned);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStandDownType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EStandDownType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eStandDownType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EStandDownType", static_cast<int>(s_Object->m_eStandDownType))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SCuriousInvestigateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInvestigationId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInvestigationId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInvestigationType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pTempLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pTempLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pSecondary") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pSecondary);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInvestigationState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tResolveStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tResolveStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStandDownType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EStandDownType", static_cast<int>(s_Object->m_eStandDownType)));

	p_Stream << "}";
}

void SCuriousInvestigateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCuriousInvestigateGroupSaveData s_Object {};

	s_Object.m_nInvestigationId = simdjson::from_json_int32(p_Document["m_nInvestigationId"]);

	s_Object.m_type = static_cast<EInvestigationType>(ZHMEnums::GetEnumValueByName("EInvestigationType", std::string_view(p_Document["m_type"])));

	s_Object.m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pTempLeader = simdjson::from_json_uint32(p_Document["m_pTempLeader"]);

	s_Object.m_pSecondary = simdjson::from_json_uint32(p_Document["m_pSecondary"]);

	s_Object.m_state = static_cast<EInvestigationState>(ZHMEnums::GetEnumValueByName("EInvestigationState", std::string_view(p_Document["m_state"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStartTime"], &s_Item);
		s_Object.m_tStartTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tResolveStartTime"], &s_Item);
		s_Object.m_tResolveStartTime = s_Item;
	}

	s_Object.m_bWarned = simdjson::from_json_bool(p_Document["m_bWarned"]);

	s_Object.m_eStandDownType = static_cast<EStandDownType>(ZHMEnums::GetEnumValueByName("EStandDownType", std::string_view(p_Document["m_eStandDownType"])));

	*reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Target) = s_Object;
}

void SCuriousInvestigateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tStartTime, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateGroupSaveData, m_tStartTime));
	ZGameTime::Serialize(&s_Object->m_tResolveStartTime, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateGroupSaveData, m_tResolveStartTime));
}

bool SCuriousInvestigateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousInvestigateGroupSaveData::operator==(const SCuriousInvestigateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousInvestigateGroupSaveData>)
		return false;

	if (m_nInvestigationId != p_Other.m_nInvestigationId) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pTempLeader != p_Other.m_pTempLeader) return false;
	if (m_pSecondary != p_Other.m_pSecondary) return false;
	if (m_state != p_Other.m_state) return false;
	if (m_tStartTime != p_Other.m_tStartTime) return false;
	if (m_tResolveStartTime != p_Other.m_tResolveStartTime) return false;
	if (m_bWarned != p_Other.m_bWarned) return false;
	if (m_eStandDownType != p_Other.m_eStandDownType) return false;

	return true;
}

ZHMTypeInfo SCuriousInvestigateSituationSaveData::TypeInfo = ZHMTypeInfo("SCuriousInvestigateSituationSaveData", sizeof(SCuriousInvestigateSituationSaveData), alignof(SCuriousInvestigateSituationSaveData), SCuriousInvestigateSituationSaveData::WriteJson, SCuriousInvestigateSituationSaveData::WriteSimpleJson, SCuriousInvestigateSituationSaveData::FromSimpleJson, SCuriousInvestigateSituationSaveData::Serialize, SCuriousInvestigateSituationSaveData::Equals);

void SCuriousInvestigateSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aInvestigationGroupIDs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aInvestigationGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aInvestigationGroupIDs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aInvestigationGroupIDs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aVIPInvestigationGroupIDs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aVIPInvestigationGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aVIPInvestigationGroupIDs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aVIPInvestigationGroupIDs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nInvestigationCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInvestigationCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDownOrder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastStandDownOrder, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SCuriousInvestigateSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aInvestigationGroupIDs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aInvestigationGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aInvestigationGroupIDs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aInvestigationGroupIDs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aVIPInvestigationGroupIDs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aVIPInvestigationGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aVIPInvestigationGroupIDs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aVIPInvestigationGroupIDs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nInvestigationCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInvestigationCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDownOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastStandDownOrder, p_Stream);

	p_Stream << "}";
}

void SCuriousInvestigateSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCuriousInvestigateSituationSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aInvestigationGroupIDs"])
	{
		s_Object.m_aInvestigationGroupIDs.push_back(simdjson::from_json_int32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aVIPInvestigationGroupIDs"])
	{
		s_Object.m_aVIPInvestigationGroupIDs.push_back(simdjson::from_json_int32(s_Item0));
	}

	s_Object.m_nInvestigationCount = simdjson::from_json_int32(p_Document["m_nInvestigationCount"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastStandDownOrder"], &s_Item);
		s_Object.m_tLastStandDownOrder = s_Item;
	}

	*reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Target) = s_Object;
}

void SCuriousInvestigateSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aInvestigationGroupIDs, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateSituationSaveData, m_aInvestigationGroupIDs));
	TArray<int32>::Serialize(&s_Object->m_aVIPInvestigationGroupIDs, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateSituationSaveData, m_aVIPInvestigationGroupIDs));
	ZGameTime::Serialize(&s_Object->m_tLastStandDownOrder, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateSituationSaveData, m_tLastStandDownOrder));
}

bool SCuriousInvestigateSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousInvestigateSituationSaveData::operator==(const SCuriousInvestigateSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousInvestigateSituationSaveData>)
		return false;

	if (m_aInvestigationGroupIDs != p_Other.m_aInvestigationGroupIDs) return false;
	if (m_aVIPInvestigationGroupIDs != p_Other.m_aVIPInvestigationGroupIDs) return false;
	if (m_nInvestigationCount != p_Other.m_nInvestigationCount) return false;
	if (m_tLastStandDownOrder != p_Other.m_tLastStandDownOrder) return false;

	return true;
}

ZHMTypeInfo SCuriousSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SCuriousSituationMemberSaveData", sizeof(SCuriousSituationMemberSaveData), alignof(SCuriousSituationMemberSaveData), SCuriousSituationMemberSaveData::WriteJson, SCuriousSituationMemberSaveData::WriteSimpleJson, SCuriousSituationMemberSaveData::FromSimpleJson, SCuriousSituationMemberSaveData::Serialize, SCuriousSituationMemberSaveData::Equals);

void SCuriousSituationMemberSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_tLastDisturbance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastDisturbance, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_escalateTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_escalateTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarned);
	p_Stream << "}";

	p_Stream << "}";
}

void SCuriousSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tLastDisturbance") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastDisturbance, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_escalateTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_escalateTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarned);

	p_Stream << "}";
}

void SCuriousSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCuriousSituationMemberSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastDisturbance"], &s_Item);
		s_Object.m_tLastDisturbance = s_Item;
	}

	s_Object.m_escalateTarget = simdjson::from_json_uint32(p_Document["m_escalateTarget"]);

	s_Object.m_bWarned = simdjson::from_json_bool(p_Document["m_bWarned"]);

	*reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Target) = s_Object;
}

void SCuriousSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastDisturbance, p_Serializer, p_OwnOffset + offsetof(SCuriousSituationMemberSaveData, m_tLastDisturbance));
}

bool SCuriousSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousSituationMemberSaveData::operator==(const SCuriousSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousSituationMemberSaveData>)
		return false;

	if (m_tLastDisturbance != p_Other.m_tLastDisturbance) return false;
	if (m_escalateTarget != p_Other.m_escalateTarget) return false;
	if (m_bWarned != p_Other.m_bWarned) return false;

	return true;
}

ZHMTypeInfo SDangerousAreaSaveData::TypeInfo = ZHMTypeInfo("SDangerousAreaSaveData", sizeof(SDangerousAreaSaveData), alignof(SDangerousAreaSaveData), SDangerousAreaSaveData::WriteJson, SDangerousAreaSaveData::WriteSimpleJson, SDangerousAreaSaveData::FromSimpleJson, SDangerousAreaSaveData::Serialize, SDangerousAreaSaveData::Equals);

void SDangerousAreaSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bDangerous") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDangerous);
	p_Stream << "}";

	p_Stream << "}";
}

void SDangerousAreaSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bDangerous") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDangerous);

	p_Stream << "}";
}

void SDangerousAreaSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDangerousAreaSaveData s_Object {};

	s_Object.m_bDangerous = simdjson::from_json_bool(p_Document["m_bDangerous"]);

	*reinterpret_cast<SDangerousAreaSaveData*>(p_Target) = s_Object;
}

void SDangerousAreaSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);

}

bool SDangerousAreaSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDangerousAreaSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDangerousAreaSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDangerousAreaSaveData::operator==(const SDangerousAreaSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDangerousAreaSaveData>)
		return false;

	if (m_bDangerous != p_Other.m_bDangerous) return false;

	return true;
}

ZHMTypeInfo SDeadBodyInfoSaveData::TypeInfo = ZHMTypeInfo("SDeadBodyInfoSaveData", sizeof(SDeadBodyInfoSaveData), alignof(SDeadBodyInfoSaveData), SDeadBodyInfoSaveData::WriteJson, SDeadBodyInfoSaveData::WriteSimpleJson, SDeadBodyInfoSaveData::FromSimpleJson, SDeadBodyInfoSaveData::Serialize, SDeadBodyInfoSaveData::Equals);

void SDeadBodyInfoSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rGuard") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rGuard);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_knownByActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_knownByActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_knownByActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_knownByActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tKnownSince") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tKnownSince, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tInvestigatedSince") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tInvestigatedSince, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPoolKnownOnly") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPoolKnownOnly);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPoolInvestigated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPoolInvestigated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGuarded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGuarded);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBodyInvestigated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBodyInvestigated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHidden") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHidden);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByAccident") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByAccident);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByUnnoticed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByUnnoticed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanSuspectedInCurrentOutfit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanSuspectedInCurrentOutfit);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByExplosion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByExplosion);
	p_Stream << "}";

	p_Stream << "}";
}

void SDeadBodyInfoSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_knownByActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_knownByActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_knownByActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_knownByActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tKnownSince") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tKnownSince, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tInvestigatedSince") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tInvestigatedSince, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPoolKnownOnly") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPoolKnownOnly);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPoolInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPoolInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGuarded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGuarded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBodyInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBodyInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByAccident") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByAccident);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByUnnoticed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByUnnoticed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanSuspectedInCurrentOutfit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanSuspectedInCurrentOutfit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByExplosion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByExplosion);

	p_Stream << "}";
}

void SDeadBodyInfoSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDeadBodyInfoSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rGuard = simdjson::from_json_uint32(p_Document["m_rGuard"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_knownByActors"])
	{
		s_Object.m_knownByActors.push_back(simdjson::from_json_uint32(s_Item0));
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tKnownSince"], &s_Item);
		s_Object.m_tKnownSince = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tInvestigatedSince"], &s_Item);
		s_Object.m_tInvestigatedSince = s_Item;
	}

	s_Object.m_bPoolKnownOnly = simdjson::from_json_bool(p_Document["m_bPoolKnownOnly"]);

	s_Object.m_bPoolInvestigated = simdjson::from_json_bool(p_Document["m_bPoolInvestigated"]);

	s_Object.m_bGuarded = simdjson::from_json_bool(p_Document["m_bGuarded"]);

	s_Object.m_bBodyInvestigated = simdjson::from_json_bool(p_Document["m_bBodyInvestigated"]);

	s_Object.m_bHidden = simdjson::from_json_bool(p_Document["m_bHidden"]);

	s_Object.m_bDeadByAccident = simdjson::from_json_bool(p_Document["m_bDeadByAccident"]);

	s_Object.m_bDeadByUnnoticed = simdjson::from_json_bool(p_Document["m_bDeadByUnnoticed"]);

	s_Object.m_bHitmanSuspectedInCurrentOutfit = simdjson::from_json_bool(p_Document["m_bHitmanSuspectedInCurrentOutfit"]);

	s_Object.m_bDeadByExplosion = simdjson::from_json_bool(p_Document["m_bDeadByExplosion"]);

	*reinterpret_cast<SDeadBodyInfoSaveData*>(p_Target) = s_Object;
}

void SDeadBodyInfoSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_knownByActors, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_knownByActors));
	ZGameTime::Serialize(&s_Object->m_tKnownSince, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_tKnownSince));
	ZGameTime::Serialize(&s_Object->m_tInvestigatedSince, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_tInvestigatedSince));
}

bool SDeadBodyInfoSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDeadBodyInfoSaveData::operator==(const SDeadBodyInfoSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDeadBodyInfoSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rGuard != p_Other.m_rGuard) return false;
	if (m_knownByActors != p_Other.m_knownByActors) return false;
	if (m_tKnownSince != p_Other.m_tKnownSince) return false;
	if (m_tInvestigatedSince != p_Other.m_tInvestigatedSince) return false;
	if (m_bPoolKnownOnly != p_Other.m_bPoolKnownOnly) return false;
	if (m_bPoolInvestigated != p_Other.m_bPoolInvestigated) return false;
	if (m_bGuarded != p_Other.m_bGuarded) return false;
	if (m_bBodyInvestigated != p_Other.m_bBodyInvestigated) return false;
	if (m_bHidden != p_Other.m_bHidden) return false;
	if (m_bDeadByAccident != p_Other.m_bDeadByAccident) return false;
	if (m_bDeadByUnnoticed != p_Other.m_bDeadByUnnoticed) return false;
	if (m_bHitmanSuspectedInCurrentOutfit != p_Other.m_bHitmanSuspectedInCurrentOutfit) return false;
	if (m_bDeadByExplosion != p_Other.m_bDeadByExplosion) return false;

	return true;
}

ZHMTypeInfo SDeadBodySensorSaveData::TypeInfo = ZHMTypeInfo("SDeadBodySensorSaveData", sizeof(SDeadBodySensorSaveData), alignof(SDeadBodySensorSaveData), SDeadBodySensorSaveData::WriteJson, SDeadBodySensorSaveData::WriteSimpleJson, SDeadBodySensorSaveData::FromSimpleJson, SDeadBodySensorSaveData::Serialize, SDeadBodySensorSaveData::Equals);

void SDeadBodySensorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aBodies") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SDeadBodyInfoSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBodies[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SDeadBodyInfoSaveData") << ",\"$val\":";
		SDeadBodyInfoSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aBodies.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBodyIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBodyIndex);
	p_Stream << "}";

	p_Stream << "}";
}

void SDeadBodySensorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBodies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBodies[i];
		SDeadBodyInfoSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBodies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBodyIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBodyIndex);

	p_Stream << "}";
}

void SDeadBodySensorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDeadBodySensorSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBodies"])
	{
		SDeadBodyInfoSaveData s_ArrayItem0;
		SDeadBodyInfoSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBodies.push_back(s_ArrayItem0);
	}

	s_Object.m_nBodyIndex = simdjson::from_json_int32(p_Document["m_nBodyIndex"]);

	*reinterpret_cast<SDeadBodySensorSaveData*>(p_Target) = s_Object;
}

void SDeadBodySensorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);

	TArray<SDeadBodyInfoSaveData>::Serialize(&s_Object->m_aBodies, p_Serializer, p_OwnOffset + offsetof(SDeadBodySensorSaveData, m_aBodies));
}

bool SDeadBodySensorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDeadBodySensorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDeadBodySensorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDeadBodySensorSaveData::operator==(const SDeadBodySensorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDeadBodySensorSaveData>)
		return false;

	if (m_aBodies != p_Other.m_aBodies) return false;
	if (m_nBodyIndex != p_Other.m_nBodyIndex) return false;

	return true;
}

ZHMTypeInfo SVector2::TypeInfo = ZHMTypeInfo("SVector2", sizeof(SVector2), alignof(SVector2), SVector2::WriteJson, SVector2::WriteSimpleJson, SVector2::FromSimpleJson, SVector2::Serialize, SVector2::Equals);

void SVector2::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << "}";

	p_Stream << "}";
}

void SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);

	p_Stream << "}";
}

void SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector2 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	*reinterpret_cast<SVector2*>(p_Target) = s_Object;
}

void SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

}

bool SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector2::operator==(const SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector2>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;

	return true;
}

ZHMTypeInfo SDecalSpawnSaveData::TypeInfo = ZHMTypeInfo("SDecalSpawnSaveData", sizeof(SDecalSpawnSaveData), alignof(SDecalSpawnSaveData), SDecalSpawnSaveData::WriteJson, SDecalSpawnSaveData::WriteSimpleJson, SDecalSpawnSaveData::FromSimpleJson, SDecalSpawnSaveData::Serialize, SDecalSpawnSaveData::Equals);

void SDecalSpawnSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bWasSpawned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasSpawned);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vNormal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vNormal, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDirection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vDirection, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vSize, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Color") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGB") << ",\"$val\":";
	SColorRGB::WriteJson(&s_Object->m_Color, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAlpha") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAlpha);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vUVOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vUVOffset, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTiling") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vTiling, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBlockingSpatialEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBlockingSpatialEntity);
	p_Stream << "}";

	p_Stream << "}";
}

void SDecalSpawnSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bWasSpawned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasSpawned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vNormal") << ":";
	float4::WriteSimpleJson(&s_Object->m_vNormal, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSize") << ":";
	float4::WriteSimpleJson(&s_Object->m_vSize, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Color") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_Color, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vUVOffset") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vUVOffset, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTiling") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vTiling, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBlockingSpatialEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBlockingSpatialEntity);

	p_Stream << "}";
}

void SDecalSpawnSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDecalSpawnSaveData s_Object {};

	s_Object.m_bWasSpawned = simdjson::from_json_bool(p_Document["m_bWasSpawned"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vNormal"], &s_Item);
		s_Object.m_vNormal = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vDirection"], &s_Item);
		s_Object.m_vDirection = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vSize"], &s_Item);
		s_Object.m_vSize = s_Item;
	}

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_Color"], &s_Item);
		s_Object.m_Color = s_Item;
	}

	s_Object.m_fAlpha = simdjson::from_json_float32(p_Document["m_fAlpha"]);

	s_Object.m_fAngle = simdjson::from_json_float32(p_Document["m_fAngle"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vUVOffset"], &s_Item);
		s_Object.m_vUVOffset = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vTiling"], &s_Item);
		s_Object.m_vTiling = s_Item;
	}

	s_Object.m_rBlockingSpatialEntity = simdjson::from_json_uint32(p_Document["m_rBlockingSpatialEntity"]);

	*reinterpret_cast<SDecalSpawnSaveData*>(p_Target) = s_Object;
}

void SDecalSpawnSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vPosition));
	float4::Serialize(&s_Object->m_vNormal, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vNormal));
	float4::Serialize(&s_Object->m_vDirection, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vDirection));
	float4::Serialize(&s_Object->m_vSize, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vSize));
	SColorRGB::Serialize(&s_Object->m_Color, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_Color));
	SVector2::Serialize(&s_Object->m_vUVOffset, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vUVOffset));
	SVector2::Serialize(&s_Object->m_vTiling, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vTiling));
}

bool SDecalSpawnSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDecalSpawnSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDecalSpawnSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDecalSpawnSaveData::operator==(const SDecalSpawnSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDecalSpawnSaveData>)
		return false;

	if (m_bWasSpawned != p_Other.m_bWasSpawned) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vNormal != p_Other.m_vNormal) return false;
	if (m_vDirection != p_Other.m_vDirection) return false;
	if (m_vSize != p_Other.m_vSize) return false;
	if (m_Color != p_Other.m_Color) return false;
	if (m_fAlpha != p_Other.m_fAlpha) return false;
	if (m_fAngle != p_Other.m_fAngle) return false;
	if (m_vUVOffset != p_Other.m_vUVOffset) return false;
	if (m_vTiling != p_Other.m_vTiling) return false;
	if (m_rBlockingSpatialEntity != p_Other.m_rBlockingSpatialEntity) return false;

	return true;
}

ZHMTypeInfo SDetectedInPrivateGroupSaveData::TypeInfo = ZHMTypeInfo("SDetectedInPrivateGroupSaveData", sizeof(SDetectedInPrivateGroupSaveData), alignof(SDetectedInPrivateGroupSaveData), SDetectedInPrivateGroupSaveData::WriteJson, SDetectedInPrivateGroupSaveData::WriteSimpleJson, SDetectedInPrivateGroupSaveData::FromSimpleJson, SDetectedInPrivateGroupSaveData::Serialize, SDetectedInPrivateGroupSaveData::Equals);

void SDetectedInPrivateGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeWaiting") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeWaiting);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rLead") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLead);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisbanded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisbanded);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirstWait") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirstWait);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";

	p_Stream << "}";
}

void SDetectedInPrivateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeWaiting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeWaiting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rLead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisbanded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisbanded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirstWait") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirstWait);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);

	p_Stream << "}";
}

void SDetectedInPrivateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDetectedInPrivateGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_fTimeWaiting = simdjson::from_json_float32(p_Document["m_fTimeWaiting"]);

	s_Object.m_rLead = simdjson::from_json_uint32(p_Document["m_rLead"]);

	s_Object.m_bDisbanded = simdjson::from_json_bool(p_Document["m_bDisbanded"]);

	s_Object.m_bFirstWait = simdjson::from_json_bool(p_Document["m_bFirstWait"]);

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	*reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Target) = s_Object;
}

void SDetectedInPrivateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SDetectedInPrivateGroupSaveData, m_fsmState));
}

bool SDetectedInPrivateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDetectedInPrivateGroupSaveData::operator==(const SDetectedInPrivateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDetectedInPrivateGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_fTimeWaiting != p_Other.m_fTimeWaiting) return false;
	if (m_rLead != p_Other.m_rLead) return false;
	if (m_bDisbanded != p_Other.m_bDisbanded) return false;
	if (m_bFirstWait != p_Other.m_bFirstWait) return false;
	if (m_target != p_Other.m_target) return false;

	return true;
}

ZHMTypeInfo SDisguiseZoneSaveData::TypeInfo = ZHMTypeInfo("SDisguiseZoneSaveData", sizeof(SDisguiseZoneSaveData), alignof(SDisguiseZoneSaveData), SDisguiseZoneSaveData::WriteJson, SDisguiseZoneSaveData::WriteSimpleJson, SDisguiseZoneSaveData::FromSimpleJson, SDisguiseZoneSaveData::Serialize, SDisguiseZoneSaveData::Equals);

void SDisguiseZoneSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SDisguiseZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SDisguiseZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDisguiseZoneSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SDisguiseZoneSaveData*>(p_Target) = s_Object;
}

void SDisguiseZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);

}

bool SDisguiseZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDisguiseZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDisguiseZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDisguiseZoneSaveData::operator==(const SDisguiseZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDisguiseZoneSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

ZHMTypeInfo SDoorSaveData::TypeInfo = ZHMTypeInfo("SDoorSaveData", sizeof(SDoorSaveData), alignof(SDoorSaveData), SDoorSaveData::WriteJson, SDoorSaveData::WriteSimpleJson, SDoorSaveData::FromSimpleJson, SDoorSaveData::Serialize, SDoorSaveData::Equals);

void SDoorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nDoorState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDoorState);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimPercent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimPercent);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAnimPercent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAnimPercent);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tOpenTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tOpenTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SDoorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nDoorState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDoorState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimPercent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimPercent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAnimPercent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAnimPercent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tOpenTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tOpenTime, p_Stream);

	p_Stream << "}";
}

void SDoorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDoorSaveData s_Object {};

	s_Object.m_nDoorState = simdjson::from_json_int32(p_Document["m_nDoorState"]);

	s_Object.m_fAnimPercent = simdjson::from_json_float32(p_Document["m_fAnimPercent"]);

	s_Object.m_fTargetAnimPercent = simdjson::from_json_float32(p_Document["m_fTargetAnimPercent"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tOpenTime"], &s_Item);
		s_Object.m_tOpenTime = s_Item;
	}

	*reinterpret_cast<SDoorSaveData*>(p_Target) = s_Object;
}

void SDoorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tOpenTime, p_Serializer, p_OwnOffset + offsetof(SDoorSaveData, m_tOpenTime));
}

bool SDoorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorSaveData::operator==(const SDoorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorSaveData>)
		return false;

	if (m_nDoorState != p_Other.m_nDoorState) return false;
	if (m_fAnimPercent != p_Other.m_fAnimPercent) return false;
	if (m_fTargetAnimPercent != p_Other.m_fTargetAnimPercent) return false;
	if (m_tOpenTime != p_Other.m_tOpenTime) return false;

	return true;
}

ZHMTypeInfo SDoorSoundDefs::TypeInfo = ZHMTypeInfo("SDoorSoundDefs", sizeof(SDoorSoundDefs), alignof(SDoorSoundDefs), SDoorSoundDefs::WriteJson, SDoorSoundDefs::WriteSimpleJson, SDoorSoundDefs::FromSimpleJson, SDoorSoundDefs::Serialize, SDoorSoundDefs::Equals);

void SDoorSoundDefs::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SDoorSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SDoorSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDoorSoundDefs s_Object {};

	*reinterpret_cast<SDoorSoundDefs*>(p_Target) = s_Object;
}

void SDoorSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

}

bool SDoorSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorSoundDefs::operator==(const SDoorSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorSoundDefs>)
		return false;


	return true;
}

ZHMTypeInfo SDoorsSaveData::TypeInfo = ZHMTypeInfo("SDoorsSaveData", sizeof(SDoorsSaveData), alignof(SDoorsSaveData), SDoorsSaveData::WriteJson, SDoorsSaveData::WriteSimpleJson, SDoorsSaveData::FromSimpleJson, SDoorsSaveData::Serialize, SDoorsSaveData::Equals);

void SDoorsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SDoorSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SDoorSaveData") << ",\"$val\":";
		SDoorSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SDoorsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SDoorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDoorsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDoorsSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SDoorSaveData s_ArrayItem0;
		SDoorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SDoorsSaveData*>(p_Target) = s_Object;
}

void SDoorsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDoorsSaveData, m_aEntities));
	TArray<SDoorSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SDoorsSaveData, m_aData));
}

bool SDoorsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorsSaveData::operator==(const SDoorsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SDramaActorSaveState::TypeInfo = ZHMTypeInfo("SDramaActorSaveState", sizeof(SDramaActorSaveState), alignof(SDramaActorSaveState), SDramaActorSaveState::WriteJson, SDramaActorSaveState::WriteSimpleJson, SDramaActorSaveState::FromSimpleJson, SDramaActorSaveState::Serialize, SDramaActorSaveState::Equals);

void SDramaActorSaveState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSequence") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSequence);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBehavior") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBehavior);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sMatchName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sMatchName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tActorSpeakEnd") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tActorSpeakEnd, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPaused") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPaused);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSpeaking") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSpeaking);
	p_Stream << "}";

	p_Stream << "}";
}

void SDramaActorSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSequence") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSequence);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sMatchName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sMatchName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tActorSpeakEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tActorSpeakEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSpeaking") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSpeaking);

	p_Stream << "}";
}

void SDramaActorSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaActorSaveState s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rSequence = simdjson::from_json_uint32(p_Document["m_rSequence"]);

	s_Object.m_rBehavior = simdjson::from_json_uint32(p_Document["m_rBehavior"]);

	s_Object.m_rCurrentSpeakEntity = simdjson::from_json_uint32(p_Document["m_rCurrentSpeakEntity"]);

	s_Object.m_rScreenplay = simdjson::from_json_uint32(p_Document["m_rScreenplay"]);

	s_Object.m_sMatchName = std::string_view(p_Document["m_sMatchName"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tActorSpeakEnd"], &s_Item);
		s_Object.m_tActorSpeakEnd = s_Item;
	}

	s_Object.m_bIsDone = simdjson::from_json_bool(p_Document["m_bIsDone"]);

	s_Object.m_bIsPaused = simdjson::from_json_bool(p_Document["m_bIsPaused"]);

	s_Object.m_bIsSpeaking = simdjson::from_json_bool(p_Document["m_bIsSpeaking"]);

	*reinterpret_cast<SDramaActorSaveState*>(p_Target) = s_Object;
}

void SDramaActorSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);

	ZString::Serialize(&s_Object->m_sMatchName, p_Serializer, p_OwnOffset + offsetof(SDramaActorSaveState, m_sMatchName));
	ZGameTime::Serialize(&s_Object->m_tActorSpeakEnd, p_Serializer, p_OwnOffset + offsetof(SDramaActorSaveState, m_tActorSpeakEnd));
}

bool SDramaActorSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaActorSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaActorSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaActorSaveState::operator==(const SDramaActorSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaActorSaveState>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rSequence != p_Other.m_rSequence) return false;
	if (m_rBehavior != p_Other.m_rBehavior) return false;
	if (m_rCurrentSpeakEntity != p_Other.m_rCurrentSpeakEntity) return false;
	if (m_rScreenplay != p_Other.m_rScreenplay) return false;
	if (m_sMatchName != p_Other.m_sMatchName) return false;
	if (m_tActorSpeakEnd != p_Other.m_tActorSpeakEnd) return false;
	if (m_bIsDone != p_Other.m_bIsDone) return false;
	if (m_bIsPaused != p_Other.m_bIsPaused) return false;
	if (m_bIsSpeaking != p_Other.m_bIsSpeaking) return false;

	return true;
}

ZHMTypeInfo SDramaActorCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaActorCollectionSaveData", sizeof(SDramaActorCollectionSaveData), alignof(SDramaActorCollectionSaveData), SDramaActorCollectionSaveData::WriteJson, SDramaActorCollectionSaveData::WriteSimpleJson, SDramaActorCollectionSaveData::FromSimpleJson, SDramaActorCollectionSaveData::Serialize, SDramaActorCollectionSaveData::Equals);

void SDramaActorCollectionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SDramaActorSaveState>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SDramaActorSaveState") << ",\"$val\":";
		SDramaActorSaveState::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SDramaActorCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaActorSaveState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaActorCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaActorCollectionSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aStates"])
	{
		SDramaActorSaveState s_ArrayItem0;
		SDramaActorSaveState::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SDramaActorCollectionSaveData*>(p_Target) = s_Object;
}

void SDramaActorCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaActorCollectionSaveData, m_aEntities));
	TArray<SDramaActorSaveState>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaActorCollectionSaveData, m_aStates));
}

bool SDramaActorCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaActorCollectionSaveData::operator==(const SDramaActorCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaActorCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

ZHMTypeInfo SDramaSetupSaveData::TypeInfo = ZHMTypeInfo("SDramaSetupSaveData", sizeof(SDramaSetupSaveData), alignof(SDramaSetupSaveData), SDramaSetupSaveData::WriteJson, SDramaSetupSaveData::WriteSimpleJson, SDramaSetupSaveData::FromSimpleJson, SDramaSetupSaveData::Serialize, SDramaSetupSaveData::Equals);

void SDramaSetupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bDoneTriggered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneTriggered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZScreenplay.EState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZScreenplay.EState", static_cast<int>(s_Object->m_eState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);
	p_Stream << "}";

	p_Stream << "}";
}

void SDramaSetupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bDoneTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneTriggered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZScreenplay.EState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);

	p_Stream << "}";
}

void SDramaSetupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaSetupSaveData s_Object {};

	s_Object.m_bDoneTriggered = simdjson::from_json_bool(p_Document["m_bDoneTriggered"]);

	s_Object.m_eState = static_cast<ZScreenplay_EState>(ZHMEnums::GetEnumValueByName("ZScreenplay.EState", std::string_view(p_Document["m_eState"])));

	s_Object.m_rSituation = simdjson::from_json_uint32(p_Document["m_rSituation"]);

	*reinterpret_cast<SDramaSetupSaveData*>(p_Target) = s_Object;
}

void SDramaSetupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);

}

bool SDramaSetupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSetupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSetupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSetupSaveData::operator==(const SDramaSetupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSetupSaveData>)
		return false;

	if (m_bDoneTriggered != p_Other.m_bDoneTriggered) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_rSituation != p_Other.m_rSituation) return false;

	return true;
}

ZHMTypeInfo SDramaSetupCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaSetupCollectionSaveData", sizeof(SDramaSetupCollectionSaveData), alignof(SDramaSetupCollectionSaveData), SDramaSetupCollectionSaveData::WriteJson, SDramaSetupCollectionSaveData::WriteSimpleJson, SDramaSetupCollectionSaveData::FromSimpleJson, SDramaSetupCollectionSaveData::Serialize, SDramaSetupCollectionSaveData::Equals);

void SDramaSetupCollectionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SDramaSetupSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SDramaSetupSaveData") << ",\"$val\":";
		SDramaSetupSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SDramaSetupCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaSetupSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaSetupCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaSetupCollectionSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aStates"])
	{
		SDramaSetupSaveData s_ArrayItem0;
		SDramaSetupSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Target) = s_Object;
}

void SDramaSetupCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaSetupCollectionSaveData, m_aEntities));
	TArray<SDramaSetupSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaSetupCollectionSaveData, m_aStates));
}

bool SDramaSetupCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSetupCollectionSaveData::operator==(const SDramaSetupCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSetupCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

ZHMTypeInfo SDramaSituationSaveData::TypeInfo = ZHMTypeInfo("SDramaSituationSaveData", sizeof(SDramaSituationSaveData), alignof(SDramaSituationSaveData), SDramaSituationSaveData::WriteJson, SDramaSituationSaveData::WriteSimpleJson, SDramaSituationSaveData::FromSimpleJson, SDramaSituationSaveData::Serialize, SDramaSituationSaveData::Equals);

void SDramaSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bSituationRunning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationRunning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsTerminated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsTerminated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPriorityModifier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPriorityModifier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentDrama") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentDrama);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bProvidersStarted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bProvidersStarted);
	p_Stream << "}";

	p_Stream << "}";
}

void SDramaSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSituationRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsTerminated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsTerminated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPriorityModifier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPriorityModifier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentDrama") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentDrama);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bProvidersStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bProvidersStarted);

	p_Stream << "}";
}

void SDramaSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaSituationSaveData s_Object {};

	s_Object.m_bSituationRunning = simdjson::from_json_bool(p_Document["m_bSituationRunning"]);

	s_Object.m_bIsTerminated = simdjson::from_json_bool(p_Document["m_bIsTerminated"]);

	s_Object.m_nPriorityModifier = simdjson::from_json_float32(p_Document["m_nPriorityModifier"]);

	s_Object.m_nCurrentDrama = simdjson::from_json_int32(p_Document["m_nCurrentDrama"]);

	s_Object.m_bProvidersStarted = simdjson::from_json_bool(p_Document["m_bProvidersStarted"]);

	*reinterpret_cast<SDramaSituationSaveData*>(p_Target) = s_Object;
}

void SDramaSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);

}

bool SDramaSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSituationSaveData::operator==(const SDramaSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSituationSaveData>)
		return false;

	if (m_bSituationRunning != p_Other.m_bSituationRunning) return false;
	if (m_bIsTerminated != p_Other.m_bIsTerminated) return false;
	if (m_nPriorityModifier != p_Other.m_nPriorityModifier) return false;
	if (m_nCurrentDrama != p_Other.m_nCurrentDrama) return false;
	if (m_bProvidersStarted != p_Other.m_bProvidersStarted) return false;

	return true;
}

ZHMTypeInfo SDramaSituationCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaSituationCollectionSaveData", sizeof(SDramaSituationCollectionSaveData), alignof(SDramaSituationCollectionSaveData), SDramaSituationCollectionSaveData::WriteJson, SDramaSituationCollectionSaveData::WriteSimpleJson, SDramaSituationCollectionSaveData::FromSimpleJson, SDramaSituationCollectionSaveData::Serialize, SDramaSituationCollectionSaveData::Equals);

void SDramaSituationCollectionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SDramaSituationSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SDramaSituationSaveData") << ",\"$val\":";
		SDramaSituationSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SDramaSituationCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaSituationSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaSituationCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaSituationCollectionSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aStates"])
	{
		SDramaSituationSaveData s_ArrayItem0;
		SDramaSituationSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Target) = s_Object;
}

void SDramaSituationCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaSituationCollectionSaveData, m_aEntities));
	TArray<SDramaSituationSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaSituationCollectionSaveData, m_aStates));
}

bool SDramaSituationCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSituationCollectionSaveData::operator==(const SDramaSituationCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSituationCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

ZHMTypeInfo SDynamicEnforcerCandidateSaveData::TypeInfo = ZHMTypeInfo("SDynamicEnforcerCandidateSaveData", sizeof(SDynamicEnforcerCandidateSaveData), alignof(SDynamicEnforcerCandidateSaveData), SDynamicEnforcerCandidateSaveData::WriteJson, SDynamicEnforcerCandidateSaveData::WriteSimpleJson, SDynamicEnforcerCandidateSaveData::FromSimpleJson, SDynamicEnforcerCandidateSaveData::Serialize, SDynamicEnforcerCandidateSaveData::Equals);

void SDynamicEnforcerCandidateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAISharedEventType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadius") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadius);
	p_Stream << "}";

	p_Stream << "}";
}

void SDynamicEnforcerCandidateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadius);

	p_Stream << "}";
}

void SDynamicEnforcerCandidateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDynamicEnforcerCandidateSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	s_Object.m_eType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eType"])));

	s_Object.m_fRadius = simdjson::from_json_float32(p_Document["m_fRadius"]);

	*reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Target) = s_Object;
}

void SDynamicEnforcerCandidateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SDynamicEnforcerCandidateSaveData, m_vPosition));
}

bool SDynamicEnforcerCandidateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicEnforcerCandidateSaveData::operator==(const SDynamicEnforcerCandidateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicEnforcerCandidateSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_fRadius != p_Other.m_fRadius) return false;

	return true;
}

ZHMTypeInfo SDynamicEnforcerServiceSaveData::TypeInfo = ZHMTypeInfo("SDynamicEnforcerServiceSaveData", sizeof(SDynamicEnforcerServiceSaveData), alignof(SDynamicEnforcerServiceSaveData), SDynamicEnforcerServiceSaveData::WriteJson, SDynamicEnforcerServiceSaveData::WriteSimpleJson, SDynamicEnforcerServiceSaveData::FromSimpleJson, SDynamicEnforcerServiceSaveData::Serialize, SDynamicEnforcerServiceSaveData::Equals);

void SDynamicEnforcerServiceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SDynamicEnforcerCandidateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SDynamicEnforcerCandidateSaveData") << ",\"$val\":";
		SDynamicEnforcerCandidateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SDynamicEnforcerServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		SDynamicEnforcerCandidateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDynamicEnforcerServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDynamicEnforcerServiceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCandidates"])
	{
		SDynamicEnforcerCandidateSaveData s_ArrayItem0;
		SDynamicEnforcerCandidateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aCandidates.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Target) = s_Object;
}

void SDynamicEnforcerServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);

	TArray<SDynamicEnforcerCandidateSaveData>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SDynamicEnforcerServiceSaveData, m_aCandidates));
}

bool SDynamicEnforcerServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicEnforcerServiceSaveData::operator==(const SDynamicEnforcerServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicEnforcerServiceSaveData>)
		return false;

	if (m_aCandidates != p_Other.m_aCandidates) return false;

	return true;
}

ZHMTypeInfo SDynamicObjectKeyValuePair::TypeInfo = ZHMTypeInfo("SDynamicObjectKeyValuePair", sizeof(SDynamicObjectKeyValuePair), alignof(SDynamicObjectKeyValuePair), SDynamicObjectKeyValuePair::WriteJson, SDynamicObjectKeyValuePair::WriteSimpleJson, SDynamicObjectKeyValuePair::FromSimpleJson, SDynamicObjectKeyValuePair::Serialize, SDynamicObjectKeyValuePair::Equals);

void SDynamicObjectKeyValuePair::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sKey") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sKey);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->value, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SDynamicObjectKeyValuePair::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->value, p_Stream);

	p_Stream << "}";
}

void SDynamicObjectKeyValuePair::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDynamicObjectKeyValuePair s_Object {};

	s_Object.sKey = std::string_view(p_Document["sKey"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["value"], &s_Item);
		s_Object.value = s_Item;
	}

	*reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Target) = s_Object;
}

void SDynamicObjectKeyValuePair::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);

	ZString::Serialize(&s_Object->sKey, p_Serializer, p_OwnOffset + offsetof(SDynamicObjectKeyValuePair, sKey));
	ZDynamicObject::Serialize(&s_Object->value, p_Serializer, p_OwnOffset + offsetof(SDynamicObjectKeyValuePair, value));
}

bool SDynamicObjectKeyValuePair::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicObjectKeyValuePair::operator==(const SDynamicObjectKeyValuePair& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicObjectKeyValuePair>)
		return false;

	if (sKey != p_Other.sKey) return false;
	if (value != p_Other.value) return false;

	return true;
}

ZHMTypeInfo SDynamicRayCastEntitySaveData::TypeInfo = ZHMTypeInfo("SDynamicRayCastEntitySaveData", sizeof(SDynamicRayCastEntitySaveData), alignof(SDynamicRayCastEntitySaveData), SDynamicRayCastEntitySaveData::WriteJson, SDynamicRayCastEntitySaveData::WriteSimpleJson, SDynamicRayCastEntitySaveData::FromSimpleJson, SDynamicRayCastEntitySaveData::Serialize, SDynamicRayCastEntitySaveData::Equals);

void SDynamicRayCastEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SDynamicRayCastEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SDynamicRayCastEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDynamicRayCastEntitySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Target) = s_Object;
}

void SDynamicRayCastEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);

}

bool SDynamicRayCastEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicRayCastEntitySaveData::operator==(const SDynamicRayCastEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicRayCastEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

ZHMTypeInfo SEntityPath::TypeInfo = ZHMTypeInfo("SEntityPath", sizeof(SEntityPath), alignof(SEntityPath), SEntityPath::WriteJson, SEntityPath::WriteSimpleJson, SEntityPath::FromSimpleJson, SEntityPath::Serialize, SEntityPath::Equals);

void SEntityPath::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nOwnerID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOwnerID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityPath") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint64>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityPath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityPath[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntityPath.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityPath::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nOwnerID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOwnerID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityPath") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityPath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityPath[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityPath.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityPath::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityPath s_Object {};

	s_Object.m_nOwnerID = simdjson::from_json_uint64(p_Document["m_nOwnerID"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntityPath"])
	{
		s_Object.m_aEntityPath.push_back(simdjson::from_json_uint64(s_Item0));
	}

	*reinterpret_cast<SEntityPath*>(p_Target) = s_Object;
}

void SEntityPath::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);

	TArray<uint64>::Serialize(&s_Object->m_aEntityPath, p_Serializer, p_OwnOffset + offsetof(SEntityPath, m_aEntityPath));
}

bool SEntityPath::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityPath*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityPath*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityPath::operator==(const SEntityPath& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityPath>)
		return false;

	if (m_nOwnerID != p_Other.m_nOwnerID) return false;
	if (m_aEntityPath != p_Other.m_aEntityPath) return false;

	return true;
}

ZHMTypeInfo SEntityPinDescriptor::TypeInfo = ZHMTypeInfo("SEntityPinDescriptor", sizeof(SEntityPinDescriptor), alignof(SEntityPinDescriptor), SEntityPinDescriptor::WriteJson, SEntityPinDescriptor::WriteSimpleJson, SEntityPinDescriptor::FromSimpleJson, SEntityPinDescriptor::Serialize, SEntityPinDescriptor::Equals);

void SEntityPinDescriptor::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourceID") << ",\"$val\":";
	ZResourceID::WriteJson(&s_Object->type, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsPlaceholder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bIsPlaceholder);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityPinDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->type, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsPlaceholder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsPlaceholder);

	p_Stream << "}";
}

void SEntityPinDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityPinDescriptor s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	s_Object.sDisplayName = std::string_view(p_Document["sDisplayName"]);

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["type"], &s_Item);
		s_Object.type = s_Item;
	}

	s_Object.sHelpText = std::string_view(p_Document["sHelpText"]);

	s_Object.bIsPlaceholder = simdjson::from_json_bool(p_Document["bIsPlaceholder"]);

	*reinterpret_cast<SEntityPinDescriptor*>(p_Target) = s_Object;
}

void SEntityPinDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sDisplayName));
	ZResourceID::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, type));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sHelpText));
}

bool SEntityPinDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityPinDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityPinDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityPinDescriptor::operator==(const SEntityPinDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityPinDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (type != p_Other.type) return false;
	if (sHelpText != p_Other.sHelpText) return false;
	if (bIsPlaceholder != p_Other.bIsPlaceholder) return false;

	return true;
}

ZHMTypeInfo SEntityTemplateEntitySubset::TypeInfo = ZHMTypeInfo("SEntityTemplateEntitySubset", sizeof(SEntityTemplateEntitySubset), alignof(SEntityTemplateEntitySubset), SEntityTemplateEntitySubset::WriteJson, SEntityTemplateEntitySubset::WriteSimpleJson, SEntityTemplateEntitySubset::FromSimpleJson, SEntityTemplateEntitySubset::Serialize, SEntityTemplateEntitySubset::Equals);

void SEntityTemplateEntitySubset::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("entities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entities.size(); ++i)
	{
		auto& s_Item0 = s_Object->entities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->entities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplateEntitySubset::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("entities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entities.size(); ++i)
	{
		auto& s_Item0 = s_Object->entities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->entities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityTemplateEntitySubset::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateEntitySubset s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["entities"])
	{
		s_Object.entities.push_back(simdjson::from_json_int32(s_Item0));
	}

	*reinterpret_cast<SEntityTemplateEntitySubset*>(p_Target) = s_Object;
}

void SEntityTemplateEntitySubset::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	TArray<int32>::Serialize(&s_Object->entities, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateEntitySubset, entities));
}

bool SEntityTemplateEntitySubset::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateEntitySubset::operator==(const SEntityTemplateEntitySubset& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateEntitySubset>)
		return false;

	if (entities != p_Other.entities) return false;

	return true;
}

ZHMTypeInfo SEntityTemplatePinConnection::TypeInfo = ZHMTypeInfo("SEntityTemplatePinConnection", sizeof(SEntityTemplatePinConnection), alignof(SEntityTemplatePinConnection), SEntityTemplatePinConnection::WriteJson, SEntityTemplatePinConnection::WriteSimpleJson, SEntityTemplatePinConnection::FromSimpleJson, SEntityTemplatePinConnection::Serialize, SEntityTemplatePinConnection::Equals);

void SEntityTemplatePinConnection::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("fromID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fromID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->toID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fromPinName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fromPinName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toPinName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->toPinName);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplatePinConnection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fromID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fromPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromPinName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toPinName);

	p_Stream << "}";
}

void SEntityTemplatePinConnection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePinConnection s_Object {};

	s_Object.fromID = simdjson::from_json_int32(p_Document["fromID"]);

	s_Object.toID = simdjson::from_json_int32(p_Document["toID"]);

	s_Object.fromPinName = std::string_view(p_Document["fromPinName"]);

	s_Object.toPinName = std::string_view(p_Document["toPinName"]);

	*reinterpret_cast<SEntityTemplatePinConnection*>(p_Target) = s_Object;
}

void SEntityTemplatePinConnection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	ZString::Serialize(&s_Object->fromPinName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, fromPinName));
	ZString::Serialize(&s_Object->toPinName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, toPinName));
}

bool SEntityTemplatePinConnection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePinConnection*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePinConnection*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePinConnection::operator==(const SEntityTemplatePinConnection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePinConnection>)
		return false;

	if (fromID != p_Other.fromID) return false;
	if (toID != p_Other.toID) return false;
	if (fromPinName != p_Other.fromPinName) return false;
	if (toPinName != p_Other.toPinName) return false;

	return true;
}

ZHMTypeInfo SEntityTemplatePropertyAlias::TypeInfo = ZHMTypeInfo("SEntityTemplatePropertyAlias", sizeof(SEntityTemplatePropertyAlias), alignof(SEntityTemplatePropertyAlias), SEntityTemplatePropertyAlias::WriteJson, SEntityTemplatePropertyAlias::WriteSimpleJson, SEntityTemplatePropertyAlias::FromSimpleJson, SEntityTemplatePropertyAlias::Serialize, SEntityTemplatePropertyAlias::Equals);

void SEntityTemplatePropertyAlias::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sAliasName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sAliasName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sPropertyName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sPropertyName);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplatePropertyAlias::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sAliasName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sAliasName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sPropertyName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sPropertyName);

	p_Stream << "}";
}

void SEntityTemplatePropertyAlias::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePropertyAlias s_Object {};

	s_Object.sAliasName = std::string_view(p_Document["sAliasName"]);

	s_Object.entityID = simdjson::from_json_int32(p_Document["entityID"]);

	s_Object.sPropertyName = std::string_view(p_Document["sPropertyName"]);

	*reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Target) = s_Object;
}

void SEntityTemplatePropertyAlias::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	ZString::Serialize(&s_Object->sAliasName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyAlias, sAliasName));
	ZString::Serialize(&s_Object->sPropertyName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyAlias, sPropertyName));
}

bool SEntityTemplatePropertyAlias::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePropertyAlias::operator==(const SEntityTemplatePropertyAlias& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePropertyAlias>)
		return false;

	if (sAliasName != p_Other.sAliasName) return false;
	if (entityID != p_Other.entityID) return false;
	if (sPropertyName != p_Other.sPropertyName) return false;

	return true;
}

ZHMTypeInfo SEntityTemplateReference::TypeInfo = ZHMTypeInfo("SEntityTemplateReference", sizeof(SEntityTemplateReference), alignof(SEntityTemplateReference), SEntityTemplateReference::WriteJson, SEntityTemplateReference::WriteSimpleJson, SEntityTemplateReference::FromSimpleJson, SEntityTemplateReference::Serialize, SEntityTemplateReference::Equals);

void SEntityTemplateReference::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->externalSceneIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->exposedEntity);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplateReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->externalSceneIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->exposedEntity);

	p_Stream << "}";
}

void SEntityTemplateReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateReference s_Object {};

	s_Object.entityID = simdjson::from_json_uint64(p_Document["entityID"]);

	s_Object.externalSceneIndex = simdjson::from_json_int32(p_Document["externalSceneIndex"]);

	s_Object.entityIndex = simdjson::from_json_int32(p_Document["entityIndex"]);

	s_Object.exposedEntity = std::string_view(p_Document["exposedEntity"]);

	*reinterpret_cast<SEntityTemplateReference*>(p_Target) = s_Object;
}

void SEntityTemplateReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	ZString::Serialize(&s_Object->exposedEntity, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateReference, exposedEntity));
}

bool SEntityTemplateReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateReference*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateReference::operator==(const SEntityTemplateReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateReference>)
		return false;

	if (entityID != p_Other.entityID) return false;
	if (externalSceneIndex != p_Other.externalSceneIndex) return false;
	if (entityIndex != p_Other.entityIndex) return false;
	if (exposedEntity != p_Other.exposedEntity) return false;

	return true;
}

ZHMTypeInfo SEntityTemplatePropertyOverride::TypeInfo = ZHMTypeInfo("SEntityTemplatePropertyOverride", sizeof(SEntityTemplatePropertyOverride), alignof(SEntityTemplatePropertyOverride), SEntityTemplatePropertyOverride::WriteJson, SEntityTemplatePropertyOverride::WriteSimpleJson, SEntityTemplatePropertyOverride::FromSimpleJson, SEntityTemplatePropertyOverride::Serialize, SEntityTemplatePropertyOverride::Equals);

void SEntityTemplatePropertyOverride::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("propertyOwner") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateReference") << ",\"$val\":";
	SEntityTemplateReference::WriteJson(&s_Object->propertyOwner, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateProperty") << ",\"$val\":";
	SEntityTemplateProperty::WriteJson(&s_Object->propertyValue, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SEntityTemplatePropertyOverride::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("propertyOwner") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->propertyOwner, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValue") << ":";
	SEntityTemplateProperty::WriteSimpleJson(&s_Object->propertyValue, p_Stream);

	p_Stream << "}";
}

void SEntityTemplatePropertyOverride::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePropertyOverride s_Object {};

	{
		SEntityTemplateReference s_Item {};
		SEntityTemplateReference::FromSimpleJson(p_Document["propertyOwner"], &s_Item);
		s_Object.propertyOwner = s_Item;
	}

	{
		SEntityTemplateProperty s_Item {};
		SEntityTemplateProperty::FromSimpleJson(p_Document["propertyValue"], &s_Item);
		s_Object.propertyValue = s_Item;
	}

	*reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Target) = s_Object;
}

void SEntityTemplatePropertyOverride::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->propertyOwner, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyOverride, propertyOwner));
	SEntityTemplateProperty::Serialize(&s_Object->propertyValue, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyOverride, propertyValue));
}

bool SEntityTemplatePropertyOverride::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePropertyOverride::operator==(const SEntityTemplatePropertyOverride& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePropertyOverride>)
		return false;

	if (propertyOwner != p_Other.propertyOwner) return false;
	if (propertyValue != p_Other.propertyValue) return false;

	return true;
}

ZHMTypeInfo SEnvironmentConfigResourceEntry::TypeInfo = ZHMTypeInfo("SEnvironmentConfigResourceEntry", sizeof(SEnvironmentConfigResourceEntry), alignof(SEnvironmentConfigResourceEntry), SEnvironmentConfigResourceEntry::WriteJson, SEnvironmentConfigResourceEntry::WriteSimpleJson, SEnvironmentConfigResourceEntry::FromSimpleJson, SEnvironmentConfigResourceEntry::Serialize, SEnvironmentConfigResourceEntry::Equals);

void SEnvironmentConfigResourceEntry::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("Name") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->Name);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ContractsDatastoreRid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourceID") << ",\"$val\":";
	ZResourceID::WriteJson(&s_Object->ContractsDatastoreRid, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("UnlockablesDatastoreRid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourceID") << ",\"$val\":";
	ZResourceID::WriteJson(&s_Object->UnlockablesDatastoreRid, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("BlobsDatastoreRid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourceID") << ",\"$val\":";
	ZResourceID::WriteJson(&s_Object->BlobsDatastoreRid, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SEnvironmentConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Name") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Name);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ContractsDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->ContractsDatastoreRid, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("UnlockablesDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->UnlockablesDatastoreRid, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("BlobsDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->BlobsDatastoreRid, p_Stream);

	p_Stream << "}";
}

void SEnvironmentConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEnvironmentConfigResourceEntry s_Object {};

	s_Object.Name = std::string_view(p_Document["Name"]);

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["ContractsDatastoreRid"], &s_Item);
		s_Object.ContractsDatastoreRid = s_Item;
	}

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["UnlockablesDatastoreRid"], &s_Item);
		s_Object.UnlockablesDatastoreRid = s_Item;
	}

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["BlobsDatastoreRid"], &s_Item);
		s_Object.BlobsDatastoreRid = s_Item;
	}

	*reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Target) = s_Object;
}

void SEnvironmentConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Name, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, Name));
	ZResourceID::Serialize(&s_Object->ContractsDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, ContractsDatastoreRid));
	ZResourceID::Serialize(&s_Object->UnlockablesDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, UnlockablesDatastoreRid));
	ZResourceID::Serialize(&s_Object->BlobsDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, BlobsDatastoreRid));
}

bool SEnvironmentConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEnvironmentConfigResourceEntry::operator==(const SEnvironmentConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEnvironmentConfigResourceEntry>)
		return false;

	if (Name != p_Other.Name) return false;
	if (ContractsDatastoreRid != p_Other.ContractsDatastoreRid) return false;
	if (UnlockablesDatastoreRid != p_Other.UnlockablesDatastoreRid) return false;
	if (BlobsDatastoreRid != p_Other.BlobsDatastoreRid) return false;

	return true;
}

ZHMTypeInfo SEnvironmentConfigResource::TypeInfo = ZHMTypeInfo("SEnvironmentConfigResource", sizeof(SEnvironmentConfigResource), alignof(SEnvironmentConfigResource), SEnvironmentConfigResource::WriteJson, SEnvironmentConfigResource::WriteSimpleJson, SEnvironmentConfigResource::FromSimpleJson, SEnvironmentConfigResource::Serialize, SEnvironmentConfigResource::Equals);

void SEnvironmentConfigResource::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("Environments") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEnvironmentConfigResourceEntry>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Environments.size(); ++i)
	{
		auto& s_Item0 = s_Object->Environments[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEnvironmentConfigResourceEntry") << ",\"$val\":";
		SEnvironmentConfigResourceEntry::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->Environments.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SEnvironmentConfigResource::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Environments") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Environments.size(); ++i)
	{
		auto& s_Item0 = s_Object->Environments[i];
		SEnvironmentConfigResourceEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->Environments.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEnvironmentConfigResource::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEnvironmentConfigResource s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["Environments"])
	{
		SEnvironmentConfigResourceEntry s_ArrayItem0;
		SEnvironmentConfigResourceEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.Environments.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SEnvironmentConfigResource*>(p_Target) = s_Object;
}

void SEnvironmentConfigResource::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);

	TArray<SEnvironmentConfigResourceEntry>::Serialize(&s_Object->Environments, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResource, Environments));
}

bool SEnvironmentConfigResource::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEnvironmentConfigResource*>(p_Left);
	auto* s_Right = reinterpret_cast<SEnvironmentConfigResource*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEnvironmentConfigResource::operator==(const SEnvironmentConfigResource& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEnvironmentConfigResource>)
		return false;

	if (Environments != p_Other.Environments) return false;

	return true;
}

ZHMTypeInfo SEscortOutBehaviorSaveData::TypeInfo = ZHMTypeInfo("SEscortOutBehaviorSaveData", sizeof(SEscortOutBehaviorSaveData), alignof(SEscortOutBehaviorSaveData), SEscortOutBehaviorSaveData::WriteJson, SEscortOutBehaviorSaveData::WriteSimpleJson, SEscortOutBehaviorSaveData::FromSimpleJson, SEscortOutBehaviorSaveData::Serialize, SEscortOutBehaviorSaveData::Equals);

void SEscortOutBehaviorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bConversationHelperPaused") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bConversationHelperPaused);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsm") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsm, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vExitPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vExitPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWarningTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tWarningTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHardWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHardWarning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEscortStateSilenceTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tEscortStateSilenceTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitHitmanToComplyWarningTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tWaitHitmanToComplyWarningTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitHitmanToComplyStateTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tWaitHitmanToComplyStateTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastLookBack") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastLookBack, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReachedExitPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReachedExitPosition);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowExitWarningEnded") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowExitWarningEnded);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bJustShowExit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bJustShowExit);
	p_Stream << "}";

	p_Stream << "}";
}

void SEscortOutBehaviorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bConversationHelperPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bConversationHelperPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsm") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsm, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vExitPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vExitPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWarningTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWarningTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHardWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHardWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEscortStateSilenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEscortStateSilenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitHitmanToComplyWarningTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitHitmanToComplyWarningTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitHitmanToComplyStateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitHitmanToComplyStateTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastLookBack") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastLookBack, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReachedExitPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReachedExitPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowExitWarningEnded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowExitWarningEnded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bJustShowExit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bJustShowExit);

	p_Stream << "}";
}

void SEscortOutBehaviorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortOutBehaviorSaveData s_Object {};

	s_Object.m_nSituation = simdjson::from_json_int32(p_Document["m_nSituation"]);

	s_Object.m_bConversationHelperPaused = simdjson::from_json_bool(p_Document["m_bConversationHelperPaused"]);

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsm"], &s_Item);
		s_Object.m_fsm = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vExitPosition"], &s_Item);
		s_Object.m_vExitPosition = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tWarningTime"], &s_Item);
		s_Object.m_tWarningTime = s_Item;
	}

	s_Object.m_bHardWarning = simdjson::from_json_bool(p_Document["m_bHardWarning"]);

	s_Object.m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tEscortStateSilenceTime"], &s_Item);
		s_Object.m_tEscortStateSilenceTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tWaitHitmanToComplyWarningTime"], &s_Item);
		s_Object.m_tWaitHitmanToComplyWarningTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tWaitHitmanToComplyStateTime"], &s_Item);
		s_Object.m_tWaitHitmanToComplyStateTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastLookBack"], &s_Item);
		s_Object.m_tLastLookBack = s_Item;
	}

	s_Object.m_bReachedExitPosition = simdjson::from_json_bool(p_Document["m_bReachedExitPosition"]);

	s_Object.m_bShowExitWarningEnded = simdjson::from_json_bool(p_Document["m_bShowExitWarningEnded"]);

	s_Object.m_bJustShowExit = simdjson::from_json_bool(p_Document["m_bJustShowExit"]);

	*reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Target) = s_Object;
}

void SEscortOutBehaviorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsm, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_fsm));
	float4::Serialize(&s_Object->m_vExitPosition, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_vExitPosition));
	ZGameTime::Serialize(&s_Object->m_tWarningTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWarningTime));
	ZGameTime::Serialize(&s_Object->m_tEscortStateSilenceTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tEscortStateSilenceTime));
	ZGameTime::Serialize(&s_Object->m_tWaitHitmanToComplyWarningTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWaitHitmanToComplyWarningTime));
	ZGameTime::Serialize(&s_Object->m_tWaitHitmanToComplyStateTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWaitHitmanToComplyStateTime));
	ZGameTime::Serialize(&s_Object->m_tLastLookBack, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tLastLookBack));
}

bool SEscortOutBehaviorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortOutBehaviorSaveData::operator==(const SEscortOutBehaviorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortOutBehaviorSaveData>)
		return false;

	if (m_nSituation != p_Other.m_nSituation) return false;
	if (m_bConversationHelperPaused != p_Other.m_bConversationHelperPaused) return false;
	if (m_fsm != p_Other.m_fsm) return false;
	if (m_vExitPosition != p_Other.m_vExitPosition) return false;
	if (m_tWarningTime != p_Other.m_tWarningTime) return false;
	if (m_bHardWarning != p_Other.m_bHardWarning) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_tEscortStateSilenceTime != p_Other.m_tEscortStateSilenceTime) return false;
	if (m_tWaitHitmanToComplyWarningTime != p_Other.m_tWaitHitmanToComplyWarningTime) return false;
	if (m_tWaitHitmanToComplyStateTime != p_Other.m_tWaitHitmanToComplyStateTime) return false;
	if (m_tLastLookBack != p_Other.m_tLastLookBack) return false;
	if (m_bReachedExitPosition != p_Other.m_bReachedExitPosition) return false;
	if (m_bShowExitWarningEnded != p_Other.m_bShowExitWarningEnded) return false;
	if (m_bJustShowExit != p_Other.m_bJustShowExit) return false;

	return true;
}

ZHMTypeInfo SEscortOutOrderSaveData::TypeInfo = ZHMTypeInfo("SEscortOutOrderSaveData", sizeof(SEscortOutOrderSaveData), alignof(SEscortOutOrderSaveData), SEscortOutOrderSaveData::WriteJson, SEscortOutOrderSaveData::WriteSimpleJson, SEscortOutOrderSaveData::FromSimpleJson, SEscortOutOrderSaveData::Serialize, SEscortOutOrderSaveData::Equals);

void SEscortOutOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aExitPoints") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<float4>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aExitPoints.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aExitPoints[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
		float4::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aExitPoints.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SEscortOutOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aExitPoints") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aExitPoints.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aExitPoints[i];
		float4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aExitPoints.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEscortOutOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortOutOrderSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aExitPoints"])
	{
		float4 s_ArrayItem0;
		float4::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aExitPoints.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SEscortOutOrderSaveData*>(p_Target) = s_Object;
}

void SEscortOutOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);

	TArray<float4>::Serialize(&s_Object->m_aExitPoints, p_Serializer, p_OwnOffset + offsetof(SEscortOutOrderSaveData, m_aExitPoints));
}

bool SEscortOutOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortOutOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortOutOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortOutOrderSaveData::operator==(const SEscortOutOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortOutOrderSaveData>)
		return false;

	if (m_aExitPoints != p_Other.m_aExitPoints) return false;

	return true;
}

ZHMTypeInfo SEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SEscortSituationActorStateSaveData", sizeof(SEscortSituationActorStateSaveData), alignof(SEscortSituationActorStateSaveData), SEscortSituationActorStateSaveData::WriteJson, SEscortSituationActorStateSaveData::WriteSimpleJson, SEscortSituationActorStateSaveData::FromSimpleJson, SEscortSituationActorStateSaveData::Serialize, SEscortSituationActorStateSaveData::Equals);

void SEscortSituationActorStateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZEscortSituationEntity.EEscortState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZEscortSituationEntity.EEscortState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eStatePrevious)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);
	p_Stream << "}";

	p_Stream << "}";
}

void SEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituationActorStateSaveData s_Object {};

	s_Object.m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_eState = static_cast<ZEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object.m_eStatePrevious = static_cast<ZEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object.m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

	*reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Target) = s_Object;
}

void SEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);

}

bool SEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationActorStateSaveData::operator==(const SEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

ZHMTypeInfo SEscortSituationActors::TypeInfo = ZHMTypeInfo("SEscortSituationActors", sizeof(SEscortSituationActors), alignof(SEscortSituationActors), SEscortSituationActors::WriteJson, SEscortSituationActors::WriteSimpleJson, SEscortSituationActors::FromSimpleJson, SEscortSituationActors::Serialize, SEscortSituationActors::Equals);

void SEscortSituationActors::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituationActors s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SEscortSituationActors*>(p_Target) = s_Object;
}

void SEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);

}

bool SEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationActors::operator==(const SEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SEscortSituationSaveData::TypeInfo = ZHMTypeInfo("SEscortSituationSaveData", sizeof(SEscortSituationSaveData), alignof(SEscortSituationSaveData), SEscortSituationSaveData::WriteJson, SEscortSituationSaveData::WriteSimpleJson, SEscortSituationSaveData::FromSimpleJson, SEscortSituationSaveData::Serialize, SEscortSituationSaveData::Equals);

void SEscortSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceSearch") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceSearch);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFoundDeadTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFoundDeadTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetDeadTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetDeadTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZEscortSituationEntity.ETargetState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorEmotionState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetEmotionState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZActBehaviorEntity.EState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetActState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEscortSituationActors>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEscortSituationActors") << ",\"$val\":";
		SEscortSituationActors::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEscortSituationActorStateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEscortSituationActorStateSaveData") << ",\"$val\":";
		SEscortSituationActorStateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSearchActs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSearchActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSearchActs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aSearchActs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SEscortSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceSearch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceSearch);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFoundDeadTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFoundDeadTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetDeadTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetDeadTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SEscortSituationActors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SEscortSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSearchActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSearchActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSearchActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSearchActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEscortSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituationSaveData s_Object {};

	s_Object.m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object.m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object.m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object.m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object.m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	s_Object.m_bForceSearch = simdjson::from_json_bool(p_Document["m_bForceSearch"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Item);
		s_Object.m_vLastPosition = s_Item;
	}

	s_Object.m_bFoundDeadTarget = simdjson::from_json_bool(p_Document["m_bFoundDeadTarget"]);

	s_Object.m_nTargetDeadTime = simdjson::from_json_int64(p_Document["m_nTargetDeadTime"]);

	s_Object.m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object.m_eTargetState = static_cast<ZEscortSituationEntity_ETargetState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object.m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object.m_eTargetActState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object.m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object.m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAddedActors"])
	{
		SEscortSituationActors s_ArrayItem0;
		SEscortSituationActors::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAddedActors.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aStates"])
	{
		SEscortSituationActorStateSaveData s_ArrayItem0;
		SEscortSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEscortActs"])
	{
		s_Object.m_aEscortActs.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSearchActs"])
	{
		s_Object.m_aSearchActs.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SEscortSituationSaveData*>(p_Target) = s_Object;
}

void SEscortSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_vLastPosition));
	TArray<SEscortSituationActors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aAddedActors));
	TArray<SEscortSituationActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aEscortActs));
	TArray<uint32>::Serialize(&s_Object->m_aSearchActs, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aSearchActs));
}

bool SEscortSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationSaveData::operator==(const SEscortSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationSaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_bForceSearch != p_Other.m_bForceSearch) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bFoundDeadTarget != p_Other.m_bFoundDeadTarget) return false;
	if (m_nTargetDeadTime != p_Other.m_nTargetDeadTime) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;
	if (m_aSearchActs != p_Other.m_aSearchActs) return false;

	return true;
}

ZHMTypeInfo SEvacuateSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SEvacuateSituationMemberSaveData", sizeof(SEvacuateSituationMemberSaveData), alignof(SEvacuateSituationMemberSaveData), SEvacuateSituationMemberSaveData::WriteJson, SEvacuateSituationMemberSaveData::WriteSimpleJson, SEvacuateSituationMemberSaveData::FromSimpleJson, SEvacuateSituationMemberSaveData::Serialize, SEvacuateSituationMemberSaveData::Equals);

void SEvacuateSituationMemberSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pGuardDutyPoint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuardDutyPoint);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointSubIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointSubIndex);
	p_Stream << "}";

	p_Stream << "}";
}

void SEvacuateSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pGuardDutyPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuardDutyPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointSubIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointSubIndex);

	p_Stream << "}";
}

void SEvacuateSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvacuateSituationMemberSaveData s_Object {};

	s_Object.m_pGuardDutyPoint = simdjson::from_json_uint32(p_Document["m_pGuardDutyPoint"]);

	s_Object.m_nPatrolWaypointIndex = simdjson::from_json_int32(p_Document["m_nPatrolWaypointIndex"]);

	s_Object.m_nPatrolWaypointSubIndex = simdjson::from_json_uint32(p_Document["m_nPatrolWaypointSubIndex"]);

	*reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Target) = s_Object;
}

void SEvacuateSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);

}

bool SEvacuateSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateSituationMemberSaveData::operator==(const SEvacuateSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateSituationMemberSaveData>)
		return false;

	if (m_pGuardDutyPoint != p_Other.m_pGuardDutyPoint) return false;
	if (m_nPatrolWaypointIndex != p_Other.m_nPatrolWaypointIndex) return false;
	if (m_nPatrolWaypointSubIndex != p_Other.m_nPatrolWaypointSubIndex) return false;

	return true;
}

ZHMTypeInfo SEvacuateSituationSaveData::TypeInfo = ZHMTypeInfo("SEvacuateSituationSaveData", sizeof(SEvacuateSituationSaveData), alignof(SEvacuateSituationSaveData), SEvacuateSituationSaveData::WriteJson, SEvacuateSituationSaveData::WriteSimpleJson, SEvacuateSituationSaveData::FromSimpleJson, SEvacuateSituationSaveData::Serialize, SEvacuateSituationSaveData::Equals);

void SEvacuateSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSeriousSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastSeriousSituation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastThreat") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastThreat, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tresspassGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_tresspassGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_evacuateGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_evacuateGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_evacuateGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_evacuateGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_activeSafeRooms") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_activeSafeRooms.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_activeSafeRooms[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_activeSafeRooms.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SEvacuateSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSeriousSituation") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSeriousSituation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastThreat") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastThreat, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tresspassGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_tresspassGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_evacuateGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_evacuateGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_evacuateGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_evacuateGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_activeSafeRooms") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_activeSafeRooms.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_activeSafeRooms[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_activeSafeRooms.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEvacuateSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvacuateSituationSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastSeriousSituation"], &s_Item);
		s_Object.m_tLastSeriousSituation = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastThreat"], &s_Item);
		s_Object.m_tLastThreat = s_Item;
	}

	s_Object.m_tresspassGroup = simdjson::from_json_int32(p_Document["m_tresspassGroup"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_evacuateGroups"])
	{
		s_Object.m_evacuateGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_activeSafeRooms"])
	{
		s_Object.m_activeSafeRooms.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SEvacuateSituationSaveData*>(p_Target) = s_Object;
}

void SEvacuateSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tLastSeriousSituation, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_tLastSeriousSituation));
	ZGameTime::Serialize(&s_Object->m_tLastThreat, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_tLastThreat));
	TArray<int32>::Serialize(&s_Object->m_evacuateGroups, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_evacuateGroups));
	TArray<uint32>::Serialize(&s_Object->m_activeSafeRooms, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_activeSafeRooms));
}

bool SEvacuateSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateSituationSaveData::operator==(const SEvacuateSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateSituationSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tLastSeriousSituation != p_Other.m_tLastSeriousSituation) return false;
	if (m_tLastThreat != p_Other.m_tLastThreat) return false;
	if (m_tresspassGroup != p_Other.m_tresspassGroup) return false;
	if (m_evacuateGroups != p_Other.m_evacuateGroups) return false;
	if (m_activeSafeRooms != p_Other.m_activeSafeRooms) return false;

	return true;
}

ZHMTypeInfo SEvacuateTrespassGroupSaveData::TypeInfo = ZHMTypeInfo("SEvacuateTrespassGroupSaveData", sizeof(SEvacuateTrespassGroupSaveData), alignof(SEvacuateTrespassGroupSaveData), SEvacuateTrespassGroupSaveData::WriteJson, SEvacuateTrespassGroupSaveData::WriteSimpleJson, SEvacuateTrespassGroupSaveData::FromSimpleJson, SEvacuateTrespassGroupSaveData::Serialize, SEvacuateTrespassGroupSaveData::Equals);

void SEvacuateTrespassGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_safeRoomNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_safeRoomNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_leader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_leader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assistant") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_assistant);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_escalate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_escalate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_completed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_completed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_standDown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_standDown);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_warningCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_warningCount);
	p_Stream << "}";

	p_Stream << "}";
}

void SEvacuateTrespassGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_safeRoomNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_safeRoomNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_leader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_leader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_assistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_escalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_escalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_completed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_completed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_standDown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_standDown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_warningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_warningCount);

	p_Stream << "}";
}

void SEvacuateTrespassGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvacuateTrespassGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_safeRoomNode = simdjson::from_json_uint32(p_Document["m_safeRoomNode"]);

	s_Object.m_leader = simdjson::from_json_uint32(p_Document["m_leader"]);

	s_Object.m_assistant = simdjson::from_json_uint32(p_Document["m_assistant"]);

	s_Object.m_escalate = simdjson::from_json_bool(p_Document["m_escalate"]);

	s_Object.m_completed = simdjson::from_json_bool(p_Document["m_completed"]);

	s_Object.m_standDown = simdjson::from_json_bool(p_Document["m_standDown"]);

	s_Object.m_warningCount = simdjson::from_json_int32(p_Document["m_warningCount"]);

	*reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Target) = s_Object;
}

void SEvacuateTrespassGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateTrespassGroupSaveData, m_fsmState));
}

bool SEvacuateTrespassGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateTrespassGroupSaveData::operator==(const SEvacuateTrespassGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateTrespassGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_safeRoomNode != p_Other.m_safeRoomNode) return false;
	if (m_leader != p_Other.m_leader) return false;
	if (m_assistant != p_Other.m_assistant) return false;
	if (m_escalate != p_Other.m_escalate) return false;
	if (m_completed != p_Other.m_completed) return false;
	if (m_standDown != p_Other.m_standDown) return false;
	if (m_warningCount != p_Other.m_warningCount) return false;

	return true;
}

ZHMTypeInfo SEvacuateVIPGroupSaveData::TypeInfo = ZHMTypeInfo("SEvacuateVIPGroupSaveData", sizeof(SEvacuateVIPGroupSaveData), alignof(SEvacuateVIPGroupSaveData), SEvacuateVIPGroupSaveData::WriteJson, SEvacuateVIPGroupSaveData::WriteSimpleJson, SEvacuateVIPGroupSaveData::FromSimpleJson, SEvacuateVIPGroupSaveData::Serialize, SEvacuateVIPGroupSaveData::Equals);

void SEvacuateVIPGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIP") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIP);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIPActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIPActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEvacuationNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEvacuationNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSafeRoomNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSafeRoomNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCompromisedEvacNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCompromisedEvacNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assignedBodyguards") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_assignedBodyguards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_assignedBodyguards[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_assignedBodyguards.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEvacuationStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tEvacuationStart, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tCornered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tCornered, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSafeRoom") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tSafeRoom, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSafeRoomStandDown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tSafeRoomStandDown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInitialFlee") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInitialFlee);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_safeRoomVIPSentActingStarted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_safeRoomVIPSentActingStarted);
	p_Stream << "}";

	p_Stream << "}";
}

void SEvacuateVIPGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIP") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIP);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIPActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIPActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEvacuationNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEvacuationNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSafeRoomNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSafeRoomNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCompromisedEvacNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCompromisedEvacNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assignedBodyguards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_assignedBodyguards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_assignedBodyguards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_assignedBodyguards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEvacuationStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEvacuationStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tCornered") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tCornered, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSafeRoom") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tSafeRoom, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSafeRoomStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tSafeRoomStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInitialFlee") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInitialFlee);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_safeRoomVIPSentActingStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_safeRoomVIPSentActingStarted);

	p_Stream << "}";
}

void SEvacuateVIPGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvacuateVIPGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_rVIP = simdjson::from_json_uint32(p_Document["m_rVIP"]);

	s_Object.m_rVIPActor = simdjson::from_json_uint32(p_Document["m_rVIPActor"]);

	s_Object.m_rEvacuationNode = simdjson::from_json_uint32(p_Document["m_rEvacuationNode"]);

	s_Object.m_rSafeRoomNode = simdjson::from_json_uint32(p_Document["m_rSafeRoomNode"]);

	s_Object.m_rCompromisedEvacNode = simdjson::from_json_uint32(p_Document["m_rCompromisedEvacNode"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_assignedBodyguards"])
	{
		s_Object.m_assignedBodyguards.push_back(simdjson::from_json_uint32(s_Item0));
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tEvacuationStart"], &s_Item);
		s_Object.m_tEvacuationStart = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tCornered"], &s_Item);
		s_Object.m_tCornered = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tSafeRoom"], &s_Item);
		s_Object.m_tSafeRoom = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tSafeRoomStandDown"], &s_Item);
		s_Object.m_tSafeRoomStandDown = s_Item;
	}

	s_Object.m_bInitialFlee = simdjson::from_json_bool(p_Document["m_bInitialFlee"]);

	s_Object.m_safeRoomVIPSentActingStarted = simdjson::from_json_bool(p_Document["m_safeRoomVIPSentActingStarted"]);

	*reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Target) = s_Object;
}

void SEvacuateVIPGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_fsmState));
	TArray<uint32>::Serialize(&s_Object->m_assignedBodyguards, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_assignedBodyguards));
	ZGameTime::Serialize(&s_Object->m_tEvacuationStart, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tEvacuationStart));
	ZGameTime::Serialize(&s_Object->m_tCornered, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tCornered));
	ZGameTime::Serialize(&s_Object->m_tSafeRoom, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tSafeRoom));
	ZGameTime::Serialize(&s_Object->m_tSafeRoomStandDown, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tSafeRoomStandDown));
}

bool SEvacuateVIPGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateVIPGroupSaveData::operator==(const SEvacuateVIPGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateVIPGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rVIP != p_Other.m_rVIP) return false;
	if (m_rVIPActor != p_Other.m_rVIPActor) return false;
	if (m_rEvacuationNode != p_Other.m_rEvacuationNode) return false;
	if (m_rSafeRoomNode != p_Other.m_rSafeRoomNode) return false;
	if (m_rCompromisedEvacNode != p_Other.m_rCompromisedEvacNode) return false;
	if (m_assignedBodyguards != p_Other.m_assignedBodyguards) return false;
	if (m_tEvacuationStart != p_Other.m_tEvacuationStart) return false;
	if (m_tCornered != p_Other.m_tCornered) return false;
	if (m_tSafeRoom != p_Other.m_tSafeRoom) return false;
	if (m_tSafeRoomStandDown != p_Other.m_tSafeRoomStandDown) return false;
	if (m_bInitialFlee != p_Other.m_bInitialFlee) return false;
	if (m_safeRoomVIPSentActingStarted != p_Other.m_safeRoomVIPSentActingStarted) return false;

	return true;
}

ZHMTypeInfo SEventChannelSaveData::TypeInfo = ZHMTypeInfo("SEventChannelSaveData", sizeof(SEventChannelSaveData), alignof(SEventChannelSaveData), SEventChannelSaveData::WriteJson, SEventChannelSaveData::WriteSimpleJson, SEventChannelSaveData::FromSimpleJson, SEventChannelSaveData::Serialize, SEventChannelSaveData::Equals);

void SEventChannelSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SEventChannelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SEventChannelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEventChannelSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SEventChannelSaveData*>(p_Target) = s_Object;
}

void SEventChannelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);

}

bool SEventChannelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventChannelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventChannelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventChannelSaveData::operator==(const SEventChannelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventChannelSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

ZHMTypeInfo SExitSaveData::TypeInfo = ZHMTypeInfo("SExitSaveData", sizeof(SExitSaveData), alignof(SExitSaveData), SExitSaveData::WriteJson, SExitSaveData::WriteSimpleJson, SExitSaveData::FromSimpleJson, SExitSaveData::Serialize, SExitSaveData::Equals);

void SExitSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SExitSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SExitSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExitSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SExitSaveData*>(p_Target) = s_Object;
}

void SExitSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);

}

bool SExitSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExitSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SExitSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExitSaveData::operator==(const SExitSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExitSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

ZHMTypeInfo SExposedEntityDescriptor::TypeInfo = ZHMTypeInfo("SExposedEntityDescriptor", sizeof(SExposedEntityDescriptor), alignof(SExposedEntityDescriptor), SExposedEntityDescriptor::WriteJson, SExposedEntityDescriptor::WriteSimpleJson, SExposedEntityDescriptor::FromSimpleJson, SExposedEntityDescriptor::Serialize, SExposedEntityDescriptor::Equals);

void SExposedEntityDescriptor::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sUpheldContract") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sUpheldContract);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << "}";

	p_Stream << "}";
}

void SExposedEntityDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sUpheldContract") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sUpheldContract);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);

	p_Stream << "}";
}

void SExposedEntityDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExposedEntityDescriptor s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	s_Object.sDisplayName = std::string_view(p_Document["sDisplayName"]);

	s_Object.sUpheldContract = std::string_view(p_Document["sUpheldContract"]);

	s_Object.sHelpText = std::string_view(p_Document["sHelpText"]);

	*reinterpret_cast<SExposedEntityDescriptor*>(p_Target) = s_Object;
}

void SExposedEntityDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sDisplayName));
	ZString::Serialize(&s_Object->sUpheldContract, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sUpheldContract));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sHelpText));
}

bool SExposedEntityDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExposedEntityDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SExposedEntityDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExposedEntityDescriptor::operator==(const SExposedEntityDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExposedEntityDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (sUpheldContract != p_Other.sUpheldContract) return false;
	if (sHelpText != p_Other.sHelpText) return false;

	return true;
}

ZHMTypeInfo SFRange::TypeInfo = ZHMTypeInfo("SFRange", sizeof(SFRange), alignof(SFRange), SFRange::WriteJson, SFRange::WriteSimpleJson, SFRange::FromSimpleJson, SFRange::Serialize, SFRange::Equals);

void SFRange::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fMin") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMin);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMax);
	p_Stream << "}";

	p_Stream << "}";
}

void SFRange::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fMin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMax);

	p_Stream << "}";
}

void SFRange::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFRange s_Object {};

	s_Object.m_fMin = simdjson::from_json_float32(p_Document["m_fMin"]);

	s_Object.m_fMax = simdjson::from_json_float32(p_Document["m_fMax"]);

	*reinterpret_cast<SFRange*>(p_Target) = s_Object;
}

void SFRange::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);

}

bool SFRange::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFRange*>(p_Left);
	auto* s_Right = reinterpret_cast<SFRange*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFRange::operator==(const SFRange& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFRange>)
		return false;

	if (m_fMin != p_Other.m_fMin) return false;
	if (m_fMax != p_Other.m_fMax) return false;

	return true;
}

ZHMTypeInfo SFaceOrderSaveData::TypeInfo = ZHMTypeInfo("SFaceOrderSaveData", sizeof(SFaceOrderSaveData), alignof(SFaceOrderSaveData), SFaceOrderSaveData::WriteJson, SFaceOrderSaveData::WriteSimpleJson, SFaceOrderSaveData::FromSimpleJson, SFaceOrderSaveData::Serialize, SFaceOrderSaveData::Equals);

void SFaceOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bLookAt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAt);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAimAt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAimAt);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateKnownPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateKnownPosition);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDurationVariance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDurationVariance);
	p_Stream << "}";

	p_Stream << "}";
}

void SFaceOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bLookAt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAimAt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAimAt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateKnownPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateKnownPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDurationVariance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDurationVariance);

	p_Stream << "}";
}

void SFaceOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFaceOrderSaveData s_Object {};

	s_Object.m_bLookAt = simdjson::from_json_bool(p_Document["m_bLookAt"]);

	s_Object.m_bAimAt = simdjson::from_json_bool(p_Document["m_bAimAt"]);

	s_Object.m_bUpdateKnownPosition = simdjson::from_json_bool(p_Document["m_bUpdateKnownPosition"]);

	s_Object.m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object.m_fDurationVariance = simdjson::from_json_float32(p_Document["m_fDurationVariance"]);

	*reinterpret_cast<SFaceOrderSaveData*>(p_Target) = s_Object;
}

void SFaceOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);

}

bool SFaceOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFaceOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFaceOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFaceOrderSaveData::operator==(const SFaceOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFaceOrderSaveData>)
		return false;

	if (m_bLookAt != p_Other.m_bLookAt) return false;
	if (m_bAimAt != p_Other.m_bAimAt) return false;
	if (m_bUpdateKnownPosition != p_Other.m_bUpdateKnownPosition) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_fDurationVariance != p_Other.m_fDurationVariance) return false;

	return true;
}

ZHMTypeInfo SFleeOrderSaveData::TypeInfo = ZHMTypeInfo("SFleeOrderSaveData", sizeof(SFleeOrderSaveData), alignof(SFleeOrderSaveData), SFleeOrderSaveData::WriteJson, SFleeOrderSaveData::WriteSimpleJson, SFleeOrderSaveData::FromSimpleJson, SFleeOrderSaveData::Serialize, SFleeOrderSaveData::Equals);

void SFleeOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eHelpReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eHelpReason)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eHelpReason))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridNodeIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridNodeIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFleeForHelp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFleeForHelp);
	p_Stream << "}";

	p_Stream << "}";
}

void SFleeOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eHelpReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eHelpReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFleeForHelp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFleeForHelp);

	p_Stream << "}";
}

void SFleeOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFleeOrderSaveData s_Object {};

	s_Object.m_eHelpReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eHelpReason"])));

	s_Object.m_nGridNodeIndex = simdjson::from_json_uint16(p_Document["m_nGridNodeIndex"]);

	s_Object.m_bFleeForHelp = simdjson::from_json_bool(p_Document["m_bFleeForHelp"]);

	*reinterpret_cast<SFleeOrderSaveData*>(p_Target) = s_Object;
}

void SFleeOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);

}

bool SFleeOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFleeOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFleeOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFleeOrderSaveData::operator==(const SFleeOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFleeOrderSaveData>)
		return false;

	if (m_eHelpReason != p_Other.m_eHelpReason) return false;
	if (m_nGridNodeIndex != p_Other.m_nGridNodeIndex) return false;
	if (m_bFleeForHelp != p_Other.m_bFleeForHelp) return false;

	return true;
}

ZHMTypeInfo SFontDefinition::TypeInfo = ZHMTypeInfo("SFontDefinition", sizeof(SFontDefinition), alignof(SFontDefinition), SFontDefinition::WriteJson, SFontDefinition::WriteSimpleJson, SFontDefinition::FromSimpleJson, SFontDefinition::Serialize, SFontDefinition::Equals);

void SFontDefinition::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sFontId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sFontId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sFontName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sFontName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eFontFlags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EFontFlags") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->eFontFlags)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EFontFlags", static_cast<int>(s_Object->eFontFlags))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScaleFactor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fScaleFactor);
	p_Stream << "}";

	p_Stream << "}";
}

void SFontDefinition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFontId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sFontName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eFontFlags") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EFontFlags", static_cast<int>(s_Object->eFontFlags)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScaleFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fScaleFactor);

	p_Stream << "}";
}

void SFontDefinition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFontDefinition s_Object {};

	s_Object.sFontId = std::string_view(p_Document["sFontId"]);

	s_Object.sFontName = std::string_view(p_Document["sFontName"]);

	s_Object.eFontFlags = static_cast<EFontFlags>(ZHMEnums::GetEnumValueByName("EFontFlags", std::string_view(p_Document["eFontFlags"])));

	s_Object.fScaleFactor = simdjson::from_json_float32(p_Document["fScaleFactor"]);

	*reinterpret_cast<SFontDefinition*>(p_Target) = s_Object;
}

void SFontDefinition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);

	ZString::Serialize(&s_Object->sFontId, p_Serializer, p_OwnOffset + offsetof(SFontDefinition, sFontId));
	ZString::Serialize(&s_Object->sFontName, p_Serializer, p_OwnOffset + offsetof(SFontDefinition, sFontName));
}

bool SFontDefinition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFontDefinition*>(p_Left);
	auto* s_Right = reinterpret_cast<SFontDefinition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFontDefinition::operator==(const SFontDefinition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFontDefinition>)
		return false;

	if (sFontId != p_Other.sFontId) return false;
	if (sFontName != p_Other.sFontName) return false;
	if (eFontFlags != p_Other.eFontFlags) return false;
	if (fScaleFactor != p_Other.fScaleFactor) return false;

	return true;
}

ZHMTypeInfo SFontLibraryDefinition::TypeInfo = ZHMTypeInfo("SFontLibraryDefinition", sizeof(SFontLibraryDefinition), alignof(SFontLibraryDefinition), SFontLibraryDefinition::WriteJson, SFontLibraryDefinition::WriteSimpleJson, SFontLibraryDefinition::FromSimpleJson, SFontLibraryDefinition::Serialize, SFontLibraryDefinition::Equals);

void SFontLibraryDefinition::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sFontLocaleID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sFontLocaleID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFontDefinitions") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SFontDefinition>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFontDefinitions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFontDefinitions[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SFontDefinition") << ",\"$val\":";
		SFontDefinition::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aFontDefinitions.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SFontLibraryDefinition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFontLocaleID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontLocaleID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFontDefinitions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFontDefinitions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFontDefinitions[i];
		SFontDefinition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aFontDefinitions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SFontLibraryDefinition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFontLibraryDefinition s_Object {};

	s_Object.sFontLocaleID = std::string_view(p_Document["sFontLocaleID"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aFontDefinitions"])
	{
		SFontDefinition s_ArrayItem0;
		SFontDefinition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aFontDefinitions.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SFontLibraryDefinition*>(p_Target) = s_Object;
}

void SFontLibraryDefinition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);

	ZString::Serialize(&s_Object->sFontLocaleID, p_Serializer, p_OwnOffset + offsetof(SFontLibraryDefinition, sFontLocaleID));
	TArray<SFontDefinition>::Serialize(&s_Object->m_aFontDefinitions, p_Serializer, p_OwnOffset + offsetof(SFontLibraryDefinition, m_aFontDefinitions));
}

bool SFontLibraryDefinition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFontLibraryDefinition*>(p_Left);
	auto* s_Right = reinterpret_cast<SFontLibraryDefinition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFontLibraryDefinition::operator==(const SFontLibraryDefinition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFontLibraryDefinition>)
		return false;

	if (sFontLocaleID != p_Other.sFontLocaleID) return false;
	if (m_aFontDefinitions != p_Other.m_aFontDefinitions) return false;

	return true;
}

ZHMTypeInfo SFootIKEventData::TypeInfo = ZHMTypeInfo("SFootIKEventData", sizeof(SFootIKEventData), alignof(SFootIKEventData), SFootIKEventData::WriteJson, SFootIKEventData::WriteSimpleJson, SFootIKEventData::FromSimpleJson, SFootIKEventData::Serialize, SFootIKEventData::Equals);

void SFootIKEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_Foot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFootIKEventData.EFoot") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_Foot)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SFootIKEventData.EFoot", static_cast<int>(s_Object->m_Foot))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SFootIKEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Foot") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SFootIKEventData.EFoot", static_cast<int>(s_Object->m_Foot)));

	p_Stream << "}";
}

void SFootIKEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFootIKEventData s_Object {};

	s_Object.m_Foot = static_cast<SFootIKEventData_EFoot>(ZHMEnums::GetEnumValueByName("SFootIKEventData.EFoot", std::string_view(p_Document["m_Foot"])));

	*reinterpret_cast<SFootIKEventData*>(p_Target) = s_Object;
}

void SFootIKEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);

}

bool SFootIKEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFootIKEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFootIKEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFootIKEventData::operator==(const SFootIKEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFootIKEventData>)
		return false;

	if (m_Foot != p_Other.m_Foot) return false;

	return true;
}

ZHMTypeInfo SFriskSuspectGroupSaveData::TypeInfo = ZHMTypeInfo("SFriskSuspectGroupSaveData", sizeof(SFriskSuspectGroupSaveData), alignof(SFriskSuspectGroupSaveData), SFriskSuspectGroupSaveData::WriteJson, SFriskSuspectGroupSaveData::WriteSimpleJson, SFriskSuspectGroupSaveData::FromSimpleJson, SFriskSuspectGroupSaveData::Serialize, SFriskSuspectGroupSaveData::Equals);

void SFriskSuspectGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanIsGuard") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanIsGuard);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAssistantState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZFriskSuspectGroup.EAssistantState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAssistantState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZFriskSuspectGroup.EAssistantState", static_cast<int>(s_Object->m_eAssistantState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDisturbanceType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eDisturbanceType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eDisturbanceType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eHitmanGreetState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZFriskSuspectGroup.EHitmanGreetState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eHitmanGreetState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZFriskSuspectGroup.EHitmanGreetState", static_cast<int>(s_Object->m_eHitmanGreetState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHitmanGreet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tHitmanGreet, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMovingTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMovingTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRunningTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRunningTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitToComplyTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tWaitToComplyTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarnOnWeaponFound") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarnOnWeaponFound);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponFound") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponFound);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMoveWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMoveWarning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirskRequestRepeated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirskRequestRepeated);
	p_Stream << "}";

	p_Stream << "}";
}

void SFriskSuspectGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanIsGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanIsGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAssistantState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZFriskSuspectGroup.EAssistantState", static_cast<int>(s_Object->m_eAssistantState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDisturbanceType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eDisturbanceType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eHitmanGreetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZFriskSuspectGroup.EHitmanGreetState", static_cast<int>(s_Object->m_eHitmanGreetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHitmanGreet") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tHitmanGreet, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitToComplyTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitToComplyTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarnOnWeaponFound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarnOnWeaponFound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponFound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponFound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMoveWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMoveWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirskRequestRepeated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirskRequestRepeated);

	p_Stream << "}";
}

void SFriskSuspectGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFriskSuspectGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_bHitmanIsGuard = simdjson::from_json_bool(p_Document["m_bHitmanIsGuard"]);

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object.m_eAssistantState = static_cast<ZFriskSuspectGroup_EAssistantState>(ZHMEnums::GetEnumValueByName("ZFriskSuspectGroup.EAssistantState", std::string_view(p_Document["m_eAssistantState"])));

	s_Object.m_eDisturbanceType = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eDisturbanceType"])));

	s_Object.m_eHitmanGreetState = static_cast<ZFriskSuspectGroup_EHitmanGreetState>(ZHMEnums::GetEnumValueByName("ZFriskSuspectGroup.EHitmanGreetState", std::string_view(p_Document["m_eHitmanGreetState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tHitmanGreet"], &s_Item);
		s_Object.m_tHitmanGreet = s_Item;
	}

	s_Object.m_fMovingTime = simdjson::from_json_float32(p_Document["m_fMovingTime"]);

	s_Object.m_fRunningTime = simdjson::from_json_float32(p_Document["m_fRunningTime"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tWaitToComplyTime"], &s_Item);
		s_Object.m_tWaitToComplyTime = s_Item;
	}

	s_Object.m_bWarnOnWeaponFound = simdjson::from_json_bool(p_Document["m_bWarnOnWeaponFound"]);

	s_Object.m_bWeaponFound = simdjson::from_json_bool(p_Document["m_bWeaponFound"]);

	s_Object.m_bMoveWarning = simdjson::from_json_bool(p_Document["m_bMoveWarning"]);

	s_Object.m_bFirskRequestRepeated = simdjson::from_json_bool(p_Document["m_bFirskRequestRepeated"]);

	*reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Target) = s_Object;
}

void SFriskSuspectGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tHitmanGreet, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_tHitmanGreet));
	ZGameTime::Serialize(&s_Object->m_tWaitToComplyTime, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_tWaitToComplyTime));
}

bool SFriskSuspectGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFriskSuspectGroupSaveData::operator==(const SFriskSuspectGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFriskSuspectGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_bHitmanIsGuard != p_Other.m_bHitmanIsGuard) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_eAssistantState != p_Other.m_eAssistantState) return false;
	if (m_eDisturbanceType != p_Other.m_eDisturbanceType) return false;
	if (m_eHitmanGreetState != p_Other.m_eHitmanGreetState) return false;
	if (m_tHitmanGreet != p_Other.m_tHitmanGreet) return false;
	if (m_fMovingTime != p_Other.m_fMovingTime) return false;
	if (m_fRunningTime != p_Other.m_fRunningTime) return false;
	if (m_tWaitToComplyTime != p_Other.m_tWaitToComplyTime) return false;
	if (m_bWarnOnWeaponFound != p_Other.m_bWarnOnWeaponFound) return false;
	if (m_bWeaponFound != p_Other.m_bWeaponFound) return false;
	if (m_bMoveWarning != p_Other.m_bMoveWarning) return false;
	if (m_bFirskRequestRepeated != p_Other.m_bFirskRequestRepeated) return false;

	return true;
}

ZHMTypeInfo SGBufferSample::TypeInfo = ZHMTypeInfo("SGBufferSample", sizeof(SGBufferSample), alignof(SGBufferSample), SGBufferSample::WriteJson, SGBufferSample::WriteSimpleJson, SGBufferSample::FromSimpleJson, SGBufferSample::Serialize, SGBufferSample::Equals);

void SGBufferSample::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("normal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->normal, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("diffuse") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->diffuse, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("specular") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->specular, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("accumulatedLight") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->accumulatedLight, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("glossiness") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->glossiness);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("translucency") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->translucency);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ao") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->ao);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("shadingModel") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->shadingModel);
	p_Stream << "}";

	p_Stream << "}";
}

void SGBufferSample::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("normal") << ":";
	SVector3::WriteSimpleJson(&s_Object->normal, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("diffuse") << ":";
	SVector3::WriteSimpleJson(&s_Object->diffuse, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("specular") << ":";
	SVector3::WriteSimpleJson(&s_Object->specular, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("accumulatedLight") << ":";
	SVector3::WriteSimpleJson(&s_Object->accumulatedLight, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("glossiness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->glossiness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("translucency") << ":";
	p_Stream << simdjson::as_json_string(s_Object->translucency);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ao") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ao);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("shadingModel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->shadingModel);

	p_Stream << "}";
}

void SGBufferSample::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGBufferSample s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["normal"], &s_Item);
		s_Object.normal = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["diffuse"], &s_Item);
		s_Object.diffuse = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["specular"], &s_Item);
		s_Object.specular = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["accumulatedLight"], &s_Item);
		s_Object.accumulatedLight = s_Item;
	}

	s_Object.glossiness = simdjson::from_json_float32(p_Document["glossiness"]);

	s_Object.translucency = simdjson::from_json_float32(p_Document["translucency"]);

	s_Object.ao = simdjson::from_json_float32(p_Document["ao"]);

	s_Object.shadingModel = simdjson::from_json_uint32(p_Document["shadingModel"]);

	*reinterpret_cast<SGBufferSample*>(p_Target) = s_Object;
}

void SGBufferSample::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);

	SVector3::Serialize(&s_Object->normal, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, normal));
	SVector3::Serialize(&s_Object->diffuse, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, diffuse));
	SVector3::Serialize(&s_Object->specular, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, specular));
	SVector3::Serialize(&s_Object->accumulatedLight, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, accumulatedLight));
}

bool SGBufferSample::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGBufferSample*>(p_Left);
	auto* s_Right = reinterpret_cast<SGBufferSample*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGBufferSample::operator==(const SGBufferSample& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGBufferSample>)
		return false;

	if (normal != p_Other.normal) return false;
	if (diffuse != p_Other.diffuse) return false;
	if (specular != p_Other.specular) return false;
	if (accumulatedLight != p_Other.accumulatedLight) return false;
	if (glossiness != p_Other.glossiness) return false;
	if (translucency != p_Other.translucency) return false;
	if (ao != p_Other.ao) return false;
	if (shadingModel != p_Other.shadingModel) return false;

	return true;
}

ZHMTypeInfo SGProperties::TypeInfo = ZHMTypeInfo("SGProperties", sizeof(SGProperties), alignof(SGProperties), SGProperties::WriteJson, SGProperties::WriteSimpleJson, SGProperties::FromSimpleJson, SGProperties::Serialize, SGProperties::Equals);

void SGProperties::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("vMin") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->vMin, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->vMax, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nGridWidth") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nGridWidth);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fGridSpacing") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fGridSpacing);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVisibilityRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nVisibilityRange);
	p_Stream << "}";

	p_Stream << "}";
}

void SGProperties::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("vMin") << ":";
	float4::WriteSimpleJson(&s_Object->vMin, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vMax") << ":";
	float4::WriteSimpleJson(&s_Object->vMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nGridWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nGridWidth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fGridSpacing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fGridSpacing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVisibilityRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVisibilityRange);

	p_Stream << "}";
}

void SGProperties::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGProperties s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vMin"], &s_Item);
		s_Object.vMin = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vMax"], &s_Item);
		s_Object.vMax = s_Item;
	}

	s_Object.nGridWidth = simdjson::from_json_int32(p_Document["nGridWidth"]);

	s_Object.fGridSpacing = simdjson::from_json_float32(p_Document["fGridSpacing"]);

	s_Object.nVisibilityRange = simdjson::from_json_int32(p_Document["nVisibilityRange"]);

	*reinterpret_cast<SGProperties*>(p_Target) = s_Object;
}

void SGProperties::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	float4::Serialize(&s_Object->vMin, p_Serializer, p_OwnOffset + offsetof(SGProperties, vMin));
	float4::Serialize(&s_Object->vMax, p_Serializer, p_OwnOffset + offsetof(SGProperties, vMax));
}

bool SGProperties::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGProperties*>(p_Left);
	auto* s_Right = reinterpret_cast<SGProperties*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGProperties::operator==(const SGProperties& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGProperties>)
		return false;

	if (vMin != p_Other.vMin) return false;
	if (vMax != p_Other.vMax) return false;
	if (nGridWidth != p_Other.nGridWidth) return false;
	if (fGridSpacing != p_Other.fGridSpacing) return false;
	if (nVisibilityRange != p_Other.nVisibilityRange) return false;

	return true;
}

ZHMTypeInfo SGWaypoint::TypeInfo = ZHMTypeInfo("SGWaypoint", sizeof(SGWaypoint), alignof(SGWaypoint), SGWaypoint::WriteJson, SGWaypoint::WriteSimpleJson, SGWaypoint::FromSimpleJson, SGWaypoint::Serialize, SGWaypoint::Equals);

void SGWaypoint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("nNeighbor0") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor0);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor1") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor1);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor2") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor2);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor3") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor3);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor4") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor4);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor5") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor5);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor6") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor6);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor7") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor7);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vPos") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->vPos, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVisionDataOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nVisionDataOffset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nLayerIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nLayerIndex);
	p_Stream << "}";

	p_Stream << "}";
}

void SGWaypoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nNeighbor0") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor0);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor1") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor1);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor2") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor2);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor3") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor3);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor4") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor4);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor5") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor5);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor6") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor6);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor7") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor7);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vPos") << ":";
	float4::WriteSimpleJson(&s_Object->vPos, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVisionDataOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVisionDataOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nLayerIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nLayerIndex);

	p_Stream << "}";
}

void SGWaypoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGWaypoint s_Object {};

	s_Object.nNeighbor0 = simdjson::from_json_uint16(p_Document["nNeighbor0"]);

	s_Object.nNeighbor1 = simdjson::from_json_uint16(p_Document["nNeighbor1"]);

	s_Object.nNeighbor2 = simdjson::from_json_uint16(p_Document["nNeighbor2"]);

	s_Object.nNeighbor3 = simdjson::from_json_uint16(p_Document["nNeighbor3"]);

	s_Object.nNeighbor4 = simdjson::from_json_uint16(p_Document["nNeighbor4"]);

	s_Object.nNeighbor5 = simdjson::from_json_uint16(p_Document["nNeighbor5"]);

	s_Object.nNeighbor6 = simdjson::from_json_uint16(p_Document["nNeighbor6"]);

	s_Object.nNeighbor7 = simdjson::from_json_uint16(p_Document["nNeighbor7"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vPos"], &s_Item);
		s_Object.vPos = s_Item;
	}

	s_Object.nVisionDataOffset = simdjson::from_json_uint32(p_Document["nVisionDataOffset"]);

	s_Object.nLayerIndex = simdjson::from_json_int16(p_Document["nLayerIndex"]);

	*reinterpret_cast<SGWaypoint*>(p_Target) = s_Object;
}

void SGWaypoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	float4::Serialize(&s_Object->vPos, p_Serializer, p_OwnOffset + offsetof(SGWaypoint, vPos));
}

bool SGWaypoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGWaypoint*>(p_Left);
	auto* s_Right = reinterpret_cast<SGWaypoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGWaypoint::operator==(const SGWaypoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGWaypoint>)
		return false;

	if (nNeighbor0 != p_Other.nNeighbor0) return false;
	if (nNeighbor1 != p_Other.nNeighbor1) return false;
	if (nNeighbor2 != p_Other.nNeighbor2) return false;
	if (nNeighbor3 != p_Other.nNeighbor3) return false;
	if (nNeighbor4 != p_Other.nNeighbor4) return false;
	if (nNeighbor5 != p_Other.nNeighbor5) return false;
	if (nNeighbor6 != p_Other.nNeighbor6) return false;
	if (nNeighbor7 != p_Other.nNeighbor7) return false;
	if (vPos != p_Other.vPos) return false;
	if (nVisionDataOffset != p_Other.nVisionDataOffset) return false;
	if (nLayerIndex != p_Other.nLayerIndex) return false;

	return true;
}

ZHMTypeInfo SGameCamProfileEntitySaveData::TypeInfo = ZHMTypeInfo("SGameCamProfileEntitySaveData", sizeof(SGameCamProfileEntitySaveData), alignof(SGameCamProfileEntitySaveData), SGameCamProfileEntitySaveData::WriteJson, SGameCamProfileEntitySaveData::WriteSimpleJson, SGameCamProfileEntitySaveData::FromSimpleJson, SGameCamProfileEntitySaveData::Serialize, SGameCamProfileEntitySaveData::Equals);

void SGameCamProfileEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SGameCamProfileEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);

	p_Stream << "}";
}

void SGameCamProfileEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameCamProfileEntitySaveData s_Object {};

	s_Object.m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	*reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Target) = s_Object;
}

void SGameCamProfileEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);

}

bool SGameCamProfileEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameCamProfileEntitySaveData::operator==(const SGameCamProfileEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameCamProfileEntitySaveData>)
		return false;

	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;

	return true;
}

ZHMTypeInfo SItemKeywordProxySaveData::TypeInfo = ZHMTypeInfo("SItemKeywordProxySaveData", sizeof(SItemKeywordProxySaveData), alignof(SItemKeywordProxySaveData), SItemKeywordProxySaveData::WriteJson, SItemKeywordProxySaveData::WriteSimpleJson, SItemKeywordProxySaveData::FromSimpleJson, SItemKeywordProxySaveData::Serialize, SItemKeywordProxySaveData::Equals);

void SItemKeywordProxySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << "}";

	p_Stream << "}";
}

void SItemKeywordProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SItemKeywordProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemKeywordProxySaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SItemKeywordProxySaveData*>(p_Target) = s_Object;
}

void SItemKeywordProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);

}

bool SItemKeywordProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemKeywordProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemKeywordProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemKeywordProxySaveData::operator==(const SItemKeywordProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemKeywordProxySaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

ZHMTypeInfo SItemKeywordProxiesSaveData::TypeInfo = ZHMTypeInfo("SItemKeywordProxiesSaveData", sizeof(SItemKeywordProxiesSaveData), alignof(SItemKeywordProxiesSaveData), SItemKeywordProxiesSaveData::WriteJson, SItemKeywordProxiesSaveData::WriteSimpleJson, SItemKeywordProxiesSaveData::FromSimpleJson, SItemKeywordProxiesSaveData::Serialize, SItemKeywordProxiesSaveData::Equals);

void SItemKeywordProxiesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SItemKeywordProxySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SItemKeywordProxySaveData") << ",\"$val\":";
		SItemKeywordProxySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SItemKeywordProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItemKeywordProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemKeywordProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemKeywordProxiesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SItemKeywordProxySaveData s_ArrayItem0;
		SItemKeywordProxySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Target) = s_Object;
}

void SItemKeywordProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SItemKeywordProxiesSaveData, m_aEntities));
	TArray<SItemKeywordProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SItemKeywordProxiesSaveData, m_aData));
}

bool SItemKeywordProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemKeywordProxiesSaveData::operator==(const SItemKeywordProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemKeywordProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SItemSaveData::TypeInfo = ZHMTypeInfo("SItemSaveData", sizeof(SItemSaveData), alignof(SItemSaveData), SItemSaveData::WriteJson, SItemSaveData::WriteSimpleJson, SItemSaveData::FromSimpleJson, SItemSaveData::Serialize, SItemSaveData::Equals);

void SItemSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnablePickup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnablePickup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKinematic") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKinematic);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSleeping") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSleeping);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPerceptible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPerceptible);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ContainerSaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_ContainerSaveData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rTransformParent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTransformParent);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSpawner") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSpawner);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rOwner") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rOwner);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHoldingContainer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHoldingContainer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTurnedOn") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTurnedOn);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEverOwnedByHitman") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEverOwnedByHitman);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasPlacedAndAttached") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasPlacedAndAttached);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bObjectInPhysicsWorld") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bObjectInPhysicsWorld);
	p_Stream << "}";

	p_Stream << "}";
}

void SItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnablePickup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnablePickup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKinematic") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKinematic);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSleeping") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSleeping);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPerceptible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPerceptible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ContainerSaveData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_ContainerSaveData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rTransformParent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTransformParent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSpawner") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSpawner);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rOwner") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rOwner);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHoldingContainer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHoldingContainer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTurnedOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTurnedOn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEverOwnedByHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEverOwnedByHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasPlacedAndAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasPlacedAndAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bObjectInPhysicsWorld") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bObjectInPhysicsWorld);

	p_Stream << "}";
}

void SItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vRotation"], &s_Item);
		s_Object.m_vRotation = s_Item;
	}

	s_Object.m_bShowItem = simdjson::from_json_bool(p_Document["m_bShowItem"]);

	s_Object.m_bEnablePickup = simdjson::from_json_bool(p_Document["m_bEnablePickup"]);

	s_Object.m_bKinematic = simdjson::from_json_bool(p_Document["m_bKinematic"]);

	s_Object.m_bSleeping = simdjson::from_json_bool(p_Document["m_bSleeping"]);

	s_Object.m_bIsPerceptible = simdjson::from_json_bool(p_Document["m_bIsPerceptible"]);

	s_Object.m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vVelocity"], &s_Item);
		s_Object.m_vVelocity = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_ContainerSaveData"], &s_Item);
		s_Object.m_ContainerSaveData = s_Item;
	}

	s_Object.m_rTransformParent = simdjson::from_json_uint32(p_Document["m_rTransformParent"]);

	s_Object.m_rSpawner = simdjson::from_json_uint32(p_Document["m_rSpawner"]);

	s_Object.m_rOwner = simdjson::from_json_uint32(p_Document["m_rOwner"]);

	s_Object.m_rHoldingContainer = simdjson::from_json_uint32(p_Document["m_rHoldingContainer"]);

	s_Object.m_bTurnedOn = simdjson::from_json_bool(p_Document["m_bTurnedOn"]);

	s_Object.m_bEverOwnedByHitman = simdjson::from_json_bool(p_Document["m_bEverOwnedByHitman"]);

	s_Object.m_bWasPlacedAndAttached = simdjson::from_json_bool(p_Document["m_bWasPlacedAndAttached"]);

	s_Object.m_bObjectInPhysicsWorld = simdjson::from_json_bool(p_Document["m_bObjectInPhysicsWorld"]);

	*reinterpret_cast<SItemSaveData*>(p_Target) = s_Object;
}

void SItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vRotation));
	SVector3::Serialize(&s_Object->m_vVelocity, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vVelocity));
	ZVariant::Serialize(&s_Object->m_ContainerSaveData, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_ContainerSaveData));
}

bool SItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemSaveData::operator==(const SItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemSaveData>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_bShowItem != p_Other.m_bShowItem) return false;
	if (m_bEnablePickup != p_Other.m_bEnablePickup) return false;
	if (m_bKinematic != p_Other.m_bKinematic) return false;
	if (m_bSleeping != p_Other.m_bSleeping) return false;
	if (m_bIsPerceptible != p_Other.m_bIsPerceptible) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;
	if (m_vVelocity != p_Other.m_vVelocity) return false;
	if (m_ContainerSaveData != p_Other.m_ContainerSaveData) return false;
	if (m_rTransformParent != p_Other.m_rTransformParent) return false;
	if (m_rSpawner != p_Other.m_rSpawner) return false;
	if (m_rOwner != p_Other.m_rOwner) return false;
	if (m_rHoldingContainer != p_Other.m_rHoldingContainer) return false;
	if (m_bTurnedOn != p_Other.m_bTurnedOn) return false;
	if (m_bEverOwnedByHitman != p_Other.m_bEverOwnedByHitman) return false;
	if (m_bWasPlacedAndAttached != p_Other.m_bWasPlacedAndAttached) return false;
	if (m_bObjectInPhysicsWorld != p_Other.m_bObjectInPhysicsWorld) return false;

	return true;
}

ZHMTypeInfo SItemsSaveData::TypeInfo = ZHMTypeInfo("SItemsSaveData", sizeof(SItemsSaveData), alignof(SItemsSaveData), SItemsSaveData::WriteJson, SItemsSaveData::WriteSimpleJson, SItemsSaveData::FromSimpleJson, SItemsSaveData::Serialize, SItemsSaveData::Equals);

void SItemsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SItemSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SItemSaveData") << ",\"$val\":";
		SItemSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SItemsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemsSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SItemSaveData s_ArrayItem0;
		SItemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SItemsSaveData*>(p_Target) = s_Object;
}

void SItemsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SItemsSaveData, m_aEntities));
	TArray<SItemSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SItemsSaveData, m_aData));
}

bool SItemsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemsSaveData::operator==(const SItemsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SLampCoreSaveState::TypeInfo = ZHMTypeInfo("SLampCoreSaveState", sizeof(SLampCoreSaveState), alignof(SLampCoreSaveState), SLampCoreSaveState::WriteJson, SLampCoreSaveState::WriteSimpleJson, SLampCoreSaveState::FromSimpleJson, SLampCoreSaveState::Serialize, SLampCoreSaveState::Equals);

void SLampCoreSaveState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fDiffusePower") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDiffusePower);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSwitchState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSwitchState);
	p_Stream << "}";

	p_Stream << "}";
}

void SLampCoreSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fDiffusePower") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDiffusePower);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSwitchState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSwitchState);

	p_Stream << "}";
}

void SLampCoreSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLampCoreSaveState s_Object {};

	s_Object.m_fDiffusePower = simdjson::from_json_float32(p_Document["m_fDiffusePower"]);

	s_Object.m_bSwitchState = simdjson::from_json_bool(p_Document["m_bSwitchState"]);

	*reinterpret_cast<SLampCoreSaveState*>(p_Target) = s_Object;
}

void SLampCoreSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);

}

bool SLampCoreSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLampCoreSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SLampCoreSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLampCoreSaveState::operator==(const SLampCoreSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLampCoreSaveState>)
		return false;

	if (m_fDiffusePower != p_Other.m_fDiffusePower) return false;
	if (m_bSwitchState != p_Other.m_bSwitchState) return false;

	return true;
}

ZHMTypeInfo SLampCoreSaveData::TypeInfo = ZHMTypeInfo("SLampCoreSaveData", sizeof(SLampCoreSaveData), alignof(SLampCoreSaveData), SLampCoreSaveData::WriteJson, SLampCoreSaveData::WriteSimpleJson, SLampCoreSaveData::FromSimpleJson, SLampCoreSaveData::Serialize, SLampCoreSaveData::Equals);

void SLampCoreSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SLampCoreSaveState>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SLampCoreSaveState") << ",\"$val\":";
		SLampCoreSaveState::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SLampCoreSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SLampCoreSaveState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLampCoreSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLampCoreSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SLampCoreSaveState s_ArrayItem0;
		SLampCoreSaveState::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SLampCoreSaveData*>(p_Target) = s_Object;
}

void SLampCoreSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SLampCoreSaveData, m_aEntities));
	TArray<SLampCoreSaveState>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SLampCoreSaveData, m_aData));
}

bool SLampCoreSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLampCoreSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLampCoreSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLampCoreSaveData::operator==(const SLampCoreSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLampCoreSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathLerpSaveData_SColorRGB::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SColorRGB", sizeof(SMathLerpSaveData_SColorRGB), alignof(SMathLerpSaveData_SColorRGB), SMathLerpSaveData_SColorRGB::WriteJson, SMathLerpSaveData_SColorRGB::WriteSimpleJson, SMathLerpSaveData_SColorRGB::FromSimpleJson, SMathLerpSaveData_SColorRGB::Serialize, SMathLerpSaveData_SColorRGB::Equals);

void SMathLerpSaveData_SColorRGB::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGB") << ",\"$val\":";
	SColorRGB::WriteJson(&s_Object->m_A, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGB") << ",\"$val\":";
	SColorRGB::WriteJson(&s_Object->m_B, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpSaveData_SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SColorRGB s_Object {};

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);

	SColorRGB::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGB, m_A));
	SColorRGB::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGB, m_B));
}

bool SMathLerpSaveData_SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SColorRGB::operator==(const SMathLerpSaveData_SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SColorRGB>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

ZHMTypeInfo SMathLerpsSaveData_SColorRGB::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SColorRGB", sizeof(SMathLerpsSaveData_SColorRGB), alignof(SMathLerpsSaveData_SColorRGB), SMathLerpsSaveData_SColorRGB::WriteJson, SMathLerpsSaveData_SColorRGB::WriteSimpleJson, SMathLerpsSaveData_SColorRGB::FromSimpleJson, SMathLerpsSaveData_SColorRGB::Serialize, SMathLerpsSaveData_SColorRGB::Equals);

void SMathLerpsSaveData_SColorRGB::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathLerpSaveData_SColorRGB>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpSaveData_SColorRGB") << ",\"$val\":";
		SMathLerpSaveData_SColorRGB::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpsSaveData_SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SColorRGB::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SColorRGB s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathLerpSaveData_SColorRGB s_ArrayItem0;
		SMathLerpSaveData_SColorRGB::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGB, m_aEntities));
	TArray<SMathLerpSaveData_SColorRGB>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGB, m_aData));
}

bool SMathLerpsSaveData_SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SColorRGB::operator==(const SMathLerpsSaveData_SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SColorRGB>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathLerpSaveData_SColorRGBA::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SColorRGBA", sizeof(SMathLerpSaveData_SColorRGBA), alignof(SMathLerpSaveData_SColorRGBA), SMathLerpSaveData_SColorRGBA::WriteJson, SMathLerpSaveData_SColorRGBA::WriteSimpleJson, SMathLerpSaveData_SColorRGBA::FromSimpleJson, SMathLerpSaveData_SColorRGBA::Serialize, SMathLerpSaveData_SColorRGBA::Equals);

void SMathLerpSaveData_SColorRGBA::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGBA") << ",\"$val\":";
	SColorRGBA::WriteJson(&s_Object->m_A, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGBA") << ",\"$val\":";
	SColorRGBA::WriteJson(&s_Object->m_B, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpSaveData_SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SColorRGBA::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SColorRGBA::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SColorRGBA s_Object {};

	{
		SColorRGBA s_Item {};
		SColorRGBA::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SColorRGBA s_Item {};
		SColorRGBA::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);

	SColorRGBA::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGBA, m_A));
	SColorRGBA::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGBA, m_B));
}

bool SMathLerpSaveData_SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SColorRGBA::operator==(const SMathLerpSaveData_SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SColorRGBA>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

ZHMTypeInfo SMathLerpsSaveData_SColorRGBA::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SColorRGBA", sizeof(SMathLerpsSaveData_SColorRGBA), alignof(SMathLerpsSaveData_SColorRGBA), SMathLerpsSaveData_SColorRGBA::WriteJson, SMathLerpsSaveData_SColorRGBA::WriteSimpleJson, SMathLerpsSaveData_SColorRGBA::FromSimpleJson, SMathLerpsSaveData_SColorRGBA::Serialize, SMathLerpsSaveData_SColorRGBA::Equals);

void SMathLerpsSaveData_SColorRGBA::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathLerpSaveData_SColorRGBA>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpSaveData_SColorRGBA") << ",\"$val\":";
		SMathLerpSaveData_SColorRGBA::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpsSaveData_SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SColorRGBA::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SColorRGBA s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathLerpSaveData_SColorRGBA s_ArrayItem0;
		SMathLerpSaveData_SColorRGBA::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGBA, m_aEntities));
	TArray<SMathLerpSaveData_SColorRGBA>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGBA, m_aData));
}

bool SMathLerpsSaveData_SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SColorRGBA::operator==(const SMathLerpsSaveData_SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SColorRGBA>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathLerpSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector2", sizeof(SMathLerpSaveData_SVector2), alignof(SMathLerpSaveData_SVector2), SMathLerpSaveData_SVector2::WriteJson, SMathLerpSaveData_SVector2::WriteSimpleJson, SMathLerpSaveData_SVector2::FromSimpleJson, SMathLerpSaveData_SVector2::Serialize, SMathLerpSaveData_SVector2::Equals);

void SMathLerpSaveData_SVector2::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_A, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_B, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SVector2 s_Object {};

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);

	SVector2::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector2, m_A));
	SVector2::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector2, m_B));
}

bool SMathLerpSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector2::operator==(const SMathLerpSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector2>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

ZHMTypeInfo SMathLerpsSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector2", sizeof(SMathLerpsSaveData_SVector2), alignof(SMathLerpsSaveData_SVector2), SMathLerpsSaveData_SVector2::WriteJson, SMathLerpsSaveData_SVector2::WriteSimpleJson, SMathLerpsSaveData_SVector2::FromSimpleJson, SMathLerpsSaveData_SVector2::Serialize, SMathLerpsSaveData_SVector2::Equals);

void SMathLerpsSaveData_SVector2::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathLerpSaveData_SVector2>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpSaveData_SVector2") << ",\"$val\":";
		SMathLerpSaveData_SVector2::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SVector2 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathLerpSaveData_SVector2 s_ArrayItem0;
		SMathLerpSaveData_SVector2::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector2, m_aEntities));
	TArray<SMathLerpSaveData_SVector2>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector2, m_aData));
}

bool SMathLerpsSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector2::operator==(const SMathLerpsSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector2>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathLerpSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector3", sizeof(SMathLerpSaveData_SVector3), alignof(SMathLerpSaveData_SVector3), SMathLerpSaveData_SVector3::WriteJson, SMathLerpSaveData_SVector3::WriteSimpleJson, SMathLerpSaveData_SVector3::FromSimpleJson, SMathLerpSaveData_SVector3::Serialize, SMathLerpSaveData_SVector3::Equals);

void SMathLerpSaveData_SVector3::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_A, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_B, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SVector3 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);

	SVector3::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector3, m_A));
	SVector3::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector3, m_B));
}

bool SMathLerpSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector3::operator==(const SMathLerpSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector3>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

ZHMTypeInfo SMathLerpsSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector3", sizeof(SMathLerpsSaveData_SVector3), alignof(SMathLerpsSaveData_SVector3), SMathLerpsSaveData_SVector3::WriteJson, SMathLerpsSaveData_SVector3::WriteSimpleJson, SMathLerpsSaveData_SVector3::FromSimpleJson, SMathLerpsSaveData_SVector3::Serialize, SMathLerpsSaveData_SVector3::Equals);

void SMathLerpsSaveData_SVector3::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathLerpSaveData_SVector3>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpSaveData_SVector3") << ",\"$val\":";
		SMathLerpSaveData_SVector3::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SVector3 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathLerpSaveData_SVector3 s_ArrayItem0;
		SMathLerpSaveData_SVector3::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector3, m_aEntities));
	TArray<SMathLerpSaveData_SVector3>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector3, m_aData));
}

bool SMathLerpsSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector3::operator==(const SMathLerpsSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector3>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathLerpSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector4", sizeof(SMathLerpSaveData_SVector4), alignof(SMathLerpSaveData_SVector4), SMathLerpSaveData_SVector4::WriteJson, SMathLerpSaveData_SVector4::WriteSimpleJson, SMathLerpSaveData_SVector4::FromSimpleJson, SMathLerpSaveData_SVector4::Serialize, SMathLerpSaveData_SVector4::Equals);

void SMathLerpSaveData_SVector4::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_A, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_B, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SVector4 s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);

	SVector4::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector4, m_A));
	SVector4::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector4, m_B));
}

bool SMathLerpSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector4::operator==(const SMathLerpSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector4>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

ZHMTypeInfo SMathLerpsSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector4", sizeof(SMathLerpsSaveData_SVector4), alignof(SMathLerpsSaveData_SVector4), SMathLerpsSaveData_SVector4::WriteJson, SMathLerpsSaveData_SVector4::WriteSimpleJson, SMathLerpsSaveData_SVector4::FromSimpleJson, SMathLerpsSaveData_SVector4::Serialize, SMathLerpsSaveData_SVector4::Equals);

void SMathLerpsSaveData_SVector4::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathLerpSaveData_SVector4>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpSaveData_SVector4") << ",\"$val\":";
		SMathLerpSaveData_SVector4::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SVector4 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathLerpSaveData_SVector4 s_ArrayItem0;
		SMathLerpSaveData_SVector4::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector4, m_aEntities));
	TArray<SMathLerpSaveData_SVector4>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector4, m_aData));
}

bool SMathLerpsSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector4::operator==(const SMathLerpsSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector4>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathLerpSaveData_float32::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_float32", sizeof(SMathLerpSaveData_float32), alignof(SMathLerpSaveData_float32), SMathLerpSaveData_float32::WriteJson, SMathLerpSaveData_float32::WriteSimpleJson, SMathLerpSaveData_float32::FromSimpleJson, SMathLerpSaveData_float32::Serialize, SMathLerpSaveData_float32::Equals);

void SMathLerpSaveData_float32::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_A);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_B);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_A);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_B);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_float32 s_Object {};

	s_Object.m_A = simdjson::from_json_float32(p_Document["m_A"]);

	s_Object.m_B = simdjson::from_json_float32(p_Document["m_B"]);

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_float32*>(p_Target) = s_Object;
}

void SMathLerpSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);

}

bool SMathLerpSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_float32::operator==(const SMathLerpSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_float32>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

ZHMTypeInfo SMathLerpsSaveData_float32::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_float32", sizeof(SMathLerpsSaveData_float32), alignof(SMathLerpsSaveData_float32), SMathLerpsSaveData_float32::WriteJson, SMathLerpsSaveData_float32::WriteSimpleJson, SMathLerpsSaveData_float32::FromSimpleJson, SMathLerpsSaveData_float32::Serialize, SMathLerpsSaveData_float32::Equals);

void SMathLerpsSaveData_float32::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathLerpSaveData_float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpSaveData_float32") << ",\"$val\":";
		SMathLerpSaveData_float32::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathLerpsSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_float32::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_float32 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathLerpSaveData_float32 s_ArrayItem0;
		SMathLerpSaveData_float32::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathLerpsSaveData_float32*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_float32, m_aEntities));
	TArray<SMathLerpSaveData_float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_float32, m_aData));
}

bool SMathLerpsSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_float32::operator==(const SMathLerpsSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_float32>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector2", sizeof(SMathMultiplyDivideSaveData_SVector2), alignof(SMathMultiplyDivideSaveData_SVector2), SMathMultiplyDivideSaveData_SVector2::WriteJson, SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector2::FromSimpleJson, SMathMultiplyDivideSaveData_SVector2::Serialize, SMathMultiplyDivideSaveData_SVector2::Equals);

void SMathMultiplyDivideSaveData_SVector2::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fA") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_fA, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_fB, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultiplyDivideSaveData_SVector2 s_Object {};

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	s_Object.m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

	*reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathMultiplyDivideSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);

	SVector2::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector2, m_fA));
	SVector2::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector2, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector2::operator==(const SMathMultiplyDivideSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector2>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

ZHMTypeInfo SMathMultipliesSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector2", sizeof(SMathMultipliesSaveData_SVector2), alignof(SMathMultipliesSaveData_SVector2), SMathMultipliesSaveData_SVector2::WriteJson, SMathMultipliesSaveData_SVector2::WriteSimpleJson, SMathMultipliesSaveData_SVector2::FromSimpleJson, SMathMultipliesSaveData_SVector2::Serialize, SMathMultipliesSaveData_SVector2::Equals);

void SMathMultipliesSaveData_SVector2::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathMultiplyDivideSaveData_SVector2>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathMultiplyDivideSaveData_SVector2") << ",\"$val\":";
		SMathMultiplyDivideSaveData_SVector2::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultipliesSaveData_SVector2 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathMultiplyDivideSaveData_SVector2 s_ArrayItem0;
		SMathMultiplyDivideSaveData_SVector2::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathMultipliesSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector2, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector2>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector2, m_aData));
}

bool SMathMultipliesSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector2::operator==(const SMathMultipliesSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector2>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector3", sizeof(SMathMultiplyDivideSaveData_SVector3), alignof(SMathMultiplyDivideSaveData_SVector3), SMathMultiplyDivideSaveData_SVector3::WriteJson, SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector3::FromSimpleJson, SMathMultiplyDivideSaveData_SVector3::Serialize, SMathMultiplyDivideSaveData_SVector3::Equals);

void SMathMultiplyDivideSaveData_SVector3::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fA") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_fA, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_fB, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultiplyDivideSaveData_SVector3 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	s_Object.m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

	*reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathMultiplyDivideSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);

	SVector3::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector3, m_fA));
	SVector3::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector3, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector3::operator==(const SMathMultiplyDivideSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector3>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

ZHMTypeInfo SMathMultipliesSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector3", sizeof(SMathMultipliesSaveData_SVector3), alignof(SMathMultipliesSaveData_SVector3), SMathMultipliesSaveData_SVector3::WriteJson, SMathMultipliesSaveData_SVector3::WriteSimpleJson, SMathMultipliesSaveData_SVector3::FromSimpleJson, SMathMultipliesSaveData_SVector3::Serialize, SMathMultipliesSaveData_SVector3::Equals);

void SMathMultipliesSaveData_SVector3::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathMultiplyDivideSaveData_SVector3>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathMultiplyDivideSaveData_SVector3") << ",\"$val\":";
		SMathMultiplyDivideSaveData_SVector3::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultipliesSaveData_SVector3 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathMultiplyDivideSaveData_SVector3 s_ArrayItem0;
		SMathMultiplyDivideSaveData_SVector3::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathMultipliesSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector3, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector3>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector3, m_aData));
}

bool SMathMultipliesSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector3::operator==(const SMathMultipliesSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector3>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector4", sizeof(SMathMultiplyDivideSaveData_SVector4), alignof(SMathMultiplyDivideSaveData_SVector4), SMathMultiplyDivideSaveData_SVector4::WriteJson, SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector4::FromSimpleJson, SMathMultiplyDivideSaveData_SVector4::Serialize, SMathMultiplyDivideSaveData_SVector4::Equals);

void SMathMultiplyDivideSaveData_SVector4::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fA") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_fA, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_fB, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultiplyDivideSaveData_SVector4 s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	s_Object.m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

	*reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathMultiplyDivideSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);

	SVector4::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector4, m_fA));
	SVector4::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector4, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector4::operator==(const SMathMultiplyDivideSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector4>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

ZHMTypeInfo SMathMultipliesSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector4", sizeof(SMathMultipliesSaveData_SVector4), alignof(SMathMultipliesSaveData_SVector4), SMathMultipliesSaveData_SVector4::WriteJson, SMathMultipliesSaveData_SVector4::WriteSimpleJson, SMathMultipliesSaveData_SVector4::FromSimpleJson, SMathMultipliesSaveData_SVector4::Serialize, SMathMultipliesSaveData_SVector4::Equals);

void SMathMultipliesSaveData_SVector4::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathMultiplyDivideSaveData_SVector4>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathMultiplyDivideSaveData_SVector4") << ",\"$val\":";
		SMathMultiplyDivideSaveData_SVector4::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultipliesSaveData_SVector4 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathMultiplyDivideSaveData_SVector4 s_ArrayItem0;
		SMathMultiplyDivideSaveData_SVector4::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathMultipliesSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector4, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector4>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector4, m_aData));
}

bool SMathMultipliesSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector4::operator==(const SMathMultipliesSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector4>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SMathMultiplyDivideSaveData_float32::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_float32", sizeof(SMathMultiplyDivideSaveData_float32), alignof(SMathMultiplyDivideSaveData_float32), SMathMultiplyDivideSaveData_float32::WriteJson, SMathMultiplyDivideSaveData_float32::WriteSimpleJson, SMathMultiplyDivideSaveData_float32::FromSimpleJson, SMathMultiplyDivideSaveData_float32::Serialize, SMathMultiplyDivideSaveData_float32::Equals);

void SMathMultiplyDivideSaveData_float32::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fA") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fA);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fB);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);
	p_Stream << "}";

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fA);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fB);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultiplyDivideSaveData_float32 s_Object {};

	s_Object.m_fA = simdjson::from_json_float32(p_Document["m_fA"]);

	s_Object.m_fB = simdjson::from_json_float32(p_Document["m_fB"]);

	s_Object.m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

	*reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Target) = s_Object;
}

void SMathMultiplyDivideSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);

}

bool SMathMultiplyDivideSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_float32::operator==(const SMathMultiplyDivideSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_float32>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

ZHMTypeInfo SMathMultipliesSaveData_float32::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_float32", sizeof(SMathMultipliesSaveData_float32), alignof(SMathMultipliesSaveData_float32), SMathMultipliesSaveData_float32::WriteJson, SMathMultipliesSaveData_float32::WriteSimpleJson, SMathMultipliesSaveData_float32::FromSimpleJson, SMathMultipliesSaveData_float32::Serialize, SMathMultipliesSaveData_float32::Equals);

void SMathMultipliesSaveData_float32::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SMathMultiplyDivideSaveData_float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathMultiplyDivideSaveData_float32") << ",\"$val\":";
		SMathMultiplyDivideSaveData_float32::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMathMultipliesSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_float32::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultipliesSaveData_float32 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SMathMultiplyDivideSaveData_float32 s_ArrayItem0;
		SMathMultiplyDivideSaveData_float32::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Target) = s_Object;
}

void SMathMultipliesSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_float32, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_float32, m_aData));
}

bool SMathMultipliesSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_float32::operator==(const SMathMultipliesSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_float32>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SShatterShardSaveData::TypeInfo = ZHMTypeInfo("SShatterShardSaveData", sizeof(SShatterShardSaveData), alignof(SShatterShardSaveData), SShatterShardSaveData::WriteJson, SShatterShardSaveData::WriteSimpleJson, SShatterShardSaveData::FromSimpleJson, SShatterShardSaveData::Serialize, SShatterShardSaveData::Equals);

void SShatterShardSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterShardSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nShardIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShardIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasBody);
	p_Stream << "}";

	p_Stream << "}";
}

void SShatterShardSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterShardSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nShardIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShardIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasBody);

	p_Stream << "}";
}

void SShatterShardSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SShatterShardSaveData s_Object {};

	s_Object.m_nShardIndex = simdjson::from_json_uint32(p_Document["m_nShardIndex"]);

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	s_Object.m_bHasBody = simdjson::from_json_bool(p_Document["m_bHasBody"]);

	*reinterpret_cast<SShatterShardSaveData*>(p_Target) = s_Object;
}

void SShatterShardSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShatterShardSaveData*>(p_Object);

}

bool SShatterShardSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShatterShardSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShatterShardSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShatterShardSaveData::operator==(const SShatterShardSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShatterShardSaveData>)
		return false;

	if (m_nShardIndex != p_Other.m_nShardIndex) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;
	if (m_bHasBody != p_Other.m_bHasBody) return false;

	return true;
}

ZHMTypeInfo SShatterShardTransformSaveData::TypeInfo = ZHMTypeInfo("SShatterShardTransformSaveData", sizeof(SShatterShardTransformSaveData), alignof(SShatterShardTransformSaveData), SShatterShardTransformSaveData::WriteJson, SShatterShardTransformSaveData::WriteSimpleJson, SShatterShardTransformSaveData::FromSimpleJson, SShatterShardTransformSaveData::Serialize, SShatterShardTransformSaveData::Equals);

void SShatterShardTransformSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterShardTransformSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vBoneRotation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vBoneRotation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vBonePosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vBonePosition, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SShatterShardTransformSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterShardTransformSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vBoneRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vBoneRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vBonePosition") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vBonePosition, p_Stream);

	p_Stream << "}";
}

void SShatterShardTransformSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SShatterShardTransformSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vBoneRotation"], &s_Item);
		s_Object.m_vBoneRotation = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vBonePosition"], &s_Item);
		s_Object.m_vBonePosition = s_Item;
	}

	*reinterpret_cast<SShatterShardTransformSaveData*>(p_Target) = s_Object;
}

void SShatterShardTransformSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShatterShardTransformSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vBoneRotation, p_Serializer, p_OwnOffset + offsetof(SShatterShardTransformSaveData, m_vBoneRotation));
	SVector4::Serialize(&s_Object->m_vBonePosition, p_Serializer, p_OwnOffset + offsetof(SShatterShardTransformSaveData, m_vBonePosition));
}

bool SShatterShardTransformSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShatterShardTransformSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShatterShardTransformSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShatterShardTransformSaveData::operator==(const SShatterShardTransformSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShatterShardTransformSaveData>)
		return false;

	if (m_vBoneRotation != p_Other.m_vBoneRotation) return false;
	if (m_vBonePosition != p_Other.m_vBonePosition) return false;

	return true;
}

ZHMTypeInfo SShatterSystemSaveData::TypeInfo = ZHMTypeInfo("SShatterSystemSaveData", sizeof(SShatterSystemSaveData), alignof(SShatterSystemSaveData), SShatterSystemSaveData::WriteJson, SShatterSystemSaveData::WriteSimpleJson, SShatterSystemSaveData::FromSimpleJson, SShatterSystemSaveData::Serialize, SShatterSystemSaveData::Equals);

void SShatterSystemSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterSystemSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aShardTransforms") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SShatterShardTransformSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aShardTransforms.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aShardTransforms[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SShatterShardTransformSaveData") << ",\"$val\":";
		SShatterShardTransformSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aShardTransforms.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aShardsData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SShatterShardSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aShardsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aShardsData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SShatterShardSaveData") << ",\"$val\":";
		SShatterShardSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aShardsData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShatterSteps") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShatterSteps);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCoreIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCoreIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoreHasBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoreHasBody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCoreKinematic") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCoreKinematic);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsInitialCoreActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInitialCoreActive);
	p_Stream << "}";

	p_Stream << "}";
}

void SShatterSystemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterSystemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aShardTransforms") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aShardTransforms.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aShardTransforms[i];
		SShatterShardTransformSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aShardTransforms.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aShardsData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aShardsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aShardsData[i];
		SShatterShardSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aShardsData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShatterSteps") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShatterSteps);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCoreIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCoreIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoreHasBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoreHasBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCoreKinematic") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCoreKinematic);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsInitialCoreActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInitialCoreActive);

	p_Stream << "}";
}

void SShatterSystemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SShatterSystemSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vRotation"], &s_Item);
		s_Object.m_vRotation = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aShardTransforms"])
	{
		SShatterShardTransformSaveData s_ArrayItem0;
		SShatterShardTransformSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aShardTransforms.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aShardsData"])
	{
		SShatterShardSaveData s_ArrayItem0;
		SShatterShardSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aShardsData.push_back(s_ArrayItem0);
	}

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_nShatterSteps = simdjson::from_json_uint32(p_Document["m_nShatterSteps"]);

	s_Object.m_nCoreIndex = simdjson::from_json_uint32(p_Document["m_nCoreIndex"]);

	s_Object.m_bCoreHasBody = simdjson::from_json_bool(p_Document["m_bCoreHasBody"]);

	s_Object.m_bIsCoreKinematic = simdjson::from_json_bool(p_Document["m_bIsCoreKinematic"]);

	s_Object.m_bIsInitialCoreActive = simdjson::from_json_bool(p_Document["m_bIsInitialCoreActive"]);

	*reinterpret_cast<SShatterSystemSaveData*>(p_Target) = s_Object;
}

void SShatterSystemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShatterSystemSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SShatterSystemSaveData, m_vRotation));
	SVector4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SShatterSystemSaveData, m_vPosition));
	TArray<SShatterShardTransformSaveData>::Serialize(&s_Object->m_aShardTransforms, p_Serializer, p_OwnOffset + offsetof(SShatterSystemSaveData, m_aShardTransforms));
	TArray<SShatterShardSaveData>::Serialize(&s_Object->m_aShardsData, p_Serializer, p_OwnOffset + offsetof(SShatterSystemSaveData, m_aShardsData));
}

bool SShatterSystemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShatterSystemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShatterSystemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShatterSystemSaveData::operator==(const SShatterSystemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShatterSystemSaveData>)
		return false;

	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_aShardTransforms != p_Other.m_aShardTransforms) return false;
	if (m_aShardsData != p_Other.m_aShardsData) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_nShatterSteps != p_Other.m_nShatterSteps) return false;
	if (m_nCoreIndex != p_Other.m_nCoreIndex) return false;
	if (m_bCoreHasBody != p_Other.m_bCoreHasBody) return false;
	if (m_bIsCoreKinematic != p_Other.m_bIsCoreKinematic) return false;
	if (m_bIsInitialCoreActive != p_Other.m_bIsInitialCoreActive) return false;

	return true;
}

ZHMTypeInfo SShatterSaveData::TypeInfo = ZHMTypeInfo("SShatterSaveData", sizeof(SShatterSaveData), alignof(SShatterSaveData), SShatterSaveData::WriteJson, SShatterSaveData::WriteSimpleJson, SShatterSaveData::FromSimpleJson, SShatterSaveData::Serialize, SShatterSaveData::Equals);

void SShatterSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SShatterSystemSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SShatterSystemSaveData") << ",\"$val\":";
		SShatterSystemSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SShatterSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SShatterSystemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SShatterSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SShatterSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SShatterSystemSaveData s_ArrayItem0;
		SShatterSystemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SShatterSaveData*>(p_Target) = s_Object;
}

void SShatterSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShatterSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SShatterSaveData, m_aEntities));
	TArray<SShatterSystemSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SShatterSaveData, m_aData));
}

bool SShatterSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShatterSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShatterSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShatterSaveData::operator==(const SShatterSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShatterSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SShotListenerSaveData::TypeInfo = ZHMTypeInfo("SShotListenerSaveData", sizeof(SShotListenerSaveData), alignof(SShotListenerSaveData), SShotListenerSaveData::WriteJson, SShotListenerSaveData::WriteSimpleJson, SShotListenerSaveData::FromSimpleJson, SShotListenerSaveData::Serialize, SShotListenerSaveData::Equals);

void SShotListenerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNPCShotProcessed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNPCShotProcessed);
	p_Stream << "}";

	p_Stream << "}";
}

void SShotListenerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNPCShotProcessed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNPCShotProcessed);

	p_Stream << "}";
}

void SShotListenerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SShotListenerSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bNPCShotProcessed = simdjson::from_json_bool(p_Document["m_bNPCShotProcessed"]);

	*reinterpret_cast<SShotListenerSaveData*>(p_Target) = s_Object;
}

void SShotListenerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);

}

bool SShotListenerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShotListenerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShotListenerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShotListenerSaveData::operator==(const SShotListenerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShotListenerSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bNPCShotProcessed != p_Other.m_bNPCShotProcessed) return false;

	return true;
}

ZHMTypeInfo SShotListenersSaveData::TypeInfo = ZHMTypeInfo("SShotListenersSaveData", sizeof(SShotListenersSaveData), alignof(SShotListenersSaveData), SShotListenersSaveData::WriteJson, SShotListenersSaveData::WriteSimpleJson, SShotListenersSaveData::FromSimpleJson, SShotListenersSaveData::Serialize, SShotListenersSaveData::Equals);

void SShotListenersSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SShotListenerSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SShotListenerSaveData") << ",\"$val\":";
		SShotListenerSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SShotListenersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SShotListenerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SShotListenersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SShotListenersSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SShotListenerSaveData s_ArrayItem0;
		SShotListenerSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SShotListenersSaveData*>(p_Target) = s_Object;
}

void SShotListenersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SShotListenersSaveData, m_aEntities));
	TArray<SShotListenerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SShotListenersSaveData, m_aData));
}

bool SShotListenersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShotListenersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShotListenersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShotListenersSaveData::operator==(const SShotListenersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShotListenersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SItsATrapSaveData::TypeInfo = ZHMTypeInfo("SItsATrapSaveData", sizeof(SItsATrapSaveData), alignof(SItsATrapSaveData), SItsATrapSaveData::WriteJson, SItsATrapSaveData::WriteSimpleJson, SItsATrapSaveData::FromSimpleJson, SItsATrapSaveData::Serialize, SItsATrapSaveData::Equals);

void SItsATrapSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimer);
	p_Stream << "}";

	p_Stream << "}";
}

void SItsATrapSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimer);

	p_Stream << "}";
}

void SItsATrapSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItsATrapSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_fTimer = simdjson::from_json_float32(p_Document["m_fTimer"]);

	*reinterpret_cast<SItsATrapSaveData*>(p_Target) = s_Object;
}

void SItsATrapSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);

}

bool SItsATrapSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItsATrapSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItsATrapSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItsATrapSaveData::operator==(const SItsATrapSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItsATrapSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fTimer != p_Other.m_fTimer) return false;

	return true;
}

ZHMTypeInfo STrapsSaveData::TypeInfo = ZHMTypeInfo("STrapsSaveData", sizeof(STrapsSaveData), alignof(STrapsSaveData), STrapsSaveData::WriteJson, STrapsSaveData::WriteSimpleJson, STrapsSaveData::FromSimpleJson, STrapsSaveData::Serialize, STrapsSaveData::Equals);

void STrapsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SItsATrapSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SItsATrapSaveData") << ",\"$val\":";
		SItsATrapSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STrapsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItsATrapSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrapsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrapsSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SItsATrapSaveData s_ArrayItem0;
		SItsATrapSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<STrapsSaveData*>(p_Target) = s_Object;
}

void STrapsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(STrapsSaveData, m_aEntities));
	TArray<SItsATrapSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(STrapsSaveData, m_aData));
}

bool STrapsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrapsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrapsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrapsSaveData::operator==(const STrapsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrapsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SVIPEvacuationNodeSaveData::TypeInfo = ZHMTypeInfo("SVIPEvacuationNodeSaveData", sizeof(SVIPEvacuationNodeSaveData), alignof(SVIPEvacuationNodeSaveData), SVIPEvacuationNodeSaveData::WriteJson, SVIPEvacuationNodeSaveData::WriteSimpleJson, SVIPEvacuationNodeSaveData::FromSimpleJson, SVIPEvacuationNodeSaveData::Serialize, SVIPEvacuationNodeSaveData::Equals);

void SVIPEvacuationNodeSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fPenaltyMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPenaltyMultiplier);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPenaltyDuration") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPenaltyDuration);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tPenalty") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tPenalty, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_compromisedOnEnter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_compromisedOnEnter);
	p_Stream << "}";

	p_Stream << "}";
}

void SVIPEvacuationNodeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fPenaltyMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPenaltyMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPenaltyDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPenaltyDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tPenalty") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tPenalty, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_compromisedOnEnter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_compromisedOnEnter);

	p_Stream << "}";
}

void SVIPEvacuationNodeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVIPEvacuationNodeSaveData s_Object {};

	s_Object.m_fPenaltyMultiplier = simdjson::from_json_float32(p_Document["m_fPenaltyMultiplier"]);

	s_Object.m_fPenaltyDuration = simdjson::from_json_float32(p_Document["m_fPenaltyDuration"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tPenalty"], &s_Item);
		s_Object.m_tPenalty = s_Item;
	}

	s_Object.m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object.m_compromisedOnEnter = simdjson::from_json_bool(p_Document["m_compromisedOnEnter"]);

	*reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Target) = s_Object;
}

void SVIPEvacuationNodeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tPenalty, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodeSaveData, m_tPenalty));
}

bool SVIPEvacuationNodeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVIPEvacuationNodeSaveData::operator==(const SVIPEvacuationNodeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVIPEvacuationNodeSaveData>)
		return false;

	if (m_fPenaltyMultiplier != p_Other.m_fPenaltyMultiplier) return false;
	if (m_fPenaltyDuration != p_Other.m_fPenaltyDuration) return false;
	if (m_tPenalty != p_Other.m_tPenalty) return false;
	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_compromisedOnEnter != p_Other.m_compromisedOnEnter) return false;

	return true;
}

ZHMTypeInfo SVIPEvacuationNodesSaveData::TypeInfo = ZHMTypeInfo("SVIPEvacuationNodesSaveData", sizeof(SVIPEvacuationNodesSaveData), alignof(SVIPEvacuationNodesSaveData), SVIPEvacuationNodesSaveData::WriteJson, SVIPEvacuationNodesSaveData::WriteSimpleJson, SVIPEvacuationNodesSaveData::FromSimpleJson, SVIPEvacuationNodesSaveData::Serialize, SVIPEvacuationNodesSaveData::Equals);

void SVIPEvacuationNodesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SVIPEvacuationNodeSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SVIPEvacuationNodeSaveData") << ",\"$val\":";
		SVIPEvacuationNodeSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SVIPEvacuationNodesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SVIPEvacuationNodeSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVIPEvacuationNodesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVIPEvacuationNodesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SVIPEvacuationNodeSaveData s_ArrayItem0;
		SVIPEvacuationNodeSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Target) = s_Object;
}

void SVIPEvacuationNodesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodesSaveData, m_aEntities));
	TArray<SVIPEvacuationNodeSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodesSaveData, m_aData));
}

bool SVIPEvacuationNodesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVIPEvacuationNodesSaveData::operator==(const SVIPEvacuationNodesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVIPEvacuationNodesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SVolumeTriggerListenerSaveData::TypeInfo = ZHMTypeInfo("SVolumeTriggerListenerSaveData", sizeof(SVolumeTriggerListenerSaveData), alignof(SVolumeTriggerListenerSaveData), SVolumeTriggerListenerSaveData::WriteJson, SVolumeTriggerListenerSaveData::WriteSimpleJson, SVolumeTriggerListenerSaveData::FromSimpleJson, SVolumeTriggerListenerSaveData::Serialize, SVolumeTriggerListenerSaveData::Equals);

void SVolumeTriggerListenerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bColliding") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bColliding);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInternalEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInternalEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SVolumeTriggerListenerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bColliding") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bColliding);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInternalEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInternalEnabled);

	p_Stream << "}";
}

void SVolumeTriggerListenerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVolumeTriggerListenerSaveData s_Object {};

	s_Object.m_bColliding = simdjson::from_json_bool(p_Document["m_bColliding"]);

	s_Object.m_bInternalEnabled = simdjson::from_json_bool(p_Document["m_bInternalEnabled"]);

	*reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Target) = s_Object;
}

void SVolumeTriggerListenerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);

}

bool SVolumeTriggerListenerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVolumeTriggerListenerSaveData::operator==(const SVolumeTriggerListenerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVolumeTriggerListenerSaveData>)
		return false;

	if (m_bColliding != p_Other.m_bColliding) return false;
	if (m_bInternalEnabled != p_Other.m_bInternalEnabled) return false;

	return true;
}

ZHMTypeInfo SVolumeTriggersSaveData::TypeInfo = ZHMTypeInfo("SVolumeTriggersSaveData", sizeof(SVolumeTriggersSaveData), alignof(SVolumeTriggersSaveData), SVolumeTriggersSaveData::WriteJson, SVolumeTriggersSaveData::WriteSimpleJson, SVolumeTriggersSaveData::FromSimpleJson, SVolumeTriggersSaveData::Serialize, SVolumeTriggersSaveData::Equals);

void SVolumeTriggersSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SVolumeTriggerListenerSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SVolumeTriggerListenerSaveData") << ",\"$val\":";
		SVolumeTriggerListenerSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SVolumeTriggersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SVolumeTriggerListenerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVolumeTriggersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVolumeTriggersSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SVolumeTriggerListenerSaveData s_ArrayItem0;
		SVolumeTriggerListenerSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SVolumeTriggersSaveData*>(p_Target) = s_Object;
}

void SVolumeTriggersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SVolumeTriggersSaveData, m_aEntities));
	TArray<SVolumeTriggerListenerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SVolumeTriggersSaveData, m_aData));
}

bool SVolumeTriggersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVolumeTriggersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVolumeTriggersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVolumeTriggersSaveData::operator==(const SVolumeTriggersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVolumeTriggersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SGameEntitySaveData::TypeInfo = ZHMTypeInfo("SGameEntitySaveData", sizeof(SGameEntitySaveData), alignof(SGameEntitySaveData), SGameEntitySaveData::WriteJson, SGameEntitySaveData::WriteSimpleJson, SGameEntitySaveData::FromSimpleJson, SGameEntitySaveData::Serialize, SGameEntitySaveData::Equals);

void SGameEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_DoorData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SDoorsSaveData") << ",\"$val\":";
	SDoorsSaveData::WriteJson(&s_Object->m_DoorData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ShatterData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SShatterSaveData") << ",\"$val\":";
	SShatterSaveData::WriteJson(&s_Object->m_ShatterData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemsData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SItemsSaveData") << ",\"$val\":";
	SItemsSaveData::WriteJson(&s_Object->m_ItemsData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_VolumeTriggersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVolumeTriggersSaveData") << ",\"$val\":";
	SVolumeTriggersSaveData::WriteJson(&s_Object->m_VolumeTriggersData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_float32") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathMultipliesSaveData_float32") << ",\"$val\":";
	SMathMultipliesSaveData_float32::WriteJson(&s_Object->m_MathMultipliesData_float32, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector2") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathMultipliesSaveData_SVector2") << ",\"$val\":";
	SMathMultipliesSaveData_SVector2::WriteJson(&s_Object->m_MathMultipliesData_Vector2, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector3") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathMultipliesSaveData_SVector3") << ",\"$val\":";
	SMathMultipliesSaveData_SVector3::WriteJson(&s_Object->m_MathMultipliesData_Vector3, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector4") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathMultipliesSaveData_SVector4") << ",\"$val\":";
	SMathMultipliesSaveData_SVector4::WriteJson(&s_Object->m_MathMultipliesData_Vector4, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ShotListenersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SShotListenersSaveData") << ",\"$val\":";
	SShotListenersSaveData::WriteJson(&s_Object->m_ShotListenersData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TrapsData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STrapsSaveData") << ",\"$val\":";
	STrapsSaveData::WriteJson(&s_Object->m_TrapsData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorProxiesData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorProxiesSaveData") << ",\"$val\":";
	SActorProxiesSaveData::WriteJson(&s_Object->m_ActorProxiesData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorStandInEntitiesData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorStandInEntitiesSaveData") << ",\"$val\":";
	SActorStandInEntitiesSaveData::WriteJson(&s_Object->m_ActorStandInEntitiesData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorBoneAttachmentsData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorBoneAttachmentsSaveData") << ",\"$val\":";
	SActorBoneAttachmentsSaveData::WriteJson(&s_Object->m_ActorBoneAttachmentsData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorKeywordProxiesData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorKeywordProxiesSaveData") << ",\"$val\":";
	SActorKeywordProxiesSaveData::WriteJson(&s_Object->m_ActorKeywordProxiesData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemKeywordProxiesData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SItemKeywordProxiesSaveData") << ",\"$val\":";
	SItemKeywordProxiesSaveData::WriteJson(&s_Object->m_ItemKeywordProxiesData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LampCoreData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SLampCoreSaveData") << ",\"$val\":";
	SLampCoreSaveData::WriteJson(&s_Object->m_LampCoreData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_VIPEvacuationNodesData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVIPEvacuationNodesSaveData") << ",\"$val\":";
	SVIPEvacuationNodesSaveData::WriteJson(&s_Object->m_VIPEvacuationNodesData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CollisionControllerAspectsData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SCollisionControllerAspectsSaveData") << ",\"$val\":";
	SCollisionControllerAspectsSaveData::WriteJson(&s_Object->m_CollisionControllerAspectsData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BodyContainersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SBodyContainersSaveData") << ",\"$val\":";
	SBodyContainersSaveData::WriteJson(&s_Object->m_BodyContainersData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_float32") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpsSaveData_float32") << ",\"$val\":";
	SMathLerpsSaveData_float32::WriteJson(&s_Object->m_MathLerpsData_float32, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector2") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpsSaveData_SVector2") << ",\"$val\":";
	SMathLerpsSaveData_SVector2::WriteJson(&s_Object->m_MathLerpsData_SVector2, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector3") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpsSaveData_SVector3") << ",\"$val\":";
	SMathLerpsSaveData_SVector3::WriteJson(&s_Object->m_MathLerpsData_SVector3, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector4") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpsSaveData_SVector4") << ",\"$val\":";
	SMathLerpsSaveData_SVector4::WriteJson(&s_Object->m_MathLerpsData_SVector4, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SColorRGB") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpsSaveData_SColorRGB") << ",\"$val\":";
	SMathLerpsSaveData_SColorRGB::WriteJson(&s_Object->m_MathLerpsData_SColorRGB, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SColorRGBA") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMathLerpsSaveData_SColorRGBA") << ",\"$val\":";
	SMathLerpsSaveData_SColorRGBA::WriteJson(&s_Object->m_MathLerpsData_SColorRGBA, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SGameEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_DoorData") << ":";
	SDoorsSaveData::WriteSimpleJson(&s_Object->m_DoorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ShatterData") << ":";
	SShatterSaveData::WriteSimpleJson(&s_Object->m_ShatterData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemsData") << ":";
	SItemsSaveData::WriteSimpleJson(&s_Object->m_ItemsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_VolumeTriggersData") << ":";
	SVolumeTriggersSaveData::WriteSimpleJson(&s_Object->m_VolumeTriggersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_float32") << ":";
	SMathMultipliesSaveData_float32::WriteSimpleJson(&s_Object->m_MathMultipliesData_float32, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector2") << ":";
	SMathMultipliesSaveData_SVector2::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector2, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector3") << ":";
	SMathMultipliesSaveData_SVector3::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector3, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector4") << ":";
	SMathMultipliesSaveData_SVector4::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector4, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ShotListenersData") << ":";
	SShotListenersSaveData::WriteSimpleJson(&s_Object->m_ShotListenersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TrapsData") << ":";
	STrapsSaveData::WriteSimpleJson(&s_Object->m_TrapsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorProxiesData") << ":";
	SActorProxiesSaveData::WriteSimpleJson(&s_Object->m_ActorProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorStandInEntitiesData") << ":";
	SActorStandInEntitiesSaveData::WriteSimpleJson(&s_Object->m_ActorStandInEntitiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorBoneAttachmentsData") << ":";
	SActorBoneAttachmentsSaveData::WriteSimpleJson(&s_Object->m_ActorBoneAttachmentsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorKeywordProxiesData") << ":";
	SActorKeywordProxiesSaveData::WriteSimpleJson(&s_Object->m_ActorKeywordProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemKeywordProxiesData") << ":";
	SItemKeywordProxiesSaveData::WriteSimpleJson(&s_Object->m_ItemKeywordProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LampCoreData") << ":";
	SLampCoreSaveData::WriteSimpleJson(&s_Object->m_LampCoreData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_VIPEvacuationNodesData") << ":";
	SVIPEvacuationNodesSaveData::WriteSimpleJson(&s_Object->m_VIPEvacuationNodesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CollisionControllerAspectsData") << ":";
	SCollisionControllerAspectsSaveData::WriteSimpleJson(&s_Object->m_CollisionControllerAspectsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BodyContainersData") << ":";
	SBodyContainersSaveData::WriteSimpleJson(&s_Object->m_BodyContainersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_float32") << ":";
	SMathLerpsSaveData_float32::WriteSimpleJson(&s_Object->m_MathLerpsData_float32, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector2") << ":";
	SMathLerpsSaveData_SVector2::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector2, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector3") << ":";
	SMathLerpsSaveData_SVector3::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector3, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector4") << ":";
	SMathLerpsSaveData_SVector4::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector4, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SColorRGB") << ":";
	SMathLerpsSaveData_SColorRGB::WriteSimpleJson(&s_Object->m_MathLerpsData_SColorRGB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SColorRGBA") << ":";
	SMathLerpsSaveData_SColorRGBA::WriteSimpleJson(&s_Object->m_MathLerpsData_SColorRGBA, p_Stream);

	p_Stream << "}";
}

void SGameEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameEntitySaveData s_Object {};

	{
		SDoorsSaveData s_Item {};
		SDoorsSaveData::FromSimpleJson(p_Document["m_DoorData"], &s_Item);
		s_Object.m_DoorData = s_Item;
	}

	{
		SShatterSaveData s_Item {};
		SShatterSaveData::FromSimpleJson(p_Document["m_ShatterData"], &s_Item);
		s_Object.m_ShatterData = s_Item;
	}

	{
		SItemsSaveData s_Item {};
		SItemsSaveData::FromSimpleJson(p_Document["m_ItemsData"], &s_Item);
		s_Object.m_ItemsData = s_Item;
	}

	{
		SVolumeTriggersSaveData s_Item {};
		SVolumeTriggersSaveData::FromSimpleJson(p_Document["m_VolumeTriggersData"], &s_Item);
		s_Object.m_VolumeTriggersData = s_Item;
	}

	{
		SMathMultipliesSaveData_float32 s_Item {};
		SMathMultipliesSaveData_float32::FromSimpleJson(p_Document["m_MathMultipliesData_float32"], &s_Item);
		s_Object.m_MathMultipliesData_float32 = s_Item;
	}

	{
		SMathMultipliesSaveData_SVector2 s_Item {};
		SMathMultipliesSaveData_SVector2::FromSimpleJson(p_Document["m_MathMultipliesData_Vector2"], &s_Item);
		s_Object.m_MathMultipliesData_Vector2 = s_Item;
	}

	{
		SMathMultipliesSaveData_SVector3 s_Item {};
		SMathMultipliesSaveData_SVector3::FromSimpleJson(p_Document["m_MathMultipliesData_Vector3"], &s_Item);
		s_Object.m_MathMultipliesData_Vector3 = s_Item;
	}

	{
		SMathMultipliesSaveData_SVector4 s_Item {};
		SMathMultipliesSaveData_SVector4::FromSimpleJson(p_Document["m_MathMultipliesData_Vector4"], &s_Item);
		s_Object.m_MathMultipliesData_Vector4 = s_Item;
	}

	{
		SShotListenersSaveData s_Item {};
		SShotListenersSaveData::FromSimpleJson(p_Document["m_ShotListenersData"], &s_Item);
		s_Object.m_ShotListenersData = s_Item;
	}

	{
		STrapsSaveData s_Item {};
		STrapsSaveData::FromSimpleJson(p_Document["m_TrapsData"], &s_Item);
		s_Object.m_TrapsData = s_Item;
	}

	{
		SActorProxiesSaveData s_Item {};
		SActorProxiesSaveData::FromSimpleJson(p_Document["m_ActorProxiesData"], &s_Item);
		s_Object.m_ActorProxiesData = s_Item;
	}

	{
		SActorStandInEntitiesSaveData s_Item {};
		SActorStandInEntitiesSaveData::FromSimpleJson(p_Document["m_ActorStandInEntitiesData"], &s_Item);
		s_Object.m_ActorStandInEntitiesData = s_Item;
	}

	{
		SActorBoneAttachmentsSaveData s_Item {};
		SActorBoneAttachmentsSaveData::FromSimpleJson(p_Document["m_ActorBoneAttachmentsData"], &s_Item);
		s_Object.m_ActorBoneAttachmentsData = s_Item;
	}

	{
		SActorKeywordProxiesSaveData s_Item {};
		SActorKeywordProxiesSaveData::FromSimpleJson(p_Document["m_ActorKeywordProxiesData"], &s_Item);
		s_Object.m_ActorKeywordProxiesData = s_Item;
	}

	{
		SItemKeywordProxiesSaveData s_Item {};
		SItemKeywordProxiesSaveData::FromSimpleJson(p_Document["m_ItemKeywordProxiesData"], &s_Item);
		s_Object.m_ItemKeywordProxiesData = s_Item;
	}

	{
		SLampCoreSaveData s_Item {};
		SLampCoreSaveData::FromSimpleJson(p_Document["m_LampCoreData"], &s_Item);
		s_Object.m_LampCoreData = s_Item;
	}

	{
		SVIPEvacuationNodesSaveData s_Item {};
		SVIPEvacuationNodesSaveData::FromSimpleJson(p_Document["m_VIPEvacuationNodesData"], &s_Item);
		s_Object.m_VIPEvacuationNodesData = s_Item;
	}

	{
		SCollisionControllerAspectsSaveData s_Item {};
		SCollisionControllerAspectsSaveData::FromSimpleJson(p_Document["m_CollisionControllerAspectsData"], &s_Item);
		s_Object.m_CollisionControllerAspectsData = s_Item;
	}

	{
		SBodyContainersSaveData s_Item {};
		SBodyContainersSaveData::FromSimpleJson(p_Document["m_BodyContainersData"], &s_Item);
		s_Object.m_BodyContainersData = s_Item;
	}

	{
		SMathLerpsSaveData_float32 s_Item {};
		SMathLerpsSaveData_float32::FromSimpleJson(p_Document["m_MathLerpsData_float32"], &s_Item);
		s_Object.m_MathLerpsData_float32 = s_Item;
	}

	{
		SMathLerpsSaveData_SVector2 s_Item {};
		SMathLerpsSaveData_SVector2::FromSimpleJson(p_Document["m_MathLerpsData_SVector2"], &s_Item);
		s_Object.m_MathLerpsData_SVector2 = s_Item;
	}

	{
		SMathLerpsSaveData_SVector3 s_Item {};
		SMathLerpsSaveData_SVector3::FromSimpleJson(p_Document["m_MathLerpsData_SVector3"], &s_Item);
		s_Object.m_MathLerpsData_SVector3 = s_Item;
	}

	{
		SMathLerpsSaveData_SVector4 s_Item {};
		SMathLerpsSaveData_SVector4::FromSimpleJson(p_Document["m_MathLerpsData_SVector4"], &s_Item);
		s_Object.m_MathLerpsData_SVector4 = s_Item;
	}

	{
		SMathLerpsSaveData_SColorRGB s_Item {};
		SMathLerpsSaveData_SColorRGB::FromSimpleJson(p_Document["m_MathLerpsData_SColorRGB"], &s_Item);
		s_Object.m_MathLerpsData_SColorRGB = s_Item;
	}

	{
		SMathLerpsSaveData_SColorRGBA s_Item {};
		SMathLerpsSaveData_SColorRGBA::FromSimpleJson(p_Document["m_MathLerpsData_SColorRGBA"], &s_Item);
		s_Object.m_MathLerpsData_SColorRGBA = s_Item;
	}

	*reinterpret_cast<SGameEntitySaveData*>(p_Target) = s_Object;
}

void SGameEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);

	SDoorsSaveData::Serialize(&s_Object->m_DoorData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_DoorData));
	SShatterSaveData::Serialize(&s_Object->m_ShatterData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ShatterData));
	SItemsSaveData::Serialize(&s_Object->m_ItemsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ItemsData));
	SVolumeTriggersSaveData::Serialize(&s_Object->m_VolumeTriggersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_VolumeTriggersData));
	SMathMultipliesSaveData_float32::Serialize(&s_Object->m_MathMultipliesData_float32, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_float32));
	SMathMultipliesSaveData_SVector2::Serialize(&s_Object->m_MathMultipliesData_Vector2, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector2));
	SMathMultipliesSaveData_SVector3::Serialize(&s_Object->m_MathMultipliesData_Vector3, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector3));
	SMathMultipliesSaveData_SVector4::Serialize(&s_Object->m_MathMultipliesData_Vector4, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector4));
	SShotListenersSaveData::Serialize(&s_Object->m_ShotListenersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ShotListenersData));
	STrapsSaveData::Serialize(&s_Object->m_TrapsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_TrapsData));
	SActorProxiesSaveData::Serialize(&s_Object->m_ActorProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorProxiesData));
	SActorStandInEntitiesSaveData::Serialize(&s_Object->m_ActorStandInEntitiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorStandInEntitiesData));
	SActorBoneAttachmentsSaveData::Serialize(&s_Object->m_ActorBoneAttachmentsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorBoneAttachmentsData));
	SActorKeywordProxiesSaveData::Serialize(&s_Object->m_ActorKeywordProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorKeywordProxiesData));
	SItemKeywordProxiesSaveData::Serialize(&s_Object->m_ItemKeywordProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ItemKeywordProxiesData));
	SLampCoreSaveData::Serialize(&s_Object->m_LampCoreData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_LampCoreData));
	SVIPEvacuationNodesSaveData::Serialize(&s_Object->m_VIPEvacuationNodesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_VIPEvacuationNodesData));
	SCollisionControllerAspectsSaveData::Serialize(&s_Object->m_CollisionControllerAspectsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_CollisionControllerAspectsData));
	SBodyContainersSaveData::Serialize(&s_Object->m_BodyContainersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_BodyContainersData));
	SMathLerpsSaveData_float32::Serialize(&s_Object->m_MathLerpsData_float32, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_float32));
	SMathLerpsSaveData_SVector2::Serialize(&s_Object->m_MathLerpsData_SVector2, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector2));
	SMathLerpsSaveData_SVector3::Serialize(&s_Object->m_MathLerpsData_SVector3, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector3));
	SMathLerpsSaveData_SVector4::Serialize(&s_Object->m_MathLerpsData_SVector4, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector4));
	SMathLerpsSaveData_SColorRGB::Serialize(&s_Object->m_MathLerpsData_SColorRGB, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SColorRGB));
	SMathLerpsSaveData_SColorRGBA::Serialize(&s_Object->m_MathLerpsData_SColorRGBA, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SColorRGBA));
}

bool SGameEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameEntitySaveData::operator==(const SGameEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameEntitySaveData>)
		return false;

	if (m_DoorData != p_Other.m_DoorData) return false;
	if (m_ShatterData != p_Other.m_ShatterData) return false;
	if (m_ItemsData != p_Other.m_ItemsData) return false;
	if (m_VolumeTriggersData != p_Other.m_VolumeTriggersData) return false;
	if (m_MathMultipliesData_float32 != p_Other.m_MathMultipliesData_float32) return false;
	if (m_MathMultipliesData_Vector2 != p_Other.m_MathMultipliesData_Vector2) return false;
	if (m_MathMultipliesData_Vector3 != p_Other.m_MathMultipliesData_Vector3) return false;
	if (m_MathMultipliesData_Vector4 != p_Other.m_MathMultipliesData_Vector4) return false;
	if (m_ShotListenersData != p_Other.m_ShotListenersData) return false;
	if (m_TrapsData != p_Other.m_TrapsData) return false;
	if (m_ActorProxiesData != p_Other.m_ActorProxiesData) return false;
	if (m_ActorStandInEntitiesData != p_Other.m_ActorStandInEntitiesData) return false;
	if (m_ActorBoneAttachmentsData != p_Other.m_ActorBoneAttachmentsData) return false;
	if (m_ActorKeywordProxiesData != p_Other.m_ActorKeywordProxiesData) return false;
	if (m_ItemKeywordProxiesData != p_Other.m_ItemKeywordProxiesData) return false;
	if (m_LampCoreData != p_Other.m_LampCoreData) return false;
	if (m_VIPEvacuationNodesData != p_Other.m_VIPEvacuationNodesData) return false;
	if (m_CollisionControllerAspectsData != p_Other.m_CollisionControllerAspectsData) return false;
	if (m_BodyContainersData != p_Other.m_BodyContainersData) return false;
	if (m_MathLerpsData_float32 != p_Other.m_MathLerpsData_float32) return false;
	if (m_MathLerpsData_SVector2 != p_Other.m_MathLerpsData_SVector2) return false;
	if (m_MathLerpsData_SVector3 != p_Other.m_MathLerpsData_SVector3) return false;
	if (m_MathLerpsData_SVector4 != p_Other.m_MathLerpsData_SVector4) return false;
	if (m_MathLerpsData_SColorRGB != p_Other.m_MathLerpsData_SColorRGB) return false;
	if (m_MathLerpsData_SColorRGBA != p_Other.m_MathLerpsData_SColorRGBA) return false;

	return true;
}

ZHMTypeInfo SKeywordSaveData::TypeInfo = ZHMTypeInfo("SKeywordSaveData", sizeof(SKeywordSaveData), alignof(SKeywordSaveData), SKeywordSaveData::WriteJson, SKeywordSaveData::WriteSimpleJson, SKeywordSaveData::FromSimpleJson, SKeywordSaveData::Serialize, SKeywordSaveData::Equals);

void SKeywordSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_HolderSaveableId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_HolderSaveableId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_KeywordID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_KeywordID);
	p_Stream << "}";

	p_Stream << "}";
}

void SKeywordSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_HolderSaveableId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_HolderSaveableId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_KeywordID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_KeywordID);

	p_Stream << "}";
}

void SKeywordSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SKeywordSaveData s_Object {};

	s_Object.m_HolderSaveableId = simdjson::from_json_uint32(p_Document["m_HolderSaveableId"]);

	s_Object.m_KeywordID = simdjson::from_json_int32(p_Document["m_KeywordID"]);

	*reinterpret_cast<SKeywordSaveData*>(p_Target) = s_Object;
}

void SKeywordSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);

}

bool SKeywordSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKeywordSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKeywordSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKeywordSaveData::operator==(const SKeywordSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKeywordSaveData>)
		return false;

	if (m_HolderSaveableId != p_Other.m_HolderSaveableId) return false;
	if (m_KeywordID != p_Other.m_KeywordID) return false;

	return true;
}

ZHMTypeInfo SGameKeywordManagerSaveData::TypeInfo = ZHMTypeInfo("SGameKeywordManagerSaveData", sizeof(SGameKeywordManagerSaveData), alignof(SGameKeywordManagerSaveData), SGameKeywordManagerSaveData::WriteJson, SGameKeywordManagerSaveData::WriteSimpleJson, SGameKeywordManagerSaveData::FromSimpleJson, SGameKeywordManagerSaveData::Serialize, SGameKeywordManagerSaveData::Equals);

void SGameKeywordManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aKeywordsData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SKeywordSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeywordsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeywordsData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SKeywordSaveData") << ",\"$val\":";
		SKeywordSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aKeywordsData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKeywordStringData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeywordStringData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeywordStringData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aKeywordStringData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SGameKeywordManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKeywordsData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeywordsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeywordsData[i];
		SKeywordSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aKeywordsData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKeywordStringData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeywordStringData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeywordStringData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKeywordStringData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameKeywordManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameKeywordManagerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aKeywordsData"])
	{
		SKeywordSaveData s_ArrayItem0;
		SKeywordSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aKeywordsData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aKeywordStringData"])
	{
		s_Object.m_aKeywordStringData.push_back(std::string_view(s_Item0));
	}

	*reinterpret_cast<SGameKeywordManagerSaveData*>(p_Target) = s_Object;
}

void SGameKeywordManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);

	TArray<SKeywordSaveData>::Serialize(&s_Object->m_aKeywordsData, p_Serializer, p_OwnOffset + offsetof(SGameKeywordManagerSaveData, m_aKeywordsData));
	TArray<ZString>::Serialize(&s_Object->m_aKeywordStringData, p_Serializer, p_OwnOffset + offsetof(SGameKeywordManagerSaveData, m_aKeywordStringData));
}

bool SGameKeywordManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameKeywordManagerSaveData::operator==(const SGameKeywordManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameKeywordManagerSaveData>)
		return false;

	if (m_aKeywordsData != p_Other.m_aKeywordsData) return false;
	if (m_aKeywordStringData != p_Other.m_aKeywordStringData) return false;

	return true;
}

ZHMTypeInfo SGameStatsWeapon::TypeInfo = ZHMTypeInfo("SGameStatsWeapon", sizeof(SGameStatsWeapon), alignof(SGameStatsWeapon), SGameStatsWeapon::WriteJson, SGameStatsWeapon::WriteSimpleJson, SGameStatsWeapon::FromSimpleJson, SGameStatsWeapon::Serialize, SGameStatsWeapon::Equals);

void SGameStatsWeapon::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_WeaponRepositoryID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_WeaponRepositoryID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eItemWeapon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("eItemType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eItemWeapon)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eItemType", static_cast<int>(s_Object->m_eItemWeapon))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSpecialSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EWeaponSpecialSituation") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSpecialSituation)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EWeaponSpecialSituation", static_cast<int>(s_Object->m_eSpecialSituation))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAmmoType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("eAmmoType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAmmoType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eAmmoType", static_cast<int>(s_Object->m_eAmmoType))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SGameStatsWeapon::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_WeaponRepositoryID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_WeaponRepositoryID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eItemWeapon") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eItemType", static_cast<int>(s_Object->m_eItemWeapon)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSpecialSituation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EWeaponSpecialSituation", static_cast<int>(s_Object->m_eSpecialSituation)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAmmoType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eAmmoType", static_cast<int>(s_Object->m_eAmmoType)));

	p_Stream << "}";
}

void SGameStatsWeapon::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameStatsWeapon s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_WeaponRepositoryID"], &s_Item);
		s_Object.m_WeaponRepositoryID = s_Item;
	}

	s_Object.m_eItemWeapon = static_cast<eItemType>(ZHMEnums::GetEnumValueByName("eItemType", std::string_view(p_Document["m_eItemWeapon"])));

	s_Object.m_eSpecialSituation = static_cast<EWeaponSpecialSituation>(ZHMEnums::GetEnumValueByName("EWeaponSpecialSituation", std::string_view(p_Document["m_eSpecialSituation"])));

	s_Object.m_eAmmoType = static_cast<eAmmoType>(ZHMEnums::GetEnumValueByName("eAmmoType", std::string_view(p_Document["m_eAmmoType"])));

	*reinterpret_cast<SGameStatsWeapon*>(p_Target) = s_Object;
}

void SGameStatsWeapon::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_WeaponRepositoryID, p_Serializer, p_OwnOffset + offsetof(SGameStatsWeapon, m_WeaponRepositoryID));
}

bool SGameStatsWeapon::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameStatsWeapon*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameStatsWeapon*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameStatsWeapon::operator==(const SGameStatsWeapon& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameStatsWeapon>)
		return false;

	if (m_WeaponRepositoryID != p_Other.m_WeaponRepositoryID) return false;
	if (m_eItemWeapon != p_Other.m_eItemWeapon) return false;
	if (m_eSpecialSituation != p_Other.m_eSpecialSituation) return false;
	if (m_eAmmoType != p_Other.m_eAmmoType) return false;

	return true;
}

ZHMTypeInfo STimerEntityCommandSaveData::TypeInfo = ZHMTypeInfo("STimerEntityCommandSaveData", sizeof(STimerEntityCommandSaveData), alignof(STimerEntityCommandSaveData), STimerEntityCommandSaveData::WriteJson, STimerEntityCommandSaveData::WriteSimpleJson, STimerEntityCommandSaveData::FromSimpleJson, STimerEntityCommandSaveData::Serialize, STimerEntityCommandSaveData::Equals);

void STimerEntityCommandSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ETimerEntityCommandType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ETimerEntityCommandType", static_cast<int>(s_Object->m_eType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fInterval") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInterval);
	p_Stream << "}";

	p_Stream << "}";
}

void STimerEntityCommandSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ETimerEntityCommandType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInterval);

	p_Stream << "}";
}

void STimerEntityCommandSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerEntityCommandSaveData s_Object {};

	s_Object.m_eType = static_cast<ETimerEntityCommandType>(ZHMEnums::GetEnumValueByName("ETimerEntityCommandType", std::string_view(p_Document["m_eType"])));

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_fInterval = simdjson::from_json_float32(p_Document["m_fInterval"]);

	*reinterpret_cast<STimerEntityCommandSaveData*>(p_Target) = s_Object;
}

void STimerEntityCommandSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);

}

bool STimerEntityCommandSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntityCommandSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntityCommandSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntityCommandSaveData::operator==(const STimerEntityCommandSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntityCommandSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_fInterval != p_Other.m_fInterval) return false;

	return true;
}

ZHMTypeInfo STimerEntityStateSaveData::TypeInfo = ZHMTypeInfo("STimerEntityStateSaveData", sizeof(STimerEntityStateSaveData), alignof(STimerEntityStateSaveData), STimerEntityStateSaveData::WriteJson, STimerEntityStateSaveData::WriteSimpleJson, STimerEntityStateSaveData::FromSimpleJson, STimerEntityStateSaveData::Serialize, STimerEntityStateSaveData::Equals);

void STimerEntityStateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fNextEventTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fNextEventTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPending") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPending);
	p_Stream << "}";

	p_Stream << "}";
}

void STimerEntityStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fNextEventTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fNextEventTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPending") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPending);

	p_Stream << "}";
}

void STimerEntityStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerEntityStateSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_fNextEventTime = simdjson::from_json_float32(p_Document["m_fNextEventTime"]);

	s_Object.m_bPending = simdjson::from_json_bool(p_Document["m_bPending"]);

	*reinterpret_cast<STimerEntityStateSaveData*>(p_Target) = s_Object;
}

void STimerEntityStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);

}

bool STimerEntityStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntityStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntityStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntityStateSaveData::operator==(const STimerEntityStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntityStateSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_fNextEventTime != p_Other.m_fNextEventTime) return false;
	if (m_bPending != p_Other.m_bPending) return false;

	return true;
}

ZHMTypeInfo SGameTimersSaveData::TypeInfo = ZHMTypeInfo("SGameTimersSaveData", sizeof(SGameTimersSaveData), alignof(SGameTimersSaveData), SGameTimersSaveData::WriteJson, SGameTimersSaveData::WriteSimpleJson, SGameTimersSaveData::FromSimpleJson, SGameTimersSaveData::Serialize, SGameTimersSaveData::Equals);

void SGameTimersSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aTimerEntityCommands") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STimerEntityCommandSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTimerEntityCommands.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTimerEntityCommands[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STimerEntityCommandSaveData") << ",\"$val\":";
		STimerEntityCommandSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aTimerEntityCommands.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTimerEntityState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STimerEntityStateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTimerEntityState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTimerEntityState[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STimerEntityStateSaveData") << ",\"$val\":";
		STimerEntityStateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aTimerEntityState.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPendingTimers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPendingTimers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPendingTimers[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aPendingTimers.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SGameTimersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTimerEntityCommands") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTimerEntityCommands.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTimerEntityCommands[i];
		STimerEntityCommandSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTimerEntityCommands.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTimerEntityState") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTimerEntityState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTimerEntityState[i];
		STimerEntityStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTimerEntityState.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPendingTimers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPendingTimers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPendingTimers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aPendingTimers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameTimersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameTimersSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aTimerEntityCommands"])
	{
		STimerEntityCommandSaveData s_ArrayItem0;
		STimerEntityCommandSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTimerEntityCommands.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aTimerEntityState"])
	{
		STimerEntityStateSaveData s_ArrayItem0;
		STimerEntityStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTimerEntityState.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aPendingTimers"])
	{
		s_Object.m_aPendingTimers.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SGameTimersSaveData*>(p_Target) = s_Object;
}

void SGameTimersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);

	TArray<STimerEntityCommandSaveData>::Serialize(&s_Object->m_aTimerEntityCommands, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aTimerEntityCommands));
	TArray<STimerEntityStateSaveData>::Serialize(&s_Object->m_aTimerEntityState, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aTimerEntityState));
	TArray<uint32>::Serialize(&s_Object->m_aPendingTimers, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aPendingTimers));
}

bool SGameTimersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameTimersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameTimersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameTimersSaveData::operator==(const SGameTimersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameTimersSaveData>)
		return false;

	if (m_aTimerEntityCommands != p_Other.m_aTimerEntityCommands) return false;
	if (m_aTimerEntityState != p_Other.m_aTimerEntityState) return false;
	if (m_aPendingTimers != p_Other.m_aPendingTimers) return false;

	return true;
}

ZHMTypeInfo SGateSaveData::TypeInfo = ZHMTypeInfo("SGateSaveData", sizeof(SGateSaveData), alignof(SGateSaveData), SGateSaveData::WriteJson, SGateSaveData::WriteSimpleJson, SGateSaveData::FromSimpleJson, SGateSaveData::Serialize, SGateSaveData::Equals);

void SGateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOpen") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOpen);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpenFraction") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpenFraction);
	p_Stream << "}";

	p_Stream << "}";
}

void SGateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOpen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOpen);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpenFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpenFraction);

	p_Stream << "}";
}

void SGateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGateSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_bIsOpen = simdjson::from_json_bool(p_Document["m_bIsOpen"]);

	s_Object.m_fOpenFraction = simdjson::from_json_float32(p_Document["m_fOpenFraction"]);

	*reinterpret_cast<SGateSaveData*>(p_Target) = s_Object;
}

void SGateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);

}

bool SGateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGateSaveData::operator==(const SGateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGateSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsOpen != p_Other.m_bIsOpen) return false;
	if (m_fOpenFraction != p_Other.m_fOpenFraction) return false;

	return true;
}

ZHMTypeInfo SLightSaveData::TypeInfo = ZHMTypeInfo("SLightSaveData", sizeof(SLightSaveData), alignof(SLightSaveData), SLightSaveData::WriteJson, SLightSaveData::WriteSimpleJson, SLightSaveData::FromSimpleJson, SLightSaveData::Serialize, SLightSaveData::Equals);

void SLightSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DiffuseColor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGB") << ",\"$val\":";
	SColorRGB::WriteJson(&s_Object->m_DiffuseColor, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDiffusePower") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDiffusePower);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAspectXByY_Actual") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAspectXByY_Actual);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);
	p_Stream << "}";

	p_Stream << "}";
}

void SLightSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DiffuseColor") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_DiffuseColor, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDiffusePower") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDiffusePower);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAspectXByY_Actual") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAspectXByY_Actual);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SLightSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLightSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_DiffuseColor"], &s_Item);
		s_Object.m_DiffuseColor = s_Item;
	}

	s_Object.m_fDiffusePower = simdjson::from_json_float32(p_Document["m_fDiffusePower"]);

	s_Object.m_fAspectXByY_Actual = simdjson::from_json_float32(p_Document["m_fAspectXByY_Actual"]);

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	*reinterpret_cast<SLightSaveData*>(p_Target) = s_Object;
}

void SLightSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);

	SColorRGB::Serialize(&s_Object->m_DiffuseColor, p_Serializer, p_OwnOffset + offsetof(SLightSaveData, m_DiffuseColor));
}

bool SLightSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLightSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLightSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLightSaveData::operator==(const SLightSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLightSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_DiffuseColor != p_Other.m_DiffuseColor) return false;
	if (m_fDiffusePower != p_Other.m_fDiffusePower) return false;
	if (m_fAspectXByY_Actual != p_Other.m_fAspectXByY_Actual) return false;
	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

ZHMTypeInfo SParticleEmitterSaveData::TypeInfo = ZHMTypeInfo("SParticleEmitterSaveData", sizeof(SParticleEmitterSaveData), alignof(SParticleEmitterSaveData), SParticleEmitterSaveData::WriteJson, SParticleEmitterSaveData::WriteSimpleJson, SParticleEmitterSaveData::FromSimpleJson, SParticleEmitterSaveData::Serialize, SParticleEmitterSaveData::Equals);

void SParticleEmitterSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsActivated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsActivated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionTimeLeft") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionTimeLeft);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionTimeFraction") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionTimeFraction);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionCntLeft") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionCntLeft);
	p_Stream << "}";

	p_Stream << "}";
}

void SParticleEmitterSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionTimeLeft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionTimeLeft);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionTimeFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionTimeFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionCntLeft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionCntLeft);

	p_Stream << "}";
}

void SParticleEmitterSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SParticleEmitterSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_bIsActivated = simdjson::from_json_bool(p_Document["m_bIsActivated"]);

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	s_Object.m_fEmissionTimeLeft = simdjson::from_json_float32(p_Document["m_fEmissionTimeLeft"]);

	s_Object.m_fEmissionTimeFraction = simdjson::from_json_float32(p_Document["m_fEmissionTimeFraction"]);

	s_Object.m_fEmissionCntLeft = simdjson::from_json_float32(p_Document["m_fEmissionCntLeft"]);

	*reinterpret_cast<SParticleEmitterSaveData*>(p_Target) = s_Object;
}

void SParticleEmitterSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);

}

bool SParticleEmitterSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SParticleEmitterSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SParticleEmitterSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SParticleEmitterSaveData::operator==(const SParticleEmitterSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SParticleEmitterSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsActivated != p_Other.m_bIsActivated) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;
	if (m_fEmissionTimeLeft != p_Other.m_fEmissionTimeLeft) return false;
	if (m_fEmissionTimeFraction != p_Other.m_fEmissionTimeFraction) return false;
	if (m_fEmissionCntLeft != p_Other.m_fEmissionCntLeft) return false;

	return true;
}

ZHMTypeInfo SPostfilterParametersSaveData::TypeInfo = ZHMTypeInfo("SPostfilterParametersSaveData", sizeof(SPostfilterParametersSaveData), alignof(SPostfilterParametersSaveData), SPostfilterParametersSaveData::WriteJson, SPostfilterParametersSaveData::WriteSimpleJson, SPostfilterParametersSaveData::FromSimpleJson, SPostfilterParametersSaveData::Serialize, SPostfilterParametersSaveData::Equals);

void SPostfilterParametersSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDepthOfFieldEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDepthOfFieldEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDepthOfFieldBlurriness") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDepthOfFieldBlurriness);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRadialBlurEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRadialBlurEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadialBlurriness") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadialBlurriness);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRadialBlurCenter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vRadialBlurCenter, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadialBlurStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadialBlurStart);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpatialBlurEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpatialBlurEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurriness") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurriness);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSpatialBlurCenter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vSpatialBlurCenter, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurStart);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurFade") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurFade);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDistortionWobbleEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDistortionWobbleEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistortionWobbleScale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistortionWobbleScale);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDistortionWobbleWaveLength") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vDistortionWobbleWaveLength, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDistortionWobbleSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vDistortionWobbleSpeed, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDistortionWobbleUseRealTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDistortionWobbleUseRealTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHDRActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHDRActive);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHDREnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHDREnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vHDRAdaptationSpeed, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationLuminanceMinMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vHDRAdaptationLuminanceMinMax, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationMiddleGrayMinMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vHDRAdaptationMiddleGrayMinMax, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRWhitePoint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRWhitePoint);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRBrightPassThreshold") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRBrightPassThreshold);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRBrightPassMaxPercentage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRBrightPassMaxPercentage);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HDRColorTint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGB") << ",\"$val\":";
	SColorRGB::WriteJson(&s_Object->m_HDRColorTint, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SPostfilterParametersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDepthOfFieldEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDepthOfFieldEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDepthOfFieldBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDepthOfFieldBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRadialBlurEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRadialBlurEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadialBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadialBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRadialBlurCenter") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vRadialBlurCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadialBlurStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadialBlurStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpatialBlurEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpatialBlurEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSpatialBlurCenter") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vSpatialBlurCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurFade") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurFade);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDistortionWobbleEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDistortionWobbleEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistortionWobbleScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistortionWobbleScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDistortionWobbleWaveLength") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vDistortionWobbleWaveLength, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDistortionWobbleSpeed") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vDistortionWobbleSpeed, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDistortionWobbleUseRealTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDistortionWobbleUseRealTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHDRActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHDRActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHDREnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHDREnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationSpeed") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationSpeed, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationLuminanceMinMax") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationLuminanceMinMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationMiddleGrayMinMax") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationMiddleGrayMinMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRWhitePoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRWhitePoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRBrightPassThreshold") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRBrightPassThreshold);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRBrightPassMaxPercentage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRBrightPassMaxPercentage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HDRColorTint") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_HDRColorTint, p_Stream);

	p_Stream << "}";
}

void SPostfilterParametersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPostfilterParametersSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_bDepthOfFieldEnabled = simdjson::from_json_bool(p_Document["m_bDepthOfFieldEnabled"]);

	s_Object.m_fDepthOfFieldBlurriness = simdjson::from_json_float32(p_Document["m_fDepthOfFieldBlurriness"]);

	s_Object.m_bRadialBlurEnabled = simdjson::from_json_bool(p_Document["m_bRadialBlurEnabled"]);

	s_Object.m_fRadialBlurriness = simdjson::from_json_float32(p_Document["m_fRadialBlurriness"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vRadialBlurCenter"], &s_Item);
		s_Object.m_vRadialBlurCenter = s_Item;
	}

	s_Object.m_fRadialBlurStart = simdjson::from_json_float32(p_Document["m_fRadialBlurStart"]);

	s_Object.m_bSpatialBlurEnabled = simdjson::from_json_bool(p_Document["m_bSpatialBlurEnabled"]);

	s_Object.m_fSpatialBlurriness = simdjson::from_json_float32(p_Document["m_fSpatialBlurriness"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vSpatialBlurCenter"], &s_Item);
		s_Object.m_vSpatialBlurCenter = s_Item;
	}

	s_Object.m_fSpatialBlurStart = simdjson::from_json_float32(p_Document["m_fSpatialBlurStart"]);

	s_Object.m_fSpatialBlurFade = simdjson::from_json_float32(p_Document["m_fSpatialBlurFade"]);

	s_Object.m_bDistortionWobbleEnabled = simdjson::from_json_bool(p_Document["m_bDistortionWobbleEnabled"]);

	s_Object.m_fDistortionWobbleScale = simdjson::from_json_float32(p_Document["m_fDistortionWobbleScale"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vDistortionWobbleWaveLength"], &s_Item);
		s_Object.m_vDistortionWobbleWaveLength = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vDistortionWobbleSpeed"], &s_Item);
		s_Object.m_vDistortionWobbleSpeed = s_Item;
	}

	s_Object.m_bDistortionWobbleUseRealTime = simdjson::from_json_bool(p_Document["m_bDistortionWobbleUseRealTime"]);

	s_Object.m_bHDRActive = simdjson::from_json_bool(p_Document["m_bHDRActive"]);

	s_Object.m_bHDREnabled = simdjson::from_json_bool(p_Document["m_bHDREnabled"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationSpeed"], &s_Item);
		s_Object.m_vHDRAdaptationSpeed = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationLuminanceMinMax"], &s_Item);
		s_Object.m_vHDRAdaptationLuminanceMinMax = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationMiddleGrayMinMax"], &s_Item);
		s_Object.m_vHDRAdaptationMiddleGrayMinMax = s_Item;
	}

	s_Object.m_fHDRWhitePoint = simdjson::from_json_float32(p_Document["m_fHDRWhitePoint"]);

	s_Object.m_fHDRBrightPassThreshold = simdjson::from_json_float32(p_Document["m_fHDRBrightPassThreshold"]);

	s_Object.m_fHDRBrightPassMaxPercentage = simdjson::from_json_float32(p_Document["m_fHDRBrightPassMaxPercentage"]);

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_HDRColorTint"], &s_Item);
		s_Object.m_HDRColorTint = s_Item;
	}

	*reinterpret_cast<SPostfilterParametersSaveData*>(p_Target) = s_Object;
}

void SPostfilterParametersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);

	SVector2::Serialize(&s_Object->m_vRadialBlurCenter, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vRadialBlurCenter));
	SVector3::Serialize(&s_Object->m_vSpatialBlurCenter, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vSpatialBlurCenter));
	SVector2::Serialize(&s_Object->m_vDistortionWobbleWaveLength, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vDistortionWobbleWaveLength));
	SVector2::Serialize(&s_Object->m_vDistortionWobbleSpeed, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vDistortionWobbleSpeed));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationSpeed, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationSpeed));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationLuminanceMinMax, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationLuminanceMinMax));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationMiddleGrayMinMax, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationMiddleGrayMinMax));
	SColorRGB::Serialize(&s_Object->m_HDRColorTint, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_HDRColorTint));
}

bool SPostfilterParametersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPostfilterParametersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPostfilterParametersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPostfilterParametersSaveData::operator==(const SPostfilterParametersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPostfilterParametersSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bDepthOfFieldEnabled != p_Other.m_bDepthOfFieldEnabled) return false;
	if (m_fDepthOfFieldBlurriness != p_Other.m_fDepthOfFieldBlurriness) return false;
	if (m_bRadialBlurEnabled != p_Other.m_bRadialBlurEnabled) return false;
	if (m_fRadialBlurriness != p_Other.m_fRadialBlurriness) return false;
	if (m_vRadialBlurCenter != p_Other.m_vRadialBlurCenter) return false;
	if (m_fRadialBlurStart != p_Other.m_fRadialBlurStart) return false;
	if (m_bSpatialBlurEnabled != p_Other.m_bSpatialBlurEnabled) return false;
	if (m_fSpatialBlurriness != p_Other.m_fSpatialBlurriness) return false;
	if (m_vSpatialBlurCenter != p_Other.m_vSpatialBlurCenter) return false;
	if (m_fSpatialBlurStart != p_Other.m_fSpatialBlurStart) return false;
	if (m_fSpatialBlurFade != p_Other.m_fSpatialBlurFade) return false;
	if (m_bDistortionWobbleEnabled != p_Other.m_bDistortionWobbleEnabled) return false;
	if (m_fDistortionWobbleScale != p_Other.m_fDistortionWobbleScale) return false;
	if (m_vDistortionWobbleWaveLength != p_Other.m_vDistortionWobbleWaveLength) return false;
	if (m_vDistortionWobbleSpeed != p_Other.m_vDistortionWobbleSpeed) return false;
	if (m_bDistortionWobbleUseRealTime != p_Other.m_bDistortionWobbleUseRealTime) return false;
	if (m_bHDRActive != p_Other.m_bHDRActive) return false;
	if (m_bHDREnabled != p_Other.m_bHDREnabled) return false;
	if (m_vHDRAdaptationSpeed != p_Other.m_vHDRAdaptationSpeed) return false;
	if (m_vHDRAdaptationLuminanceMinMax != p_Other.m_vHDRAdaptationLuminanceMinMax) return false;
	if (m_vHDRAdaptationMiddleGrayMinMax != p_Other.m_vHDRAdaptationMiddleGrayMinMax) return false;
	if (m_fHDRWhitePoint != p_Other.m_fHDRWhitePoint) return false;
	if (m_fHDRBrightPassThreshold != p_Other.m_fHDRBrightPassThreshold) return false;
	if (m_fHDRBrightPassMaxPercentage != p_Other.m_fHDRBrightPassMaxPercentage) return false;
	if (m_HDRColorTint != p_Other.m_HDRColorTint) return false;

	return true;
}

ZHMTypeInfo SRenderMaterialSaveData::TypeInfo = ZHMTypeInfo("SRenderMaterialSaveData", sizeof(SRenderMaterialSaveData), alignof(SRenderMaterialSaveData), SRenderMaterialSaveData::WriteJson, SRenderMaterialSaveData::WriteSimpleJson, SRenderMaterialSaveData::FromSimpleJson, SRenderMaterialSaveData::Serialize, SRenderMaterialSaveData::Equals);

void SRenderMaterialSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDynamicParametersOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDynamicParametersOffset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);
	p_Stream << "}";

	p_Stream << "}";
}

void SRenderMaterialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDynamicParametersOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDynamicParametersOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);

	p_Stream << "}";
}

void SRenderMaterialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRenderMaterialSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_nDynamicParametersOffset = simdjson::from_json_uint32(p_Document["m_nDynamicParametersOffset"]);

	s_Object.m_bActive = simdjson::from_json_bool(p_Document["m_bActive"]);

	*reinterpret_cast<SRenderMaterialSaveData*>(p_Target) = s_Object;
}

void SRenderMaterialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);

}

bool SRenderMaterialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRenderMaterialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRenderMaterialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRenderMaterialSaveData::operator==(const SRenderMaterialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRenderMaterialSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_nDynamicParametersOffset != p_Other.m_nDynamicParametersOffset) return false;
	if (m_bActive != p_Other.m_bActive) return false;

	return true;
}

ZHMTypeInfo SGameplayRenderablesSaveData::TypeInfo = ZHMTypeInfo("SGameplayRenderablesSaveData", sizeof(SGameplayRenderablesSaveData), alignof(SGameplayRenderablesSaveData), SGameplayRenderablesSaveData::WriteJson, SGameplayRenderablesSaveData::WriteSimpleJson, SGameplayRenderablesSaveData::FromSimpleJson, SGameplayRenderablesSaveData::Serialize, SGameplayRenderablesSaveData::Equals);

void SGameplayRenderablesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aLightData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SLightSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aLightData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aLightData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SLightSaveData") << ",\"$val\":";
		SLightSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aLightData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMaterialData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SRenderMaterialSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMaterialData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMaterialData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SRenderMaterialSaveData") << ",\"$val\":";
		SRenderMaterialSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aMaterialData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aParticleData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SParticleEmitterSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aParticleData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aParticleData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SParticleEmitterSaveData") << ",\"$val\":";
		SParticleEmitterSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aParticleData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneAttachData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SBoneAttachSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneAttachData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneAttachData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SBoneAttachSaveData") << ",\"$val\":";
		SBoneAttachSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aBoneAttachData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPostFilterParametersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SPostfilterParametersSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPostFilterParametersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPostFilterParametersData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SPostfilterParametersSaveData") << ",\"$val\":";
		SPostfilterParametersSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aPostFilterParametersData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGateData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SGateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGateData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGateData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SGateSaveData") << ",\"$val\":";
		SGateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aGateData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicParametersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicParametersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicParametersData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aDynamicParametersData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SGameplayRenderablesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aLightData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aLightData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aLightData[i];
		SLightSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aLightData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMaterialData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMaterialData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMaterialData[i];
		SRenderMaterialSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aMaterialData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aParticleData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aParticleData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aParticleData[i];
		SParticleEmitterSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aParticleData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneAttachData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneAttachData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneAttachData[i];
		SBoneAttachSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBoneAttachData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPostFilterParametersData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPostFilterParametersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPostFilterParametersData[i];
		SPostfilterParametersSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPostFilterParametersData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGateData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGateData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGateData[i];
		SGateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGateData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicParametersData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicParametersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicParametersData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDynamicParametersData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameplayRenderablesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameplayRenderablesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aLightData"])
	{
		SLightSaveData s_ArrayItem0;
		SLightSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aLightData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aMaterialData"])
	{
		SRenderMaterialSaveData s_ArrayItem0;
		SRenderMaterialSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aMaterialData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aParticleData"])
	{
		SParticleEmitterSaveData s_ArrayItem0;
		SParticleEmitterSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aParticleData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBoneAttachData"])
	{
		SBoneAttachSaveData s_ArrayItem0;
		SBoneAttachSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBoneAttachData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aPostFilterParametersData"])
	{
		SPostfilterParametersSaveData s_ArrayItem0;
		SPostfilterParametersSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aPostFilterParametersData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGateData"])
	{
		SGateSaveData s_ArrayItem0;
		SGateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGateData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aDynamicParametersData"])
	{
		s_Object.m_aDynamicParametersData.push_back(simdjson::from_json_uint8(s_Item0));
	}

	*reinterpret_cast<SGameplayRenderablesSaveData*>(p_Target) = s_Object;
}

void SGameplayRenderablesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);

	TArray<SLightSaveData>::Serialize(&s_Object->m_aLightData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aLightData));
	TArray<SRenderMaterialSaveData>::Serialize(&s_Object->m_aMaterialData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aMaterialData));
	TArray<SParticleEmitterSaveData>::Serialize(&s_Object->m_aParticleData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aParticleData));
	TArray<SBoneAttachSaveData>::Serialize(&s_Object->m_aBoneAttachData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aBoneAttachData));
	TArray<SPostfilterParametersSaveData>::Serialize(&s_Object->m_aPostFilterParametersData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aPostFilterParametersData));
	TArray<SGateSaveData>::Serialize(&s_Object->m_aGateData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aGateData));
	TArray<uint8>::Serialize(&s_Object->m_aDynamicParametersData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aDynamicParametersData));
}

bool SGameplayRenderablesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameplayRenderablesSaveData::operator==(const SGameplayRenderablesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameplayRenderablesSaveData>)
		return false;

	if (m_aLightData != p_Other.m_aLightData) return false;
	if (m_aMaterialData != p_Other.m_aMaterialData) return false;
	if (m_aParticleData != p_Other.m_aParticleData) return false;
	if (m_aBoneAttachData != p_Other.m_aBoneAttachData) return false;
	if (m_aPostFilterParametersData != p_Other.m_aPostFilterParametersData) return false;
	if (m_aGateData != p_Other.m_aGateData) return false;
	if (m_aDynamicParametersData != p_Other.m_aDynamicParametersData) return false;

	return true;
}

ZHMTypeInfo SGetHelpGroupSaveData::TypeInfo = ZHMTypeInfo("SGetHelpGroupSaveData", sizeof(SGetHelpGroupSaveData), alignof(SGetHelpGroupSaveData), SGetHelpGroupSaveData::WriteJson, SGetHelpGroupSaveData::WriteSimpleJson, SGetHelpGroupSaveData::FromSimpleJson, SGetHelpGroupSaveData::Serialize, SGetHelpGroupSaveData::Equals);

void SGetHelpGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vLastKnownTargetPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vLastKnownTargetPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rReturnNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rReturnNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_blocked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_blocked.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_blocked[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_blocked.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReportingToHitman") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReportingToHitman);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStartedReportDialog") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedReportDialog);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMultipleBodies") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMultipleBodies);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGetHelpOrderCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGetHelpOrderCompleted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDoneReporting") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneReporting);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGetHelpCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tGetHelpCompleted, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_type)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pReporter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pReporter);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGuard") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuard);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_additionalGuards") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_additionalGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_additionalGuards[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_additionalGuards.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SGetHelpGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vLastKnownTargetPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vLastKnownTargetPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rReturnNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rReturnNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_blocked") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_blocked.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_blocked[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_blocked.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReportingToHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReportingToHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStartedReportDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedReportDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMultipleBodies") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMultipleBodies);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGetHelpOrderCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGetHelpOrderCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDoneReporting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneReporting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGetHelpCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGetHelpCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pReporter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pReporter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_additionalGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_additionalGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_additionalGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_additionalGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGetHelpGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGetHelpGroupSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vLastKnownTargetPosition"], &s_Item);
		s_Object.m_vLastKnownTargetPosition = s_Item;
	}

	s_Object.m_rReturnNode = simdjson::from_json_uint16(p_Document["m_rReturnNode"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_blocked"])
	{
		s_Object.m_blocked.push_back(simdjson::from_json_uint16(s_Item0));
	}

	s_Object.m_bReportingToHitman = simdjson::from_json_bool(p_Document["m_bReportingToHitman"]);

	s_Object.m_bStartedReportDialog = simdjson::from_json_bool(p_Document["m_bStartedReportDialog"]);

	s_Object.m_bMultipleBodies = simdjson::from_json_bool(p_Document["m_bMultipleBodies"]);

	s_Object.m_bGetHelpOrderCompleted = simdjson::from_json_bool(p_Document["m_bGetHelpOrderCompleted"]);

	s_Object.m_bDoneReporting = simdjson::from_json_bool(p_Document["m_bDoneReporting"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tGetHelpCompleted"], &s_Item);
		s_Object.m_tGetHelpCompleted = s_Item;
	}

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object.m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	s_Object.m_pReporter = simdjson::from_json_uint32(p_Document["m_pReporter"]);

	s_Object.m_pGuard = simdjson::from_json_uint32(p_Document["m_pGuard"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_additionalGuards"])
	{
		s_Object.m_additionalGuards.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SGetHelpGroupSaveData*>(p_Target) = s_Object;
}

void SGetHelpGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vLastKnownTargetPosition, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_vLastKnownTargetPosition));
	TArray<uint16>::Serialize(&s_Object->m_blocked, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_blocked));
	ZGameTime::Serialize(&s_Object->m_tGetHelpCompleted, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_tGetHelpCompleted));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_fsmState));
	TArray<uint32>::Serialize(&s_Object->m_additionalGuards, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_additionalGuards));
}

bool SGetHelpGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpGroupSaveData::operator==(const SGetHelpGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpGroupSaveData>)
		return false;

	if (m_vLastKnownTargetPosition != p_Other.m_vLastKnownTargetPosition) return false;
	if (m_rReturnNode != p_Other.m_rReturnNode) return false;
	if (m_blocked != p_Other.m_blocked) return false;
	if (m_bReportingToHitman != p_Other.m_bReportingToHitman) return false;
	if (m_bStartedReportDialog != p_Other.m_bStartedReportDialog) return false;
	if (m_bMultipleBodies != p_Other.m_bMultipleBodies) return false;
	if (m_bGetHelpOrderCompleted != p_Other.m_bGetHelpOrderCompleted) return false;
	if (m_bDoneReporting != p_Other.m_bDoneReporting) return false;
	if (m_tGetHelpCompleted != p_Other.m_tGetHelpCompleted) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pReporter != p_Other.m_pReporter) return false;
	if (m_pGuard != p_Other.m_pGuard) return false;
	if (m_additionalGuards != p_Other.m_additionalGuards) return false;

	return true;
}

ZHMTypeInfo SGetHelpOrderSaveData::TypeInfo = ZHMTypeInfo("SGetHelpOrderSaveData", sizeof(SGetHelpOrderSaveData), alignof(SGetHelpOrderSaveData), SGetHelpOrderSaveData::WriteJson, SGetHelpOrderSaveData::WriteSimpleJson, SGetHelpOrderSaveData::FromSimpleJson, SGetHelpOrderSaveData::Serialize, SGetHelpOrderSaveData::Equals);

void SGetHelpOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_helpType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAISharedEventType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_helpType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_helpType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInitialGuard") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInitialGuard);
	p_Stream << "}";

	p_Stream << "}";
}

void SGetHelpOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_helpType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_helpType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInitialGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInitialGuard);

	p_Stream << "}";
}

void SGetHelpOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGetHelpOrderSaveData s_Object {};

	s_Object.m_helpType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_helpType"])));

	s_Object.m_rInitialGuard = simdjson::from_json_uint32(p_Document["m_rInitialGuard"]);

	*reinterpret_cast<SGetHelpOrderSaveData*>(p_Target) = s_Object;
}

void SGetHelpOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);

}

bool SGetHelpOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpOrderSaveData::operator==(const SGetHelpOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpOrderSaveData>)
		return false;

	if (m_helpType != p_Other.m_helpType) return false;
	if (m_rInitialGuard != p_Other.m_rInitialGuard) return false;

	return true;
}

ZHMTypeInfo SHelpingActorRequestSaveData::TypeInfo = ZHMTypeInfo("SHelpingActorRequestSaveData", sizeof(SHelpingActorRequestSaveData), alignof(SHelpingActorRequestSaveData), SHelpingActorRequestSaveData::WriteJson, SHelpingActorRequestSaveData::WriteSimpleJson, SHelpingActorRequestSaveData::FromSimpleJson, SHelpingActorRequestSaveData::Serialize, SHelpingActorRequestSaveData::Equals);

void SHelpingActorRequestSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLocation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vLocation, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SHelpingActorRequestSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLocation") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLocation, p_Stream);

	p_Stream << "}";
}

void SHelpingActorRequestSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHelpingActorRequestSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aCandidates"])
	{
		s_Object.m_aCandidates.push_back(simdjson::from_json_uint32(s_Item0));
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLocation"], &s_Item);
		s_Object.m_vLocation = s_Item;
	}

	*reinterpret_cast<SHelpingActorRequestSaveData*>(p_Target) = s_Object;
}

void SHelpingActorRequestSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SHelpingActorRequestSaveData, m_aCandidates));
	SVector3::Serialize(&s_Object->m_vLocation, p_Serializer, p_OwnOffset + offsetof(SHelpingActorRequestSaveData, m_vLocation));
}

bool SHelpingActorRequestSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHelpingActorRequestSaveData::operator==(const SHelpingActorRequestSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHelpingActorRequestSaveData>)
		return false;

	if (m_aCandidates != p_Other.m_aCandidates) return false;
	if (m_vLocation != p_Other.m_vLocation) return false;

	return true;
}

ZHMTypeInfo SHelpingActorSaveData::TypeInfo = ZHMTypeInfo("SHelpingActorSaveData", sizeof(SHelpingActorSaveData), alignof(SHelpingActorSaveData), SHelpingActorSaveData::WriteJson, SHelpingActorSaveData::WriteSimpleJson, SHelpingActorSaveData::FromSimpleJson, SHelpingActorSaveData::Serialize, SHelpingActorSaveData::Equals);

void SHelpingActorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nLocationKnowledgeIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLocationKnowledgeIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SHelpingActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nLocationKnowledgeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLocationKnowledgeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SHelpingActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHelpingActorSaveData s_Object {};

	s_Object.m_nLocationKnowledgeIndex = simdjson::from_json_int32(p_Document["m_nLocationKnowledgeIndex"]);

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SHelpingActorSaveData*>(p_Target) = s_Object;
}

void SHelpingActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);

}

bool SHelpingActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHelpingActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHelpingActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHelpingActorSaveData::operator==(const SHelpingActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHelpingActorSaveData>)
		return false;

	if (m_nLocationKnowledgeIndex != p_Other.m_nLocationKnowledgeIndex) return false;
	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SGetHelpServiceSaveData::TypeInfo = ZHMTypeInfo("SGetHelpServiceSaveData", sizeof(SGetHelpServiceSaveData), alignof(SGetHelpServiceSaveData), SGetHelpServiceSaveData::WriteJson, SGetHelpServiceSaveData::WriteSimpleJson, SGetHelpServiceSaveData::FromSimpleJson, SGetHelpServiceSaveData::Serialize, SGetHelpServiceSaveData::Equals);

void SGetHelpServiceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aHelpingActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SHelpingActorSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHelpingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHelpingActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SHelpingActorSaveData") << ",\"$val\":";
		SHelpingActorSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aHelpingActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aHelpingActorRequests") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SHelpingActorRequestSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHelpingActorRequests.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHelpingActorRequests[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SHelpingActorRequestSaveData") << ",\"$val\":";
		SHelpingActorRequestSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aHelpingActorRequests.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SGetHelpServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aHelpingActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHelpingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHelpingActors[i];
		SHelpingActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aHelpingActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aHelpingActorRequests") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHelpingActorRequests.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHelpingActorRequests[i];
		SHelpingActorRequestSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aHelpingActorRequests.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGetHelpServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGetHelpServiceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aHelpingActors"])
	{
		SHelpingActorSaveData s_ArrayItem0;
		SHelpingActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aHelpingActors.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aHelpingActorRequests"])
	{
		SHelpingActorRequestSaveData s_ArrayItem0;
		SHelpingActorRequestSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aHelpingActorRequests.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SGetHelpServiceSaveData*>(p_Target) = s_Object;
}

void SGetHelpServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);

	TArray<SHelpingActorSaveData>::Serialize(&s_Object->m_aHelpingActors, p_Serializer, p_OwnOffset + offsetof(SGetHelpServiceSaveData, m_aHelpingActors));
	TArray<SHelpingActorRequestSaveData>::Serialize(&s_Object->m_aHelpingActorRequests, p_Serializer, p_OwnOffset + offsetof(SGetHelpServiceSaveData, m_aHelpingActorRequests));
}

bool SGetHelpServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpServiceSaveData::operator==(const SGetHelpServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpServiceSaveData>)
		return false;

	if (m_aHelpingActors != p_Other.m_aHelpingActors) return false;
	if (m_aHelpingActorRequests != p_Other.m_aHelpingActorRequests) return false;

	return true;
}

ZHMTypeInfo SGuardBodySituationMemberSaveData::TypeInfo = ZHMTypeInfo("SGuardBodySituationMemberSaveData", sizeof(SGuardBodySituationMemberSaveData), alignof(SGuardBodySituationMemberSaveData), SGuardBodySituationMemberSaveData::WriteJson, SGuardBodySituationMemberSaveData::WriteSimpleJson, SGuardBodySituationMemberSaveData::FromSimpleJson, SGuardBodySituationMemberSaveData::Serialize, SGuardBodySituationMemberSaveData::Equals);

void SGuardBodySituationMemberSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bHasThingsTodo") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasThingsTodo);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDeadBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDeadBody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBodybag") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBodybag);
	p_Stream << "}";

	p_Stream << "}";
}

void SGuardBodySituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bHasThingsTodo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasThingsTodo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBodybag") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBodybag);

	p_Stream << "}";
}

void SGuardBodySituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGuardBodySituationMemberSaveData s_Object {};

	s_Object.m_bHasThingsTodo = simdjson::from_json_bool(p_Document["m_bHasThingsTodo"]);

	s_Object.m_rDeadBody = simdjson::from_json_uint32(p_Document["m_rDeadBody"]);

	s_Object.m_rBodybag = simdjson::from_json_uint32(p_Document["m_rBodybag"]);

	*reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Target) = s_Object;
}

void SGuardBodySituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);

}

bool SGuardBodySituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardBodySituationMemberSaveData::operator==(const SGuardBodySituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardBodySituationMemberSaveData>)
		return false;

	if (m_bHasThingsTodo != p_Other.m_bHasThingsTodo) return false;
	if (m_rDeadBody != p_Other.m_rDeadBody) return false;
	if (m_rBodybag != p_Other.m_rBodybag) return false;

	return true;
}

ZHMTypeInfo SGuardBodySituationSaveData::TypeInfo = ZHMTypeInfo("SGuardBodySituationSaveData", sizeof(SGuardBodySituationSaveData), alignof(SGuardBodySituationSaveData), SGuardBodySituationSaveData::WriteJson, SGuardBodySituationSaveData::WriteSimpleJson, SGuardBodySituationSaveData::FromSimpleJson, SGuardBodySituationSaveData::Serialize, SGuardBodySituationSaveData::Equals);

void SGuardBodySituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bBystanderFieldsFailed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBystanderFieldsFailed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGuardInSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGuardInSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLastGetHelpGroupFailed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLastGetHelpGroupFailed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneCanSeeBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneCanSeeBody);
	p_Stream << "}";

	p_Stream << "}";
}

void SGuardBodySituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bBystanderFieldsFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBystanderFieldsFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGuardInSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGuardInSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLastGetHelpGroupFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLastGetHelpGroupFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneCanSeeBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneCanSeeBody);

	p_Stream << "}";
}

void SGuardBodySituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGuardBodySituationSaveData s_Object {};

	s_Object.m_bBystanderFieldsFailed = simdjson::from_json_bool(p_Document["m_bBystanderFieldsFailed"]);

	s_Object.m_bGuardInSituation = simdjson::from_json_bool(p_Document["m_bGuardInSituation"]);

	s_Object.m_bLastGetHelpGroupFailed = simdjson::from_json_bool(p_Document["m_bLastGetHelpGroupFailed"]);

	s_Object.m_bSomeoneCanSeeBody = simdjson::from_json_bool(p_Document["m_bSomeoneCanSeeBody"]);

	*reinterpret_cast<SGuardBodySituationSaveData*>(p_Target) = s_Object;
}

void SGuardBodySituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);

}

bool SGuardBodySituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardBodySituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardBodySituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardBodySituationSaveData::operator==(const SGuardBodySituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardBodySituationSaveData>)
		return false;

	if (m_bBystanderFieldsFailed != p_Other.m_bBystanderFieldsFailed) return false;
	if (m_bGuardInSituation != p_Other.m_bGuardInSituation) return false;
	if (m_bLastGetHelpGroupFailed != p_Other.m_bLastGetHelpGroupFailed) return false;
	if (m_bSomeoneCanSeeBody != p_Other.m_bSomeoneCanSeeBody) return false;

	return true;
}

ZHMTypeInfo SGuardPointGroupSaveData::TypeInfo = ZHMTypeInfo("SGuardPointGroupSaveData", sizeof(SGuardPointGroupSaveData), alignof(SGuardPointGroupSaveData), SGuardPointGroupSaveData::WriteJson, SGuardPointGroupSaveData::WriteSimpleJson, SGuardPointGroupSaveData::FromSimpleJson, SGuardPointGroupSaveData::Serialize, SGuardPointGroupSaveData::Equals);

void SGuardPointGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardPointGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bGroupEngaged") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGroupEngaged);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_combatZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_combatZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_guardPointEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_guardPointEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGroupTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tGroupTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SGuardPointGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardPointGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bGroupEngaged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGroupEngaged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_combatZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_combatZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_guardPointEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_guardPointEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGroupTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGroupTime, p_Stream);

	p_Stream << "}";
}

void SGuardPointGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGuardPointGroupSaveData s_Object {};

	s_Object.m_bGroupEngaged = simdjson::from_json_bool(p_Document["m_bGroupEngaged"]);

	s_Object.m_combatZone = simdjson::from_json_uint32(p_Document["m_combatZone"]);

	s_Object.m_guardPointEntity = simdjson::from_json_uint32(p_Document["m_guardPointEntity"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tGroupTime"], &s_Item);
		s_Object.m_tGroupTime = s_Item;
	}

	*reinterpret_cast<SGuardPointGroupSaveData*>(p_Target) = s_Object;
}

void SGuardPointGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardPointGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGroupTime, p_Serializer, p_OwnOffset + offsetof(SGuardPointGroupSaveData, m_tGroupTime));
}

bool SGuardPointGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardPointGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardPointGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardPointGroupSaveData::operator==(const SGuardPointGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardPointGroupSaveData>)
		return false;

	if (m_bGroupEngaged != p_Other.m_bGroupEngaged) return false;
	if (m_combatZone != p_Other.m_combatZone) return false;
	if (m_guardPointEntity != p_Other.m_guardPointEntity) return false;
	if (m_tGroupTime != p_Other.m_tGroupTime) return false;

	return true;
}

ZHMTypeInfo SGuardPointOrderSaveData::TypeInfo = ZHMTypeInfo("SGuardPointOrderSaveData", sizeof(SGuardPointOrderSaveData), alignof(SGuardPointOrderSaveData), SGuardPointOrderSaveData::WriteJson, SGuardPointOrderSaveData::WriteSimpleJson, SGuardPointOrderSaveData::FromSimpleJson, SGuardPointOrderSaveData::Serialize, SGuardPointOrderSaveData::Equals);

void SGuardPointOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_guardPoint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_guardPoint);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_walkOnly") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_walkOnly);
	p_Stream << "}";

	p_Stream << "}";
}

void SGuardPointOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_guardPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_guardPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_walkOnly") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_walkOnly);

	p_Stream << "}";
}

void SGuardPointOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGuardPointOrderSaveData s_Object {};

	s_Object.m_guardPoint = simdjson::from_json_uint32(p_Document["m_guardPoint"]);

	s_Object.m_walkOnly = simdjson::from_json_bool(p_Document["m_walkOnly"]);

	*reinterpret_cast<SGuardPointOrderSaveData*>(p_Target) = s_Object;
}

void SGuardPointOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);

}

bool SGuardPointOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardPointOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardPointOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardPointOrderSaveData::operator==(const SGuardPointOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardPointOrderSaveData>)
		return false;

	if (m_guardPoint != p_Other.m_guardPoint) return false;
	if (m_walkOnly != p_Other.m_walkOnly) return false;

	return true;
}

ZHMTypeInfo SHM5CrippleBoxSaveData::TypeInfo = ZHMTypeInfo("SHM5CrippleBoxSaveData", sizeof(SHM5CrippleBoxSaveData), alignof(SHM5CrippleBoxSaveData), SHM5CrippleBoxSaveData::WriteJson, SHM5CrippleBoxSaveData::WriteSimpleJson, SHM5CrippleBoxSaveData::FromSimpleJson, SHM5CrippleBoxSaveData::Serialize, SHM5CrippleBoxSaveData::Equals);

void SHM5CrippleBoxSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bInSequence") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInSequence);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllowBaseMovements") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllowBaseMovements);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSequenceAllowCamera") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSequenceAllowCamera);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLedges") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLedges);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShootingBallet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShootingBallet);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCover") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCover);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTakeClothes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTakeClothes);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLadder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLadder);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPullVictimFromWindow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPullVictimFromWindow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFiberWireKill") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFiberWireKill);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bClimbWindow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bClimbWindow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bThrowBodyOverRail") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bThrowBodyOverRail);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDumpBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDumpBody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOperateCPDoor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOperateCPDoor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHideInCloset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHideInCloset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombat") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombat);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVentilatorShaft") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVentilatorShaft);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGrabVictim") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGrabVictim);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPushVictimThroughWindowAndRail") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPushVictimThroughWindowAndRail);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKickVictimOverLedge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKickVictimOverLedge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPickupItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPickupItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDragBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDragBody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bThrowItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bThrowItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlaceItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlaceItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRun") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRun);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTurn") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTurn);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSneak") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSneak);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoSnapSneak") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoSnapSneak);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandUp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandUp);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFastWalk") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFastWalk);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMovementAllowed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMovementAllowed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIdleAnimationsAllowed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIdleAnimationsAllowed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItems") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItems);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanHolsterItems") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanHolsterItems);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverTakedown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverTakedown);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverScale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverScale);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverToCover") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverToCover);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatSnapNeck") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatSnapNeck);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatChoke") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatChoke);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatPistolFinish") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatPistolFinish);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatProps") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatProps);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatStandart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatStandart);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatFakeSwing") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatFakeSwing);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGameCameraAutoAlign") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGameCameraAutoAlign);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInstinct") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInstinct);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanCancelShootingBallet") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanCancelShootingBallet);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlindFire") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlindFire);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAim") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAim);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHairTrigger") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHairTrigger);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFire") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFire);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOpenLogbook") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOpenLogbook);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOpenPauseMenu") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOpenPauseMenu);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivatedByPinSignal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivatedByPinSignal);
	p_Stream << "}";

	p_Stream << "}";
}

void SHM5CrippleBoxSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bInSequence") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInSequence);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllowBaseMovements") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllowBaseMovements);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSequenceAllowCamera") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSequenceAllowCamera);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLedges") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLedges);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShootingBallet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShootingBallet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCover") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCover);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTakeClothes") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTakeClothes);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLadder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLadder);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPullVictimFromWindow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPullVictimFromWindow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFiberWireKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFiberWireKill);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bClimbWindow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bClimbWindow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bThrowBodyOverRail") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bThrowBodyOverRail);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDumpBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDumpBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOperateCPDoor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOperateCPDoor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHideInCloset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHideInCloset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombat") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombat);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVentilatorShaft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVentilatorShaft);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGrabVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGrabVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPushVictimThroughWindowAndRail") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPushVictimThroughWindowAndRail);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKickVictimOverLedge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKickVictimOverLedge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPickupItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPickupItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDragBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDragBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bThrowItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bThrowItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlaceItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlaceItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTurn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTurn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSneak") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSneak);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoSnapSneak") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoSnapSneak);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandUp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandUp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFastWalk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFastWalk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMovementAllowed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMovementAllowed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIdleAnimationsAllowed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIdleAnimationsAllowed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanHolsterItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanHolsterItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverTakedown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverTakedown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverToCover") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverToCover);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatSnapNeck") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatSnapNeck);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatChoke") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatChoke);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatPistolFinish") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatPistolFinish);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatProps") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatProps);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatStandart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatStandart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatFakeSwing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatFakeSwing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGameCameraAutoAlign") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGameCameraAutoAlign);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInstinct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInstinct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanCancelShootingBallet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanCancelShootingBallet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlindFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlindFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHairTrigger") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHairTrigger);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOpenLogbook") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOpenLogbook);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOpenPauseMenu") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOpenPauseMenu);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivatedByPinSignal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivatedByPinSignal);

	p_Stream << "}";
}

void SHM5CrippleBoxSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHM5CrippleBoxSaveData s_Object {};

	s_Object.m_bInSequence = simdjson::from_json_bool(p_Document["m_bInSequence"]);

	s_Object.m_bAllowBaseMovements = simdjson::from_json_bool(p_Document["m_bAllowBaseMovements"]);

	s_Object.m_bSequenceAllowCamera = simdjson::from_json_bool(p_Document["m_bSequenceAllowCamera"]);

	s_Object.m_bLedges = simdjson::from_json_bool(p_Document["m_bLedges"]);

	s_Object.m_bShootingBallet = simdjson::from_json_bool(p_Document["m_bShootingBallet"]);

	s_Object.m_bCover = simdjson::from_json_bool(p_Document["m_bCover"]);

	s_Object.m_bTakeClothes = simdjson::from_json_bool(p_Document["m_bTakeClothes"]);

	s_Object.m_bLadder = simdjson::from_json_bool(p_Document["m_bLadder"]);

	s_Object.m_bPullVictimFromWindow = simdjson::from_json_bool(p_Document["m_bPullVictimFromWindow"]);

	s_Object.m_bFiberWireKill = simdjson::from_json_bool(p_Document["m_bFiberWireKill"]);

	s_Object.m_bClimbWindow = simdjson::from_json_bool(p_Document["m_bClimbWindow"]);

	s_Object.m_bThrowBodyOverRail = simdjson::from_json_bool(p_Document["m_bThrowBodyOverRail"]);

	s_Object.m_bDumpBody = simdjson::from_json_bool(p_Document["m_bDumpBody"]);

	s_Object.m_bOperateCPDoor = simdjson::from_json_bool(p_Document["m_bOperateCPDoor"]);

	s_Object.m_bHideInCloset = simdjson::from_json_bool(p_Document["m_bHideInCloset"]);

	s_Object.m_bCloseCombat = simdjson::from_json_bool(p_Document["m_bCloseCombat"]);

	s_Object.m_bVentilatorShaft = simdjson::from_json_bool(p_Document["m_bVentilatorShaft"]);

	s_Object.m_bGrabVictim = simdjson::from_json_bool(p_Document["m_bGrabVictim"]);

	s_Object.m_bPushVictimThroughWindowAndRail = simdjson::from_json_bool(p_Document["m_bPushVictimThroughWindowAndRail"]);

	s_Object.m_bKickVictimOverLedge = simdjson::from_json_bool(p_Document["m_bKickVictimOverLedge"]);

	s_Object.m_bPickupItem = simdjson::from_json_bool(p_Document["m_bPickupItem"]);

	s_Object.m_bDropItem = simdjson::from_json_bool(p_Document["m_bDropItem"]);

	s_Object.m_bDragBody = simdjson::from_json_bool(p_Document["m_bDragBody"]);

	s_Object.m_bThrowItem = simdjson::from_json_bool(p_Document["m_bThrowItem"]);

	s_Object.m_bPlaceItem = simdjson::from_json_bool(p_Document["m_bPlaceItem"]);

	s_Object.m_bRun = simdjson::from_json_bool(p_Document["m_bRun"]);

	s_Object.m_bTurn = simdjson::from_json_bool(p_Document["m_bTurn"]);

	s_Object.m_bSneak = simdjson::from_json_bool(p_Document["m_bSneak"]);

	s_Object.m_bNoSnapSneak = simdjson::from_json_bool(p_Document["m_bNoSnapSneak"]);

	s_Object.m_bStandUp = simdjson::from_json_bool(p_Document["m_bStandUp"]);

	s_Object.m_bFastWalk = simdjson::from_json_bool(p_Document["m_bFastWalk"]);

	s_Object.m_bMovementAllowed = simdjson::from_json_bool(p_Document["m_bMovementAllowed"]);

	s_Object.m_bIdleAnimationsAllowed = simdjson::from_json_bool(p_Document["m_bIdleAnimationsAllowed"]);

	s_Object.m_bItems = simdjson::from_json_bool(p_Document["m_bItems"]);

	s_Object.m_bCanHolsterItems = simdjson::from_json_bool(p_Document["m_bCanHolsterItems"]);

	s_Object.m_bCoverTakedown = simdjson::from_json_bool(p_Document["m_bCoverTakedown"]);

	s_Object.m_bCoverScale = simdjson::from_json_bool(p_Document["m_bCoverScale"]);

	s_Object.m_bCoverToCover = simdjson::from_json_bool(p_Document["m_bCoverToCover"]);

	s_Object.m_bCloseCombatSnapNeck = simdjson::from_json_bool(p_Document["m_bCloseCombatSnapNeck"]);

	s_Object.m_bCloseCombatChoke = simdjson::from_json_bool(p_Document["m_bCloseCombatChoke"]);

	s_Object.m_bCloseCombatPistolFinish = simdjson::from_json_bool(p_Document["m_bCloseCombatPistolFinish"]);

	s_Object.m_bCloseCombatProps = simdjson::from_json_bool(p_Document["m_bCloseCombatProps"]);

	s_Object.m_bCloseCombatStandart = simdjson::from_json_bool(p_Document["m_bCloseCombatStandart"]);

	s_Object.m_bCloseCombatFakeSwing = simdjson::from_json_bool(p_Document["m_bCloseCombatFakeSwing"]);

	s_Object.m_bGameCameraAutoAlign = simdjson::from_json_bool(p_Document["m_bGameCameraAutoAlign"]);

	s_Object.m_bInstinct = simdjson::from_json_bool(p_Document["m_bInstinct"]);

	s_Object.m_bCanCancelShootingBallet = simdjson::from_json_bool(p_Document["m_bCanCancelShootingBallet"]);

	s_Object.m_bBlindFire = simdjson::from_json_bool(p_Document["m_bBlindFire"]);

	s_Object.m_bAim = simdjson::from_json_bool(p_Document["m_bAim"]);

	s_Object.m_bHairTrigger = simdjson::from_json_bool(p_Document["m_bHairTrigger"]);

	s_Object.m_bFire = simdjson::from_json_bool(p_Document["m_bFire"]);

	s_Object.m_bOpenLogbook = simdjson::from_json_bool(p_Document["m_bOpenLogbook"]);

	s_Object.m_bOpenPauseMenu = simdjson::from_json_bool(p_Document["m_bOpenPauseMenu"]);

	s_Object.m_bActivatedByPinSignal = simdjson::from_json_bool(p_Document["m_bActivatedByPinSignal"]);

	*reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Target) = s_Object;
}

void SHM5CrippleBoxSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);

}

bool SHM5CrippleBoxSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHM5CrippleBoxSaveData::operator==(const SHM5CrippleBoxSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHM5CrippleBoxSaveData>)
		return false;

	if (m_bInSequence != p_Other.m_bInSequence) return false;
	if (m_bAllowBaseMovements != p_Other.m_bAllowBaseMovements) return false;
	if (m_bSequenceAllowCamera != p_Other.m_bSequenceAllowCamera) return false;
	if (m_bLedges != p_Other.m_bLedges) return false;
	if (m_bShootingBallet != p_Other.m_bShootingBallet) return false;
	if (m_bCover != p_Other.m_bCover) return false;
	if (m_bTakeClothes != p_Other.m_bTakeClothes) return false;
	if (m_bLadder != p_Other.m_bLadder) return false;
	if (m_bPullVictimFromWindow != p_Other.m_bPullVictimFromWindow) return false;
	if (m_bFiberWireKill != p_Other.m_bFiberWireKill) return false;
	if (m_bClimbWindow != p_Other.m_bClimbWindow) return false;
	if (m_bThrowBodyOverRail != p_Other.m_bThrowBodyOverRail) return false;
	if (m_bDumpBody != p_Other.m_bDumpBody) return false;
	if (m_bOperateCPDoor != p_Other.m_bOperateCPDoor) return false;
	if (m_bHideInCloset != p_Other.m_bHideInCloset) return false;
	if (m_bCloseCombat != p_Other.m_bCloseCombat) return false;
	if (m_bVentilatorShaft != p_Other.m_bVentilatorShaft) return false;
	if (m_bGrabVictim != p_Other.m_bGrabVictim) return false;
	if (m_bPushVictimThroughWindowAndRail != p_Other.m_bPushVictimThroughWindowAndRail) return false;
	if (m_bKickVictimOverLedge != p_Other.m_bKickVictimOverLedge) return false;
	if (m_bPickupItem != p_Other.m_bPickupItem) return false;
	if (m_bDropItem != p_Other.m_bDropItem) return false;
	if (m_bDragBody != p_Other.m_bDragBody) return false;
	if (m_bThrowItem != p_Other.m_bThrowItem) return false;
	if (m_bPlaceItem != p_Other.m_bPlaceItem) return false;
	if (m_bRun != p_Other.m_bRun) return false;
	if (m_bTurn != p_Other.m_bTurn) return false;
	if (m_bSneak != p_Other.m_bSneak) return false;
	if (m_bNoSnapSneak != p_Other.m_bNoSnapSneak) return false;
	if (m_bStandUp != p_Other.m_bStandUp) return false;
	if (m_bFastWalk != p_Other.m_bFastWalk) return false;
	if (m_bMovementAllowed != p_Other.m_bMovementAllowed) return false;
	if (m_bIdleAnimationsAllowed != p_Other.m_bIdleAnimationsAllowed) return false;
	if (m_bItems != p_Other.m_bItems) return false;
	if (m_bCanHolsterItems != p_Other.m_bCanHolsterItems) return false;
	if (m_bCoverTakedown != p_Other.m_bCoverTakedown) return false;
	if (m_bCoverScale != p_Other.m_bCoverScale) return false;
	if (m_bCoverToCover != p_Other.m_bCoverToCover) return false;
	if (m_bCloseCombatSnapNeck != p_Other.m_bCloseCombatSnapNeck) return false;
	if (m_bCloseCombatChoke != p_Other.m_bCloseCombatChoke) return false;
	if (m_bCloseCombatPistolFinish != p_Other.m_bCloseCombatPistolFinish) return false;
	if (m_bCloseCombatProps != p_Other.m_bCloseCombatProps) return false;
	if (m_bCloseCombatStandart != p_Other.m_bCloseCombatStandart) return false;
	if (m_bCloseCombatFakeSwing != p_Other.m_bCloseCombatFakeSwing) return false;
	if (m_bGameCameraAutoAlign != p_Other.m_bGameCameraAutoAlign) return false;
	if (m_bInstinct != p_Other.m_bInstinct) return false;
	if (m_bCanCancelShootingBallet != p_Other.m_bCanCancelShootingBallet) return false;
	if (m_bBlindFire != p_Other.m_bBlindFire) return false;
	if (m_bAim != p_Other.m_bAim) return false;
	if (m_bHairTrigger != p_Other.m_bHairTrigger) return false;
	if (m_bFire != p_Other.m_bFire) return false;
	if (m_bOpenLogbook != p_Other.m_bOpenLogbook) return false;
	if (m_bOpenPauseMenu != p_Other.m_bOpenPauseMenu) return false;
	if (m_bActivatedByPinSignal != p_Other.m_bActivatedByPinSignal) return false;

	return true;
}

ZHMTypeInfo SHUDPromptDisplayInfo::TypeInfo = ZHMTypeInfo("SHUDPromptDisplayInfo", sizeof(SHUDPromptDisplayInfo), alignof(SHUDPromptDisplayInfo), SHUDPromptDisplayInfo::WriteJson, SHUDPromptDisplayInfo::WriteSimpleJson, SHUDPromptDisplayInfo::FromSimpleJson, SHUDPromptDisplayInfo::Serialize, SHUDPromptDisplayInfo::Equals);

void SHUDPromptDisplayInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActionPromptState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActionPromptState", static_cast<int>(s_Object->m_eState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIconId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIconId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTypeId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTypeId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistance);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowWarning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoActionAvailable") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoActionAvailable);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLabel") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLabel);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sGlyph") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sGlyph);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpacity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpacity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegalItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegalItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspiciousItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspiciousItem);
	p_Stream << "}";

	p_Stream << "}";
}

void SHUDPromptDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActionPromptState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIconId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIconId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTypeId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTypeId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoActionAvailable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoActionAvailable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sGlyph") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sGlyph);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpacity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpacity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegalItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegalItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspiciousItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspiciousItem);

	p_Stream << "}";
}

void SHUDPromptDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDPromptDisplayInfo s_Object {};

	s_Object.m_bActive = simdjson::from_json_bool(p_Document["m_bActive"]);

	s_Object.m_eState = static_cast<EActionPromptState>(ZHMEnums::GetEnumValueByName("EActionPromptState", std::string_view(p_Document["m_eState"])));

	s_Object.m_nIconId = simdjson::from_json_int32(p_Document["m_nIconId"]);

	s_Object.m_eTypeId = simdjson::from_json_int32(p_Document["m_eTypeId"]);

	s_Object.m_fProgress = simdjson::from_json_float32(p_Document["m_fProgress"]);

	s_Object.m_fDistance = simdjson::from_json_float32(p_Document["m_fDistance"]);

	s_Object.m_bShowWarning = simdjson::from_json_bool(p_Document["m_bShowWarning"]);

	s_Object.m_bNoActionAvailable = simdjson::from_json_bool(p_Document["m_bNoActionAvailable"]);

	s_Object.m_sLabel = std::string_view(p_Document["m_sLabel"]);

	s_Object.m_sDescription = std::string_view(p_Document["m_sDescription"]);

	s_Object.m_sGlyph = std::string_view(p_Document["m_sGlyph"]);

	s_Object.m_fOpacity = simdjson::from_json_float32(p_Document["m_fOpacity"]);

	s_Object.m_bIllegalItem = simdjson::from_json_bool(p_Document["m_bIllegalItem"]);

	s_Object.m_bSuspiciousItem = simdjson::from_json_bool(p_Document["m_bSuspiciousItem"]);

	*reinterpret_cast<SHUDPromptDisplayInfo*>(p_Target) = s_Object;
}

void SHUDPromptDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->m_sLabel, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sLabel));
	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sDescription));
	ZString::Serialize(&s_Object->m_sGlyph, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sGlyph));
}

bool SHUDPromptDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDPromptDisplayInfo::operator==(const SHUDPromptDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDPromptDisplayInfo>)
		return false;

	if (m_bActive != p_Other.m_bActive) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_nIconId != p_Other.m_nIconId) return false;
	if (m_eTypeId != p_Other.m_eTypeId) return false;
	if (m_fProgress != p_Other.m_fProgress) return false;
	if (m_fDistance != p_Other.m_fDistance) return false;
	if (m_bShowWarning != p_Other.m_bShowWarning) return false;
	if (m_bNoActionAvailable != p_Other.m_bNoActionAvailable) return false;
	if (m_sLabel != p_Other.m_sLabel) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_sGlyph != p_Other.m_sGlyph) return false;
	if (m_fOpacity != p_Other.m_fOpacity) return false;
	if (m_bIllegalItem != p_Other.m_bIllegalItem) return false;
	if (m_bSuspiciousItem != p_Other.m_bSuspiciousItem) return false;

	return true;
}

ZHMTypeInfo SHUDPromptDisplayInfoArray_Dummy::TypeInfo = ZHMTypeInfo("SHUDPromptDisplayInfoArray_Dummy", sizeof(SHUDPromptDisplayInfoArray_Dummy), alignof(SHUDPromptDisplayInfoArray_Dummy), SHUDPromptDisplayInfoArray_Dummy::WriteJson, SHUDPromptDisplayInfoArray_Dummy::WriteSimpleJson, SHUDPromptDisplayInfoArray_Dummy::FromSimpleJson, SHUDPromptDisplayInfoArray_Dummy::Serialize, SHUDPromptDisplayInfoArray_Dummy::Equals);

void SHUDPromptDisplayInfoArray_Dummy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SHUDPromptDisplayInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SHUDPromptDisplayInfo") << ",\"$val\":";
		SHUDPromptDisplayInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SHUDPromptDisplayInfoArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SHUDPromptDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SHUDPromptDisplayInfoArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDPromptDisplayInfoArray_Dummy s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["dummy"])
	{
		SHUDPromptDisplayInfo s_ArrayItem0;
		SHUDPromptDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Target) = s_Object;
}

void SHUDPromptDisplayInfoArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);

	TArray<SHUDPromptDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfoArray_Dummy, dummy));
}

bool SHUDPromptDisplayInfoArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDPromptDisplayInfoArray_Dummy::operator==(const SHUDPromptDisplayInfoArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDPromptDisplayInfoArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

ZHMTypeInfo SHUDTimerControllerSaveData::TypeInfo = ZHMTypeInfo("SHUDTimerControllerSaveData", sizeof(SHUDTimerControllerSaveData), alignof(SHUDTimerControllerSaveData), SHUDTimerControllerSaveData::WriteJson, SHUDTimerControllerSaveData::WriteSimpleJson, SHUDTimerControllerSaveData::FromSimpleJson, SHUDTimerControllerSaveData::Serialize, SHUDTimerControllerSaveData::Equals);

void SHUDTimerControllerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pCurrentInstance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCurrentInstance);
	p_Stream << "}";

	p_Stream << "}";
}

void SHUDTimerControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pCurrentInstance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCurrentInstance);

	p_Stream << "}";
}

void SHUDTimerControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDTimerControllerSaveData s_Object {};

	s_Object.m_pCurrentInstance = simdjson::from_json_uint32(p_Document["m_pCurrentInstance"]);

	*reinterpret_cast<SHUDTimerControllerSaveData*>(p_Target) = s_Object;
}

void SHUDTimerControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);

}

bool SHUDTimerControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDTimerControllerSaveData::operator==(const SHUDTimerControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDTimerControllerSaveData>)
		return false;

	if (m_pCurrentInstance != p_Other.m_pCurrentInstance) return false;

	return true;
}

ZHMTypeInfo SHUDVisibilityController2SaveData::TypeInfo = ZHMTypeInfo("SHUDVisibilityController2SaveData", sizeof(SHUDVisibilityController2SaveData), alignof(SHUDVisibilityController2SaveData), SHUDVisibilityController2SaveData::WriteJson, SHUDVisibilityController2SaveData::WriteSimpleJson, SHUDVisibilityController2SaveData::FromSimpleJson, SHUDVisibilityController2SaveData::Serialize, SHUDVisibilityController2SaveData::Equals);

void SHUDVisibilityController2SaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eCurrentRequest") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHUDUIRoot.EHUDVisibility") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eCurrentRequest)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHUDUIRoot.EHUDVisibility", static_cast<int>(s_Object->m_eCurrentRequest))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SHUDVisibilityController2SaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eCurrentRequest") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHUDUIRoot.EHUDVisibility", static_cast<int>(s_Object->m_eCurrentRequest)));

	p_Stream << "}";
}

void SHUDVisibilityController2SaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDVisibilityController2SaveData s_Object {};

	s_Object.m_eCurrentRequest = static_cast<ZHUDUIRoot_EHUDVisibility>(ZHMEnums::GetEnumValueByName("ZHUDUIRoot.EHUDVisibility", std::string_view(p_Document["m_eCurrentRequest"])));

	*reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Target) = s_Object;
}

void SHUDVisibilityController2SaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);

}

bool SHUDVisibilityController2SaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDVisibilityController2SaveData::operator==(const SHUDVisibilityController2SaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDVisibilityController2SaveData>)
		return false;

	if (m_eCurrentRequest != p_Other.m_eCurrentRequest) return false;

	return true;
}

ZHMTypeInfo SHandleClosetGroupSaveData::TypeInfo = ZHMTypeInfo("SHandleClosetGroupSaveData", sizeof(SHandleClosetGroupSaveData), alignof(SHandleClosetGroupSaveData), SHandleClosetGroupSaveData::WriteJson, SHandleClosetGroupSaveData::WriteSimpleJson, SHandleClosetGroupSaveData::FromSimpleJson, SHandleClosetGroupSaveData::Serialize, SHandleClosetGroupSaveData::Equals);

void SHandleClosetGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pProcessingMember") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pProcessingMember);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_startTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_startTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SpeechState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EHandleClosetSpeechState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_SpeechState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHandleClosetSpeechState", static_cast<int>(s_Object->m_SpeechState))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SHandleClosetGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pProcessingMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pProcessingMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_startTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_startTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SpeechState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHandleClosetSpeechState", static_cast<int>(s_Object->m_SpeechState)));

	p_Stream << "}";
}

void SHandleClosetGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHandleClosetGroupSaveData s_Object {};

	s_Object.m_pProcessingMember = simdjson::from_json_uint32(p_Document["m_pProcessingMember"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_startTime"], &s_Item);
		s_Object.m_startTime = s_Item;
	}

	s_Object.m_SpeechState = static_cast<EHandleClosetSpeechState>(ZHMEnums::GetEnumValueByName("EHandleClosetSpeechState", std::string_view(p_Document["m_SpeechState"])));

	*reinterpret_cast<SHandleClosetGroupSaveData*>(p_Target) = s_Object;
}

void SHandleClosetGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_startTime, p_Serializer, p_OwnOffset + offsetof(SHandleClosetGroupSaveData, m_startTime));
}

bool SHandleClosetGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHandleClosetGroupSaveData::operator==(const SHandleClosetGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHandleClosetGroupSaveData>)
		return false;

	if (m_pProcessingMember != p_Other.m_pProcessingMember) return false;
	if (m_startTime != p_Other.m_startTime) return false;
	if (m_SpeechState != p_Other.m_SpeechState) return false;

	return true;
}

ZHMTypeInfo SHeroEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SHeroEscortSituationActorStateSaveData", sizeof(SHeroEscortSituationActorStateSaveData), alignof(SHeroEscortSituationActorStateSaveData), SHeroEscortSituationActorStateSaveData::WriteJson, SHeroEscortSituationActorStateSaveData::WriteSimpleJson, SHeroEscortSituationActorStateSaveData::FromSimpleJson, SHeroEscortSituationActorStateSaveData::Serialize, SHeroEscortSituationActorStateSaveData::Equals);

void SHeroEscortSituationActorStateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHeroEscortSituationEntity.EEscortState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHeroEscortSituationEntity.EEscortState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eStatePrevious)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);
	p_Stream << "}";

	p_Stream << "}";
}

void SHeroEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SHeroEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituationActorStateSaveData s_Object {};

	s_Object.m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_eState = static_cast<ZHeroEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object.m_eStatePrevious = static_cast<ZHeroEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object.m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

	*reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Target) = s_Object;
}

void SHeroEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);

}

bool SHeroEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituationActorStateSaveData::operator==(const SHeroEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

ZHMTypeInfo SHeroEscortSituationActors::TypeInfo = ZHMTypeInfo("SHeroEscortSituationActors", sizeof(SHeroEscortSituationActors), alignof(SHeroEscortSituationActors), SHeroEscortSituationActors::WriteJson, SHeroEscortSituationActors::WriteSimpleJson, SHeroEscortSituationActors::FromSimpleJson, SHeroEscortSituationActors::Serialize, SHeroEscortSituationActors::Equals);

void SHeroEscortSituationActors::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SHeroEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SHeroEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituationActors s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SHeroEscortSituationActors*>(p_Target) = s_Object;
}

void SHeroEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);

}

bool SHeroEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituationActors::operator==(const SHeroEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SHeroEscortSituationSaveData::TypeInfo = ZHMTypeInfo("SHeroEscortSituationSaveData", sizeof(SHeroEscortSituationSaveData), alignof(SHeroEscortSituationSaveData), SHeroEscortSituationSaveData::WriteJson, SHeroEscortSituationSaveData::WriteSimpleJson, SHeroEscortSituationSaveData::FromSimpleJson, SHeroEscortSituationSaveData::Serialize, SHeroEscortSituationSaveData::Equals);

void SHeroEscortSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHeroEscortSituationEntity.ETargetState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorEmotionState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetEmotionState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZActBehaviorEntity.EState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetActState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SHeroEscortSituationActors>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SHeroEscortSituationActors") << ",\"$val\":";
		SHeroEscortSituationActors::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SHeroEscortSituationActorStateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SHeroEscortSituationActorStateSaveData") << ",\"$val\":";
		SHeroEscortSituationActorStateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeSinceLossOfSight") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeSinceLossOfSight);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RecordedHitmanOutfit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_RecordedHitmanOutfit, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SHeroEscortSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SHeroEscortSituationActors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SHeroEscortSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeSinceLossOfSight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeSinceLossOfSight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RecordedHitmanOutfit") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_RecordedHitmanOutfit, p_Stream);

	p_Stream << "}";
}

void SHeroEscortSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituationSaveData s_Object {};

	s_Object.m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object.m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object.m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object.m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object.m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Item);
		s_Object.m_vLastPosition = s_Item;
	}

	s_Object.m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object.m_eTargetState = static_cast<ZHeroEscortSituationEntity_ETargetState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituationEntity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object.m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object.m_eTargetActState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object.m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object.m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAddedActors"])
	{
		SHeroEscortSituationActors s_ArrayItem0;
		SHeroEscortSituationActors::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAddedActors.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aStates"])
	{
		SHeroEscortSituationActorStateSaveData s_ArrayItem0;
		SHeroEscortSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEscortActs"])
	{
		s_Object.m_aEscortActs.push_back(simdjson::from_json_uint32(s_Item0));
	}

	s_Object.m_fTimeSinceLossOfSight = simdjson::from_json_float32(p_Document["m_fTimeSinceLossOfSight"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_RecordedHitmanOutfit"], &s_Item);
		s_Object.m_RecordedHitmanOutfit = s_Item;
	}

	*reinterpret_cast<SHeroEscortSituationSaveData*>(p_Target) = s_Object;
}

void SHeroEscortSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_vLastPosition));
	TArray<SHeroEscortSituationActors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_aAddedActors));
	TArray<SHeroEscortSituationActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_aEscortActs));
	ZRepositoryID::Serialize(&s_Object->m_RecordedHitmanOutfit, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_RecordedHitmanOutfit));
}

bool SHeroEscortSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituationSaveData::operator==(const SHeroEscortSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituationSaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;
	if (m_fTimeSinceLossOfSight != p_Other.m_fTimeSinceLossOfSight) return false;
	if (m_RecordedHitmanOutfit != p_Other.m_RecordedHitmanOutfit) return false;

	return true;
}

ZHMTypeInfo SHeroItemActionSaveData::TypeInfo = ZHMTypeInfo("SHeroItemActionSaveData", sizeof(SHeroItemActionSaveData), alignof(SHeroItemActionSaveData), SHeroItemActionSaveData::WriteJson, SHeroItemActionSaveData::WriteSimpleJson, SHeroItemActionSaveData::FromSimpleJson, SHeroItemActionSaveData::Serialize, SHeroItemActionSaveData::Equals);

void SHeroItemActionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << "}";

	p_Stream << "}";
}

void SHeroItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SHeroItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroItemActionSaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SHeroItemActionSaveData*>(p_Target) = s_Object;
}

void SHeroItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);

}

bool SHeroItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroItemActionSaveData::operator==(const SHeroItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroItemActionSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

ZHMTypeInfo SHeroItemAttachmentSaveData::TypeInfo = ZHMTypeInfo("SHeroItemAttachmentSaveData", sizeof(SHeroItemAttachmentSaveData), alignof(SHeroItemAttachmentSaveData), SHeroItemAttachmentSaveData::WriteJson, SHeroItemAttachmentSaveData::WriteSimpleJson, SHeroItemAttachmentSaveData::FromSimpleJson, SHeroItemAttachmentSaveData::Serialize, SHeroItemAttachmentSaveData::Equals);

void SHeroItemAttachmentSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << "}";

	p_Stream << "}";
}

void SHeroItemAttachmentSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SHeroItemAttachmentSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroItemAttachmentSaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Target) = s_Object;
}

void SHeroItemAttachmentSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);

}

bool SHeroItemAttachmentSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroItemAttachmentSaveData::operator==(const SHeroItemAttachmentSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroItemAttachmentSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

ZHMTypeInfo SHeroStandInSaveState::TypeInfo = ZHMTypeInfo("SHeroStandInSaveState", sizeof(SHeroStandInSaveState), alignof(SHeroStandInSaveState), SHeroStandInSaveState::WriteJson, SHeroStandInSaveState::WriteSimpleJson, SHeroStandInSaveState::FromSimpleJson, SHeroStandInSaveState::Serialize, SHeroStandInSaveState::Equals);

void SHeroStandInSaveState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << "}";

	p_Stream << "}";
}

void SHeroStandInSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);

	p_Stream << "}";
}

void SHeroStandInSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroStandInSaveState s_Object {};

	s_Object.m_rCurrentSpeakEntity = simdjson::from_json_uint32(p_Document["m_rCurrentSpeakEntity"]);

	s_Object.m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	*reinterpret_cast<SHeroStandInSaveState*>(p_Target) = s_Object;
}

void SHeroStandInSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);

}

bool SHeroStandInSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroStandInSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroStandInSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroStandInSaveState::operator==(const SHeroStandInSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroStandInSaveState>)
		return false;

	if (m_rCurrentSpeakEntity != p_Other.m_rCurrentSpeakEntity) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;

	return true;
}

ZHMTypeInfo SHintEntrySaveData::TypeInfo = ZHMTypeInfo("SHintEntrySaveData", sizeof(SHintEntrySaveData), alignof(SHintEntrySaveData), SHintEntrySaveData::WriteJson, SHintEntrySaveData::WriteSimpleJson, SHintEntrySaveData::FromSimpleJson, SHintEntrySaveData::Serialize, SHintEntrySaveData::Equals);

void SHintEntrySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsValid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsValid);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_hint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_hint);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_context") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_context);
	p_Stream << "}";

	p_Stream << "}";
}

void SHintEntrySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsValid);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_hint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_hint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_context") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_context);

	p_Stream << "}";
}

void SHintEntrySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHintEntrySaveData s_Object {};

	s_Object.m_bIsValid = simdjson::from_json_bool(p_Document["m_bIsValid"]);

	s_Object.m_hint = simdjson::from_json_uint32(p_Document["m_hint"]);

	s_Object.m_context = simdjson::from_json_uint32(p_Document["m_context"]);

	*reinterpret_cast<SHintEntrySaveData*>(p_Target) = s_Object;
}

void SHintEntrySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);

}

bool SHintEntrySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHintEntrySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHintEntrySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHintEntrySaveData::operator==(const SHintEntrySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHintEntrySaveData>)
		return false;

	if (m_bIsValid != p_Other.m_bIsValid) return false;
	if (m_hint != p_Other.m_hint) return false;
	if (m_context != p_Other.m_context) return false;

	return true;
}

ZHMTypeInfo SHintManagerSaveData::TypeInfo = ZHMTypeInfo("SHintManagerSaveData", sizeof(SHintManagerSaveData), alignof(SHintManagerSaveData), SHintManagerSaveData::WriteJson, SHintManagerSaveData::WriteSimpleJson, SHintManagerSaveData::FromSimpleJson, SHintManagerSaveData::Serialize, SHintManagerSaveData::Equals);

void SHintManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_activeHint") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SHintEntrySaveData") << ",\"$val\":";
	SHintEntrySaveData::WriteJson(&s_Object->m_activeHint, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aQueue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SHintEntrySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aQueue.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aQueue[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SHintEntrySaveData") << ",\"$val\":";
		SHintEntrySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aQueue.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRunning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRunning);
	p_Stream << "}";

	p_Stream << "}";
}

void SHintManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_activeHint") << ":";
	SHintEntrySaveData::WriteSimpleJson(&s_Object->m_activeHint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aQueue") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aQueue.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aQueue[i];
		SHintEntrySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aQueue.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRunning);

	p_Stream << "}";
}

void SHintManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHintManagerSaveData s_Object {};

	{
		SHintEntrySaveData s_Item {};
		SHintEntrySaveData::FromSimpleJson(p_Document["m_activeHint"], &s_Item);
		s_Object.m_activeHint = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aQueue"])
	{
		SHintEntrySaveData s_ArrayItem0;
		SHintEntrySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aQueue.push_back(s_ArrayItem0);
	}

	s_Object.m_bIsRunning = simdjson::from_json_bool(p_Document["m_bIsRunning"]);

	*reinterpret_cast<SHintManagerSaveData*>(p_Target) = s_Object;
}

void SHintManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);

	SHintEntrySaveData::Serialize(&s_Object->m_activeHint, p_Serializer, p_OwnOffset + offsetof(SHintManagerSaveData, m_activeHint));
	TArray<SHintEntrySaveData>::Serialize(&s_Object->m_aQueue, p_Serializer, p_OwnOffset + offsetof(SHintManagerSaveData, m_aQueue));
}

bool SHintManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHintManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHintManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHintManagerSaveData::operator==(const SHintManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHintManagerSaveData>)
		return false;

	if (m_activeHint != p_Other.m_activeHint) return false;
	if (m_aQueue != p_Other.m_aQueue) return false;
	if (m_bIsRunning != p_Other.m_bIsRunning) return false;

	return true;
}

ZHMTypeInfo SHitmanSaveData::TypeInfo = ZHMTypeInfo("SHitmanSaveData", sizeof(SHitmanSaveData), alignof(SHitmanSaveData), SHitmanSaveData::WriteJson, SHitmanSaveData::WriteSimpleJson, SHitmanSaveData::FromSimpleJson, SHitmanSaveData::Serialize, SHitmanSaveData::Equals);

void SHitmanSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHitmanSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_OutfitID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_OutfitID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHealth") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHealth);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Inventory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_Inventory, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Camera") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_Camera, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMovementType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EBaseMovementType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eMovementType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EBaseMovementType", static_cast<int>(s_Object->m_eMovementType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MovementData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_MovementData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLethalAgilityElementUsed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLethalAgilityElementUsed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsChangingClothes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsChangingClothes);
	p_Stream << "}";

	p_Stream << "}";
}

void SHitmanSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHitmanSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_OutfitID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_OutfitID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHealth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHealth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Inventory") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Inventory, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Camera") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Camera, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMovementType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EBaseMovementType", static_cast<int>(s_Object->m_eMovementType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MovementData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_MovementData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLethalAgilityElementUsed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLethalAgilityElementUsed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsChangingClothes") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsChangingClothes);

	p_Stream << "}";
}

void SHitmanSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHitmanSaveData s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_OutfitID"], &s_Item);
		s_Object.m_OutfitID = s_Item;
	}

	s_Object.m_nOutfitCharset = simdjson::from_json_int32(p_Document["m_nOutfitCharset"]);

	s_Object.m_nOutfitVariation = simdjson::from_json_int32(p_Document["m_nOutfitVariation"]);

	s_Object.m_fHealth = simdjson::from_json_float32(p_Document["m_fHealth"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vRotation"], &s_Item);
		s_Object.m_vRotation = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Inventory"], &s_Item);
		s_Object.m_Inventory = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Camera"], &s_Item);
		s_Object.m_Camera = s_Item;
	}

	s_Object.m_eMovementType = static_cast<EBaseMovementType>(ZHMEnums::GetEnumValueByName("EBaseMovementType", std::string_view(p_Document["m_eMovementType"])));

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_MovementData"], &s_Item);
		s_Object.m_MovementData = s_Item;
	}

	s_Object.m_bLethalAgilityElementUsed = simdjson::from_json_bool(p_Document["m_bLethalAgilityElementUsed"]);

	s_Object.m_bIsChangingClothes = simdjson::from_json_bool(p_Document["m_bIsChangingClothes"]);

	*reinterpret_cast<SHitmanSaveData*>(p_Target) = s_Object;
}

void SHitmanSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHitmanSaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_OutfitID, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_OutfitID));
	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_vRotation));
	ZVariant::Serialize(&s_Object->m_Inventory, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_Inventory));
	ZVariant::Serialize(&s_Object->m_Camera, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_Camera));
	ZVariant::Serialize(&s_Object->m_MovementData, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_MovementData));
}

bool SHitmanSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHitmanSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHitmanSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHitmanSaveData::operator==(const SHitmanSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHitmanSaveData>)
		return false;

	if (m_OutfitID != p_Other.m_OutfitID) return false;
	if (m_nOutfitCharset != p_Other.m_nOutfitCharset) return false;
	if (m_nOutfitVariation != p_Other.m_nOutfitVariation) return false;
	if (m_fHealth != p_Other.m_fHealth) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_Inventory != p_Other.m_Inventory) return false;
	if (m_Camera != p_Other.m_Camera) return false;
	if (m_eMovementType != p_Other.m_eMovementType) return false;
	if (m_MovementData != p_Other.m_MovementData) return false;
	if (m_bLethalAgilityElementUsed != p_Other.m_bLethalAgilityElementUsed) return false;
	if (m_bIsChangingClothes != p_Other.m_bIsChangingClothes) return false;

	return true;
}

ZHMTypeInfo SHudMissionTimerControllerData::TypeInfo = ZHMTypeInfo("SHudMissionTimerControllerData", sizeof(SHudMissionTimerControllerData), alignof(SHudMissionTimerControllerData), SHudMissionTimerControllerData::WriteJson, SHudMissionTimerControllerData::WriteSimpleJson, SHudMissionTimerControllerData::FromSimpleJson, SHudMissionTimerControllerData::Serialize, SHudMissionTimerControllerData::Equals);

void SHudMissionTimerControllerData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fScoreGameTimeStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_fScoreGameTimeStart, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasIntroCutFired") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasIntroCutFired);
	p_Stream << "}";

	p_Stream << "}";
}

void SHudMissionTimerControllerData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fScoreGameTimeStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_fScoreGameTimeStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasIntroCutFired") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasIntroCutFired);

	p_Stream << "}";
}

void SHudMissionTimerControllerData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHudMissionTimerControllerData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_fScoreGameTimeStart"], &s_Item);
		s_Object.m_fScoreGameTimeStart = s_Item;
	}

	s_Object.m_bWasIntroCutFired = simdjson::from_json_bool(p_Document["m_bWasIntroCutFired"]);

	*reinterpret_cast<SHudMissionTimerControllerData*>(p_Target) = s_Object;
}

void SHudMissionTimerControllerData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_fScoreGameTimeStart, p_Serializer, p_OwnOffset + offsetof(SHudMissionTimerControllerData, m_fScoreGameTimeStart));
}

bool SHudMissionTimerControllerData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHudMissionTimerControllerData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHudMissionTimerControllerData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHudMissionTimerControllerData::operator==(const SHudMissionTimerControllerData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHudMissionTimerControllerData>)
		return false;

	if (m_fScoreGameTimeStart != p_Other.m_fScoreGameTimeStart) return false;
	if (m_bWasIntroCutFired != p_Other.m_bWasIntroCutFired) return false;

	return true;
}

ZHMTypeInfo SHumanShieldGroupSaveData::TypeInfo = ZHMTypeInfo("SHumanShieldGroupSaveData", sizeof(SHumanShieldGroupSaveData), alignof(SHumanShieldGroupSaveData), SHumanShieldGroupSaveData::WriteJson, SHumanShieldGroupSaveData::WriteSimpleJson, SHumanShieldGroupSaveData::FromSimpleJson, SHumanShieldGroupSaveData::Serialize, SHumanShieldGroupSaveData::Equals);

void SHumanShieldGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGroupTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tGroupTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pVictim") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pVictim);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pRelationship") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pRelationship);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SpeechState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EHumanShieldSpeechState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_SpeechState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHumanShieldSpeechState", static_cast<int>(s_Object->m_SpeechState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPositionMemberIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPositionMemberIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_positionRequestMember") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_positionRequestMember);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastPositionRequest") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastPositionRequest, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWeaponFiredTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastWeaponFiredTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SHumanShieldGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGroupTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGroupTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pRelationship") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pRelationship);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SpeechState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHumanShieldSpeechState", static_cast<int>(s_Object->m_SpeechState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPositionMemberIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPositionMemberIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_positionRequestMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_positionRequestMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastPositionRequest") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastPositionRequest, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWeaponFiredTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastWeaponFiredTime, p_Stream);

	p_Stream << "}";
}

void SHumanShieldGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHumanShieldGroupSaveData s_Object {};

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tGroupTime"], &s_Item);
		s_Object.m_tGroupTime = s_Item;
	}

	s_Object.m_pVictim = simdjson::from_json_uint32(p_Document["m_pVictim"]);

	s_Object.m_pRelationship = simdjson::from_json_uint32(p_Document["m_pRelationship"]);

	s_Object.m_SpeechState = static_cast<EHumanShieldSpeechState>(ZHMEnums::GetEnumValueByName("EHumanShieldSpeechState", std::string_view(p_Document["m_SpeechState"])));

	s_Object.m_nPositionMemberIndex = simdjson::from_json_int32(p_Document["m_nPositionMemberIndex"]);

	s_Object.m_positionRequestMember = simdjson::from_json_uint32(p_Document["m_positionRequestMember"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastPositionRequest"], &s_Item);
		s_Object.m_tLastPositionRequest = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastWeaponFiredTime"], &s_Item);
		s_Object.m_tLastWeaponFiredTime = s_Item;
	}

	*reinterpret_cast<SHumanShieldGroupSaveData*>(p_Target) = s_Object;
}

void SHumanShieldGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGroupTime, p_Serializer, p_OwnOffset + offsetof(SHumanShieldGroupSaveData, m_tGroupTime));
	ZGameTime::Serialize(&s_Object->m_tLastPositionRequest, p_Serializer, p_OwnOffset + offsetof(SHumanShieldGroupSaveData, m_tLastPositionRequest));
	ZGameTime::Serialize(&s_Object->m_tLastWeaponFiredTime, p_Serializer, p_OwnOffset + offsetof(SHumanShieldGroupSaveData, m_tLastWeaponFiredTime));
}

bool SHumanShieldGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHumanShieldGroupSaveData::operator==(const SHumanShieldGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHumanShieldGroupSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_tGroupTime != p_Other.m_tGroupTime) return false;
	if (m_pVictim != p_Other.m_pVictim) return false;
	if (m_pRelationship != p_Other.m_pRelationship) return false;
	if (m_SpeechState != p_Other.m_SpeechState) return false;
	if (m_nPositionMemberIndex != p_Other.m_nPositionMemberIndex) return false;
	if (m_positionRequestMember != p_Other.m_positionRequestMember) return false;
	if (m_tLastPositionRequest != p_Other.m_tLastPositionRequest) return false;
	if (m_tLastWeaponFiredTime != p_Other.m_tLastWeaponFiredTime) return false;

	return true;
}

ZHMTypeInfo SIntelData::TypeInfo = ZHMTypeInfo("SIntelData", sizeof(SIntelData), alignof(SIntelData), SIntelData::WriteJson, SIntelData::WriteSimpleJson, SIntelData::FromSimpleJson, SIntelData::Serialize, SIntelData::Equals);

void SIntelData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sHeadline") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sHeadline);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyHeadline") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyHeadline);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodytext") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodytext);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);
	p_Stream << "}";

	p_Stream << "}";
}

void SIntelData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sHeadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sHeadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyHeadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyHeadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodytext") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodytext);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);

	p_Stream << "}";
}

void SIntelData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelData s_Object {};

	s_Object.m_sHeadline = std::string_view(p_Document["m_sHeadline"]);

	s_Object.m_sBodyHeadline = std::string_view(p_Document["m_sBodyHeadline"]);

	s_Object.m_sBodytext = std::string_view(p_Document["m_sBodytext"]);

	s_Object.m_sImage = std::string_view(p_Document["m_sImage"]);

	*reinterpret_cast<SIntelData*>(p_Target) = s_Object;
}

void SIntelData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);

	ZString::Serialize(&s_Object->m_sHeadline, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sHeadline));
	ZString::Serialize(&s_Object->m_sBodyHeadline, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sBodyHeadline));
	ZString::Serialize(&s_Object->m_sBodytext, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sBodytext));
	ZString::Serialize(&s_Object->m_sImage, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sImage));
}

bool SIntelData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelData*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelData::operator==(const SIntelData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelData>)
		return false;

	if (m_sHeadline != p_Other.m_sHeadline) return false;
	if (m_sBodyHeadline != p_Other.m_sBodyHeadline) return false;
	if (m_sBodytext != p_Other.m_sBodytext) return false;
	if (m_sImage != p_Other.m_sImage) return false;

	return true;
}

ZHMTypeInfo SIntelDataArray_dummy::TypeInfo = ZHMTypeInfo("SIntelDataArray_dummy", sizeof(SIntelDataArray_dummy), alignof(SIntelDataArray_dummy), SIntelDataArray_dummy::WriteJson, SIntelDataArray_dummy::WriteSimpleJson, SIntelDataArray_dummy::FromSimpleJson, SIntelDataArray_dummy::Serialize, SIntelDataArray_dummy::Equals);

void SIntelDataArray_dummy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SIntelData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SIntelData") << ",\"$val\":";
		SIntelData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SIntelDataArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelDataArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelDataArray_dummy s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["dummy"])
	{
		SIntelData s_ArrayItem0;
		SIntelData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SIntelDataArray_dummy*>(p_Target) = s_Object;
}

void SIntelDataArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);

	TArray<SIntelData>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelDataArray_dummy, dummy));
}

bool SIntelDataArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDataArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDataArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDataArray_dummy::operator==(const SIntelDataArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDataArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

ZHMTypeInfo SIntelDisplayInfo::TypeInfo = ZHMTypeInfo("SIntelDisplayInfo", sizeof(SIntelDisplayInfo), alignof(SIntelDisplayInfo), SIntelDisplayInfo::WriteJson, SIntelDisplayInfo::WriteSimpleJson, SIntelDisplayInfo::FromSimpleJson, SIntelDisplayInfo::Serialize, SIntelDisplayInfo::Equals);

void SIntelDisplayInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("index") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->index);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selected") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->selected);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("headline") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->headline);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bodyheadline") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bodyheadline);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("text") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->text);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("img") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->img);
	p_Stream << "}";

	p_Stream << "}";
}

void SIntelDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("index") << ":";
	p_Stream << simdjson::as_json_string(s_Object->index);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->selected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("headline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->headline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bodyheadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bodyheadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("text") << ":";
	p_Stream << simdjson::as_json_string(s_Object->text);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("img") << ":";
	p_Stream << simdjson::as_json_string(s_Object->img);

	p_Stream << "}";
}

void SIntelDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelDisplayInfo s_Object {};

	s_Object.index = simdjson::from_json_int32(p_Document["index"]);

	s_Object.selected = simdjson::from_json_bool(p_Document["selected"]);

	s_Object.active = simdjson::from_json_bool(p_Document["active"]);

	s_Object.headline = std::string_view(p_Document["headline"]);

	s_Object.bodyheadline = std::string_view(p_Document["bodyheadline"]);

	s_Object.text = std::string_view(p_Document["text"]);

	s_Object.img = std::string_view(p_Document["img"]);

	*reinterpret_cast<SIntelDisplayInfo*>(p_Target) = s_Object;
}

void SIntelDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->headline, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, headline));
	ZString::Serialize(&s_Object->bodyheadline, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, bodyheadline));
	ZString::Serialize(&s_Object->text, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, text));
	ZString::Serialize(&s_Object->img, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, img));
}

bool SIntelDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDisplayInfo::operator==(const SIntelDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDisplayInfo>)
		return false;

	if (index != p_Other.index) return false;
	if (selected != p_Other.selected) return false;
	if (active != p_Other.active) return false;
	if (headline != p_Other.headline) return false;
	if (bodyheadline != p_Other.bodyheadline) return false;
	if (text != p_Other.text) return false;
	if (img != p_Other.img) return false;

	return true;
}

ZHMTypeInfo SIntelDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SIntelDisplayInfoArray_dummy", sizeof(SIntelDisplayInfoArray_dummy), alignof(SIntelDisplayInfoArray_dummy), SIntelDisplayInfoArray_dummy::WriteJson, SIntelDisplayInfoArray_dummy::WriteSimpleJson, SIntelDisplayInfoArray_dummy::FromSimpleJson, SIntelDisplayInfoArray_dummy::Serialize, SIntelDisplayInfoArray_dummy::Equals);

void SIntelDisplayInfoArray_dummy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SIntelDisplayInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SIntelDisplayInfo") << ",\"$val\":";
		SIntelDisplayInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SIntelDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelDisplayInfoArray_dummy s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["dummy"])
	{
		SIntelDisplayInfo s_ArrayItem0;
		SIntelDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Target) = s_Object;
}

void SIntelDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);

	TArray<SIntelDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfoArray_dummy, dummy));
}

bool SIntelDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDisplayInfoArray_dummy::operator==(const SIntelDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

ZHMTypeInfo SIntelListDisplayInfo::TypeInfo = ZHMTypeInfo("SIntelListDisplayInfo", sizeof(SIntelListDisplayInfo), alignof(SIntelListDisplayInfo), SIntelListDisplayInfo::WriteJson, SIntelListDisplayInfo::WriteSimpleJson, SIntelListDisplayInfo::FromSimpleJson, SIntelListDisplayInfo::Serialize, SIntelListDisplayInfo::Equals);

void SIntelListDisplayInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("index") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->index);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("newInfo") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->newInfo);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << "}";

	p_Stream << "}";
}

void SIntelListDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("index") << ":";
	p_Stream << simdjson::as_json_string(s_Object->index);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("newInfo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->newInfo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);

	p_Stream << "}";
}

void SIntelListDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelListDisplayInfo s_Object {};

	s_Object.index = simdjson::from_json_int32(p_Document["index"]);

	s_Object.active = simdjson::from_json_bool(p_Document["active"]);

	s_Object.newInfo = simdjson::from_json_bool(p_Document["newInfo"]);

	s_Object.label = std::string_view(p_Document["label"]);

	*reinterpret_cast<SIntelListDisplayInfo*>(p_Target) = s_Object;
}

void SIntelListDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SIntelListDisplayInfo, label));
}

bool SIntelListDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelListDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelListDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelListDisplayInfo::operator==(const SIntelListDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelListDisplayInfo>)
		return false;

	if (index != p_Other.index) return false;
	if (active != p_Other.active) return false;
	if (newInfo != p_Other.newInfo) return false;
	if (label != p_Other.label) return false;

	return true;
}

ZHMTypeInfo SIntelListDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SIntelListDisplayInfoArray_dummy", sizeof(SIntelListDisplayInfoArray_dummy), alignof(SIntelListDisplayInfoArray_dummy), SIntelListDisplayInfoArray_dummy::WriteJson, SIntelListDisplayInfoArray_dummy::WriteSimpleJson, SIntelListDisplayInfoArray_dummy::FromSimpleJson, SIntelListDisplayInfoArray_dummy::Serialize, SIntelListDisplayInfoArray_dummy::Equals);

void SIntelListDisplayInfoArray_dummy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SIntelListDisplayInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SIntelListDisplayInfo") << ",\"$val\":";
		SIntelListDisplayInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SIntelListDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelListDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelListDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelListDisplayInfoArray_dummy s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["dummy"])
	{
		SIntelListDisplayInfo s_ArrayItem0;
		SIntelListDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Target) = s_Object;
}

void SIntelListDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);

	TArray<SIntelListDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelListDisplayInfoArray_dummy, dummy));
}

bool SIntelListDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelListDisplayInfoArray_dummy::operator==(const SIntelListDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelListDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

ZHMTypeInfo SIntelSaveData::TypeInfo = ZHMTypeInfo("SIntelSaveData", sizeof(SIntelSaveData), alignof(SIntelSaveData), SIntelSaveData::WriteJson, SIntelSaveData::WriteSimpleJson, SIntelSaveData::FromSimpleJson, SIntelSaveData::Serialize, SIntelSaveData::Equals);

void SIntelSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rCurrentStage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentStage);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTracked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTracked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUnlocked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUnlocked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegistered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegistered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsLastTriggered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsLastTriggered);
	p_Stream << "}";

	p_Stream << "}";
}

void SIntelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentStage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentStage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTracked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTracked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUnlocked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUnlocked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegistered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsLastTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsLastTriggered);

	p_Stream << "}";
}

void SIntelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelSaveData s_Object {};

	s_Object.m_rCurrentStage = simdjson::from_json_uint32(p_Document["m_rCurrentStage"]);

	s_Object.m_bTracked = simdjson::from_json_bool(p_Document["m_bTracked"]);

	s_Object.m_bUnlocked = simdjson::from_json_bool(p_Document["m_bUnlocked"]);

	s_Object.m_bRegistered = simdjson::from_json_bool(p_Document["m_bRegistered"]);

	s_Object.m_bIsLastTriggered = simdjson::from_json_bool(p_Document["m_bIsLastTriggered"]);

	*reinterpret_cast<SIntelSaveData*>(p_Target) = s_Object;
}

void SIntelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);

}

bool SIntelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelSaveData::operator==(const SIntelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelSaveData>)
		return false;

	if (m_rCurrentStage != p_Other.m_rCurrentStage) return false;
	if (m_bTracked != p_Other.m_bTracked) return false;
	if (m_bUnlocked != p_Other.m_bUnlocked) return false;
	if (m_bRegistered != p_Other.m_bRegistered) return false;
	if (m_bIsLastTriggered != p_Other.m_bIsLastTriggered) return false;

	return true;
}

ZHMTypeInfo SInteractionIndicatorInstanceData::TypeInfo = ZHMTypeInfo("SInteractionIndicatorInstanceData", sizeof(SInteractionIndicatorInstanceData), alignof(SInteractionIndicatorInstanceData), SInteractionIndicatorInstanceData::WriteJson, SInteractionIndicatorInstanceData::WriteSimpleJson, SInteractionIndicatorInstanceData::FromSimpleJson, SInteractionIndicatorInstanceData::Serialize, SInteractionIndicatorInstanceData::Equals);

void SInteractionIndicatorInstanceData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_eState);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIconId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIconId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTypeId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTypeId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLabel") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLabel);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sGlyph") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sGlyph);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegal);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoActionAvailable") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoActionAvailable);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegalItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegalItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspiciousItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspiciousItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRotateIndicator") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRotateIndicator);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
	SVector2::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedDataUpdate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedDataUpdate);
	p_Stream << "}";

	p_Stream << "}";
}

void SInteractionIndicatorInstanceData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIconId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIconId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTypeId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTypeId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sGlyph") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sGlyph);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoActionAvailable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoActionAvailable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegalItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegalItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspiciousItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspiciousItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRotateIndicator") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRotateIndicator);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedDataUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedDataUpdate);

	p_Stream << "}";
}

void SInteractionIndicatorInstanceData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInteractionIndicatorInstanceData s_Object {};

	s_Object.m_eState = simdjson::from_json_int32(p_Document["m_eState"]);

	s_Object.m_nIconId = simdjson::from_json_int32(p_Document["m_nIconId"]);

	s_Object.m_eTypeId = simdjson::from_json_int32(p_Document["m_eTypeId"]);

	s_Object.m_fProgress = simdjson::from_json_float32(p_Document["m_fProgress"]);

	s_Object.m_sLabel = std::string_view(p_Document["m_sLabel"]);

	s_Object.m_sDescription = std::string_view(p_Document["m_sDescription"]);

	s_Object.m_sGlyph = std::string_view(p_Document["m_sGlyph"]);

	s_Object.m_fAnimation = simdjson::from_json_float32(p_Document["m_fAnimation"]);

	s_Object.m_bIllegal = simdjson::from_json_bool(p_Document["m_bIllegal"]);

	s_Object.m_bNoActionAvailable = simdjson::from_json_bool(p_Document["m_bNoActionAvailable"]);

	s_Object.m_bInRange = simdjson::from_json_bool(p_Document["m_bInRange"]);

	s_Object.m_bIllegalItem = simdjson::from_json_bool(p_Document["m_bIllegalItem"]);

	s_Object.m_bSuspiciousItem = simdjson::from_json_bool(p_Document["m_bSuspiciousItem"]);

	s_Object.m_bRotateIndicator = simdjson::from_json_bool(p_Document["m_bRotateIndicator"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vRotation"], &s_Item);
		s_Object.m_vRotation = s_Item;
	}

	s_Object.m_bNeedDataUpdate = simdjson::from_json_bool(p_Document["m_bNeedDataUpdate"]);

	*reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Target) = s_Object;
}

void SInteractionIndicatorInstanceData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);

	ZString::Serialize(&s_Object->m_sLabel, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_sLabel));
	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_sDescription));
	ZString::Serialize(&s_Object->m_sGlyph, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_sGlyph));
	SVector2::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_vPosition));
	SVector3::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_vRotation));
}

bool SInteractionIndicatorInstanceData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInteractionIndicatorInstanceData::operator==(const SInteractionIndicatorInstanceData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInteractionIndicatorInstanceData>)
		return false;

	if (m_eState != p_Other.m_eState) return false;
	if (m_nIconId != p_Other.m_nIconId) return false;
	if (m_eTypeId != p_Other.m_eTypeId) return false;
	if (m_fProgress != p_Other.m_fProgress) return false;
	if (m_sLabel != p_Other.m_sLabel) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_sGlyph != p_Other.m_sGlyph) return false;
	if (m_fAnimation != p_Other.m_fAnimation) return false;
	if (m_bIllegal != p_Other.m_bIllegal) return false;
	if (m_bNoActionAvailable != p_Other.m_bNoActionAvailable) return false;
	if (m_bInRange != p_Other.m_bInRange) return false;
	if (m_bIllegalItem != p_Other.m_bIllegalItem) return false;
	if (m_bSuspiciousItem != p_Other.m_bSuspiciousItem) return false;
	if (m_bRotateIndicator != p_Other.m_bRotateIndicator) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_bNeedDataUpdate != p_Other.m_bNeedDataUpdate) return false;

	return true;
}

ZHMTypeInfo SInteractionIndicatorInstanceDataArray_Dummy::TypeInfo = ZHMTypeInfo("SInteractionIndicatorInstanceDataArray_Dummy", sizeof(SInteractionIndicatorInstanceDataArray_Dummy), alignof(SInteractionIndicatorInstanceDataArray_Dummy), SInteractionIndicatorInstanceDataArray_Dummy::WriteJson, SInteractionIndicatorInstanceDataArray_Dummy::WriteSimpleJson, SInteractionIndicatorInstanceDataArray_Dummy::FromSimpleJson, SInteractionIndicatorInstanceDataArray_Dummy::Serialize, SInteractionIndicatorInstanceDataArray_Dummy::Equals);

void SInteractionIndicatorInstanceDataArray_Dummy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SInteractionIndicatorInstanceData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SInteractionIndicatorInstanceData") << ",\"$val\":";
		SInteractionIndicatorInstanceData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SInteractionIndicatorInstanceDataArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SInteractionIndicatorInstanceData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInteractionIndicatorInstanceDataArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInteractionIndicatorInstanceDataArray_Dummy s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["dummy"])
	{
		SInteractionIndicatorInstanceData s_ArrayItem0;
		SInteractionIndicatorInstanceData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Target) = s_Object;
}

void SInteractionIndicatorInstanceDataArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);

	TArray<SInteractionIndicatorInstanceData>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceDataArray_Dummy, dummy));
}

bool SInteractionIndicatorInstanceDataArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInteractionIndicatorInstanceDataArray_Dummy::operator==(const SInteractionIndicatorInstanceDataArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInteractionIndicatorInstanceDataArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

ZHMTypeInfo SInventoryControllerItemSaveData::TypeInfo = ZHMTypeInfo("SInventoryControllerItemSaveData", sizeof(SInventoryControllerItemSaveData), alignof(SInventoryControllerItemSaveData), SInventoryControllerItemSaveData::WriteJson, SInventoryControllerItemSaveData::WriteSimpleJson, SInventoryControllerItemSaveData::FromSimpleJson, SInventoryControllerItemSaveData::Serialize, SInventoryControllerItemSaveData::Equals);

void SInventoryControllerItemSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rItemEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItemEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmo") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmo);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fShootingBalletCooldown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fShootingBalletCooldown);
	p_Stream << "}";

	p_Stream << "}";
}

void SInventoryControllerItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItemEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItemEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fShootingBalletCooldown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fShootingBalletCooldown);

	p_Stream << "}";
}

void SInventoryControllerItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryControllerItemSaveData s_Object {};

	s_Object.m_rItemEntity = simdjson::from_json_uint32(p_Document["m_rItemEntity"]);

	s_Object.m_nAmmo = simdjson::from_json_uint32(p_Document["m_nAmmo"]);

	s_Object.m_fShootingBalletCooldown = simdjson::from_json_float32(p_Document["m_fShootingBalletCooldown"]);

	*reinterpret_cast<SInventoryControllerItemSaveData*>(p_Target) = s_Object;
}

void SInventoryControllerItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);

}

bool SInventoryControllerItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryControllerItemSaveData::operator==(const SInventoryControllerItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryControllerItemSaveData>)
		return false;

	if (m_rItemEntity != p_Other.m_rItemEntity) return false;
	if (m_nAmmo != p_Other.m_nAmmo) return false;
	if (m_fShootingBalletCooldown != p_Other.m_fShootingBalletCooldown) return false;

	return true;
}

ZHMTypeInfo SStoredSlotSaveData::TypeInfo = ZHMTypeInfo("SStoredSlotSaveData", sizeof(SStoredSlotSaveData), alignof(SStoredSlotSaveData), SStoredSlotSaveData::WriteJson, SStoredSlotSaveData::WriteSimpleJson, SStoredSlotSaveData::FromSimpleJson, SStoredSlotSaveData::Serialize, SStoredSlotSaveData::Equals);

void SStoredSlotSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iStoredInventorySlotIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iStoredInventorySlotIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iStoreReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iStoreReason);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItemsStored") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemsStored);
	p_Stream << "}";

	p_Stream << "}";
}

void SStoredSlotSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iStoredInventorySlotIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iStoredInventorySlotIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iStoreReason") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iStoreReason);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItemsStored") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemsStored);

	p_Stream << "}";
}

void SStoredSlotSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStoredSlotSaveData s_Object {};

	s_Object.m_iStoredInventorySlotIndex = simdjson::from_json_uint32(p_Document["m_iStoredInventorySlotIndex"]);

	s_Object.m_iStoreReason = simdjson::from_json_uint8(p_Document["m_iStoreReason"]);

	s_Object.m_bItemsStored = simdjson::from_json_bool(p_Document["m_bItemsStored"]);

	*reinterpret_cast<SStoredSlotSaveData*>(p_Target) = s_Object;
}

void SStoredSlotSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);

}

bool SStoredSlotSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStoredSlotSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStoredSlotSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStoredSlotSaveData::operator==(const SStoredSlotSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStoredSlotSaveData>)
		return false;

	if (m_iStoredInventorySlotIndex != p_Other.m_iStoredInventorySlotIndex) return false;
	if (m_iStoreReason != p_Other.m_iStoreReason) return false;
	if (m_bItemsStored != p_Other.m_bItemsStored) return false;

	return true;
}

ZHMTypeInfo SInventoryControllerSaveData::TypeInfo = ZHMTypeInfo("SInventoryControllerSaveData", sizeof(SInventoryControllerSaveData), alignof(SInventoryControllerSaveData), SInventoryControllerSaveData::WriteJson, SInventoryControllerSaveData::WriteSimpleJson, SInventoryControllerSaveData::FromSimpleJson, SInventoryControllerSaveData::Serialize, SInventoryControllerSaveData::Equals);

void SInventoryControllerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SInventoryControllerItemSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SInventoryControllerItemSaveData") << ",\"$val\":";
		SInventoryControllerItemSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEquippedItemIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEquippedItemIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMostRecentItemIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMostRecentItemIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StoredSlot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SStoredSlotSaveData") << ",\"$val\":";
	SStoredSlotSaveData::WriteJson(&s_Object->m_StoredSlot, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountGun") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountGun);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRevolver") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRevolver);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountSMG") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountSMG);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRifle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRifle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountShotgun") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountShotgun);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountSniper") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountSniper);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountMG") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountMG);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRPG") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRPG);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountFake") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountFake);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountLightPistol") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountLightPistol);
	p_Stream << "}";

	p_Stream << "}";
}

void SInventoryControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		SInventoryControllerItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEquippedItemIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEquippedItemIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMostRecentItemIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMostRecentItemIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StoredSlot") << ":";
	SStoredSlotSaveData::WriteSimpleJson(&s_Object->m_StoredSlot, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountGun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountGun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRevolver") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRevolver);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountSMG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountSMG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRifle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRifle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountShotgun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountShotgun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountSniper") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountSniper);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountMG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountMG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRPG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRPG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountFake") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountFake);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountLightPistol") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountLightPistol);

	p_Stream << "}";
}

void SInventoryControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryControllerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aItems"])
	{
		SInventoryControllerItemSaveData s_ArrayItem0;
		SInventoryControllerItemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItems.push_back(s_ArrayItem0);
	}

	s_Object.m_nEquippedItemIndex = simdjson::from_json_uint32(p_Document["m_nEquippedItemIndex"]);

	s_Object.m_nMostRecentItemIndex = simdjson::from_json_uint32(p_Document["m_nMostRecentItemIndex"]);

	{
		SStoredSlotSaveData s_Item {};
		SStoredSlotSaveData::FromSimpleJson(p_Document["m_StoredSlot"], &s_Item);
		s_Object.m_StoredSlot = s_Item;
	}

	s_Object.m_nAmmoCountGun = simdjson::from_json_uint32(p_Document["m_nAmmoCountGun"]);

	s_Object.m_nAmmoCountRevolver = simdjson::from_json_uint32(p_Document["m_nAmmoCountRevolver"]);

	s_Object.m_nAmmoCountSMG = simdjson::from_json_uint32(p_Document["m_nAmmoCountSMG"]);

	s_Object.m_nAmmoCountRifle = simdjson::from_json_uint32(p_Document["m_nAmmoCountRifle"]);

	s_Object.m_nAmmoCountShotgun = simdjson::from_json_uint32(p_Document["m_nAmmoCountShotgun"]);

	s_Object.m_nAmmoCountSniper = simdjson::from_json_uint32(p_Document["m_nAmmoCountSniper"]);

	s_Object.m_nAmmoCountMG = simdjson::from_json_uint32(p_Document["m_nAmmoCountMG"]);

	s_Object.m_nAmmoCountRPG = simdjson::from_json_uint32(p_Document["m_nAmmoCountRPG"]);

	s_Object.m_nAmmoCountFake = simdjson::from_json_uint32(p_Document["m_nAmmoCountFake"]);

	s_Object.m_nAmmoCountLightPistol = simdjson::from_json_uint32(p_Document["m_nAmmoCountLightPistol"]);

	*reinterpret_cast<SInventoryControllerSaveData*>(p_Target) = s_Object;
}

void SInventoryControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);

	TArray<SInventoryControllerItemSaveData>::Serialize(&s_Object->m_aItems, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_aItems));
	SStoredSlotSaveData::Serialize(&s_Object->m_StoredSlot, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_StoredSlot));
}

bool SInventoryControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryControllerSaveData::operator==(const SInventoryControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryControllerSaveData>)
		return false;

	if (m_aItems != p_Other.m_aItems) return false;
	if (m_nEquippedItemIndex != p_Other.m_nEquippedItemIndex) return false;
	if (m_nMostRecentItemIndex != p_Other.m_nMostRecentItemIndex) return false;
	if (m_StoredSlot != p_Other.m_StoredSlot) return false;
	if (m_nAmmoCountGun != p_Other.m_nAmmoCountGun) return false;
	if (m_nAmmoCountRevolver != p_Other.m_nAmmoCountRevolver) return false;
	if (m_nAmmoCountSMG != p_Other.m_nAmmoCountSMG) return false;
	if (m_nAmmoCountRifle != p_Other.m_nAmmoCountRifle) return false;
	if (m_nAmmoCountShotgun != p_Other.m_nAmmoCountShotgun) return false;
	if (m_nAmmoCountSniper != p_Other.m_nAmmoCountSniper) return false;
	if (m_nAmmoCountMG != p_Other.m_nAmmoCountMG) return false;
	if (m_nAmmoCountRPG != p_Other.m_nAmmoCountRPG) return false;
	if (m_nAmmoCountFake != p_Other.m_nAmmoCountFake) return false;
	if (m_nAmmoCountLightPistol != p_Other.m_nAmmoCountLightPistol) return false;

	return true;
}

ZHMTypeInfo SInventoryItem::TypeInfo = ZHMTypeInfo("SInventoryItem", sizeof(SInventoryItem), alignof(SInventoryItem), SInventoryItem::WriteJson, SInventoryItem::WriteSimpleJson, SInventoryItem::FromSimpleJson, SInventoryItem::Serialize, SInventoryItem::Equals);

void SInventoryItem::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryItem*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sInstanceId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sInstanceId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sUnlockableId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sUnlockableId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repositoryId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->repositoryId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aRepositoryAssetIds") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZRepositoryID>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aRepositoryAssetIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->aRepositoryAssetIds[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
		ZRepositoryID::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->aRepositoryAssetIds.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aModifierIds") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZRepositoryID>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->aModifierIds[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
		ZRepositoryID::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->aModifierIds.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SInventoryItem::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryItem*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sInstanceId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sInstanceId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sUnlockableId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sUnlockableId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repositoryId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->repositoryId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aRepositoryAssetIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aRepositoryAssetIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->aRepositoryAssetIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aRepositoryAssetIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aModifierIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->aModifierIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aModifierIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInventoryItem::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryItem s_Object {};

	s_Object.sInstanceId = std::string_view(p_Document["sInstanceId"]);

	s_Object.sUnlockableId = std::string_view(p_Document["sUnlockableId"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["repositoryId"], &s_Item);
		s_Object.repositoryId = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["aRepositoryAssetIds"])
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aRepositoryAssetIds.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["aModifierIds"])
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aModifierIds.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SInventoryItem*>(p_Target) = s_Object;
}

void SInventoryItem::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryItem*>(p_Object);

	ZString::Serialize(&s_Object->sInstanceId, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, sInstanceId));
	ZString::Serialize(&s_Object->sUnlockableId, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, sUnlockableId));
	ZRepositoryID::Serialize(&s_Object->repositoryId, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, repositoryId));
	TArray<ZRepositoryID>::Serialize(&s_Object->aRepositoryAssetIds, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, aRepositoryAssetIds));
	TArray<ZRepositoryID>::Serialize(&s_Object->aModifierIds, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, aModifierIds));
}

bool SInventoryItem::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryItem*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryItem*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryItem::operator==(const SInventoryItem& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryItem>)
		return false;

	if (sInstanceId != p_Other.sInstanceId) return false;
	if (sUnlockableId != p_Other.sUnlockableId) return false;
	if (repositoryId != p_Other.repositoryId) return false;
	if (aRepositoryAssetIds != p_Other.aRepositoryAssetIds) return false;
	if (aModifierIds != p_Other.aModifierIds) return false;

	return true;
}

ZHMTypeInfo SInventoryInfo::TypeInfo = ZHMTypeInfo("SInventoryInfo", sizeof(SInventoryInfo), alignof(SInventoryInfo), SInventoryInfo::WriteJson, SInventoryInfo::WriteSimpleJson, SInventoryInfo::FromSimpleJson, SInventoryInfo::Serialize, SInventoryInfo::Equals);

void SInventoryInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aPockets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SInventoryItem>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPockets.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPockets[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SInventoryItem") << ",\"$val\":";
		SInventoryItem::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aPockets.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CarriedItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SInventoryItem") << ",\"$val\":";
	SInventoryItem::WriteJson(&s_Object->m_CarriedItem, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SInventoryInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aPockets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPockets.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPockets[i];
		SInventoryItem::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPockets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CarriedItem") << ":";
	SInventoryItem::WriteSimpleJson(&s_Object->m_CarriedItem, p_Stream);

	p_Stream << "}";
}

void SInventoryInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryInfo s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aPockets"])
	{
		SInventoryItem s_ArrayItem0;
		SInventoryItem::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aPockets.push_back(s_ArrayItem0);
	}

	{
		SInventoryItem s_Item {};
		SInventoryItem::FromSimpleJson(p_Document["m_CarriedItem"], &s_Item);
		s_Object.m_CarriedItem = s_Item;
	}

	*reinterpret_cast<SInventoryInfo*>(p_Target) = s_Object;
}

void SInventoryInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryInfo*>(p_Object);

	TArray<SInventoryItem>::Serialize(&s_Object->m_aPockets, p_Serializer, p_OwnOffset + offsetof(SInventoryInfo, m_aPockets));
	SInventoryItem::Serialize(&s_Object->m_CarriedItem, p_Serializer, p_OwnOffset + offsetof(SInventoryInfo, m_CarriedItem));
}

bool SInventoryInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryInfo::operator==(const SInventoryInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryInfo>)
		return false;

	if (m_aPockets != p_Other.m_aPockets) return false;
	if (m_CarriedItem != p_Other.m_CarriedItem) return false;

	return true;
}

ZHMTypeInfo SInventoryUISlot::TypeInfo = ZHMTypeInfo("SInventoryUISlot", sizeof(SInventoryUISlot), alignof(SInventoryUISlot), SInventoryUISlot::WriteJson, SInventoryUISlot::WriteSimpleJson, SInventoryUISlot::FromSimpleJson, SInventoryUISlot::Serialize, SInventoryUISlot::Equals);

void SInventoryUISlot::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlot*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->icon, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedIcon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->containedIcon, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedLabel") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->containedLabel);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("description") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->description);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("perks") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->perks.size(); ++i)
	{
		auto& s_Item0 = s_Object->perks[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->perks.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("silencer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->silencer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("count") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->count);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ammo") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->ammo);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("id") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->id, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("weaponCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->weaponCategory);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategory);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategoryLKey") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategoryLKey);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedItemCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->containedItemCategory);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedItemCategoryLKey") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->containedItemCategoryLKey);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inventoryCategoryIcon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->inventoryCategoryIcon);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isDroppable") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->isDroppable);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("detectedDuringFrisk") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->detectedDuringFrisk);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("actionAndKillTypes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->actionAndKillTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->actionAndKillTypes[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->actionAndKillTypes.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("suspicious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->suspicious);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("illegal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->illegal);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("canReload") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->canReload);
	p_Stream << "}";

	p_Stream << "}";
}

void SInventoryUISlot::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlot*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedIcon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->containedIcon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->containedLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("description") << ":";
	p_Stream << simdjson::as_json_string(s_Object->description);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("perks") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->perks.size(); ++i)
	{
		auto& s_Item0 = s_Object->perks[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->perks.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("silencer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->silencer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("count") << ":";
	p_Stream << simdjson::as_json_string(s_Object->count);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ammo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ammo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("id") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("weaponCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->weaponCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategoryLKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategoryLKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedItemCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->containedItemCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedItemCategoryLKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->containedItemCategoryLKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inventoryCategoryIcon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->inventoryCategoryIcon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isDroppable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isDroppable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("detectedDuringFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->detectedDuringFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("actionAndKillTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->actionAndKillTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->actionAndKillTypes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->actionAndKillTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("suspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->suspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("illegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->illegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("canReload") << ":";
	p_Stream << simdjson::as_json_string(s_Object->canReload);

	p_Stream << "}";
}

void SInventoryUISlot::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryUISlot s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["containedIcon"], &s_Item);
		s_Object.containedIcon = s_Item;
	}

	s_Object.label = std::string_view(p_Document["label"]);

	s_Object.containedLabel = std::string_view(p_Document["containedLabel"]);

	s_Object.description = std::string_view(p_Document["description"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["perks"])
	{
		s_Object.perks.push_back(std::string_view(s_Item0));
	}

	s_Object.silencer = simdjson::from_json_bool(p_Document["silencer"]);

	s_Object.count = simdjson::from_json_int32(p_Document["count"]);

	s_Object.ammo = simdjson::from_json_int32(p_Document["ammo"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["id"], &s_Item);
		s_Object.id = s_Item;
	}

	s_Object.weaponCategory = std::string_view(p_Document["weaponCategory"]);

	s_Object.nAmmoRemaining = simdjson::from_json_int32(p_Document["nAmmoRemaining"]);

	s_Object.nAmmoTotal = simdjson::from_json_int32(p_Document["nAmmoTotal"]);

	s_Object.nAmmoInClip = simdjson::from_json_int32(p_Document["nAmmoInClip"]);

	s_Object.nWeaponType = simdjson::from_json_int32(p_Document["nWeaponType"]);

	s_Object.itemCategory = std::string_view(p_Document["itemCategory"]);

	s_Object.itemCategoryLKey = std::string_view(p_Document["itemCategoryLKey"]);

	s_Object.containedItemCategory = std::string_view(p_Document["containedItemCategory"]);

	s_Object.containedItemCategoryLKey = std::string_view(p_Document["containedItemCategoryLKey"]);

	s_Object.inventoryCategoryIcon = std::string_view(p_Document["inventoryCategoryIcon"]);

	s_Object.isDroppable = simdjson::from_json_bool(p_Document["isDroppable"]);

	s_Object.detectedDuringFrisk = simdjson::from_json_bool(p_Document["detectedDuringFrisk"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["actionAndKillTypes"])
	{
		s_Object.actionAndKillTypes.push_back(std::string_view(s_Item0));
	}

	s_Object.suspicious = simdjson::from_json_bool(p_Document["suspicious"]);

	s_Object.illegal = simdjson::from_json_bool(p_Document["illegal"]);

	s_Object.canReload = simdjson::from_json_bool(p_Document["canReload"]);

	*reinterpret_cast<SInventoryUISlot*>(p_Target) = s_Object;
}

void SInventoryUISlot::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlot*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, icon));
	ZRuntimeResourceID::Serialize(&s_Object->containedIcon, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, containedIcon));
	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, label));
	ZString::Serialize(&s_Object->containedLabel, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, containedLabel));
	ZString::Serialize(&s_Object->description, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, description));
	TArray<ZString>::Serialize(&s_Object->perks, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, perks));
	ZRepositoryID::Serialize(&s_Object->id, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, id));
	ZString::Serialize(&s_Object->weaponCategory, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, weaponCategory));
	ZString::Serialize(&s_Object->itemCategory, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, itemCategory));
	ZString::Serialize(&s_Object->itemCategoryLKey, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, itemCategoryLKey));
	ZString::Serialize(&s_Object->containedItemCategory, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, containedItemCategory));
	ZString::Serialize(&s_Object->containedItemCategoryLKey, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, containedItemCategoryLKey));
	ZString::Serialize(&s_Object->inventoryCategoryIcon, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, inventoryCategoryIcon));
	TArray<ZString>::Serialize(&s_Object->actionAndKillTypes, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, actionAndKillTypes));
}

bool SInventoryUISlot::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryUISlot*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryUISlot*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryUISlot::operator==(const SInventoryUISlot& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryUISlot>)
		return false;

	if (icon != p_Other.icon) return false;
	if (containedIcon != p_Other.containedIcon) return false;
	if (label != p_Other.label) return false;
	if (containedLabel != p_Other.containedLabel) return false;
	if (description != p_Other.description) return false;
	if (perks != p_Other.perks) return false;
	if (silencer != p_Other.silencer) return false;
	if (count != p_Other.count) return false;
	if (ammo != p_Other.ammo) return false;
	if (id != p_Other.id) return false;
	if (weaponCategory != p_Other.weaponCategory) return false;
	if (nAmmoRemaining != p_Other.nAmmoRemaining) return false;
	if (nAmmoTotal != p_Other.nAmmoTotal) return false;
	if (nAmmoInClip != p_Other.nAmmoInClip) return false;
	if (nWeaponType != p_Other.nWeaponType) return false;
	if (itemCategory != p_Other.itemCategory) return false;
	if (itemCategoryLKey != p_Other.itemCategoryLKey) return false;
	if (containedItemCategory != p_Other.containedItemCategory) return false;
	if (containedItemCategoryLKey != p_Other.containedItemCategoryLKey) return false;
	if (inventoryCategoryIcon != p_Other.inventoryCategoryIcon) return false;
	if (isDroppable != p_Other.isDroppable) return false;
	if (detectedDuringFrisk != p_Other.detectedDuringFrisk) return false;
	if (actionAndKillTypes != p_Other.actionAndKillTypes) return false;
	if (suspicious != p_Other.suspicious) return false;
	if (illegal != p_Other.illegal) return false;
	if (canReload != p_Other.canReload) return false;

	return true;
}

ZHMTypeInfo SInventoryUI::TypeInfo = ZHMTypeInfo("SInventoryUI", sizeof(SInventoryUI), alignof(SInventoryUI), SInventoryUI::WriteJson, SInventoryUI::WriteSimpleJson, SInventoryUI::FromSimpleJson, SInventoryUI::Serialize, SInventoryUI::Equals);

void SInventoryUI::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryUI*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("mainslots") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SInventoryUISlot>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslots[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SInventoryUISlot") << ",\"$val\":";
		SInventoryUISlot::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->mainslots.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslots") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SInventoryUISlot>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->otherslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->otherslots[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SInventoryUISlot") << ",\"$val\":";
		SInventoryUISlot::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->otherslots.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selectedIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->selectedIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isActionInventory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->isActionInventory);
	p_Stream << "}";

	p_Stream << "}";
}

void SInventoryUI::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryUI*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mainslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslots[i];
		SInventoryUISlot::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->mainslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->otherslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->otherslots[i];
		SInventoryUISlot::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->otherslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selectedIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->selectedIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isActionInventory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isActionInventory);

	p_Stream << "}";
}

void SInventoryUI::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryUI s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["mainslots"])
	{
		SInventoryUISlot s_ArrayItem0;
		SInventoryUISlot::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.mainslots.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["otherslots"])
	{
		SInventoryUISlot s_ArrayItem0;
		SInventoryUISlot::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.otherslots.push_back(s_ArrayItem0);
	}

	s_Object.selectedIndex = simdjson::from_json_int32(p_Document["selectedIndex"]);

	s_Object.isActionInventory = simdjson::from_json_bool(p_Document["isActionInventory"]);

	*reinterpret_cast<SInventoryUI*>(p_Target) = s_Object;
}

void SInventoryUI::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryUI*>(p_Object);

	TArray<SInventoryUISlot>::Serialize(&s_Object->mainslots, p_Serializer, p_OwnOffset + offsetof(SInventoryUI, mainslots));
	TArray<SInventoryUISlot>::Serialize(&s_Object->otherslots, p_Serializer, p_OwnOffset + offsetof(SInventoryUI, otherslots));
}

bool SInventoryUI::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryUI*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryUI*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryUI::operator==(const SInventoryUI& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryUI>)
		return false;

	if (mainslots != p_Other.mainslots) return false;
	if (otherslots != p_Other.otherslots) return false;
	if (selectedIndex != p_Other.selectedIndex) return false;
	if (isActionInventory != p_Other.isActionInventory) return false;

	return true;
}

ZHMTypeInfo ZInvestigateDisguiseGroup_SDialogLines::TypeInfo = ZHMTypeInfo("ZInvestigateDisguiseGroup.SDialogLines", sizeof(ZInvestigateDisguiseGroup_SDialogLines), alignof(ZInvestigateDisguiseGroup_SDialogLines), ZInvestigateDisguiseGroup_SDialogLines::WriteJson, ZInvestigateDisguiseGroup_SDialogLines::WriteSimpleJson, ZInvestigateDisguiseGroup_SDialogLines::FromSimpleJson, ZInvestigateDisguiseGroup_SDialogLines::Serialize, ZInvestigateDisguiseGroup_SDialogLines::Equals);

void ZInvestigateDisguiseGroup_SDialogLines::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eFirstWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSoundDefs.EDefinition") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eFirstWarning)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eFirstWarning))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSecondWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSoundDefs.EDefinition") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSecondWarning)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eSecondWarning))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eThirdWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSoundDefs.EDefinition") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eThirdWarning)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eThirdWarning))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZInvestigateDisguiseGroup_SDialogLines::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFirstWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eFirstWarning)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSecondWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eSecondWarning)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eThirdWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eThirdWarning)));

	p_Stream << "}";
}

void ZInvestigateDisguiseGroup_SDialogLines::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInvestigateDisguiseGroup_SDialogLines s_Object {};

	s_Object.m_eFirstWarning = static_cast<SActorSoundDefs_EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_eFirstWarning"])));

	s_Object.m_eSecondWarning = static_cast<SActorSoundDefs_EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_eSecondWarning"])));

	s_Object.m_eThirdWarning = static_cast<SActorSoundDefs_EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_eThirdWarning"])));

	*reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Target) = s_Object;
}

void ZInvestigateDisguiseGroup_SDialogLines::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Object);

}

bool ZInvestigateDisguiseGroup_SDialogLines::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateDisguiseGroup_SDialogLines::operator==(const ZInvestigateDisguiseGroup_SDialogLines& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateDisguiseGroup_SDialogLines>)
		return false;

	if (m_eFirstWarning != p_Other.m_eFirstWarning) return false;
	if (m_eSecondWarning != p_Other.m_eSecondWarning) return false;
	if (m_eThirdWarning != p_Other.m_eThirdWarning) return false;

	return true;
}

ZHMTypeInfo SInvestigateDisguiseGroupSaveData::TypeInfo = ZHMTypeInfo("SInvestigateDisguiseGroupSaveData", sizeof(SInvestigateDisguiseGroupSaveData), alignof(SInvestigateDisguiseGroupSaveData), SInvestigateDisguiseGroupSaveData::WriteJson, SInvestigateDisguiseGroupSaveData::WriteSimpleJson, SInvestigateDisguiseGroupSaveData::FromSimpleJson, SInvestigateDisguiseGroupSaveData::Serialize, SInvestigateDisguiseGroupSaveData::Equals);

void SInvestigateDisguiseGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInvestigateDisguiseGroup.EState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_state)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateDisguiseGroup.EState", static_cast<int>(s_Object->m_state))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pPendingLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pPendingLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStart, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_groupAge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_groupAge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDisguiseFollowTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDisguiseFollowTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetRunningTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetRunningTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastWarning, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iWarningCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iWarningCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eLeaderMoveSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZMoveToOrder.EMoveSpeed") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eLeaderMoveSpeed)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZMoveToOrder.EMoveSpeed", static_cast<int>(s_Object->m_eLeaderMoveSpeed))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDownOrder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastStandDownOrder, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartFollow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStartFollow, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginalPositionLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vOriginalPositionLeader, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_dialogLines") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInvestigateDisguiseGroup.SDialogLines") << ",\"$val\":";
	ZInvestigateDisguiseGroup_SDialogLines::WriteJson(&s_Object->m_dialogLines, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderOrderAssigned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderOrderAssigned);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSearchCompleted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchCompleted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderMovingBack") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderMovingBack);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitingForDistanceStanddown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitingForDistanceStanddown);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFollow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFollow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMembersFollow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMembersFollow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunningWarningIssued") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunningWarningIssued);
	p_Stream << "}";

	p_Stream << "}";
}

void SInvestigateDisguiseGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateDisguiseGroup.EState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pPendingLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pPendingLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_groupAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_groupAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDisguiseFollowTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDisguiseFollowTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWarning") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastWarning, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eLeaderMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZMoveToOrder.EMoveSpeed", static_cast<int>(s_Object->m_eLeaderMoveSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDownOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastStandDownOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartFollow") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartFollow, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginalPositionLeader") << ":";
	float4::WriteSimpleJson(&s_Object->m_vOriginalPositionLeader, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_dialogLines") << ":";
	ZInvestigateDisguiseGroup_SDialogLines::WriteSimpleJson(&s_Object->m_dialogLines, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSearchCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderMovingBack") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderMovingBack);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitingForDistanceStanddown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitingForDistanceStanddown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFollow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFollow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMembersFollow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMembersFollow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunningWarningIssued") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunningWarningIssued);

	p_Stream << "}";
}

void SInvestigateDisguiseGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInvestigateDisguiseGroupSaveData s_Object {};

	s_Object.m_state = static_cast<ZInvestigateDisguiseGroup_EState>(ZHMEnums::GetEnumValueByName("ZInvestigateDisguiseGroup.EState", std::string_view(p_Document["m_state"])));

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pPendingLeader = simdjson::from_json_uint32(p_Document["m_pPendingLeader"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Item);
		s_Object.m_tStart = s_Item;
	}

	s_Object.m_groupAge = simdjson::from_json_float32(p_Document["m_groupAge"]);

	s_Object.m_fDisguiseFollowTime = simdjson::from_json_float32(p_Document["m_fDisguiseFollowTime"]);

	s_Object.m_fTargetRunningTime = simdjson::from_json_float32(p_Document["m_fTargetRunningTime"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastWarning"], &s_Item);
		s_Object.m_tLastWarning = s_Item;
	}

	s_Object.m_iWarningCount = simdjson::from_json_int32(p_Document["m_iWarningCount"]);

	s_Object.m_eLeaderMoveSpeed = static_cast<ZMoveToOrder_EMoveSpeed>(ZHMEnums::GetEnumValueByName("ZMoveToOrder.EMoveSpeed", std::string_view(p_Document["m_eLeaderMoveSpeed"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Item);
		s_Object.m_tLastEscalateOrder = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastStandDownOrder"], &s_Item);
		s_Object.m_tLastStandDownOrder = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStartFollow"], &s_Item);
		s_Object.m_tStartFollow = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vOriginalPositionLeader"], &s_Item);
		s_Object.m_vOriginalPositionLeader = s_Item;
	}

	{
		ZInvestigateDisguiseGroup_SDialogLines s_Item {};
		ZInvestigateDisguiseGroup_SDialogLines::FromSimpleJson(p_Document["m_dialogLines"], &s_Item);
		s_Object.m_dialogLines = s_Item;
	}

	s_Object.m_bLeaderOrderAssigned = simdjson::from_json_bool(p_Document["m_bLeaderOrderAssigned"]);

	s_Object.m_bSearchCompleted = simdjson::from_json_bool(p_Document["m_bSearchCompleted"]);

	s_Object.m_bLeaderMovingBack = simdjson::from_json_bool(p_Document["m_bLeaderMovingBack"]);

	s_Object.m_bWaitingForDistanceStanddown = simdjson::from_json_bool(p_Document["m_bWaitingForDistanceStanddown"]);

	s_Object.m_bFollow = simdjson::from_json_bool(p_Document["m_bFollow"]);

	s_Object.m_bMembersFollow = simdjson::from_json_bool(p_Document["m_bMembersFollow"]);

	s_Object.m_bRunningWarningIssued = simdjson::from_json_bool(p_Document["m_bRunningWarningIssued"]);

	*reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Target) = s_Object;
}

void SInvestigateDisguiseGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tStart));
	ZGameTime::Serialize(&s_Object->m_tLastWarning, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastWarning));
	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastEscalateOrder));
	ZGameTime::Serialize(&s_Object->m_tLastStandDownOrder, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastStandDownOrder));
	ZGameTime::Serialize(&s_Object->m_tStartFollow, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tStartFollow));
	float4::Serialize(&s_Object->m_vOriginalPositionLeader, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_vOriginalPositionLeader));
	ZInvestigateDisguiseGroup_SDialogLines::Serialize(&s_Object->m_dialogLines, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_dialogLines));
}

bool SInvestigateDisguiseGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInvestigateDisguiseGroupSaveData::operator==(const SInvestigateDisguiseGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInvestigateDisguiseGroupSaveData>)
		return false;

	if (m_state != p_Other.m_state) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pPendingLeader != p_Other.m_pPendingLeader) return false;
	if (m_tStart != p_Other.m_tStart) return false;
	if (m_groupAge != p_Other.m_groupAge) return false;
	if (m_fDisguiseFollowTime != p_Other.m_fDisguiseFollowTime) return false;
	if (m_fTargetRunningTime != p_Other.m_fTargetRunningTime) return false;
	if (m_tLastWarning != p_Other.m_tLastWarning) return false;
	if (m_iWarningCount != p_Other.m_iWarningCount) return false;
	if (m_eLeaderMoveSpeed != p_Other.m_eLeaderMoveSpeed) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_tLastStandDownOrder != p_Other.m_tLastStandDownOrder) return false;
	if (m_tStartFollow != p_Other.m_tStartFollow) return false;
	if (m_vOriginalPositionLeader != p_Other.m_vOriginalPositionLeader) return false;
	if (m_dialogLines != p_Other.m_dialogLines) return false;
	if (m_bLeaderOrderAssigned != p_Other.m_bLeaderOrderAssigned) return false;
	if (m_bSearchCompleted != p_Other.m_bSearchCompleted) return false;
	if (m_bLeaderMovingBack != p_Other.m_bLeaderMovingBack) return false;
	if (m_bWaitingForDistanceStanddown != p_Other.m_bWaitingForDistanceStanddown) return false;
	if (m_bFollow != p_Other.m_bFollow) return false;
	if (m_bMembersFollow != p_Other.m_bMembersFollow) return false;
	if (m_bRunningWarningIssued != p_Other.m_bRunningWarningIssued) return false;

	return true;
}

ZHMTypeInfo SInvestigateWeaponGroupSaveData::TypeInfo = ZHMTypeInfo("SInvestigateWeaponGroupSaveData", sizeof(SInvestigateWeaponGroupSaveData), alignof(SInvestigateWeaponGroupSaveData), SInvestigateWeaponGroupSaveData::WriteJson, SInvestigateWeaponGroupSaveData::WriteSimpleJson, SInvestigateWeaponGroupSaveData::FromSimpleJson, SInvestigateWeaponGroupSaveData::Serialize, SInvestigateWeaponGroupSaveData::Equals);

void SInvestigateWeaponGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rReporter") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rReporter);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInvestigator") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInvestigator);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rGuard") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rGuard);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastGuardSearch") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastGuardSearch, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aUnconsciousGuards") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aUnconsciousGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aUnconsciousGuards[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aUnconsciousGuards.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SInvestigateWeaponGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rReporter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rReporter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInvestigator") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInvestigator);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastGuardSearch") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastGuardSearch, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aUnconsciousGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aUnconsciousGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aUnconsciousGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aUnconsciousGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInvestigateWeaponGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInvestigateWeaponGroupSaveData s_Object {};

	s_Object.m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object.m_rReporter = simdjson::from_json_uint32(p_Document["m_rReporter"]);

	s_Object.m_rInvestigator = simdjson::from_json_uint32(p_Document["m_rInvestigator"]);

	s_Object.m_rGuard = simdjson::from_json_uint32(p_Document["m_rGuard"]);

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastGuardSearch"], &s_Item);
		s_Object.m_tLastGuardSearch = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aUnconsciousGuards"])
	{
		s_Object.m_aUnconsciousGuards.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Target) = s_Object;
}

void SInvestigateWeaponGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tLastGuardSearch, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_tLastGuardSearch));
	TArray<uint32>::Serialize(&s_Object->m_aUnconsciousGuards, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_aUnconsciousGuards));
}

bool SInvestigateWeaponGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInvestigateWeaponGroupSaveData::operator==(const SInvestigateWeaponGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInvestigateWeaponGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_rReporter != p_Other.m_rReporter) return false;
	if (m_rInvestigator != p_Other.m_rInvestigator) return false;
	if (m_rGuard != p_Other.m_rGuard) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tLastGuardSearch != p_Other.m_tLastGuardSearch) return false;
	if (m_aUnconsciousGuards != p_Other.m_aUnconsciousGuards) return false;

	return true;
}

ZHMTypeInfo SItemInstanceSaveData::TypeInfo = ZHMTypeInfo("SItemInstanceSaveData", sizeof(SItemInstanceSaveData), alignof(SItemInstanceSaveData), SItemInstanceSaveData::WriteJson, SItemInstanceSaveData::WriteSimpleJson, SItemInstanceSaveData::FromSimpleJson, SItemInstanceSaveData::Serialize, SItemInstanceSaveData::Equals);

void SItemInstanceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemInstanceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_repositoryId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_repositoryId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sOnlineInstanceId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sOnlineInstanceId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aItemModifierIds") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZRepositoryID>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemModifierIds[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
		ZRepositoryID::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aItemModifierIds.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SItemInstanceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemInstanceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_repositoryId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_repositoryId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sOnlineInstanceId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sOnlineInstanceId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aItemModifierIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemModifierIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItemModifierIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemInstanceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemInstanceSaveData s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_repositoryId"], &s_Item);
		s_Object.m_repositoryId = s_Item;
	}

	s_Object.m_sOnlineInstanceId = std::string_view(p_Document["m_sOnlineInstanceId"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aItemModifierIds"])
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItemModifierIds.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SItemInstanceSaveData*>(p_Target) = s_Object;
}

void SItemInstanceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemInstanceSaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_repositoryId, p_Serializer, p_OwnOffset + offsetof(SItemInstanceSaveData, m_repositoryId));
	ZString::Serialize(&s_Object->m_sOnlineInstanceId, p_Serializer, p_OwnOffset + offsetof(SItemInstanceSaveData, m_sOnlineInstanceId));
	TArray<ZRepositoryID>::Serialize(&s_Object->m_aItemModifierIds, p_Serializer, p_OwnOffset + offsetof(SItemInstanceSaveData, m_aItemModifierIds));
}

bool SItemInstanceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemInstanceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemInstanceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemInstanceSaveData::operator==(const SItemInstanceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemInstanceSaveData>)
		return false;

	if (m_repositoryId != p_Other.m_repositoryId) return false;
	if (m_sOnlineInstanceId != p_Other.m_sOnlineInstanceId) return false;
	if (m_aItemModifierIds != p_Other.m_aItemModifierIds) return false;

	return true;
}

ZHMTypeInfo SItemOnBackUIData::TypeInfo = ZHMTypeInfo("SItemOnBackUIData", sizeof(SItemOnBackUIData), alignof(SItemOnBackUIData), SItemOnBackUIData::WriteJson, SItemOnBackUIData::WriteSimpleJson, SItemOnBackUIData::FromSimpleJson, SItemOnBackUIData::Serialize, SItemOnBackUIData::Equals);

void SItemOnBackUIData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->icon, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHasItemToShow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bHasItemToShow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSuspicious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bSuspicious);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIllegal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bIllegal);
	p_Stream << "}";

	p_Stream << "}";
}

void SItemOnBackUIData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHasItemToShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHasItemToShow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIllegal);

	p_Stream << "}";
}

void SItemOnBackUIData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemOnBackUIData s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	s_Object.bHasItemToShow = simdjson::from_json_bool(p_Document["bHasItemToShow"]);

	s_Object.bSuspicious = simdjson::from_json_bool(p_Document["bSuspicious"]);

	s_Object.bIllegal = simdjson::from_json_bool(p_Document["bIllegal"]);

	*reinterpret_cast<SItemOnBackUIData*>(p_Target) = s_Object;
}

void SItemOnBackUIData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SItemOnBackUIData, icon));
}

bool SItemOnBackUIData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemOnBackUIData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemOnBackUIData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemOnBackUIData::operator==(const SItemOnBackUIData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemOnBackUIData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (bHasItemToShow != p_Other.bHasItemToShow) return false;
	if (bSuspicious != p_Other.bSuspicious) return false;
	if (bIllegal != p_Other.bIllegal) return false;

	return true;
}

ZHMTypeInfo SItemSpawnerSaveData::TypeInfo = ZHMTypeInfo("SItemSpawnerSaveData", sizeof(SItemSpawnerSaveData), alignof(SItemSpawnerSaveData), SItemSpawnerSaveData::WriteJson, SItemSpawnerSaveData::WriteSimpleJson, SItemSpawnerSaveData::FromSimpleJson, SItemSpawnerSaveData::Serialize, SItemSpawnerSaveData::Equals);

void SItemSpawnerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bItemUpdateTransformChange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemUpdateTransformChange);
	p_Stream << "}";

	p_Stream << "}";
}

void SItemSpawnerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bItemUpdateTransformChange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemUpdateTransformChange);

	p_Stream << "}";
}

void SItemSpawnerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemSpawnerSaveData s_Object {};

	s_Object.m_bItemUpdateTransformChange = simdjson::from_json_bool(p_Document["m_bItemUpdateTransformChange"]);

	*reinterpret_cast<SItemSpawnerSaveData*>(p_Target) = s_Object;
}

void SItemSpawnerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);

}

bool SItemSpawnerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemSpawnerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemSpawnerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemSpawnerSaveData::operator==(const SItemSpawnerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemSpawnerSaveData>)
		return false;

	if (m_bItemUpdateTransformChange != p_Other.m_bItemUpdateTransformChange) return false;

	return true;
}

ZHMTypeInfo SItemStorageSaveData::TypeInfo = ZHMTypeInfo("SItemStorageSaveData", sizeof(SItemStorageSaveData), alignof(SItemStorageSaveData), SItemStorageSaveData::WriteJson, SItemStorageSaveData::WriteSimpleJson, SItemStorageSaveData::FromSimpleJson, SItemStorageSaveData::Serialize, SItemStorageSaveData::Equals);

void SItemStorageSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_ContainedItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_ContainedItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Storage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_Storage);
	p_Stream << "}";

	p_Stream << "}";
}

void SItemStorageSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ContainedItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_ContainedItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Storage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_Storage);

	p_Stream << "}";
}

void SItemStorageSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemStorageSaveData s_Object {};

	s_Object.m_ContainedItem = simdjson::from_json_uint32(p_Document["m_ContainedItem"]);

	s_Object.m_Storage = simdjson::from_json_uint32(p_Document["m_Storage"]);

	*reinterpret_cast<SItemStorageSaveData*>(p_Target) = s_Object;
}

void SItemStorageSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);

}

bool SItemStorageSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemStorageSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemStorageSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemStorageSaveData::operator==(const SItemStorageSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemStorageSaveData>)
		return false;

	if (m_ContainedItem != p_Other.m_ContainedItem) return false;
	if (m_Storage != p_Other.m_Storage) return false;

	return true;
}

ZHMTypeInfo SItemWeaponSaveData::TypeInfo = ZHMTypeInfo("SItemWeaponSaveData", sizeof(SItemWeaponSaveData), alignof(SItemWeaponSaveData), SItemWeaponSaveData::WriteJson, SItemWeaponSaveData::WriteSimpleJson, SItemWeaponSaveData::FromSimpleJson, SItemWeaponSaveData::Serialize, SItemWeaponSaveData::Equals);

void SItemWeaponSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nBulletsInMagazine") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletsInMagazine);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nExtraMagazineBullets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nExtraMagazineBullets);
	p_Stream << "}";

	p_Stream << "}";
}

void SItemWeaponSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nBulletsInMagazine") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletsInMagazine);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nExtraMagazineBullets") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nExtraMagazineBullets);

	p_Stream << "}";
}

void SItemWeaponSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemWeaponSaveData s_Object {};

	s_Object.m_nBulletsInMagazine = simdjson::from_json_uint16(p_Document["m_nBulletsInMagazine"]);

	s_Object.m_nExtraMagazineBullets = simdjson::from_json_uint16(p_Document["m_nExtraMagazineBullets"]);

	*reinterpret_cast<SItemWeaponSaveData*>(p_Target) = s_Object;
}

void SItemWeaponSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);

}

bool SItemWeaponSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemWeaponSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemWeaponSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemWeaponSaveData::operator==(const SItemWeaponSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemWeaponSaveData>)
		return false;

	if (m_nBulletsInMagazine != p_Other.m_nBulletsInMagazine) return false;
	if (m_nExtraMagazineBullets != p_Other.m_nExtraMagazineBullets) return false;

	return true;
}

ZHMTypeInfo SLayerBehaviorConfiguration::TypeInfo = ZHMTypeInfo("SLayerBehaviorConfiguration", sizeof(SLayerBehaviorConfiguration), alignof(SLayerBehaviorConfiguration), SLayerBehaviorConfiguration::WriteJson, SLayerBehaviorConfiguration::WriteSimpleJson, SLayerBehaviorConfiguration::FromSimpleJson, SLayerBehaviorConfiguration::Serialize, SLayerBehaviorConfiguration::Equals);

void SLayerBehaviorConfiguration::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bTrigger") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTrigger);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCollector") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollector);
	p_Stream << "}";

	p_Stream << "}";
}

void SLayerBehaviorConfiguration::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bTrigger") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTrigger);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCollector") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollector);

	p_Stream << "}";
}

void SLayerBehaviorConfiguration::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLayerBehaviorConfiguration s_Object {};

	s_Object.m_bTrigger = simdjson::from_json_bool(p_Document["m_bTrigger"]);

	s_Object.m_bCollector = simdjson::from_json_bool(p_Document["m_bCollector"]);

	*reinterpret_cast<SLayerBehaviorConfiguration*>(p_Target) = s_Object;
}

void SLayerBehaviorConfiguration::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);

}

bool SLayerBehaviorConfiguration::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Left);
	auto* s_Right = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLayerBehaviorConfiguration::operator==(const SLayerBehaviorConfiguration& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLayerBehaviorConfiguration>)
		return false;

	if (m_bTrigger != p_Other.m_bTrigger) return false;
	if (m_bCollector != p_Other.m_bCollector) return false;

	return true;
}

ZHMTypeInfo SLeadEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SLeadEscortSituationActorStateSaveData", sizeof(SLeadEscortSituationActorStateSaveData), alignof(SLeadEscortSituationActorStateSaveData), SLeadEscortSituationActorStateSaveData::WriteJson, SLeadEscortSituationActorStateSaveData::WriteSimpleJson, SLeadEscortSituationActorStateSaveData::FromSimpleJson, SLeadEscortSituationActorStateSaveData::Serialize, SLeadEscortSituationActorStateSaveData::Equals);

void SLeadEscortSituationActorStateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZLeadEscortSituationEntity.EEscortState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZLeadEscortSituationEntity.EEscortState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eStatePrevious)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);
	p_Stream << "}";

	p_Stream << "}";
}

void SLeadEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SLeadEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLeadEscortSituationActorStateSaveData s_Object {};

	s_Object.m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_eState = static_cast<ZLeadEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object.m_eStatePrevious = static_cast<ZLeadEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object.m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

	*reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Target) = s_Object;
}

void SLeadEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);

}

bool SLeadEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationActorStateSaveData::operator==(const SLeadEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

ZHMTypeInfo SLeadEscortSituationActors::TypeInfo = ZHMTypeInfo("SLeadEscortSituationActors", sizeof(SLeadEscortSituationActors), alignof(SLeadEscortSituationActors), SLeadEscortSituationActors::WriteJson, SLeadEscortSituationActors::WriteSimpleJson, SLeadEscortSituationActors::FromSimpleJson, SLeadEscortSituationActors::Serialize, SLeadEscortSituationActors::Equals);

void SLeadEscortSituationActors::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";

	p_Stream << "}";
}

void SLeadEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SLeadEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLeadEscortSituationActors s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SLeadEscortSituationActors*>(p_Target) = s_Object;
}

void SLeadEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);

}

bool SLeadEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationActors::operator==(const SLeadEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

ZHMTypeInfo SLeadEscortSituationSaveData::TypeInfo = ZHMTypeInfo("SLeadEscortSituationSaveData", sizeof(SLeadEscortSituationSaveData), alignof(SLeadEscortSituationSaveData), SLeadEscortSituationSaveData::WriteJson, SLeadEscortSituationSaveData::WriteSimpleJson, SLeadEscortSituationSaveData::FromSimpleJson, SLeadEscortSituationSaveData::Serialize, SLeadEscortSituationSaveData::Equals);

void SLeadEscortSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZLeadEscortSituationEntity.ETargetState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorEmotionState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetEmotionState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZActBehaviorEntity.EState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eTargetActState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SLeadEscortSituationActors>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SLeadEscortSituationActors") << ",\"$val\":";
		SLeadEscortSituationActors::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SLeadEscortSituationActorStateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SLeadEscortSituationActorStateSaveData") << ",\"$val\":";
		SLeadEscortSituationActorStateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SLeadEscortSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SLeadEscortSituationActors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SLeadEscortSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLeadEscortSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLeadEscortSituationSaveData s_Object {};

	s_Object.m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object.m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object.m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object.m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object.m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Item);
		s_Object.m_vLastPosition = s_Item;
	}

	s_Object.m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object.m_eTargetState = static_cast<ZLeadEscortSituationEntity_ETargetState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object.m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object.m_eTargetActState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object.m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object.m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAddedActors"])
	{
		SLeadEscortSituationActors s_ArrayItem0;
		SLeadEscortSituationActors::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAddedActors.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aStates"])
	{
		SLeadEscortSituationActorStateSaveData s_ArrayItem0;
		SLeadEscortSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEscortActs"])
	{
		s_Object.m_aEscortActs.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SLeadEscortSituationSaveData*>(p_Target) = s_Object;
}

void SLeadEscortSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_vLastPosition));
	TArray<SLeadEscortSituationActors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aAddedActors));
	TArray<SLeadEscortSituationActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aEscortActs));
}

bool SLeadEscortSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationSaveData::operator==(const SLeadEscortSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationSaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;

	return true;
}

ZHMTypeInfo SLevelReferenceableEntitieSaveData::TypeInfo = ZHMTypeInfo("SLevelReferenceableEntitieSaveData", sizeof(SLevelReferenceableEntitieSaveData), alignof(SLevelReferenceableEntitieSaveData), SLevelReferenceableEntitieSaveData::WriteJson, SLevelReferenceableEntitieSaveData::WriteSimpleJson, SLevelReferenceableEntitieSaveData::FromSimpleJson, SLevelReferenceableEntitieSaveData::Serialize, SLevelReferenceableEntitieSaveData::Equals);

void SLevelReferenceableEntitieSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sSceneResource") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sSceneResource);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAdditionalBrickResources") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAdditionalBrickResources.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAdditionalBrickResources[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aAdditionalBrickResources.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SLevelReferenceableEntitieSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sSceneResource") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sSceneResource);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAdditionalBrickResources") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAdditionalBrickResources.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAdditionalBrickResources[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAdditionalBrickResources.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLevelReferenceableEntitieSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLevelReferenceableEntitieSaveData s_Object {};

	s_Object.m_sSceneResource = std::string_view(p_Document["m_sSceneResource"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAdditionalBrickResources"])
	{
		s_Object.m_aAdditionalBrickResources.push_back(std::string_view(s_Item0));
	}

	*reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Target) = s_Object;
}

void SLevelReferenceableEntitieSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sSceneResource, p_Serializer, p_OwnOffset + offsetof(SLevelReferenceableEntitieSaveData, m_sSceneResource));
	TArray<ZString>::Serialize(&s_Object->m_aAdditionalBrickResources, p_Serializer, p_OwnOffset + offsetof(SLevelReferenceableEntitieSaveData, m_aAdditionalBrickResources));
}

bool SLevelReferenceableEntitieSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLevelReferenceableEntitieSaveData::operator==(const SLevelReferenceableEntitieSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLevelReferenceableEntitieSaveData>)
		return false;

	if (m_sSceneResource != p_Other.m_sSceneResource) return false;
	if (m_aAdditionalBrickResources != p_Other.m_aAdditionalBrickResources) return false;

	return true;
}

ZHMTypeInfo SObjetiveSaveData::TypeInfo = ZHMTypeInfo("SObjetiveSaveData", sizeof(SObjetiveSaveData), alignof(SObjetiveSaveData), SObjetiveSaveData::WriteJson, SObjetiveSaveData::WriteSimpleJson, SObjetiveSaveData::FromSimpleJson, SObjetiveSaveData::Serialize, SObjetiveSaveData::Equals);

void SObjetiveSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("IContractObjective.Type") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Type", static_cast<int>(s_Object->m_eType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_SaveData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SObjetiveSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Type", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SaveData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_SaveData, p_Stream);

	p_Stream << "}";
}

void SObjetiveSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SObjetiveSaveData s_Object {};

	s_Object.m_eType = static_cast<IContractObjective_Type>(ZHMEnums::GetEnumValueByName("IContractObjective.Type", std::string_view(p_Document["m_eType"])));

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_SaveData"], &s_Item);
		s_Object.m_SaveData = s_Item;
	}

	*reinterpret_cast<SObjetiveSaveData*>(p_Target) = s_Object;
}

void SObjetiveSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_SaveData, p_Serializer, p_OwnOffset + offsetof(SObjetiveSaveData, m_SaveData));
}

bool SObjetiveSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SObjetiveSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SObjetiveSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SObjetiveSaveData::operator==(const SObjetiveSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SObjetiveSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_SaveData != p_Other.m_SaveData) return false;

	return true;
}

ZHMTypeInfo SSoundAmbienceSaveData::TypeInfo = ZHMTypeInfo("SSoundAmbienceSaveData", sizeof(SSoundAmbienceSaveData), alignof(SSoundAmbienceSaveData), SSoundAmbienceSaveData::WriteJson, SSoundAmbienceSaveData::WriteSimpleJson, SSoundAmbienceSaveData::FromSimpleJson, SSoundAmbienceSaveData::Serialize, SSoundAmbienceSaveData::Equals);

void SSoundAmbienceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rCurrentAmbience") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentAmbience);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentGate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentGate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTransitionAmount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTransitionAmount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnteredFromSide0") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnteredFromSide0);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInTransition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInTransition);
	p_Stream << "}";

	p_Stream << "}";
}

void SSoundAmbienceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentAmbience") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentAmbience);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentGate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentGate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTransitionAmount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTransitionAmount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnteredFromSide0") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnteredFromSide0);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInTransition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInTransition);

	p_Stream << "}";
}

void SSoundAmbienceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSoundAmbienceSaveData s_Object {};

	s_Object.m_rCurrentAmbience = simdjson::from_json_uint32(p_Document["m_rCurrentAmbience"]);

	s_Object.m_rCurrentGate = simdjson::from_json_uint32(p_Document["m_rCurrentGate"]);

	s_Object.m_fTransitionAmount = simdjson::from_json_float32(p_Document["m_fTransitionAmount"]);

	s_Object.m_bEnteredFromSide0 = simdjson::from_json_bool(p_Document["m_bEnteredFromSide0"]);

	s_Object.m_bInTransition = simdjson::from_json_bool(p_Document["m_bInTransition"]);

	*reinterpret_cast<SSoundAmbienceSaveData*>(p_Target) = s_Object;
}

void SSoundAmbienceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);

}

bool SSoundAmbienceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSoundAmbienceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSoundAmbienceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSoundAmbienceSaveData::operator==(const SSoundAmbienceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSoundAmbienceSaveData>)
		return false;

	if (m_rCurrentAmbience != p_Other.m_rCurrentAmbience) return false;
	if (m_rCurrentGate != p_Other.m_rCurrentGate) return false;
	if (m_fTransitionAmount != p_Other.m_fTransitionAmount) return false;
	if (m_bEnteredFromSide0 != p_Other.m_bEnteredFromSide0) return false;
	if (m_bInTransition != p_Other.m_bInTransition) return false;

	return true;
}

ZHMTypeInfo SLevelSaveData::TypeInfo = ZHMTypeInfo("SLevelSaveData", sizeof(SLevelSaveData), alignof(SLevelSaveData), SLevelSaveData::WriteJson, SLevelSaveData::WriteSimpleJson, SLevelSaveData::FromSimpleJson, SLevelSaveData::Serialize, SLevelSaveData::Equals);

void SLevelSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nGameTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGameTimePrev") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTimePrev);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGameTimeDelta") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTimeDelta);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sScene") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sScene);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLocationId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLocationId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractSessionId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractSessionId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLastEventToken") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLastEventToken);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_EnabledEntranceId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_EnabledEntranceId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StartupDisguiseId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_StartupDisguiseId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_contractData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_contractData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStartupInventory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SInventoryInfo") << ",\"$val\":";
	SInventoryInfo::WriteJson(&s_Object->m_aStartupInventory, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStartupAgencyPickupSelection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SAgencyPickupInfo") << ",\"$val\":";
	SAgencyPickupInfo::WriteJson(&s_Object->m_aStartupAgencyPickupSelection, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aObjectives") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SObjetiveSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aObjectives.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aObjectives[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SObjetiveSaveData") << ",\"$val\":";
		SObjetiveSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aObjectives.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGameChangers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZVariant>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGameChangers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGameChangers[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
		ZVariant::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aGameChangers.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SoundAmbienceData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SSoundAmbienceSaveData") << ",\"$val\":";
	SSoundAmbienceSaveData::WriteJson(&s_Object->m_SoundAmbienceData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ChallengesSaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SChallengesSaveData") << ",\"$val\":";
	SChallengesSaveData::WriteJson(&s_Object->m_ChallengesSaveData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSaveGameLimit") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSaveGameLimit);
	p_Stream << "}";

	p_Stream << "}";
}

void SLevelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nGameTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGameTimePrev") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTimePrev);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGameTimeDelta") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTimeDelta);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sScene") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sScene);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLocationId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLocationId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractSessionId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractSessionId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLastEventToken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLastEventToken);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_EnabledEntranceId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_EnabledEntranceId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StartupDisguiseId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_StartupDisguiseId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_contractData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_contractData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStartupInventory") << ":";
	SInventoryInfo::WriteSimpleJson(&s_Object->m_aStartupInventory, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStartupAgencyPickupSelection") << ":";
	SAgencyPickupInfo::WriteSimpleJson(&s_Object->m_aStartupAgencyPickupSelection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aObjectives") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aObjectives.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aObjectives[i];
		SObjetiveSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aObjectives.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGameChangers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGameChangers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGameChangers[i];
		ZVariant::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGameChangers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SoundAmbienceData") << ":";
	SSoundAmbienceSaveData::WriteSimpleJson(&s_Object->m_SoundAmbienceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ChallengesSaveData") << ":";
	SChallengesSaveData::WriteSimpleJson(&s_Object->m_ChallengesSaveData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSaveGameLimit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSaveGameLimit);

	p_Stream << "}";
}

void SLevelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLevelSaveData s_Object {};

	s_Object.m_nGameTime = simdjson::from_json_int64(p_Document["m_nGameTime"]);

	s_Object.m_nGameTimePrev = simdjson::from_json_int64(p_Document["m_nGameTimePrev"]);

	s_Object.m_nGameTimeDelta = simdjson::from_json_int64(p_Document["m_nGameTimeDelta"]);

	s_Object.m_sScene = std::string_view(p_Document["m_sScene"]);

	s_Object.m_sLocationId = std::string_view(p_Document["m_sLocationId"]);

	s_Object.m_sContractId = std::string_view(p_Document["m_sContractId"]);

	s_Object.m_sContractSessionId = std::string_view(p_Document["m_sContractSessionId"]);

	s_Object.m_sLastEventToken = std::string_view(p_Document["m_sLastEventToken"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_EnabledEntranceId"], &s_Item);
		s_Object.m_EnabledEntranceId = s_Item;
	}

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_StartupDisguiseId"], &s_Item);
		s_Object.m_StartupDisguiseId = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_contractData"], &s_Item);
		s_Object.m_contractData = s_Item;
	}

	{
		SInventoryInfo s_Item {};
		SInventoryInfo::FromSimpleJson(p_Document["m_aStartupInventory"], &s_Item);
		s_Object.m_aStartupInventory = s_Item;
	}

	{
		SAgencyPickupInfo s_Item {};
		SAgencyPickupInfo::FromSimpleJson(p_Document["m_aStartupAgencyPickupSelection"], &s_Item);
		s_Object.m_aStartupAgencyPickupSelection = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aObjectives"])
	{
		SObjetiveSaveData s_ArrayItem0;
		SObjetiveSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aObjectives.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGameChangers"])
	{
		ZVariant s_ArrayItem0;
		ZVariant::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGameChangers.push_back(s_ArrayItem0);
	}

	{
		SSoundAmbienceSaveData s_Item {};
		SSoundAmbienceSaveData::FromSimpleJson(p_Document["m_SoundAmbienceData"], &s_Item);
		s_Object.m_SoundAmbienceData = s_Item;
	}

	{
		SChallengesSaveData s_Item {};
		SChallengesSaveData::FromSimpleJson(p_Document["m_ChallengesSaveData"], &s_Item);
		s_Object.m_ChallengesSaveData = s_Item;
	}

	s_Object.m_nSaveGameLimit = simdjson::from_json_int32(p_Document["m_nSaveGameLimit"]);

	*reinterpret_cast<SLevelSaveData*>(p_Target) = s_Object;
}

void SLevelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sScene, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sScene));
	ZString::Serialize(&s_Object->m_sLocationId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sLocationId));
	ZString::Serialize(&s_Object->m_sContractId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sContractId));
	ZString::Serialize(&s_Object->m_sContractSessionId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sContractSessionId));
	ZString::Serialize(&s_Object->m_sLastEventToken, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sLastEventToken));
	ZRepositoryID::Serialize(&s_Object->m_EnabledEntranceId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_EnabledEntranceId));
	ZRepositoryID::Serialize(&s_Object->m_StartupDisguiseId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_StartupDisguiseId));
	ZVariant::Serialize(&s_Object->m_contractData, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_contractData));
	SInventoryInfo::Serialize(&s_Object->m_aStartupInventory, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_aStartupInventory));
	SAgencyPickupInfo::Serialize(&s_Object->m_aStartupAgencyPickupSelection, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_aStartupAgencyPickupSelection));
	TArray<SObjetiveSaveData>::Serialize(&s_Object->m_aObjectives, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_aObjectives));
	TArray<ZVariant>::Serialize(&s_Object->m_aGameChangers, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_aGameChangers));
	SSoundAmbienceSaveData::Serialize(&s_Object->m_SoundAmbienceData, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_SoundAmbienceData));
	SChallengesSaveData::Serialize(&s_Object->m_ChallengesSaveData, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_ChallengesSaveData));
}

bool SLevelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLevelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLevelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLevelSaveData::operator==(const SLevelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLevelSaveData>)
		return false;

	if (m_nGameTime != p_Other.m_nGameTime) return false;
	if (m_nGameTimePrev != p_Other.m_nGameTimePrev) return false;
	if (m_nGameTimeDelta != p_Other.m_nGameTimeDelta) return false;
	if (m_sScene != p_Other.m_sScene) return false;
	if (m_sLocationId != p_Other.m_sLocationId) return false;
	if (m_sContractId != p_Other.m_sContractId) return false;
	if (m_sContractSessionId != p_Other.m_sContractSessionId) return false;
	if (m_sLastEventToken != p_Other.m_sLastEventToken) return false;
	if (m_EnabledEntranceId != p_Other.m_EnabledEntranceId) return false;
	if (m_StartupDisguiseId != p_Other.m_StartupDisguiseId) return false;
	if (m_contractData != p_Other.m_contractData) return false;
	if (m_aStartupInventory != p_Other.m_aStartupInventory) return false;
	if (m_aStartupAgencyPickupSelection != p_Other.m_aStartupAgencyPickupSelection) return false;
	if (m_aObjectives != p_Other.m_aObjectives) return false;
	if (m_aGameChangers != p_Other.m_aGameChangers) return false;
	if (m_SoundAmbienceData != p_Other.m_SoundAmbienceData) return false;
	if (m_ChallengesSaveData != p_Other.m_ChallengesSaveData) return false;
	if (m_nSaveGameLimit != p_Other.m_nSaveGameLimit) return false;

	return true;
}

ZHMTypeInfo SLightFlickerEntitySaveData::TypeInfo = ZHMTypeInfo("SLightFlickerEntitySaveData", sizeof(SLightFlickerEntitySaveData), alignof(SLightFlickerEntitySaveData), SLightFlickerEntitySaveData::WriteJson, SLightFlickerEntitySaveData::WriteSimpleJson, SLightFlickerEntitySaveData::FromSimpleJson, SLightFlickerEntitySaveData::Serialize, SLightFlickerEntitySaveData::Equals);

void SLightFlickerEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bLightOn") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLightOn);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFlickerOn") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFlickerOn);
	p_Stream << "}";

	p_Stream << "}";
}

void SLightFlickerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bLightOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLightOn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFlickerOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFlickerOn);

	p_Stream << "}";
}

void SLightFlickerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLightFlickerEntitySaveData s_Object {};

	s_Object.m_bLightOn = simdjson::from_json_bool(p_Document["m_bLightOn"]);

	s_Object.m_bFlickerOn = simdjson::from_json_bool(p_Document["m_bFlickerOn"]);

	*reinterpret_cast<SLightFlickerEntitySaveData*>(p_Target) = s_Object;
}

void SLightFlickerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);

}

bool SLightFlickerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLightFlickerEntitySaveData::operator==(const SLightFlickerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLightFlickerEntitySaveData>)
		return false;

	if (m_bLightOn != p_Other.m_bLightOn) return false;
	if (m_bFlickerOn != p_Other.m_bFlickerOn) return false;

	return true;
}

ZHMTypeInfo SLoadRuntimeResourceResult::TypeInfo = ZHMTypeInfo("SLoadRuntimeResourceResult", sizeof(SLoadRuntimeResourceResult), alignof(SLoadRuntimeResourceResult), SLoadRuntimeResourceResult::WriteJson, SLoadRuntimeResourceResult::WriteSimpleJson, SLoadRuntimeResourceResult::FromSimpleJson, SLoadRuntimeResourceResult::Serialize, SLoadRuntimeResourceResult::Equals);

void SLoadRuntimeResourceResult::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sFilePath") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sFilePath);
	p_Stream << "}";

	p_Stream << "}";
}

void SLoadRuntimeResourceResult::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFilePath") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFilePath);

	p_Stream << "}";
}

void SLoadRuntimeResourceResult::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLoadRuntimeResourceResult s_Object {};

	s_Object.sFilePath = std::string_view(p_Document["sFilePath"]);

	*reinterpret_cast<SLoadRuntimeResourceResult*>(p_Target) = s_Object;
}

void SLoadRuntimeResourceResult::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	ZString::Serialize(&s_Object->sFilePath, p_Serializer, p_OwnOffset + offsetof(SLoadRuntimeResourceResult, sFilePath));
}

bool SLoadRuntimeResourceResult::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Left);
	auto* s_Right = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLoadRuntimeResourceResult::operator==(const SLoadRuntimeResourceResult& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLoadRuntimeResourceResult>)
		return false;

	if (sFilePath != p_Other.sFilePath) return false;

	return true;
}

ZHMTypeInfo SLocalizedVideoData::TypeInfo = ZHMTypeInfo("SLocalizedVideoData", sizeof(SLocalizedVideoData), alignof(SLocalizedVideoData), SLocalizedVideoData::WriteJson, SLocalizedVideoData::WriteSimpleJson, SLocalizedVideoData::FromSimpleJson, SLocalizedVideoData::Serialize, SLocalizedVideoData::Equals);

void SLocalizedVideoData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("AudioLanguages") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->AudioLanguages.size(); ++i)
	{
		auto& s_Item0 = s_Object->AudioLanguages[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->AudioLanguages.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("VideoRidsPerAudioLanguage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZRuntimeResourceID>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->VideoRidsPerAudioLanguage.size(); ++i)
	{
		auto& s_Item0 = s_Object->VideoRidsPerAudioLanguage[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
		ZRuntimeResourceID::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->VideoRidsPerAudioLanguage.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SubtitleLanguages") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->SubtitleLanguages.size(); ++i)
	{
		auto& s_Item0 = s_Object->SubtitleLanguages[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->SubtitleLanguages.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SubtitleMarkupsPerLanguage") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->SubtitleMarkupsPerLanguage.size(); ++i)
	{
		auto& s_Item0 = s_Object->SubtitleMarkupsPerLanguage[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->SubtitleMarkupsPerLanguage.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SLocalizedVideoData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("AudioLanguages") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->AudioLanguages.size(); ++i)
	{
		auto& s_Item0 = s_Object->AudioLanguages[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->AudioLanguages.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("VideoRidsPerAudioLanguage") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->VideoRidsPerAudioLanguage.size(); ++i)
	{
		auto& s_Item0 = s_Object->VideoRidsPerAudioLanguage[i];
		ZRuntimeResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->VideoRidsPerAudioLanguage.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SubtitleLanguages") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->SubtitleLanguages.size(); ++i)
	{
		auto& s_Item0 = s_Object->SubtitleLanguages[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->SubtitleLanguages.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SubtitleMarkupsPerLanguage") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->SubtitleMarkupsPerLanguage.size(); ++i)
	{
		auto& s_Item0 = s_Object->SubtitleMarkupsPerLanguage[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->SubtitleMarkupsPerLanguage.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLocalizedVideoData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLocalizedVideoData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["AudioLanguages"])
	{
		s_Object.AudioLanguages.push_back(std::string_view(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["VideoRidsPerAudioLanguage"])
	{
		ZRuntimeResourceID s_ArrayItem0;
		ZRuntimeResourceID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.VideoRidsPerAudioLanguage.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["SubtitleLanguages"])
	{
		s_Object.SubtitleLanguages.push_back(std::string_view(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["SubtitleMarkupsPerLanguage"])
	{
		s_Object.SubtitleMarkupsPerLanguage.push_back(std::string_view(s_Item0));
	}

	*reinterpret_cast<SLocalizedVideoData*>(p_Target) = s_Object;
}

void SLocalizedVideoData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);

	TArray<ZString>::Serialize(&s_Object->AudioLanguages, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, AudioLanguages));
	TArray<ZRuntimeResourceID>::Serialize(&s_Object->VideoRidsPerAudioLanguage, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, VideoRidsPerAudioLanguage));
	TArray<ZString>::Serialize(&s_Object->SubtitleLanguages, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, SubtitleLanguages));
	TArray<ZString>::Serialize(&s_Object->SubtitleMarkupsPerLanguage, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, SubtitleMarkupsPerLanguage));
}

bool SLocalizedVideoData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLocalizedVideoData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLocalizedVideoData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLocalizedVideoData::operator==(const SLocalizedVideoData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLocalizedVideoData>)
		return false;

	if (AudioLanguages != p_Other.AudioLanguages) return false;
	if (VideoRidsPerAudioLanguage != p_Other.VideoRidsPerAudioLanguage) return false;
	if (SubtitleLanguages != p_Other.SubtitleLanguages) return false;
	if (SubtitleMarkupsPerLanguage != p_Other.SubtitleMarkupsPerLanguage) return false;

	return true;
}

ZHMTypeInfo SLockdownManagerAIZoneSaveData::TypeInfo = ZHMTypeInfo("SLockdownManagerAIZoneSaveData", sizeof(SLockdownManagerAIZoneSaveData), alignof(SLockdownManagerAIZoneSaveData), SLockdownManagerAIZoneSaveData::WriteJson, SLockdownManagerAIZoneSaveData::WriteSimpleJson, SLockdownManagerAIZoneSaveData::FromSimpleJson, SLockdownManagerAIZoneSaveData::Serialize, SLockdownManagerAIZoneSaveData::Equals);

void SLockdownManagerAIZoneSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_tExpiry") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tExpiry, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tExpiryHeroOutside") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tExpiryHeroOutside, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rZone);
	p_Stream << "}";

	p_Stream << "}";
}

void SLockdownManagerAIZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tExpiry") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiry, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tExpiryHeroOutside") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiryHeroOutside, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rZone);

	p_Stream << "}";
}

void SLockdownManagerAIZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLockdownManagerAIZoneSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tExpiry"], &s_Item);
		s_Object.m_tExpiry = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tExpiryHeroOutside"], &s_Item);
		s_Object.m_tExpiryHeroOutside = s_Item;
	}

	s_Object.m_rZone = simdjson::from_json_uint32(p_Document["m_rZone"]);

	*reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Target) = s_Object;
}

void SLockdownManagerAIZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tExpiry, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerAIZoneSaveData, m_tExpiry));
	ZGameTime::Serialize(&s_Object->m_tExpiryHeroOutside, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerAIZoneSaveData, m_tExpiryHeroOutside));
}

bool SLockdownManagerAIZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLockdownManagerAIZoneSaveData::operator==(const SLockdownManagerAIZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLockdownManagerAIZoneSaveData>)
		return false;

	if (m_tExpiry != p_Other.m_tExpiry) return false;
	if (m_tExpiryHeroOutside != p_Other.m_tExpiryHeroOutside) return false;
	if (m_rZone != p_Other.m_rZone) return false;

	return true;
}

ZHMTypeInfo SLockdownManagerSaveData::TypeInfo = ZHMTypeInfo("SLockdownManagerSaveData", sizeof(SLockdownManagerSaveData), alignof(SLockdownManagerSaveData), SLockdownManagerSaveData::WriteJson, SLockdownManagerSaveData::WriteSimpleJson, SLockdownManagerSaveData::FromSimpleJson, SLockdownManagerSaveData::Serialize, SLockdownManagerSaveData::Equals);

void SLockdownManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aAIZones") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SLockdownManagerAIZoneSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAIZones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAIZones[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SLockdownManagerAIZoneSaveData") << ",\"$val\":";
		SLockdownManagerAIZoneSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aAIZones.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SLockdownManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAIZones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAIZones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAIZones[i];
		SLockdownManagerAIZoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAIZones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLockdownManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLockdownManagerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAIZones"])
	{
		SLockdownManagerAIZoneSaveData s_ArrayItem0;
		SLockdownManagerAIZoneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAIZones.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SLockdownManagerSaveData*>(p_Target) = s_Object;
}

void SLockdownManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);

	TArray<SLockdownManagerAIZoneSaveData>::Serialize(&s_Object->m_aAIZones, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerSaveData, m_aAIZones));
}

bool SLockdownManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLockdownManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLockdownManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLockdownManagerSaveData::operator==(const SLockdownManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLockdownManagerSaveData>)
		return false;

	if (m_aAIZones != p_Other.m_aAIZones) return false;

	return true;
}

ZHMTypeInfo SManHuntServiceSaveData::TypeInfo = ZHMTypeInfo("SManHuntServiceSaveData", sizeof(SManHuntServiceSaveData), alignof(SManHuntServiceSaveData), SManHuntServiceSaveData::WriteJson, SManHuntServiceSaveData::WriteSimpleJson, SManHuntServiceSaveData::FromSimpleJson, SManHuntServiceSaveData::Serialize, SManHuntServiceSaveData::Equals);

void SManHuntServiceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rGuardNodes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint16>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_rGuardNodes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_rGuardNodes[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_rGuardNodes.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInitialNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInitialNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGuardSightRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGuardSightRange);
	p_Stream << "}";

	p_Stream << "}";
}

void SManHuntServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rGuardNodes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_rGuardNodes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_rGuardNodes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_rGuardNodes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInitialNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInitialNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGuardSightRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGuardSightRange);

	p_Stream << "}";
}

void SManHuntServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SManHuntServiceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_rGuardNodes"])
	{
		s_Object.m_rGuardNodes.push_back(simdjson::from_json_uint16(s_Item0));
	}

	s_Object.m_rInitialNode = simdjson::from_json_uint16(p_Document["m_rInitialNode"]);

	s_Object.m_fGuardSightRange = simdjson::from_json_float32(p_Document["m_fGuardSightRange"]);

	*reinterpret_cast<SManHuntServiceSaveData*>(p_Target) = s_Object;
}

void SManHuntServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_rGuardNodes, p_Serializer, p_OwnOffset + offsetof(SManHuntServiceSaveData, m_rGuardNodes));
}

bool SManHuntServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SManHuntServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SManHuntServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SManHuntServiceSaveData::operator==(const SManHuntServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SManHuntServiceSaveData>)
		return false;

	if (m_rGuardNodes != p_Other.m_rGuardNodes) return false;
	if (m_rInitialNode != p_Other.m_rInitialNode) return false;
	if (m_fGuardSightRange != p_Other.m_fGuardSightRange) return false;

	return true;
}

ZHMTypeInfo SMapMarkerData::TypeInfo = ZHMTypeInfo("SMapMarkerData", sizeof(SMapMarkerData), alignof(SMapMarkerData), SMapMarkerData::WriteJson, SMapMarkerData::WriteSimpleJson, SMapMarkerData::FromSimpleJson, SMapMarkerData::Serialize, SMapMarkerData::Equals);

void SMapMarkerData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("pathPoints") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SVector2>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pathPoints.size(); ++i)
	{
		auto& s_Item0 = s_Object->pathPoints[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector2") << ",\"$val\":";
		SVector2::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->pathPoints.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SMapMarkerData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("pathPoints") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pathPoints.size(); ++i)
	{
		auto& s_Item0 = s_Object->pathPoints[i];
		SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pathPoints.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMapMarkerData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMapMarkerData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["pathPoints"])
	{
		SVector2 s_ArrayItem0;
		SVector2::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.pathPoints.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SMapMarkerData*>(p_Target) = s_Object;
}

void SMapMarkerData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);

	TArray<SVector2>::Serialize(&s_Object->pathPoints, p_Serializer, p_OwnOffset + offsetof(SMapMarkerData, pathPoints));
}

bool SMapMarkerData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMapMarkerData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMapMarkerData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMapMarkerData::operator==(const SMapMarkerData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMapMarkerData>)
		return false;

	if (pathPoints != p_Other.pathPoints) return false;

	return true;
}

ZHMTypeInfo SMatrix33::TypeInfo = ZHMTypeInfo("SMatrix33", sizeof(SMatrix33), alignof(SMatrix33), SMatrix33::WriteJson, SMatrix33::WriteSimpleJson, SMatrix33::FromSimpleJson, SMatrix33::Serialize, SMatrix33::Equals);

void SMatrix33::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("XAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->XAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->YAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->ZAxis, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SMatrix33::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->ZAxis, p_Stream);

	p_Stream << "}";
}

void SMatrix33::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix33 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	*reinterpret_cast<SMatrix33*>(p_Target) = s_Object;
}

void SMatrix33::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	SVector3::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, XAxis));
	SVector3::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, YAxis));
	SVector3::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, ZAxis));
}

bool SMatrix33::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix33*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix33*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix33::operator==(const SMatrix33& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix33>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;

	return true;
}

ZHMTypeInfo SMatrix43::TypeInfo = ZHMTypeInfo("SMatrix43", sizeof(SMatrix43), alignof(SMatrix43), SMatrix43::WriteJson, SMatrix43::WriteSimpleJson, SMatrix43::FromSimpleJson, SMatrix43::Serialize, SMatrix43::Equals);

void SMatrix43::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("XAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->XAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->YAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->ZAxis, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->Trans, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SMatrix43::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->ZAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	SVector3::WriteSimpleJson(&s_Object->Trans, p_Stream);

	p_Stream << "}";
}

void SMatrix43::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix43 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["Trans"], &s_Item);
		s_Object.Trans = s_Item;
	}

	*reinterpret_cast<SMatrix43*>(p_Target) = s_Object;
}

void SMatrix43::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	SVector3::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, XAxis));
	SVector3::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, YAxis));
	SVector3::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, ZAxis));
	SVector3::Serialize(&s_Object->Trans, p_Serializer, p_OwnOffset + offsetof(SMatrix43, Trans));
}

bool SMatrix43::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix43*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix43*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix43::operator==(const SMatrix43& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix43>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;
	if (Trans != p_Other.Trans) return false;

	return true;
}

ZHMTypeInfo SMatrix44::TypeInfo = ZHMTypeInfo("SMatrix44", sizeof(SMatrix44), alignof(SMatrix44), SMatrix44::WriteJson, SMatrix44::WriteSimpleJson, SMatrix44::FromSimpleJson, SMatrix44::Serialize, SMatrix44::Equals);

void SMatrix44::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m11") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m11);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m12") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m12);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m13") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m13);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m14") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m14);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m21") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m21);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m22") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m22);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m23") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m23);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m24") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m24);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m31") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m31);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m32") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m32);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m33") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m33);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m34") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m34);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m41") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m41);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m42") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m42);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m43") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m43);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m44") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m44);
	p_Stream << "}";

	p_Stream << "}";
}

void SMatrix44::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m11") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m11);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m12") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m12);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m13") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m13);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m14") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m14);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m21") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m21);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m22") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m22);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m23") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m23);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m24") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m24);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m31") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m31);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m32") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m32);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m33") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m33);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m34") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m34);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m41") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m41);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m42") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m42);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m43") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m43);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m44") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m44);

	p_Stream << "}";
}

void SMatrix44::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix44 s_Object {};

	s_Object.m11 = simdjson::from_json_float32(p_Document["m11"]);

	s_Object.m12 = simdjson::from_json_float32(p_Document["m12"]);

	s_Object.m13 = simdjson::from_json_float32(p_Document["m13"]);

	s_Object.m14 = simdjson::from_json_float32(p_Document["m14"]);

	s_Object.m21 = simdjson::from_json_float32(p_Document["m21"]);

	s_Object.m22 = simdjson::from_json_float32(p_Document["m22"]);

	s_Object.m23 = simdjson::from_json_float32(p_Document["m23"]);

	s_Object.m24 = simdjson::from_json_float32(p_Document["m24"]);

	s_Object.m31 = simdjson::from_json_float32(p_Document["m31"]);

	s_Object.m32 = simdjson::from_json_float32(p_Document["m32"]);

	s_Object.m33 = simdjson::from_json_float32(p_Document["m33"]);

	s_Object.m34 = simdjson::from_json_float32(p_Document["m34"]);

	s_Object.m41 = simdjson::from_json_float32(p_Document["m41"]);

	s_Object.m42 = simdjson::from_json_float32(p_Document["m42"]);

	s_Object.m43 = simdjson::from_json_float32(p_Document["m43"]);

	s_Object.m44 = simdjson::from_json_float32(p_Document["m44"]);

	*reinterpret_cast<SMatrix44*>(p_Target) = s_Object;
}

void SMatrix44::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

}

bool SMatrix44::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix44*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix44*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix44::operator==(const SMatrix44& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix44>)
		return false;

	if (m11 != p_Other.m11) return false;
	if (m12 != p_Other.m12) return false;
	if (m13 != p_Other.m13) return false;
	if (m14 != p_Other.m14) return false;
	if (m21 != p_Other.m21) return false;
	if (m22 != p_Other.m22) return false;
	if (m23 != p_Other.m23) return false;
	if (m24 != p_Other.m24) return false;
	if (m31 != p_Other.m31) return false;
	if (m32 != p_Other.m32) return false;
	if (m33 != p_Other.m33) return false;
	if (m34 != p_Other.m34) return false;
	if (m41 != p_Other.m41) return false;
	if (m42 != p_Other.m42) return false;
	if (m43 != p_Other.m43) return false;
	if (m44 != p_Other.m44) return false;

	return true;
}

ZHMTypeInfo SMovementAgilitySaveData::TypeInfo = ZHMTypeInfo("SMovementAgilitySaveData", sizeof(SMovementAgilitySaveData), alignof(SMovementAgilitySaveData), SMovementAgilitySaveData::WriteJson, SMovementAgilitySaveData::WriteSimpleJson, SMovementAgilitySaveData::FromSimpleJson, SMovementAgilitySaveData::Serialize, SMovementAgilitySaveData::Equals);

void SMovementAgilitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rLedgeGuide") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLedgeGuide);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceLeftRightTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceLeftRightTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePrevAgilityState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAgilityState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_ePrevAgilityState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAgilityState", static_cast<int>(s_Object->m_ePrevAgilityState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAgilityState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAgilityState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAgilityState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAgilityState", static_cast<int>(s_Object->m_eAgilityState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nActiveAnimNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nActiveAnimNode);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCameraOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ECameraOffset_old") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eCameraOffset)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECameraOffset_old", static_cast<int>(s_Object->m_eCameraOffset))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void SMovementAgilitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rLedgeGuide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLedgeGuide);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceLeftRightTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceLeftRightTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePrevAgilityState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAgilityState", static_cast<int>(s_Object->m_ePrevAgilityState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAgilityState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAgilityState", static_cast<int>(s_Object->m_eAgilityState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nActiveAnimNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nActiveAnimNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCameraOffset") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECameraOffset_old", static_cast<int>(s_Object->m_eCameraOffset)));

	p_Stream << "}";
}

void SMovementAgilitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementAgilitySaveData s_Object {};

	s_Object.m_rLedgeGuide = simdjson::from_json_uint32(p_Document["m_rLedgeGuide"]);

	s_Object.m_fFaceLeftRightTarget = simdjson::from_json_float32(p_Document["m_fFaceLeftRightTarget"]);

	s_Object.m_ePrevAgilityState = static_cast<EAgilityState>(ZHMEnums::GetEnumValueByName("EAgilityState", std::string_view(p_Document["m_ePrevAgilityState"])));

	s_Object.m_eAgilityState = static_cast<EAgilityState>(ZHMEnums::GetEnumValueByName("EAgilityState", std::string_view(p_Document["m_eAgilityState"])));

	s_Object.m_nActiveAnimNode = simdjson::from_json_uint32(p_Document["m_nActiveAnimNode"]);

	s_Object.m_eCameraOffset = static_cast<ECameraOffset_old>(ZHMEnums::GetEnumValueByName("ECameraOffset_old", std::string_view(p_Document["m_eCameraOffset"])));

	*reinterpret_cast<SMovementAgilitySaveData*>(p_Target) = s_Object;
}

void SMovementAgilitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);

}

bool SMovementAgilitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementAgilitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementAgilitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementAgilitySaveData::operator==(const SMovementAgilitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementAgilitySaveData>)
		return false;

	if (m_rLedgeGuide != p_Other.m_rLedgeGuide) return false;
	if (m_fFaceLeftRightTarget != p_Other.m_fFaceLeftRightTarget) return false;
	if (m_ePrevAgilityState != p_Other.m_ePrevAgilityState) return false;
	if (m_eAgilityState != p_Other.m_eAgilityState) return false;
	if (m_nActiveAnimNode != p_Other.m_nActiveAnimNode) return false;
	if (m_eCameraOffset != p_Other.m_eCameraOffset) return false;

	return true;
}

ZHMTypeInfo SMovementCoverSaveData::TypeInfo = ZHMTypeInfo("SMovementCoverSaveData", sizeof(SMovementCoverSaveData), alignof(SMovementCoverSaveData), SMovementCoverSaveData::WriteJson, SMovementCoverSaveData::WriteSimpleJson, SMovementCoverSaveData::FromSimpleJson, SMovementCoverSaveData::Serialize, SMovementCoverSaveData::Equals);

void SMovementCoverSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rCoverPlane") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCoverPlane);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCoverAnimNodeID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCoverAnimNodeID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeftSideFacing") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeftSideFacing);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCrouched") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCrouched);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mPositionInCover") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMatrix") << ",\"$val\":";
	SMatrix::WriteJson(&s_Object->m_mPositionInCover, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SMovementCoverSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCoverPlane") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCoverPlane);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCoverAnimNodeID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCoverAnimNodeID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeftSideFacing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeftSideFacing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCrouched") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCrouched);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mPositionInCover") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mPositionInCover, p_Stream);

	p_Stream << "}";
}

void SMovementCoverSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementCoverSaveData s_Object {};

	s_Object.m_rCoverPlane = simdjson::from_json_uint32(p_Document["m_rCoverPlane"]);

	s_Object.m_nCoverAnimNodeID = simdjson::from_json_uint32(p_Document["m_nCoverAnimNodeID"]);

	s_Object.m_bLeftSideFacing = simdjson::from_json_bool(p_Document["m_bLeftSideFacing"]);

	s_Object.m_bCrouched = simdjson::from_json_bool(p_Document["m_bCrouched"]);

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_mPositionInCover"], &s_Item);
		s_Object.m_mPositionInCover = s_Item;
	}

	*reinterpret_cast<SMovementCoverSaveData*>(p_Target) = s_Object;
}

void SMovementCoverSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);

	SMatrix::Serialize(&s_Object->m_mPositionInCover, p_Serializer, p_OwnOffset + offsetof(SMovementCoverSaveData, m_mPositionInCover));
}

bool SMovementCoverSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementCoverSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementCoverSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementCoverSaveData::operator==(const SMovementCoverSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementCoverSaveData>)
		return false;

	if (m_rCoverPlane != p_Other.m_rCoverPlane) return false;
	if (m_nCoverAnimNodeID != p_Other.m_nCoverAnimNodeID) return false;
	if (m_bLeftSideFacing != p_Other.m_bLeftSideFacing) return false;
	if (m_bCrouched != p_Other.m_bCrouched) return false;
	if (m_mPositionInCover != p_Other.m_mPositionInCover) return false;

	return true;
}

ZHMTypeInfo SMovementDisguiseSafeZoneSaveData::TypeInfo = ZHMTypeInfo("SMovementDisguiseSafeZoneSaveData", sizeof(SMovementDisguiseSafeZoneSaveData), alignof(SMovementDisguiseSafeZoneSaveData), SMovementDisguiseSafeZoneSaveData::WriteJson, SMovementDisguiseSafeZoneSaveData::WriteSimpleJson, SMovementDisguiseSafeZoneSaveData::FromSimpleJson, SMovementDisguiseSafeZoneSaveData::Serialize, SMovementDisguiseSafeZoneSaveData::Equals);

void SMovementDisguiseSafeZoneSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rSafeZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSafeZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSafeZoneAnimNode") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSafeZoneAnimNode);
	p_Stream << "}";

	p_Stream << "}";
}

void SMovementDisguiseSafeZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSafeZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSafeZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSafeZoneAnimNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSafeZoneAnimNode);

	p_Stream << "}";
}

void SMovementDisguiseSafeZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementDisguiseSafeZoneSaveData s_Object {};

	s_Object.m_rSafeZone = simdjson::from_json_uint32(p_Document["m_rSafeZone"]);

	s_Object.m_nSafeZoneAnimNode = simdjson::from_json_uint32(p_Document["m_nSafeZoneAnimNode"]);

	*reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Target) = s_Object;
}

void SMovementDisguiseSafeZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);

}

bool SMovementDisguiseSafeZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDisguiseSafeZoneSaveData::operator==(const SMovementDisguiseSafeZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDisguiseSafeZoneSaveData>)
		return false;

	if (m_rSafeZone != p_Other.m_rSafeZone) return false;
	if (m_nSafeZoneAnimNode != p_Other.m_nSafeZoneAnimNode) return false;

	return true;
}

ZHMTypeInfo SMovementDragBodySaveData::TypeInfo = ZHMTypeInfo("SMovementDragBodySaveData", sizeof(SMovementDragBodySaveData), alignof(SMovementDragBodySaveData), SMovementDragBodySaveData::WriteJson, SMovementDragBodySaveData::WriteSimpleJson, SMovementDragBodySaveData::FromSimpleJson, SMovementDragBodySaveData::Serialize, SMovementDragBodySaveData::Equals);

void SMovementDragBodySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rDraggedActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDraggedActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGrabBoneID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGrabBoneID);
	p_Stream << "}";

	p_Stream << "}";
}

void SMovementDragBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rDraggedActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDraggedActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGrabBoneID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGrabBoneID);

	p_Stream << "}";
}

void SMovementDragBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementDragBodySaveData s_Object {};

	s_Object.m_rDraggedActor = simdjson::from_json_uint32(p_Document["m_rDraggedActor"]);

	s_Object.m_nGrabBoneID = simdjson::from_json_uint32(p_Document["m_nGrabBoneID"]);

	*reinterpret_cast<SMovementDragBodySaveData*>(p_Target) = s_Object;
}

void SMovementDragBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);

}

bool SMovementDragBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDragBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDragBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDragBodySaveData::operator==(const SMovementDragBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDragBodySaveData>)
		return false;

	if (m_rDraggedActor != p_Other.m_rDraggedActor) return false;
	if (m_nGrabBoneID != p_Other.m_nGrabBoneID) return false;

	return true;
}

ZHMTypeInfo SMovementDrainPipeSaveData::TypeInfo = ZHMTypeInfo("SMovementDrainPipeSaveData", sizeof(SMovementDrainPipeSaveData), alignof(SMovementDrainPipeSaveData), SMovementDrainPipeSaveData::WriteJson, SMovementDrainPipeSaveData::WriteSimpleJson, SMovementDrainPipeSaveData::FromSimpleJson, SMovementDrainPipeSaveData::Serialize, SMovementDrainPipeSaveData::Equals);

void SMovementDrainPipeSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rDrainPipe") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDrainPipe);
	p_Stream << "}";

	p_Stream << "}";
}

void SMovementDrainPipeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rDrainPipe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDrainPipe);

	p_Stream << "}";
}

void SMovementDrainPipeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementDrainPipeSaveData s_Object {};

	s_Object.m_rDrainPipe = simdjson::from_json_uint32(p_Document["m_rDrainPipe"]);

	*reinterpret_cast<SMovementDrainPipeSaveData*>(p_Target) = s_Object;
}

void SMovementDrainPipeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);

}

bool SMovementDrainPipeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDrainPipeSaveData::operator==(const SMovementDrainPipeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDrainPipeSaveData>)
		return false;

	if (m_rDrainPipe != p_Other.m_rDrainPipe) return false;

	return true;
}

ZHMTypeInfo SMovementHideInClosetSaveData::TypeInfo = ZHMTypeInfo("SMovementHideInClosetSaveData", sizeof(SMovementHideInClosetSaveData), alignof(SMovementHideInClosetSaveData), SMovementHideInClosetSaveData::WriteJson, SMovementHideInClosetSaveData::WriteSimpleJson, SMovementHideInClosetSaveData::FromSimpleJson, SMovementHideInClosetSaveData::Serialize, SMovementHideInClosetSaveData::Equals);

void SMovementHideInClosetSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eCurrentClosetType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ICloset.EClosetType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eCurrentClosetType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ICloset.EClosetType", static_cast<int>(s_Object->m_eCurrentClosetType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCloset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCloset);
	p_Stream << "}";

	p_Stream << "}";
}

void SMovementHideInClosetSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eCurrentClosetType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ICloset.EClosetType", static_cast<int>(s_Object->m_eCurrentClosetType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCloset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCloset);

	p_Stream << "}";
}

void SMovementHideInClosetSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementHideInClosetSaveData s_Object {};

	s_Object.m_eCurrentClosetType = static_cast<ICloset_EClosetType>(ZHMEnums::GetEnumValueByName("ICloset.EClosetType", std::string_view(p_Document["m_eCurrentClosetType"])));

	s_Object.m_rCloset = simdjson::from_json_uint32(p_Document["m_rCloset"]);

	*reinterpret_cast<SMovementHideInClosetSaveData*>(p_Target) = s_Object;
}

void SMovementHideInClosetSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);

}

bool SMovementHideInClosetSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementHideInClosetSaveData::operator==(const SMovementHideInClosetSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementHideInClosetSaveData>)
		return false;

	if (m_eCurrentClosetType != p_Other.m_eCurrentClosetType) return false;
	if (m_rCloset != p_Other.m_rCloset) return false;

	return true;
}

ZHMTypeInfo SMovementLadderSaveData::TypeInfo = ZHMTypeInfo("SMovementLadderSaveData", sizeof(SMovementLadderSaveData), alignof(SMovementLadderSaveData), SMovementLadderSaveData::WriteJson, SMovementLadderSaveData::WriteSimpleJson, SMovementLadderSaveData::FromSimpleJson, SMovementLadderSaveData::Serialize, SMovementLadderSaveData::Equals);

void SMovementLadderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rLadder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLadder);
	p_Stream << "}";

	p_Stream << "}";
}

void SMovementLadderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rLadder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLadder);

	p_Stream << "}";
}

void SMovementLadderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementLadderSaveData s_Object {};

	s_Object.m_rLadder = simdjson::from_json_uint32(p_Document["m_rLadder"]);

	*reinterpret_cast<SMovementLadderSaveData*>(p_Target) = s_Object;
}

void SMovementLadderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);

}

bool SMovementLadderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementLadderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementLadderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementLadderSaveData::operator==(const SMovementLadderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementLadderSaveData>)
		return false;

	if (m_rLadder != p_Other.m_rLadder) return false;

	return true;
}

ZHMTypeInfo SMovementLocomotionSaveData::TypeInfo = ZHMTypeInfo("SMovementLocomotionSaveData", sizeof(SMovementLocomotionSaveData), alignof(SMovementLocomotionSaveData), SMovementLocomotionSaveData::WriteJson, SMovementLocomotionSaveData::WriteSimpleJson, SMovementLocomotionSaveData::FromSimpleJson, SMovementLocomotionSaveData::Serialize, SMovementLocomotionSaveData::Equals);

void SMovementLocomotionSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsSneaking") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSneaking);
	p_Stream << "}";

	p_Stream << "}";
}

void SMovementLocomotionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsSneaking") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSneaking);

	p_Stream << "}";
}

void SMovementLocomotionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementLocomotionSaveData s_Object {};

	s_Object.m_bIsSneaking = simdjson::from_json_bool(p_Document["m_bIsSneaking"]);

	*reinterpret_cast<SMovementLocomotionSaveData*>(p_Target) = s_Object;
}

void SMovementLocomotionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);

}

bool SMovementLocomotionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementLocomotionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementLocomotionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementLocomotionSaveData::operator==(const SMovementLocomotionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementLocomotionSaveData>)
		return false;

	if (m_bIsSneaking != p_Other.m_bIsSneaking) return false;

	return true;
}

ZHMTypeInfo SMusicGridData::TypeInfo = ZHMTypeInfo("SMusicGridData", sizeof(SMusicGridData), alignof(SMusicGridData), SMusicGridData::WriteJson, SMusicGridData::WriteSimpleJson, SMusicGridData::FromSimpleJson, SMusicGridData::Serialize, SMusicGridData::Equals);

void SMusicGridData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fGridDurationSec") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridDurationSec);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridOffsetSec") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridOffsetSec);
	p_Stream << "}";

	p_Stream << "}";
}

void SMusicGridData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fGridDurationSec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridDurationSec);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridOffsetSec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridOffsetSec);

	p_Stream << "}";
}

void SMusicGridData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMusicGridData s_Object {};

	s_Object.m_fGridDurationSec = simdjson::from_json_float32(p_Document["m_fGridDurationSec"]);

	s_Object.m_fGridOffsetSec = simdjson::from_json_float32(p_Document["m_fGridOffsetSec"]);

	*reinterpret_cast<SMusicGridData*>(p_Target) = s_Object;
}

void SMusicGridData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);

}

bool SMusicGridData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMusicGridData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMusicGridData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMusicGridData::operator==(const SMusicGridData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMusicGridData>)
		return false;

	if (m_fGridDurationSec != p_Other.m_fGridDurationSec) return false;
	if (m_fGridOffsetSec != p_Other.m_fGridOffsetSec) return false;

	return true;
}

ZHMTypeInfo SNRange::TypeInfo = ZHMTypeInfo("SNRange", sizeof(SNRange), alignof(SNRange), SNRange::WriteJson, SNRange::WriteSimpleJson, SNRange::FromSimpleJson, SNRange::Serialize, SNRange::Equals);

void SNRange::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nMin") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMin);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMax);
	p_Stream << "}";

	p_Stream << "}";
}

void SNRange::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nMin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMax);

	p_Stream << "}";
}

void SNRange::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SNRange s_Object {};

	s_Object.m_nMin = simdjson::from_json_int32(p_Document["m_nMin"]);

	s_Object.m_nMax = simdjson::from_json_int32(p_Document["m_nMax"]);

	*reinterpret_cast<SNRange*>(p_Target) = s_Object;
}

void SNRange::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);

}

bool SNRange::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SNRange*>(p_Left);
	auto* s_Right = reinterpret_cast<SNRange*>(p_Right);

	return *s_Left == *s_Right;
}

bool SNRange::operator==(const SNRange& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SNRange>)
		return false;

	if (m_nMin != p_Other.m_nMin) return false;
	if (m_nMax != p_Other.m_nMax) return false;

	return true;
}

ZHMTypeInfo SObserversGroupSaveData::TypeInfo = ZHMTypeInfo("SObserversGroupSaveData", sizeof(SObserversGroupSaveData), alignof(SObserversGroupSaveData), SObserversGroupSaveData::WriteJson, SObserversGroupSaveData::WriteSimpleJson, SObserversGroupSaveData::FromSimpleJson, SObserversGroupSaveData::Serialize, SObserversGroupSaveData::Equals);

void SObserversGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingObservers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingObservers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingObservers[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aWaitingObservers.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_observerDistanceMax") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_observerDistanceMax);
	p_Stream << "}";

	p_Stream << "}";
}

void SObserversGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingObservers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingObservers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingObservers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aWaitingObservers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_observerDistanceMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_observerDistanceMax);

	p_Stream << "}";
}

void SObserversGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SObserversGroupSaveData s_Object {};

	s_Object.m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aWaitingObservers"])
	{
		s_Object.m_aWaitingObservers.push_back(simdjson::from_json_uint32(s_Item0));
	}

	s_Object.m_observerDistanceMax = simdjson::from_json_float32(p_Document["m_observerDistanceMax"]);

	*reinterpret_cast<SObserversGroupSaveData*>(p_Target) = s_Object;
}

void SObserversGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aWaitingObservers, p_Serializer, p_OwnOffset + offsetof(SObserversGroupSaveData, m_aWaitingObservers));
}

bool SObserversGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SObserversGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SObserversGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SObserversGroupSaveData::operator==(const SObserversGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SObserversGroupSaveData>)
		return false;

	if (m_target != p_Other.m_target) return false;
	if (m_aWaitingObservers != p_Other.m_aWaitingObservers) return false;
	if (m_observerDistanceMax != p_Other.m_observerDistanceMax) return false;

	return true;
}

ZHMTypeInfo SOnlineEvent::TypeInfo = ZHMTypeInfo("SOnlineEvent", sizeof(SOnlineEvent), alignof(SOnlineEvent), SOnlineEvent::WriteJson, SOnlineEvent::WriteSimpleJson, SOnlineEvent::FromSimpleJson, SOnlineEvent::Serialize, SOnlineEvent::Equals);

void SOnlineEvent::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
	ZDynamicObject::WriteJson(&s_Object->data, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SOnlineEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("data") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->data, p_Stream);

	p_Stream << "}";
}

void SOnlineEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SOnlineEvent s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["data"], &s_Item);
		s_Object.data = s_Item;
	}

	*reinterpret_cast<SOnlineEvent*>(p_Target) = s_Object;
}

void SOnlineEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SOnlineEvent, sName));
	ZDynamicObject::Serialize(&s_Object->data, p_Serializer, p_OwnOffset + offsetof(SOnlineEvent, data));
}

bool SOnlineEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SOnlineEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<SOnlineEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool SOnlineEvent::operator==(const SOnlineEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SOnlineEvent>)
		return false;

	if (sName != p_Other.sName) return false;
	if (data != p_Other.data) return false;

	return true;
}

ZHMTypeInfo SOnlineSaveData::TypeInfo = ZHMTypeInfo("SOnlineSaveData", sizeof(SOnlineSaveData), alignof(SOnlineSaveData), SOnlineSaveData::WriteJson, SOnlineSaveData::WriteSimpleJson, SOnlineSaveData::FromSimpleJson, SOnlineSaveData::Serialize, SOnlineSaveData::Equals);

void SOnlineSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOnlineSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeStamp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTimeStamp);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOnline") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOnline);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractSessionId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractSessionId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLastEventToken") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLastEventToken);
	p_Stream << "}";

	p_Stream << "}";
}

void SOnlineSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOnlineSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeStamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTimeStamp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOnline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOnline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractSessionId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractSessionId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLastEventToken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLastEventToken);

	p_Stream << "}";
}

void SOnlineSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SOnlineSaveData s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	s_Object.m_nTimeStamp = simdjson::from_json_int64(p_Document["m_nTimeStamp"]);

	s_Object.m_bIsOnline = simdjson::from_json_bool(p_Document["m_bIsOnline"]);

	s_Object.m_sContractSessionId = std::string_view(p_Document["m_sContractSessionId"]);

	s_Object.m_sLastEventToken = std::string_view(p_Document["m_sLastEventToken"]);

	*reinterpret_cast<SOnlineSaveData*>(p_Target) = s_Object;
}

void SOnlineSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SOnlineSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SOnlineSaveData, m_sName));
	ZString::Serialize(&s_Object->m_sContractSessionId, p_Serializer, p_OwnOffset + offsetof(SOnlineSaveData, m_sContractSessionId));
	ZString::Serialize(&s_Object->m_sLastEventToken, p_Serializer, p_OwnOffset + offsetof(SOnlineSaveData, m_sLastEventToken));
}

bool SOnlineSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SOnlineSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SOnlineSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SOnlineSaveData::operator==(const SOnlineSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SOnlineSaveData>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_nTimeStamp != p_Other.m_nTimeStamp) return false;
	if (m_bIsOnline != p_Other.m_bIsOnline) return false;
	if (m_sContractSessionId != p_Other.m_sContractSessionId) return false;
	if (m_sLastEventToken != p_Other.m_sLastEventToken) return false;

	return true;
}

ZHMTypeInfo SOptionValueSaveData::TypeInfo = ZHMTypeInfo("SOptionValueSaveData", sizeof(SOptionValueSaveData), alignof(SOptionValueSaveData), SOptionValueSaveData::WriteJson, SOptionValueSaveData::WriteSimpleJson, SOptionValueSaveData::FromSimpleJson, SOptionValueSaveData::Serialize, SOptionValueSaveData::Equals);

void SOptionValueSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_Value") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_Value, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SOptionValueSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Value, p_Stream);

	p_Stream << "}";
}

void SOptionValueSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SOptionValueSaveData s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Value"], &s_Item);
		s_Object.m_Value = s_Item;
	}

	*reinterpret_cast<SOptionValueSaveData*>(p_Target) = s_Object;
}

void SOptionValueSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Value, p_Serializer, p_OwnOffset + offsetof(SOptionValueSaveData, m_Value));
}

bool SOptionValueSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SOptionValueSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SOptionValueSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SOptionValueSaveData::operator==(const SOptionValueSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SOptionValueSaveData>)
		return false;

	if (m_Value != p_Other.m_Value) return false;

	return true;
}

ZHMTypeInfo SPFObstactleSaveData::TypeInfo = ZHMTypeInfo("SPFObstactleSaveData", sizeof(SPFObstactleSaveData), alignof(SPFObstactleSaveData), SPFObstactleSaveData::WriteJson, SPFObstactleSaveData::WriteSimpleJson, SPFObstactleSaveData::FromSimpleJson, SPFObstactleSaveData::Serialize, SPFObstactleSaveData::Equals);

void SPFObstactleSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void SPFObstactleSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SPFObstactleSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPFObstactleSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SPFObstactleSaveData*>(p_Target) = s_Object;
}

void SPFObstactleSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);

}

bool SPFObstactleSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPFObstactleSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPFObstactleSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPFObstactleSaveData::operator==(const SPFObstactleSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPFObstactleSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

ZHMTypeInfo SPatrolGroupSaveData::TypeInfo = ZHMTypeInfo("SPatrolGroupSaveData", sizeof(SPatrolGroupSaveData), alignof(SPatrolGroupSaveData), SPatrolGroupSaveData::WriteJson, SPatrolGroupSaveData::WriteSimpleJson, SPatrolGroupSaveData::FromSimpleJson, SPatrolGroupSaveData::Serialize, SPatrolGroupSaveData::Equals);

void SPatrolGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nRouteID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRouteID);
	p_Stream << "}";

	p_Stream << "}";
}

void SPatrolGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nRouteID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRouteID);

	p_Stream << "}";
}

void SPatrolGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPatrolGroupSaveData s_Object {};

	s_Object.m_nRouteID = simdjson::from_json_int32(p_Document["m_nRouteID"]);

	*reinterpret_cast<SPatrolGroupSaveData*>(p_Target) = s_Object;
}

void SPatrolGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);

}

bool SPatrolGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPatrolGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPatrolGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPatrolGroupSaveData::operator==(const SPatrolGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPatrolGroupSaveData>)
		return false;

	if (m_nRouteID != p_Other.m_nRouteID) return false;

	return true;
}

ZHMTypeInfo SPatrolOrderSaveData::TypeInfo = ZHMTypeInfo("SPatrolOrderSaveData", sizeof(SPatrolOrderSaveData), alignof(SPatrolOrderSaveData), SPatrolOrderSaveData::WriteJson, SPatrolOrderSaveData::WriteSimpleJson, SPatrolOrderSaveData::FromSimpleJson, SPatrolOrderSaveData::Serialize, SPatrolOrderSaveData::Equals);

void SPatrolOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SPatrolOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SPatrolOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPatrolOrderSaveData s_Object {};

	*reinterpret_cast<SPatrolOrderSaveData*>(p_Target) = s_Object;
}

void SPatrolOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);

}

bool SPatrolOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPatrolOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPatrolOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPatrolOrderSaveData::operator==(const SPatrolOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPatrolOrderSaveData>)
		return false;


	return true;
}

ZHMTypeInfo SPerceptibleCrowdBodySaveData::TypeInfo = ZHMTypeInfo("SPerceptibleCrowdBodySaveData", sizeof(SPerceptibleCrowdBodySaveData), alignof(SPerceptibleCrowdBodySaveData), SPerceptibleCrowdBodySaveData::WriteJson, SPerceptibleCrowdBodySaveData::WriteSimpleJson, SPerceptibleCrowdBodySaveData::FromSimpleJson, SPerceptibleCrowdBodySaveData::Serialize, SPerceptibleCrowdBodySaveData::Equals);

void SPerceptibleCrowdBodySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rCombatZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCombatZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSharedKnowledge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSharedKnowledge);
	p_Stream << "}";

	p_Stream << "}";
}

void SPerceptibleCrowdBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCombatZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCombatZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSharedKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSharedKnowledge);

	p_Stream << "}";
}

void SPerceptibleCrowdBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPerceptibleCrowdBodySaveData s_Object {};

	s_Object.m_rCombatZone = simdjson::from_json_uint32(p_Document["m_rCombatZone"]);

	s_Object.m_rSharedKnowledge = simdjson::from_json_int32(p_Document["m_rSharedKnowledge"]);

	*reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Target) = s_Object;
}

void SPerceptibleCrowdBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);

}

bool SPerceptibleCrowdBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPerceptibleCrowdBodySaveData::operator==(const SPerceptibleCrowdBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPerceptibleCrowdBodySaveData>)
		return false;

	if (m_rCombatZone != p_Other.m_rCombatZone) return false;
	if (m_rSharedKnowledge != p_Other.m_rSharedKnowledge) return false;

	return true;
}

ZHMTypeInfo SPersistentEntitySaveData::TypeInfo = ZHMTypeInfo("SPersistentEntitySaveData", sizeof(SPersistentEntitySaveData), alignof(SPersistentEntitySaveData), SPersistentEntitySaveData::WriteJson, SPersistentEntitySaveData::WriteSimpleJson, SPersistentEntitySaveData::FromSimpleJson, SPersistentEntitySaveData::Serialize, SPersistentEntitySaveData::Equals);

void SPersistentEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nResourceId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nResourceId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityNames") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityNames.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityNames[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntityNames.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SPersistentEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nResourceId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nResourceId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityNames") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityNames.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityNames[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityNames.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPersistentEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPersistentEntitySaveData s_Object {};

	s_Object.m_nResourceId = simdjson::from_json_uint64(p_Document["m_nResourceId"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntityNames"])
	{
		s_Object.m_aEntityNames.push_back(std::string_view(s_Item0));
	}

	*reinterpret_cast<SPersistentEntitySaveData*>(p_Target) = s_Object;
}

void SPersistentEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);

	TArray<ZString>::Serialize(&s_Object->m_aEntityNames, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveData, m_aEntityNames));
}

bool SPersistentEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPersistentEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPersistentEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPersistentEntitySaveData::operator==(const SPersistentEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPersistentEntitySaveData>)
		return false;

	if (m_nResourceId != p_Other.m_nResourceId) return false;
	if (m_aEntityNames != p_Other.m_aEntityNames) return false;

	return true;
}

ZHMTypeInfo SPersistentEntitySaveDataList::TypeInfo = ZHMTypeInfo("SPersistentEntitySaveDataList", sizeof(SPersistentEntitySaveDataList), alignof(SPersistentEntitySaveDataList), SPersistentEntitySaveDataList::WriteJson, SPersistentEntitySaveDataList::WriteSimpleJson, SPersistentEntitySaveDataList::FromSimpleJson, SPersistentEntitySaveDataList::Serialize, SPersistentEntitySaveDataList::Equals);

void SPersistentEntitySaveDataList::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntityDatas") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SPersistentEntitySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityDatas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityDatas[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SPersistentEntitySaveData") << ",\"$val\":";
		SPersistentEntitySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEntityDatas.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SPersistentEntitySaveDataList::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntityDatas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityDatas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityDatas[i];
		SPersistentEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityDatas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPersistentEntitySaveDataList::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPersistentEntitySaveDataList s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntityDatas"])
	{
		SPersistentEntitySaveData s_ArrayItem0;
		SPersistentEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEntityDatas.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SPersistentEntitySaveDataList*>(p_Target) = s_Object;
}

void SPersistentEntitySaveDataList::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);

	TArray<SPersistentEntitySaveData>::Serialize(&s_Object->m_aEntityDatas, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveDataList, m_aEntityDatas));
}

bool SPersistentEntitySaveDataList::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Left);
	auto* s_Right = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPersistentEntitySaveDataList::operator==(const SPersistentEntitySaveDataList& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPersistentEntitySaveDataList>)
		return false;

	if (m_aEntityDatas != p_Other.m_aEntityDatas) return false;

	return true;
}

ZHMTypeInfo SPhysicsSaveData::TypeInfo = ZHMTypeInfo("SPhysicsSaveData", sizeof(SPhysicsSaveData), alignof(SPhysicsSaveData), SPhysicsSaveData::WriteJson, SPhysicsSaveData::WriteSimpleJson, SPhysicsSaveData::FromSimpleJson, SPhysicsSaveData::Serialize, SPhysicsSaveData::Equals);

void SPhysicsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsInPhysicsWorld") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInPhysicsWorld);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsKinematicBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsKinematicBody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << "}";

	p_Stream << "}";
}

void SPhysicsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInPhysicsWorld") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInPhysicsWorld);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsKinematicBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsKinematicBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);

	p_Stream << "}";
}

void SPhysicsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPhysicsSaveData s_Object {};

	s_Object.m_bIsInPhysicsWorld = simdjson::from_json_bool(p_Document["m_bIsInPhysicsWorld"]);

	s_Object.m_bIsKinematicBody = simdjson::from_json_bool(p_Document["m_bIsKinematicBody"]);

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	*reinterpret_cast<SPhysicsSaveData*>(p_Target) = s_Object;
}

void SPhysicsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);

}

bool SPhysicsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPhysicsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPhysicsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPhysicsSaveData::operator==(const SPhysicsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPhysicsSaveData>)
		return false;

	if (m_bIsInPhysicsWorld != p_Other.m_bIsInPhysicsWorld) return false;
	if (m_bIsKinematicBody != p_Other.m_bIsKinematicBody) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;

	return true;
}

ZHMTypeInfo SPhysicsListSaveData::TypeInfo = ZHMTypeInfo("SPhysicsListSaveData", sizeof(SPhysicsListSaveData), alignof(SPhysicsListSaveData), SPhysicsListSaveData::WriteJson, SPhysicsListSaveData::WriteSimpleJson, SPhysicsListSaveData::FromSimpleJson, SPhysicsListSaveData::Serialize, SPhysicsListSaveData::Equals);

void SPhysicsListSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntityRefs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityRefs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityRefs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntityRefs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityDatas") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SPhysicsSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityDatas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityDatas[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SPhysicsSaveData") << ",\"$val\":";
		SPhysicsSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEntityDatas.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SPhysicsListSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntityRefs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityRefs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityRefs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityRefs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityDatas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityDatas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityDatas[i];
		SPhysicsSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityDatas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPhysicsListSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPhysicsListSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntityRefs"])
	{
		s_Object.m_aEntityRefs.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntityDatas"])
	{
		SPhysicsSaveData s_ArrayItem0;
		SPhysicsSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEntityDatas.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SPhysicsListSaveData*>(p_Target) = s_Object;
}

void SPhysicsListSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntityRefs, p_Serializer, p_OwnOffset + offsetof(SPhysicsListSaveData, m_aEntityRefs));
	TArray<SPhysicsSaveData>::Serialize(&s_Object->m_aEntityDatas, p_Serializer, p_OwnOffset + offsetof(SPhysicsListSaveData, m_aEntityDatas));
}

bool SPhysicsListSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPhysicsListSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPhysicsListSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPhysicsListSaveData::operator==(const SPhysicsListSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPhysicsListSaveData>)
		return false;

	if (m_aEntityRefs != p_Other.m_aEntityRefs) return false;
	if (m_aEntityDatas != p_Other.m_aEntityDatas) return false;

	return true;
}

ZHMTypeInfo SPrivateAreaSaveData::TypeInfo = ZHMTypeInfo("SPrivateAreaSaveData", sizeof(SPrivateAreaSaveData), alignof(SPrivateAreaSaveData), SPrivateAreaSaveData::WriteJson, SPrivateAreaSaveData::WriteSimpleJson, SPrivateAreaSaveData::FromSimpleJson, SPrivateAreaSaveData::Serialize, SPrivateAreaSaveData::Equals);

void SPrivateAreaSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsInside") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInside);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nHasEntered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHasEntered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasExited") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasExited);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpotted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpotted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHitmanEnterPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vHitmanEnterPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHitmanExitPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vHitmanExitPosition, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SPrivateAreaSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInside") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInside);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nHasEntered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHasEntered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasExited") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasExited);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpotted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpotted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHitmanEnterPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vHitmanEnterPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHitmanExitPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vHitmanExitPosition, p_Stream);

	p_Stream << "}";
}

void SPrivateAreaSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPrivateAreaSaveData s_Object {};

	s_Object.m_bIsInside = simdjson::from_json_bool(p_Document["m_bIsInside"]);

	s_Object.m_nHasEntered = simdjson::from_json_bool(p_Document["m_nHasEntered"]);

	s_Object.m_bHasExited = simdjson::from_json_bool(p_Document["m_bHasExited"]);

	s_Object.m_bSpotted = simdjson::from_json_bool(p_Document["m_bSpotted"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vHitmanEnterPosition"], &s_Item);
		s_Object.m_vHitmanEnterPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vHitmanExitPosition"], &s_Item);
		s_Object.m_vHitmanExitPosition = s_Item;
	}

	*reinterpret_cast<SPrivateAreaSaveData*>(p_Target) = s_Object;
}

void SPrivateAreaSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vHitmanEnterPosition, p_Serializer, p_OwnOffset + offsetof(SPrivateAreaSaveData, m_vHitmanEnterPosition));
	float4::Serialize(&s_Object->m_vHitmanExitPosition, p_Serializer, p_OwnOffset + offsetof(SPrivateAreaSaveData, m_vHitmanExitPosition));
}

bool SPrivateAreaSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPrivateAreaSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPrivateAreaSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPrivateAreaSaveData::operator==(const SPrivateAreaSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPrivateAreaSaveData>)
		return false;

	if (m_bIsInside != p_Other.m_bIsInside) return false;
	if (m_nHasEntered != p_Other.m_nHasEntered) return false;
	if (m_bHasExited != p_Other.m_bHasExited) return false;
	if (m_bSpotted != p_Other.m_bSpotted) return false;
	if (m_vHitmanEnterPosition != p_Other.m_vHitmanEnterPosition) return false;
	if (m_vHitmanExitPosition != p_Other.m_vHitmanExitPosition) return false;

	return true;
}

ZHMTypeInfo SRandomTimerEntitySaveData::TypeInfo = ZHMTypeInfo("SRandomTimerEntitySaveData", sizeof(SRandomTimerEntitySaveData), alignof(SRandomTimerEntitySaveData), SRandomTimerEntitySaveData::WriteJson, SRandomTimerEntitySaveData::WriteSimpleJson, SRandomTimerEntitySaveData::FromSimpleJson, SRandomTimerEntitySaveData::Serialize, SRandomTimerEntitySaveData::Equals);

void SRandomTimerEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegistered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegistered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMinTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMinTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMaxTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMaxTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProbability") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProbability);
	p_Stream << "}";

	p_Stream << "}";
}

void SRandomTimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegistered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMinTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMinTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMaxTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMaxTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProbability") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProbability);

	p_Stream << "}";
}

void SRandomTimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRandomTimerEntitySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bRegistered = simdjson::from_json_bool(p_Document["m_bRegistered"]);

	s_Object.m_fMinTime = simdjson::from_json_float32(p_Document["m_fMinTime"]);

	s_Object.m_fMaxTime = simdjson::from_json_float32(p_Document["m_fMaxTime"]);

	s_Object.m_fProbability = simdjson::from_json_float32(p_Document["m_fProbability"]);

	*reinterpret_cast<SRandomTimerEntitySaveData*>(p_Target) = s_Object;
}

void SRandomTimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);

}

bool SRandomTimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRandomTimerEntitySaveData::operator==(const SRandomTimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRandomTimerEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bRegistered != p_Other.m_bRegistered) return false;
	if (m_fMinTime != p_Other.m_fMinTime) return false;
	if (m_fMaxTime != p_Other.m_fMaxTime) return false;
	if (m_fProbability != p_Other.m_fProbability) return false;

	return true;
}

ZHMTypeInfo SRandomTimerEntitiesSaveData::TypeInfo = ZHMTypeInfo("SRandomTimerEntitiesSaveData", sizeof(SRandomTimerEntitiesSaveData), alignof(SRandomTimerEntitiesSaveData), SRandomTimerEntitiesSaveData::WriteJson, SRandomTimerEntitiesSaveData::WriteSimpleJson, SRandomTimerEntitiesSaveData::FromSimpleJson, SRandomTimerEntitiesSaveData::Serialize, SRandomTimerEntitiesSaveData::Equals);

void SRandomTimerEntitiesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SRandomTimerEntitySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SRandomTimerEntitySaveData") << ",\"$val\":";
		SRandomTimerEntitySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SRandomTimerEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SRandomTimerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SRandomTimerEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRandomTimerEntitiesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		SRandomTimerEntitySaveData s_ArrayItem0;
		SRandomTimerEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Target) = s_Object;
}

void SRandomTimerEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SRandomTimerEntitiesSaveData, m_aEntities));
	TArray<SRandomTimerEntitySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SRandomTimerEntitiesSaveData, m_aData));
}

bool SRandomTimerEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRandomTimerEntitiesSaveData::operator==(const SRandomTimerEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRandomTimerEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo ZBitArray::TypeInfo = ZHMTypeInfo("ZBitArray", sizeof(ZBitArray), alignof(ZBitArray), ZBitArray::WriteJson, ZBitArray::WriteSimpleJson, ZBitArray::FromSimpleJson, ZBitArray::Serialize, ZBitArray::Equals);

void ZBitArray::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aBytes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBytes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBytes[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aBytes.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSize);
	p_Stream << "}";

	p_Stream << "}";
}

void ZBitArray::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBytes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBytes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBytes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBytes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSize);

	p_Stream << "}";
}

void ZBitArray::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZBitArray s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aBytes"])
	{
		s_Object.m_aBytes.push_back(simdjson::from_json_uint8(s_Item0));
	}

	s_Object.m_nSize = simdjson::from_json_uint32(p_Document["m_nSize"]);

	*reinterpret_cast<ZBitArray*>(p_Target) = s_Object;
}

void ZBitArray::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aBytes, p_Serializer, p_OwnOffset + offsetof(ZBitArray, m_aBytes));
}

bool ZBitArray::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZBitArray*>(p_Left);
	auto* s_Right = reinterpret_cast<ZBitArray*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZBitArray::operator==(const ZBitArray& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZBitArray>)
		return false;

	if (m_aBytes != p_Other.m_aBytes) return false;
	if (m_nSize != p_Other.m_nSize) return false;

	return true;
}

ZHMTypeInfo SReasoningGrid::TypeInfo = ZHMTypeInfo("SReasoningGrid", sizeof(SReasoningGrid), alignof(SReasoningGrid), SReasoningGrid::WriteJson, SReasoningGrid::WriteSimpleJson, SReasoningGrid::FromSimpleJson, SReasoningGrid::Serialize, SReasoningGrid::Equals);

void SReasoningGrid::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_WaypointList") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SGWaypoint>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_WaypointList.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_WaypointList[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SGWaypoint") << ",\"$val\":";
		SGWaypoint::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_WaypointList.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LowVisibilityBits") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZBitArray") << ",\"$val\":";
	ZBitArray::WriteJson(&s_Object->m_LowVisibilityBits, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighVisibilityBits") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZBitArray") << ",\"$val\":";
	ZBitArray::WriteJson(&s_Object->m_HighVisibilityBits, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Properties") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SGProperties") << ",\"$val\":";
	SGProperties::WriteJson(&s_Object->m_Properties, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNodeCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNodeCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pVisibilityData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint8>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_pVisibilityData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_pVisibilityData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_pVisibilityData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadEndData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZBitArray") << ",\"$val\":";
	ZBitArray::WriteJson(&s_Object->m_deadEndData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SReasoningGrid::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_WaypointList") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_WaypointList.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_WaypointList[i];
		SGWaypoint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_WaypointList.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LowVisibilityBits") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_LowVisibilityBits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighVisibilityBits") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_HighVisibilityBits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Properties") << ":";
	SGProperties::WriteSimpleJson(&s_Object->m_Properties, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNodeCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNodeCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pVisibilityData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_pVisibilityData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_pVisibilityData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_pVisibilityData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadEndData") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_deadEndData, p_Stream);

	p_Stream << "}";
}

void SReasoningGrid::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SReasoningGrid s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_WaypointList"])
	{
		SGWaypoint s_ArrayItem0;
		SGWaypoint::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_WaypointList.push_back(s_ArrayItem0);
	}

	{
		ZBitArray s_Item {};
		ZBitArray::FromSimpleJson(p_Document["m_LowVisibilityBits"], &s_Item);
		s_Object.m_LowVisibilityBits = s_Item;
	}

	{
		ZBitArray s_Item {};
		ZBitArray::FromSimpleJson(p_Document["m_HighVisibilityBits"], &s_Item);
		s_Object.m_HighVisibilityBits = s_Item;
	}

	{
		SGProperties s_Item {};
		SGProperties::FromSimpleJson(p_Document["m_Properties"], &s_Item);
		s_Object.m_Properties = s_Item;
	}

	s_Object.m_nNodeCount = simdjson::from_json_uint32(p_Document["m_nNodeCount"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_pVisibilityData"])
	{
		s_Object.m_pVisibilityData.push_back(simdjson::from_json_uint8(s_Item0));
	}

	{
		ZBitArray s_Item {};
		ZBitArray::FromSimpleJson(p_Document["m_deadEndData"], &s_Item);
		s_Object.m_deadEndData = s_Item;
	}

	*reinterpret_cast<SReasoningGrid*>(p_Target) = s_Object;
}

void SReasoningGrid::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	TArray<SGWaypoint>::Serialize(&s_Object->m_WaypointList, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_WaypointList));
	ZBitArray::Serialize(&s_Object->m_LowVisibilityBits, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_LowVisibilityBits));
	ZBitArray::Serialize(&s_Object->m_HighVisibilityBits, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_HighVisibilityBits));
	SGProperties::Serialize(&s_Object->m_Properties, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_Properties));
	TArray<uint8>::Serialize(&s_Object->m_pVisibilityData, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_pVisibilityData));
	ZBitArray::Serialize(&s_Object->m_deadEndData, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_deadEndData));
}

bool SReasoningGrid::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SReasoningGrid*>(p_Left);
	auto* s_Right = reinterpret_cast<SReasoningGrid*>(p_Right);

	return *s_Left == *s_Right;
}

bool SReasoningGrid::operator==(const SReasoningGrid& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SReasoningGrid>)
		return false;

	if (m_WaypointList != p_Other.m_WaypointList) return false;
	if (m_LowVisibilityBits != p_Other.m_LowVisibilityBits) return false;
	if (m_HighVisibilityBits != p_Other.m_HighVisibilityBits) return false;
	if (m_Properties != p_Other.m_Properties) return false;
	if (m_nNodeCount != p_Other.m_nNodeCount) return false;
	if (m_pVisibilityData != p_Other.m_pVisibilityData) return false;
	if (m_deadEndData != p_Other.m_deadEndData) return false;

	return true;
}

ZHMTypeInfo SRecoverUnconsciousGroupSaveData::TypeInfo = ZHMTypeInfo("SRecoverUnconsciousGroupSaveData", sizeof(SRecoverUnconsciousGroupSaveData), alignof(SRecoverUnconsciousGroupSaveData), SRecoverUnconsciousGroupSaveData::WriteJson, SRecoverUnconsciousGroupSaveData::WriteSimpleJson, SRecoverUnconsciousGroupSaveData::FromSimpleJson, SRecoverUnconsciousGroupSaveData::Serialize, SRecoverUnconsciousGroupSaveData::Equals);

void SRecoverUnconsciousGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVictim") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVictim);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rWaker") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rWaker);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWokenUpInTheGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWokenUpInTheGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFastWakeUp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFastWakeUp);
	p_Stream << "}";

	p_Stream << "}";
}

void SRecoverUnconsciousGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rWaker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rWaker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWokenUpInTheGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWokenUpInTheGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFastWakeUp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFastWakeUp);

	p_Stream << "}";
}

void SRecoverUnconsciousGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRecoverUnconsciousGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_rVictim = simdjson::from_json_uint32(p_Document["m_rVictim"]);

	s_Object.m_rWaker = simdjson::from_json_uint32(p_Document["m_rWaker"]);

	s_Object.m_fTimer = simdjson::from_json_float32(p_Document["m_fTimer"]);

	s_Object.m_bEscalate = simdjson::from_json_bool(p_Document["m_bEscalate"]);

	s_Object.m_bWokenUpInTheGroup = simdjson::from_json_bool(p_Document["m_bWokenUpInTheGroup"]);

	s_Object.m_bFastWakeUp = simdjson::from_json_bool(p_Document["m_bFastWakeUp"]);

	*reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Target) = s_Object;
}

void SRecoverUnconsciousGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SRecoverUnconsciousGroupSaveData, m_fsmState));
}

bool SRecoverUnconsciousGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRecoverUnconsciousGroupSaveData::operator==(const SRecoverUnconsciousGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRecoverUnconsciousGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rVictim != p_Other.m_rVictim) return false;
	if (m_rWaker != p_Other.m_rWaker) return false;
	if (m_fTimer != p_Other.m_fTimer) return false;
	if (m_bEscalate != p_Other.m_bEscalate) return false;
	if (m_bWokenUpInTheGroup != p_Other.m_bWokenUpInTheGroup) return false;
	if (m_bFastWakeUp != p_Other.m_bFastWakeUp) return false;

	return true;
}

ZHMTypeInfo SRemoteControlReceiverSaveData::TypeInfo = ZHMTypeInfo("SRemoteControlReceiverSaveData", sizeof(SRemoteControlReceiverSaveData), alignof(SRemoteControlReceiverSaveData), SRemoteControlReceiverSaveData::WriteJson, SRemoteControlReceiverSaveData::WriteSimpleJson, SRemoteControlReceiverSaveData::FromSimpleJson, SRemoteControlReceiverSaveData::Serialize, SRemoteControlReceiverSaveData::Equals);

void SRemoteControlReceiverSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReceiverActivated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReceiverActivated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);
	p_Stream << "}";

	p_Stream << "}";
}

void SRemoteControlReceiverSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReceiverActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReceiverActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);

	p_Stream << "}";
}

void SRemoteControlReceiverSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRemoteControlReceiverSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bReceiverActivated = simdjson::from_json_bool(p_Document["m_bReceiverActivated"]);

	s_Object.m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

	*reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Target) = s_Object;
}

void SRemoteControlReceiverSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);

}

bool SRemoteControlReceiverSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRemoteControlReceiverSaveData::operator==(const SRemoteControlReceiverSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRemoteControlReceiverSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bReceiverActivated != p_Other.m_bReceiverActivated) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;

	return true;
}

ZHMTypeInfo SRenderVideoPlayerSaveData::TypeInfo = ZHMTypeInfo("SRenderVideoPlayerSaveData", sizeof(SRenderVideoPlayerSaveData), alignof(SRenderVideoPlayerSaveData), SRenderVideoPlayerSaveData::WriteJson, SRenderVideoPlayerSaveData::WriteSimpleJson, SRenderVideoPlayerSaveData::FromSimpleJson, SRenderVideoPlayerSaveData::Serialize, SRenderVideoPlayerSaveData::Equals);

void SRenderVideoPlayerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bPlaying") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlaying);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLooping") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLooping);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseAlpha") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseAlpha);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirstFrame") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirstFrame);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVideoError") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVideoError);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldBeStopped") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldBeStopped);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_LastVisible, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_StartTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SRenderVideoPlayerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPlaying") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlaying);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLooping") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLooping);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirstFrame") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirstFrame);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVideoError") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVideoError);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldBeStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldBeStopped);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastVisible") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_LastVisible, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_StartTime, p_Stream);

	p_Stream << "}";
}

void SRenderVideoPlayerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRenderVideoPlayerSaveData s_Object {};

	s_Object.m_bPlaying = simdjson::from_json_bool(p_Document["m_bPlaying"]);

	s_Object.m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	s_Object.m_bLooping = simdjson::from_json_bool(p_Document["m_bLooping"]);

	s_Object.m_bUseAlpha = simdjson::from_json_bool(p_Document["m_bUseAlpha"]);

	s_Object.m_bFirstFrame = simdjson::from_json_bool(p_Document["m_bFirstFrame"]);

	s_Object.m_bRunning = simdjson::from_json_bool(p_Document["m_bRunning"]);

	s_Object.m_bVideoError = simdjson::from_json_bool(p_Document["m_bVideoError"]);

	s_Object.m_bShouldBeStopped = simdjson::from_json_bool(p_Document["m_bShouldBeStopped"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_LastVisible"], &s_Item);
		s_Object.m_LastVisible = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_StartTime"], &s_Item);
		s_Object.m_StartTime = s_Item;
	}

	*reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Target) = s_Object;
}

void SRenderVideoPlayerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_LastVisible, p_Serializer, p_OwnOffset + offsetof(SRenderVideoPlayerSaveData, m_LastVisible));
	ZGameTime::Serialize(&s_Object->m_StartTime, p_Serializer, p_OwnOffset + offsetof(SRenderVideoPlayerSaveData, m_StartTime));
}

bool SRenderVideoPlayerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRenderVideoPlayerSaveData::operator==(const SRenderVideoPlayerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRenderVideoPlayerSaveData>)
		return false;

	if (m_bPlaying != p_Other.m_bPlaying) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;
	if (m_bLooping != p_Other.m_bLooping) return false;
	if (m_bUseAlpha != p_Other.m_bUseAlpha) return false;
	if (m_bFirstFrame != p_Other.m_bFirstFrame) return false;
	if (m_bRunning != p_Other.m_bRunning) return false;
	if (m_bVideoError != p_Other.m_bVideoError) return false;
	if (m_bShouldBeStopped != p_Other.m_bShouldBeStopped) return false;
	if (m_LastVisible != p_Other.m_LastVisible) return false;
	if (m_StartTime != p_Other.m_StartTime) return false;

	return true;
}

ZHMTypeInfo SRepositionOrderSaveData::TypeInfo = ZHMTypeInfo("SRepositionOrderSaveData", sizeof(SRepositionOrderSaveData), alignof(SRepositionOrderSaveData), SRepositionOrderSaveData::WriteJson, SRepositionOrderSaveData::WriteSimpleJson, SRepositionOrderSaveData::FromSimpleJson, SRepositionOrderSaveData::Serialize, SRepositionOrderSaveData::Equals);

void SRepositionOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bStrafe") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStrafe);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAimAtTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAimAtTarget);
	p_Stream << "}";

	p_Stream << "}";
}

void SRepositionOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStrafe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStrafe);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAimAtTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAimAtTarget);

	p_Stream << "}";
}

void SRepositionOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRepositionOrderSaveData s_Object {};

	s_Object.m_bStrafe = simdjson::from_json_bool(p_Document["m_bStrafe"]);

	s_Object.m_bAimAtTarget = simdjson::from_json_bool(p_Document["m_bAimAtTarget"]);

	*reinterpret_cast<SRepositionOrderSaveData*>(p_Target) = s_Object;
}

void SRepositionOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);

}

bool SRepositionOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRepositionOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRepositionOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRepositionOrderSaveData::operator==(const SRepositionOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRepositionOrderSaveData>)
		return false;

	if (m_bStrafe != p_Other.m_bStrafe) return false;
	if (m_bAimAtTarget != p_Other.m_bAimAtTarget) return false;

	return true;
}

ZHMTypeInfo SRotateEntitySaveData::TypeInfo = ZHMTypeInfo("SRotateEntitySaveData", sizeof(SRotateEntitySaveData), alignof(SRotateEntitySaveData), SRotateEntitySaveData::WriteJson, SRotateEntitySaveData::WriteSimpleJson, SRotateEntitySaveData::FromSimpleJson, SRotateEntitySaveData::Serialize, SRotateEntitySaveData::Equals);

void SRotateEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fXAxisSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fXAxisSpeed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fYAxisSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fYAxisSpeed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fZAxisSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fZAxisSpeed);
	p_Stream << "}";

	p_Stream << "}";
}

void SRotateEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fXAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fXAxisSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fYAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fYAxisSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fZAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fZAxisSpeed);

	p_Stream << "}";
}

void SRotateEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRotateEntitySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_fXAxisSpeed = simdjson::from_json_float32(p_Document["m_fXAxisSpeed"]);

	s_Object.m_fYAxisSpeed = simdjson::from_json_float32(p_Document["m_fYAxisSpeed"]);

	s_Object.m_fZAxisSpeed = simdjson::from_json_float32(p_Document["m_fZAxisSpeed"]);

	*reinterpret_cast<SRotateEntitySaveData*>(p_Target) = s_Object;
}

void SRotateEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);

}

bool SRotateEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRotateEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRotateEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRotateEntitySaveData::operator==(const SRotateEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRotateEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fXAxisSpeed != p_Other.m_fXAxisSpeed) return false;
	if (m_fYAxisSpeed != p_Other.m_fYAxisSpeed) return false;
	if (m_fZAxisSpeed != p_Other.m_fZAxisSpeed) return false;

	return true;
}

ZHMTypeInfo SSavableData::TypeInfo = ZHMTypeInfo("SSavableData", sizeof(SSavableData), alignof(SSavableData), SSavableData::WriteJson, SSavableData::WriteSimpleJson, SSavableData::FromSimpleJson, SSavableData::Serialize, SSavableData::Equals);

void SSavableData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_EntitiesData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_EntitiesData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_Data, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nId);
	p_Stream << "}";

	p_Stream << "}";
}

void SSavableData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EntitiesData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_EntitiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nId);

	p_Stream << "}";
}

void SSavableData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSavableData s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_EntitiesData"], &s_Item);
		s_Object.m_EntitiesData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Item);
		s_Object.m_Data = s_Item;
	}

	s_Object.m_nId = simdjson::from_json_uint32(p_Document["m_nId"]);

	*reinterpret_cast<SSavableData*>(p_Target) = s_Object;
}

void SSavableData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_EntitiesData, p_Serializer, p_OwnOffset + offsetof(SSavableData, m_EntitiesData));
	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SSavableData, m_Data));
}

bool SSavableData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSavableData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSavableData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSavableData::operator==(const SSavableData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSavableData>)
		return false;

	if (m_EntitiesData != p_Other.m_EntitiesData) return false;
	if (m_Data != p_Other.m_Data) return false;
	if (m_nId != p_Other.m_nId) return false;

	return true;
}

ZHMTypeInfo SVariantStruct::TypeInfo = ZHMTypeInfo("SVariantStruct", sizeof(SVariantStruct), alignof(SVariantStruct), SVariantStruct::WriteJson, SVariantStruct::WriteSimpleJson, SVariantStruct::FromSimpleJson, SVariantStruct::Serialize, SVariantStruct::Equals);

void SVariantStruct::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_Data") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_Data, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SVariantStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);

	p_Stream << "}";
}

void SVariantStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVariantStruct s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Item);
		s_Object.m_Data = s_Item;
	}

	*reinterpret_cast<SVariantStruct*>(p_Target) = s_Object;
}

void SVariantStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SVariantStruct, m_Data));
}

bool SVariantStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVariantStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SVariantStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVariantStruct::operator==(const SVariantStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVariantStruct>)
		return false;

	if (m_Data != p_Other.m_Data) return false;

	return true;
}

ZHMTypeInfo SSavableEntitiesSaveData::TypeInfo = ZHMTypeInfo("SSavableEntitiesSaveData", sizeof(SSavableEntitiesSaveData), alignof(SSavableEntitiesSaveData), SSavableEntitiesSaveData::WriteJson, SSavableEntitiesSaveData::WriteSimpleJson, SSavableEntitiesSaveData::FromSimpleJson, SSavableEntitiesSaveData::Serialize, SSavableEntitiesSaveData::Equals);

void SSavableEntitiesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SVariantStruct>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SVariantStruct") << ",\"$val\":";
		SVariantStruct::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEntityData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SSavableEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityData[i];
		SVariantStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSavableEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSavableEntitiesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntityData"])
	{
		SVariantStruct s_ArrayItem0;
		SVariantStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEntityData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SSavableEntitiesSaveData*>(p_Target) = s_Object;
}

void SSavableEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SSavableEntitiesSaveData, m_aEntities));
	TArray<SVariantStruct>::Serialize(&s_Object->m_aEntityData, p_Serializer, p_OwnOffset + offsetof(SSavableEntitiesSaveData, m_aEntityData));
}

bool SSavableEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSavableEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSavableEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSavableEntitiesSaveData::operator==(const SSavableEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSavableEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aEntityData != p_Other.m_aEntityData) return false;

	return true;
}

ZHMTypeInfo SSaveGameData::TypeInfo = ZHMTypeInfo("SSaveGameData", sizeof(SSaveGameData), alignof(SSaveGameData), SSaveGameData::WriteJson, SSaveGameData::WriteSimpleJson, SSaveGameData::FromSimpleJson, SSaveGameData::Serialize, SSaveGameData::Equals);

void SSaveGameData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSavableObjectsData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSavableData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSavableObjectsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSavableObjectsData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSavableData") << ",\"$val\":";
		SSavableData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aSavableObjectsData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityPaths") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityPath>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityPaths.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityPaths[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityPath") << ",\"$val\":";
		SEntityPath::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aEntityPaths.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SSaveGameData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSavableObjectsData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSavableObjectsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSavableObjectsData[i];
		SSavableData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSavableObjectsData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityPaths") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityPaths.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityPaths[i];
		SEntityPath::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityPaths.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSaveGameData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSaveGameData s_Object {};

	s_Object.m_nVersion = simdjson::from_json_uint32(p_Document["m_nVersion"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSavableObjectsData"])
	{
		SSavableData s_ArrayItem0;
		SSavableData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSavableObjectsData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntityPaths"])
	{
		SEntityPath s_ArrayItem0;
		SEntityPath::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEntityPaths.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SSaveGameData*>(p_Target) = s_Object;
}

void SSaveGameData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);

	TArray<SSavableData>::Serialize(&s_Object->m_aSavableObjectsData, p_Serializer, p_OwnOffset + offsetof(SSaveGameData, m_aSavableObjectsData));
	TArray<SEntityPath>::Serialize(&s_Object->m_aEntityPaths, p_Serializer, p_OwnOffset + offsetof(SSaveGameData, m_aEntityPaths));
}

bool SSaveGameData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameData::operator==(const SSaveGameData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameData>)
		return false;

	if (m_nVersion != p_Other.m_nVersion) return false;
	if (m_aSavableObjectsData != p_Other.m_aSavableObjectsData) return false;
	if (m_aEntityPaths != p_Other.m_aEntityPaths) return false;

	return true;
}

ZHMTypeInfo SSaveGameMetaData::TypeInfo = ZHMTypeInfo("SSaveGameMetaData", sizeof(SSaveGameMetaData), alignof(SSaveGameMetaData), SSaveGameMetaData::WriteJson, SSaveGameMetaData::WriteSimpleJson, SSaveGameMetaData::FromSimpleJson, SSaveGameMetaData::Serialize, SSaveGameMetaData::Equals);

void SSaveGameMetaData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("nSlot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint8") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nSlot);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eSaveType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ESaveType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->eSaveType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESaveType", static_cast<int>(s_Object->eSaveType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sContractId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractTitle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sContractTitle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sContractType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLocationId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sLocationId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractSessionId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sContractSessionId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLastEventToken") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sLastEventToken);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsOnline") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bIsOnline);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aScreenShot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aScreenShot.size(); ++i)
	{
		auto& s_Item0 = s_Object->aScreenShot[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->aScreenShot.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aRequirements") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ERequirementId>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aRequirements.size(); ++i)
	{
		auto& s_Item0 = s_Object->aRequirements[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ERequirementId") << ",\"$val\":";
		p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Item0)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ERequirementId", static_cast<int>(s_Item0))) << "}";
		p_Stream << "}";

		if (i < s_Object->aRequirements.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SSaveGameMetaData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nSlot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSlot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eSaveType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESaveType", static_cast<int>(s_Object->eSaveType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractTitle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLocationId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sLocationId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractSessionId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractSessionId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLastEventToken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sLastEventToken);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsOnline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsOnline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aScreenShot") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aScreenShot.size(); ++i)
	{
		auto& s_Item0 = s_Object->aScreenShot[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aScreenShot.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aRequirements") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aRequirements.size(); ++i)
	{
		auto& s_Item0 = s_Object->aRequirements[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ERequirementId", static_cast<int>(s_Item0)));

		if (i < s_Object->aRequirements.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSaveGameMetaData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSaveGameMetaData s_Object {};

	s_Object.nSlot = simdjson::from_json_uint8(p_Document["nSlot"]);

	s_Object.eSaveType = static_cast<ESaveType>(ZHMEnums::GetEnumValueByName("ESaveType", std::string_view(p_Document["eSaveType"])));

	s_Object.sContractId = std::string_view(p_Document["sContractId"]);

	s_Object.sContractTitle = std::string_view(p_Document["sContractTitle"]);

	s_Object.sContractType = std::string_view(p_Document["sContractType"]);

	s_Object.sLocationId = std::string_view(p_Document["sLocationId"]);

	s_Object.sContractSessionId = std::string_view(p_Document["sContractSessionId"]);

	s_Object.sLastEventToken = std::string_view(p_Document["sLastEventToken"]);

	s_Object.bIsOnline = simdjson::from_json_bool(p_Document["bIsOnline"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["aScreenShot"])
	{
		s_Object.aScreenShot.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["aRequirements"])
	{
		s_Object.aRequirements.push_back(static_cast<ERequirementId>(ZHMEnums::GetEnumValueByName("ERequirementId", std::string_view(s_Item0))));
	}

	*reinterpret_cast<SSaveGameMetaData*>(p_Target) = s_Object;
}

void SSaveGameMetaData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);

	ZString::Serialize(&s_Object->sContractId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractId));
	ZString::Serialize(&s_Object->sContractTitle, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractTitle));
	ZString::Serialize(&s_Object->sContractType, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractType));
	ZString::Serialize(&s_Object->sLocationId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sLocationId));
	ZString::Serialize(&s_Object->sContractSessionId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractSessionId));
	ZString::Serialize(&s_Object->sLastEventToken, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sLastEventToken));
	TArray<uint32>::Serialize(&s_Object->aScreenShot, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, aScreenShot));
	TArray<ERequirementId>::Serialize(&s_Object->aRequirements, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, aRequirements));
}

bool SSaveGameMetaData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameMetaData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameMetaData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameMetaData::operator==(const SSaveGameMetaData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameMetaData>)
		return false;

	if (nSlot != p_Other.nSlot) return false;
	if (eSaveType != p_Other.eSaveType) return false;
	if (sContractId != p_Other.sContractId) return false;
	if (sContractTitle != p_Other.sContractTitle) return false;
	if (sContractType != p_Other.sContractType) return false;
	if (sLocationId != p_Other.sLocationId) return false;
	if (sContractSessionId != p_Other.sContractSessionId) return false;
	if (sLastEventToken != p_Other.sLastEventToken) return false;
	if (bIsOnline != p_Other.bIsOnline) return false;
	if (aScreenShot != p_Other.aScreenShot) return false;
	if (aRequirements != p_Other.aRequirements) return false;

	return true;
}

ZHMTypeInfo SSaveGameHeader::TypeInfo = ZHMTypeInfo("SSaveGameHeader", sizeof(SSaveGameHeader), alignof(SSaveGameHeader), SSaveGameHeader::WriteJson, SSaveGameHeader::WriteSimpleJson, SSaveGameHeader::FromSimpleJson, SSaveGameHeader::Serialize, SSaveGameHeader::Equals);

void SSaveGameHeader::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("nFourCC") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nFourCC);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVersion") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nVersion);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nCrc32") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nCrc32);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nSize);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nTimeStamp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nTimeStamp);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("MetaData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SSaveGameMetaData") << ",\"$val\":";
	SSaveGameMetaData::WriteJson(&s_Object->MetaData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SSaveGameHeader::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nFourCC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nFourCC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nCrc32") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nCrc32);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nTimeStamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nTimeStamp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("MetaData") << ":";
	SSaveGameMetaData::WriteSimpleJson(&s_Object->MetaData, p_Stream);

	p_Stream << "}";
}

void SSaveGameHeader::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSaveGameHeader s_Object {};

	s_Object.nFourCC = simdjson::from_json_uint32(p_Document["nFourCC"]);

	s_Object.nVersion = simdjson::from_json_uint32(p_Document["nVersion"]);

	s_Object.nCrc32 = simdjson::from_json_uint32(p_Document["nCrc32"]);

	s_Object.nSize = simdjson::from_json_uint32(p_Document["nSize"]);

	s_Object.nTimeStamp = simdjson::from_json_int64(p_Document["nTimeStamp"]);

	{
		SSaveGameMetaData s_Item {};
		SSaveGameMetaData::FromSimpleJson(p_Document["MetaData"], &s_Item);
		s_Object.MetaData = s_Item;
	}

	*reinterpret_cast<SSaveGameHeader*>(p_Target) = s_Object;
}

void SSaveGameHeader::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);

	SSaveGameMetaData::Serialize(&s_Object->MetaData, p_Serializer, p_OwnOffset + offsetof(SSaveGameHeader, MetaData));
}

bool SSaveGameHeader::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameHeader*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameHeader*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameHeader::operator==(const SSaveGameHeader& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameHeader>)
		return false;

	if (nFourCC != p_Other.nFourCC) return false;
	if (nVersion != p_Other.nVersion) return false;
	if (nCrc32 != p_Other.nCrc32) return false;
	if (nSize != p_Other.nSize) return false;
	if (nTimeStamp != p_Other.nTimeStamp) return false;
	if (MetaData != p_Other.MetaData) return false;

	return true;
}

ZHMTypeInfo SScreenplayManagerSaveData::TypeInfo = ZHMTypeInfo("SScreenplayManagerSaveData", sizeof(SScreenplayManagerSaveData), alignof(SScreenplayManagerSaveData), SScreenplayManagerSaveData::WriteJson, SScreenplayManagerSaveData::WriteSimpleJson, SScreenplayManagerSaveData::FromSimpleJson, SScreenplayManagerSaveData::Serialize, SScreenplayManagerSaveData::Equals);

void SScreenplayManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_DramaActorData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SDramaActorCollectionSaveData") << ",\"$val\":";
	SDramaActorCollectionSaveData::WriteJson(&s_Object->m_DramaActorData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSituationData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SDramaSituationCollectionSaveData") << ",\"$val\":";
	SDramaSituationCollectionSaveData::WriteJson(&s_Object->m_DramaSituationData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSetupData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SDramaSetupCollectionSaveData") << ",\"$val\":";
	SDramaSetupCollectionSaveData::WriteJson(&s_Object->m_DramaSetupData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SScreenplayManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_DramaActorData") << ":";
	SDramaActorCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaActorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSituationData") << ":";
	SDramaSituationCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaSituationData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSetupData") << ":";
	SDramaSetupCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaSetupData, p_Stream);

	p_Stream << "}";
}

void SScreenplayManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SScreenplayManagerSaveData s_Object {};

	{
		SDramaActorCollectionSaveData s_Item {};
		SDramaActorCollectionSaveData::FromSimpleJson(p_Document["m_DramaActorData"], &s_Item);
		s_Object.m_DramaActorData = s_Item;
	}

	{
		SDramaSituationCollectionSaveData s_Item {};
		SDramaSituationCollectionSaveData::FromSimpleJson(p_Document["m_DramaSituationData"], &s_Item);
		s_Object.m_DramaSituationData = s_Item;
	}

	{
		SDramaSetupCollectionSaveData s_Item {};
		SDramaSetupCollectionSaveData::FromSimpleJson(p_Document["m_DramaSetupData"], &s_Item);
		s_Object.m_DramaSetupData = s_Item;
	}

	*reinterpret_cast<SScreenplayManagerSaveData*>(p_Target) = s_Object;
}

void SScreenplayManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);

	SDramaActorCollectionSaveData::Serialize(&s_Object->m_DramaActorData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaActorData));
	SDramaSituationCollectionSaveData::Serialize(&s_Object->m_DramaSituationData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaSituationData));
	SDramaSetupCollectionSaveData::Serialize(&s_Object->m_DramaSetupData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaSetupData));
}

bool SScreenplayManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SScreenplayManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SScreenplayManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SScreenplayManagerSaveData::operator==(const SScreenplayManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SScreenplayManagerSaveData>)
		return false;

	if (m_DramaActorData != p_Other.m_DramaActorData) return false;
	if (m_DramaSituationData != p_Other.m_DramaSituationData) return false;
	if (m_DramaSetupData != p_Other.m_DramaSetupData) return false;

	return true;
}

ZHMTypeInfo SSecuritySystemCameraSaveData::TypeInfo = ZHMTypeInfo("SSecuritySystemCameraSaveData", sizeof(SSecuritySystemCameraSaveData), alignof(SSecuritySystemCameraSaveData), SSecuritySystemCameraSaveData::WriteJson, SSecuritySystemCameraSaveData::WriteSimpleJson, SSecuritySystemCameraSaveData::FromSimpleJson, SSecuritySystemCameraSaveData::Serialize, SSecuritySystemCameraSaveData::Equals);

void SSecuritySystemCameraSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEscalation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEscalation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFunctional") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFunctional);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasEnteredOnce") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasEnteredOnce);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasInvestigated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasInvestigated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);
	p_Stream << "}";

	p_Stream << "}";
}

void SSecuritySystemCameraSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEscalation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEscalation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFunctional") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFunctional);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasEnteredOnce") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasEnteredOnce);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);

	p_Stream << "}";
}

void SSecuritySystemCameraSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSecuritySystemCameraSaveData s_Object {};

	s_Object.m_nEscalation = simdjson::from_json_uint16(p_Document["m_nEscalation"]);

	s_Object.m_bIsFunctional = simdjson::from_json_bool(p_Document["m_bIsFunctional"]);

	s_Object.m_bHasEnteredOnce = simdjson::from_json_bool(p_Document["m_bHasEnteredOnce"]);

	s_Object.m_bWasInvestigated = simdjson::from_json_bool(p_Document["m_bWasInvestigated"]);

	s_Object.m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

	*reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Target) = s_Object;
}

void SSecuritySystemCameraSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);

}

bool SSecuritySystemCameraSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSecuritySystemCameraSaveData::operator==(const SSecuritySystemCameraSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSecuritySystemCameraSaveData>)
		return false;

	if (m_nEscalation != p_Other.m_nEscalation) return false;
	if (m_bIsFunctional != p_Other.m_bIsFunctional) return false;
	if (m_bHasEnteredOnce != p_Other.m_bHasEnteredOnce) return false;
	if (m_bWasInvestigated != p_Other.m_bWasInvestigated) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;

	return true;
}

ZHMTypeInfo SSecuritySystemRecorderSaveData::TypeInfo = ZHMTypeInfo("SSecuritySystemRecorderSaveData", sizeof(SSecuritySystemRecorderSaveData), alignof(SSecuritySystemRecorderSaveData), SSecuritySystemRecorderSaveData::WriteJson, SSecuritySystemRecorderSaveData::WriteSimpleJson, SSecuritySystemRecorderSaveData::FromSimpleJson, SSecuritySystemRecorderSaveData::Serialize, SSecuritySystemRecorderSaveData::Equals);

void SSecuritySystemRecorderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bHasRecordings") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRecordings);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFunctional") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFunctional);
	p_Stream << "}";

	p_Stream << "}";
}

void SSecuritySystemRecorderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bHasRecordings") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRecordings);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFunctional") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFunctional);

	p_Stream << "}";
}

void SSecuritySystemRecorderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSecuritySystemRecorderSaveData s_Object {};

	s_Object.m_bHasRecordings = simdjson::from_json_bool(p_Document["m_bHasRecordings"]);

	s_Object.m_bIsFunctional = simdjson::from_json_bool(p_Document["m_bIsFunctional"]);

	*reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Target) = s_Object;
}

void SSecuritySystemRecorderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);

}

bool SSecuritySystemRecorderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSecuritySystemRecorderSaveData::operator==(const SSecuritySystemRecorderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSecuritySystemRecorderSaveData>)
		return false;

	if (m_bHasRecordings != p_Other.m_bHasRecordings) return false;
	if (m_bIsFunctional != p_Other.m_bIsFunctional) return false;

	return true;
}

ZHMTypeInfo SSentryGroupSaveData::TypeInfo = ZHMTypeInfo("SSentryGroupSaveData", sizeof(SSentryGroupSaveData), alignof(SSentryGroupSaveData), SSentryGroupSaveData::WriteJson, SSentryGroupSaveData::WriteSimpleJson, SSentryGroupSaveData::FromSimpleJson, SSentryGroupSaveData::Serialize, SSentryGroupSaveData::Equals);

void SSentryGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSentryZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSentryZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eActionPrompt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ESentryActionPrompt") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eActionPrompt)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESentryActionPrompt", static_cast<int>(s_Object->m_eActionPrompt))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRequestedAction") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRequestedAction);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowingWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowingWarning);
	p_Stream << "}";

	p_Stream << "}";
}

void SSentryGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSentryZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSentryZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eActionPrompt") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESentryActionPrompt", static_cast<int>(s_Object->m_eActionPrompt)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRequestedAction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRequestedAction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowingWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowingWarning);

	p_Stream << "}";
}

void SSentryGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSentryGroupSaveData s_Object {};

	s_Object.m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_rSentryZone = simdjson::from_json_uint32(p_Document["m_rSentryZone"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Item);
		s_Object.m_tLastEscalateOrder = s_Item;
	}

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_eActionPrompt = static_cast<ESentryActionPrompt>(ZHMEnums::GetEnumValueByName("ESentryActionPrompt", std::string_view(p_Document["m_eActionPrompt"])));

	s_Object.m_bRequestedAction = simdjson::from_json_bool(p_Document["m_bRequestedAction"]);

	s_Object.m_bShowingWarning = simdjson::from_json_bool(p_Document["m_bShowingWarning"]);

	*reinterpret_cast<SSentryGroupSaveData*>(p_Target) = s_Object;
}

void SSentryGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(SSentryGroupSaveData, m_tLastEscalateOrder));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SSentryGroupSaveData, m_fsmState));
}

bool SSentryGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryGroupSaveData::operator==(const SSentryGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_rSentryZone != p_Other.m_rSentryZone) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_eActionPrompt != p_Other.m_eActionPrompt) return false;
	if (m_bRequestedAction != p_Other.m_bRequestedAction) return false;
	if (m_bShowingWarning != p_Other.m_bShowingWarning) return false;

	return true;
}

ZHMTypeInfo SSentryOrderSaveData::TypeInfo = ZHMTypeInfo("SSentryOrderSaveData", sizeof(SSentryOrderSaveData), alignof(SSentryOrderSaveData), SSentryOrderSaveData::WriteJson, SSentryOrderSaveData::WriteSimpleJson, SSentryOrderSaveData::FromSimpleJson, SSentryOrderSaveData::Serialize, SSentryOrderSaveData::Equals);

void SSentryOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rSentryZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSentryZone);
	p_Stream << "}";

	p_Stream << "}";
}

void SSentryOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSentryZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSentryZone);

	p_Stream << "}";
}

void SSentryOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSentryOrderSaveData s_Object {};

	s_Object.m_rSentryZone = simdjson::from_json_uint32(p_Document["m_rSentryZone"]);

	*reinterpret_cast<SSentryOrderSaveData*>(p_Target) = s_Object;
}

void SSentryOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);

}

bool SSentryOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryOrderSaveData::operator==(const SSentryOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryOrderSaveData>)
		return false;

	if (m_rSentryZone != p_Other.m_rSentryZone) return false;

	return true;
}

ZHMTypeInfo SSentryZoneSaveData::TypeInfo = ZHMTypeInfo("SSentryZoneSaveData", sizeof(SSentryZoneSaveData), alignof(SSentryZoneSaveData), SSentryZoneSaveData::WriteJson, SSentryZoneSaveData::WriteSimpleJson, SSentryZoneSaveData::FromSimpleJson, SSentryZoneSaveData::Serialize, SSentryZoneSaveData::Equals);

void SSentryZoneSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_tGreetingCooldown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tGreetingCooldown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLoiteringCooldown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLoiteringCooldown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowingWarning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowingWarning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bLeftThroughWarningZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bLeftThroughWarningZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bEnteredThroughEntranceZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bEnteredThroughEntranceZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInEntranceZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bInEntranceZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInWarningZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bInWarningZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInGreetingZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bInGreetingZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInReFriskZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bInReFriskZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInRequiredDisguise") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInRequiredDisguise);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInFriskExemptDisguise") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInFriskExemptDisguise);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasRequiredItem") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRequiredItem);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanShowActionPrompt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanShowActionPrompt);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInAnyZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInAnyZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationActive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationActive);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrisked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrisked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItemChecked") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemChecked);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreeted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreeted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedInstruction") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedInstruction);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedLoitering") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedLoitering);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedUnexpected") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedUnexpected);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInFriskWarningZone") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInFriskWarningZone);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesAllowedDisabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesAllowedDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesAllowedDisabled[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aDisguisesAllowedDisabled.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesFriskExemptDisabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesFriskExemptDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesFriskExemptDisabled[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aDisguisesFriskExemptDisabled.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesDontEscalateOnLineCrossingDisabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SSentryZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tGreetingCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGreetingCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLoiteringCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLoiteringCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowingWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowingWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bLeftThroughWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bLeftThroughWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bEnteredThroughEntranceZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bEnteredThroughEntranceZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInEntranceZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInEntranceZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInGreetingZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInGreetingZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInReFriskZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInReFriskZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInRequiredDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInRequiredDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInFriskExemptDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInFriskExemptDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasRequiredItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRequiredItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanShowActionPrompt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanShowActionPrompt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInAnyZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInAnyZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrisked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrisked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItemChecked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemChecked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreeted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreeted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedInstruction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedInstruction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedLoitering") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedLoitering);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedUnexpected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedUnexpected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInFriskWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInFriskWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesAllowedDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesAllowedDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesAllowedDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesAllowedDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesFriskExemptDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesFriskExemptDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesFriskExemptDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesFriskExemptDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesDontEscalateOnLineCrossingDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSentryZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSentryZoneSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tGreetingCooldown"], &s_Item);
		s_Object.m_tGreetingCooldown = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLoiteringCooldown"], &s_Item);
		s_Object.m_tLoiteringCooldown = s_Item;
	}

	s_Object.m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	s_Object.m_bShowingWarning = simdjson::from_json_bool(p_Document["m_bShowingWarning"]);

	s_Object.bLeftThroughWarningZone = simdjson::from_json_bool(p_Document["bLeftThroughWarningZone"]);

	s_Object.bEnteredThroughEntranceZone = simdjson::from_json_bool(p_Document["bEnteredThroughEntranceZone"]);

	s_Object.bInEntranceZone = simdjson::from_json_bool(p_Document["bInEntranceZone"]);

	s_Object.bInWarningZone = simdjson::from_json_bool(p_Document["bInWarningZone"]);

	s_Object.bInGreetingZone = simdjson::from_json_bool(p_Document["bInGreetingZone"]);

	s_Object.bInReFriskZone = simdjson::from_json_bool(p_Document["bInReFriskZone"]);

	s_Object.m_bInRequiredDisguise = simdjson::from_json_bool(p_Document["m_bInRequiredDisguise"]);

	s_Object.m_bInFriskExemptDisguise = simdjson::from_json_bool(p_Document["m_bInFriskExemptDisguise"]);

	s_Object.m_bHasRequiredItem = simdjson::from_json_bool(p_Document["m_bHasRequiredItem"]);

	s_Object.m_bCanShowActionPrompt = simdjson::from_json_bool(p_Document["m_bCanShowActionPrompt"]);

	s_Object.m_bTargetInAnyZone = simdjson::from_json_bool(p_Document["m_bTargetInAnyZone"]);

	s_Object.m_bSituationActive = simdjson::from_json_bool(p_Document["m_bSituationActive"]);

	s_Object.m_bFrisked = simdjson::from_json_bool(p_Document["m_bFrisked"]);

	s_Object.m_bItemChecked = simdjson::from_json_bool(p_Document["m_bItemChecked"]);

	s_Object.m_bGreeted = simdjson::from_json_bool(p_Document["m_bGreeted"]);

	s_Object.m_bGreetedInstruction = simdjson::from_json_bool(p_Document["m_bGreetedInstruction"]);

	s_Object.m_bGreetedLoitering = simdjson::from_json_bool(p_Document["m_bGreetedLoitering"]);

	s_Object.m_bGreetedUnexpected = simdjson::from_json_bool(p_Document["m_bGreetedUnexpected"]);

	s_Object.m_bInFriskWarningZone = simdjson::from_json_bool(p_Document["m_bInFriskWarningZone"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aDisguisesAllowedDisabled"])
	{
		s_Object.m_aDisguisesAllowedDisabled.push_back(simdjson::from_json_bool(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aDisguisesFriskExemptDisabled"])
	{
		s_Object.m_aDisguisesFriskExemptDisabled.push_back(simdjson::from_json_bool(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aDisguisesDontEscalateOnLineCrossingDisabled"])
	{
		s_Object.m_aDisguisesDontEscalateOnLineCrossingDisabled.push_back(simdjson::from_json_bool(s_Item0));
	}

	*reinterpret_cast<SSentryZoneSaveData*>(p_Target) = s_Object;
}

void SSentryZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGreetingCooldown, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_tGreetingCooldown));
	ZGameTime::Serialize(&s_Object->m_tLoiteringCooldown, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_tLoiteringCooldown));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesAllowedDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesAllowedDisabled));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesFriskExemptDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesFriskExemptDisabled));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesDontEscalateOnLineCrossingDisabled));
}

bool SSentryZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryZoneSaveData::operator==(const SSentryZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryZoneSaveData>)
		return false;

	if (m_tGreetingCooldown != p_Other.m_tGreetingCooldown) return false;
	if (m_tLoiteringCooldown != p_Other.m_tLoiteringCooldown) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_bShowingWarning != p_Other.m_bShowingWarning) return false;
	if (bLeftThroughWarningZone != p_Other.bLeftThroughWarningZone) return false;
	if (bEnteredThroughEntranceZone != p_Other.bEnteredThroughEntranceZone) return false;
	if (bInEntranceZone != p_Other.bInEntranceZone) return false;
	if (bInWarningZone != p_Other.bInWarningZone) return false;
	if (bInGreetingZone != p_Other.bInGreetingZone) return false;
	if (bInReFriskZone != p_Other.bInReFriskZone) return false;
	if (m_bInRequiredDisguise != p_Other.m_bInRequiredDisguise) return false;
	if (m_bInFriskExemptDisguise != p_Other.m_bInFriskExemptDisguise) return false;
	if (m_bHasRequiredItem != p_Other.m_bHasRequiredItem) return false;
	if (m_bCanShowActionPrompt != p_Other.m_bCanShowActionPrompt) return false;
	if (m_bTargetInAnyZone != p_Other.m_bTargetInAnyZone) return false;
	if (m_bSituationActive != p_Other.m_bSituationActive) return false;
	if (m_bFrisked != p_Other.m_bFrisked) return false;
	if (m_bItemChecked != p_Other.m_bItemChecked) return false;
	if (m_bGreeted != p_Other.m_bGreeted) return false;
	if (m_bGreetedInstruction != p_Other.m_bGreetedInstruction) return false;
	if (m_bGreetedLoitering != p_Other.m_bGreetedLoitering) return false;
	if (m_bGreetedUnexpected != p_Other.m_bGreetedUnexpected) return false;
	if (m_bInFriskWarningZone != p_Other.m_bInFriskWarningZone) return false;
	if (m_aDisguisesAllowedDisabled != p_Other.m_aDisguisesAllowedDisabled) return false;
	if (m_aDisguisesFriskExemptDisabled != p_Other.m_aDisguisesFriskExemptDisabled) return false;
	if (m_aDisguisesDontEscalateOnLineCrossingDisabled != p_Other.m_aDisguisesDontEscalateOnLineCrossingDisabled) return false;

	return true;
}

ZHMTypeInfo SSequenceTrackSaveData::TypeInfo = ZHMTypeInfo("SSequenceTrackSaveData", sizeof(SSequenceTrackSaveData), alignof(SSequenceTrackSaveData), SSequenceTrackSaveData::WriteJson, SSequenceTrackSaveData::WriteSimpleJson, SSequenceTrackSaveData::FromSimpleJson, SSequenceTrackSaveData::Serialize, SSequenceTrackSaveData::Equals);

void SSequenceTrackSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rTrackEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTrackEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomTrackData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_CustomTrackData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SSequenceTrackSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTrackEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTrackEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomTrackData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomTrackData, p_Stream);

	p_Stream << "}";
}

void SSequenceTrackSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSequenceTrackSaveData s_Object {};

	s_Object.m_rTrackEntity = simdjson::from_json_uint32(p_Document["m_rTrackEntity"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CustomTrackData"], &s_Item);
		s_Object.m_CustomTrackData = s_Item;
	}

	*reinterpret_cast<SSequenceTrackSaveData*>(p_Target) = s_Object;
}

void SSequenceTrackSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_CustomTrackData, p_Serializer, p_OwnOffset + offsetof(SSequenceTrackSaveData, m_CustomTrackData));
}

bool SSequenceTrackSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceTrackSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceTrackSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceTrackSaveData::operator==(const SSequenceTrackSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceTrackSaveData>)
		return false;

	if (m_rTrackEntity != p_Other.m_rTrackEntity) return false;
	if (m_CustomTrackData != p_Other.m_CustomTrackData) return false;

	return true;
}

ZHMTypeInfo SSequenceSaveData::TypeInfo = ZHMTypeInfo("SSequenceSaveData", sizeof(SSequenceSaveData), alignof(SSequenceSaveData), SSequenceSaveData::WriteJson, SSequenceSaveData::WriteSimpleJson, SSequenceSaveData::FromSimpleJson, SSequenceSaveData::Serialize, SSequenceSaveData::Equals);

void SSequenceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_commandQueue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZSequenceEntity.ECommand>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_commandQueue.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_commandQueue[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZSequenceEntity.ECommand") << ",\"$val\":";
		p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Item0)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSequenceEntity.ECommand", static_cast<int>(s_Item0))) << "}";
		p_Stream << "}";

		if (i < s_Object->m_commandQueue.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sequenceTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_sequenceTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sequenceOrigin") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sequenceOrigin);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasRunData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRunData);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTrackSaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSequenceTrackSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackSaveData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSequenceTrackSaveData") << ",\"$val\":";
		SSequenceTrackSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aTrackSaveData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_effectiveSequenceTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_effectiveSequenceTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentLoop") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentLoop);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStateFlags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_eStateFlags);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPausedOnStart") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPausedOnStart);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivatedByIActivatable") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivatedByIActivatable);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGettingDeactivated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGettingDeactivated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOnGameStopped") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOnGameStopped);
	p_Stream << "}";

	p_Stream << "}";
}

void SSequenceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_commandQueue") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_commandQueue.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_commandQueue[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSequenceEntity.ECommand", static_cast<int>(s_Item0)));

		if (i < s_Object->m_commandQueue.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sequenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_sequenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sequenceOrigin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sequenceOrigin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasRunData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRunData);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTrackSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackSaveData[i];
		SSequenceTrackSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_effectiveSequenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_effectiveSequenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentLoop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentLoop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStateFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eStateFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPausedOnStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPausedOnStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivatedByIActivatable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivatedByIActivatable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGettingDeactivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGettingDeactivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOnGameStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOnGameStopped);

	p_Stream << "}";
}

void SSequenceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSequenceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_commandQueue"])
	{
		s_Object.m_commandQueue.push_back(static_cast<ZSequenceEntity_ECommand>(ZHMEnums::GetEnumValueByName("ZSequenceEntity.ECommand", std::string_view(s_Item0))));
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_sequenceTime"], &s_Item);
		s_Object.m_sequenceTime = s_Item;
	}

	s_Object.m_sequenceOrigin = simdjson::from_json_uint32(p_Document["m_sequenceOrigin"]);

	s_Object.m_bHasRunData = simdjson::from_json_bool(p_Document["m_bHasRunData"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aTrackSaveData"])
	{
		SSequenceTrackSaveData s_ArrayItem0;
		SSequenceTrackSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTrackSaveData.push_back(s_ArrayItem0);
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_effectiveSequenceTime"], &s_Item);
		s_Object.m_effectiveSequenceTime = s_Item;
	}

	s_Object.m_nCurrentLoop = simdjson::from_json_int32(p_Document["m_nCurrentLoop"]);

	s_Object.m_eStateFlags = simdjson::from_json_uint16(p_Document["m_eStateFlags"]);

	s_Object.m_bPausedOnStart = simdjson::from_json_bool(p_Document["m_bPausedOnStart"]);

	s_Object.m_bActivatedByIActivatable = simdjson::from_json_bool(p_Document["m_bActivatedByIActivatable"]);

	s_Object.m_bGettingDeactivated = simdjson::from_json_bool(p_Document["m_bGettingDeactivated"]);

	s_Object.m_bOnGameStopped = simdjson::from_json_bool(p_Document["m_bOnGameStopped"]);

	*reinterpret_cast<SSequenceSaveData*>(p_Target) = s_Object;
}

void SSequenceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);

	TArray<ZSequenceEntity_ECommand>::Serialize(&s_Object->m_commandQueue, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_commandQueue));
	ZGameTime::Serialize(&s_Object->m_sequenceTime, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_sequenceTime));
	TArray<SSequenceTrackSaveData>::Serialize(&s_Object->m_aTrackSaveData, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_aTrackSaveData));
	ZGameTime::Serialize(&s_Object->m_effectiveSequenceTime, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_effectiveSequenceTime));
}

bool SSequenceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceSaveData::operator==(const SSequenceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceSaveData>)
		return false;

	if (m_commandQueue != p_Other.m_commandQueue) return false;
	if (m_sequenceTime != p_Other.m_sequenceTime) return false;
	if (m_sequenceOrigin != p_Other.m_sequenceOrigin) return false;
	if (m_bHasRunData != p_Other.m_bHasRunData) return false;
	if (m_aTrackSaveData != p_Other.m_aTrackSaveData) return false;
	if (m_effectiveSequenceTime != p_Other.m_effectiveSequenceTime) return false;
	if (m_nCurrentLoop != p_Other.m_nCurrentLoop) return false;
	if (m_eStateFlags != p_Other.m_eStateFlags) return false;
	if (m_bPausedOnStart != p_Other.m_bPausedOnStart) return false;
	if (m_bActivatedByIActivatable != p_Other.m_bActivatedByIActivatable) return false;
	if (m_bGettingDeactivated != p_Other.m_bGettingDeactivated) return false;
	if (m_bOnGameStopped != p_Other.m_bOnGameStopped) return false;

	return true;
}

ZHMTypeInfo SSequenceManagerSaveData::TypeInfo = ZHMTypeInfo("SSequenceManagerSaveData", sizeof(SSequenceManagerSaveData), alignof(SSequenceManagerSaveData), SSequenceManagerSaveData::WriteJson, SSequenceManagerSaveData::WriteSimpleJson, SSequenceManagerSaveData::FromSimpleJson, SSequenceManagerSaveData::Serialize, SSequenceManagerSaveData::Equals);

void SSequenceManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSequenceSaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSequenceSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSequenceSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSequenceSaveData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSequenceSaveData") << ",\"$val\":";
		SSequenceSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aSequenceSaveData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SSequenceManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSequenceSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSequenceSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSequenceSaveData[i];
		SSequenceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSequenceSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSequenceManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSequenceManagerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSequenceSaveData"])
	{
		SSequenceSaveData s_ArrayItem0;
		SSequenceSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSequenceSaveData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SSequenceManagerSaveData*>(p_Target) = s_Object;
}

void SSequenceManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SSequenceManagerSaveData, m_aEntities));
	TArray<SSequenceSaveData>::Serialize(&s_Object->m_aSequenceSaveData, p_Serializer, p_OwnOffset + offsetof(SSequenceManagerSaveData, m_aSequenceSaveData));
}

bool SSequenceManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceManagerSaveData::operator==(const SSequenceManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceManagerSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aSequenceSaveData != p_Other.m_aSequenceSaveData) return false;

	return true;
}

ZHMTypeInfo SSerializedValue::TypeInfo = ZHMTypeInfo("SSerializedValue", sizeof(SSerializedValue), alignof(SSerializedValue), SSerializedValue::WriteJson, SSerializedValue::WriteSimpleJson, SSerializedValue::FromSimpleJson, SSerializedValue::Serialize, SSerializedValue::Equals);

void SSerializedValue::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SSerializedValue::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SSerializedValue::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSerializedValue s_Object {};

	*reinterpret_cast<SSerializedValue*>(p_Target) = s_Object;
}

void SSerializedValue::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

}

bool SSerializedValue::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSerializedValue*>(p_Left);
	auto* s_Right = reinterpret_cast<SSerializedValue*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSerializedValue::operator==(const SSerializedValue& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSerializedValue>)
		return false;


	return true;
}

ZHMTypeInfo SSettingsParamMultiplier::TypeInfo = ZHMTypeInfo("SSettingsParamMultiplier", sizeof(SSettingsParamMultiplier), alignof(SSettingsParamMultiplier), SSettingsParamMultiplier::WriteJson, SSettingsParamMultiplier::WriteSimpleJson, SSettingsParamMultiplier::FromSimpleJson, SSettingsParamMultiplier::Serialize, SSettingsParamMultiplier::Equals);

void SSettingsParamMultiplier::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eSettingsParam") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ESettingsParam") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSettingsParam)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESettingsParam", static_cast<int>(s_Object->m_eSettingsParam))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMultiplier") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMultiplier);
	p_Stream << "}";

	p_Stream << "}";
}

void SSettingsParamMultiplier::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSettingsParam") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESettingsParam", static_cast<int>(s_Object->m_eSettingsParam)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMultiplier);

	p_Stream << "}";
}

void SSettingsParamMultiplier::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSettingsParamMultiplier s_Object {};

	s_Object.m_eSettingsParam = static_cast<ESettingsParam>(ZHMEnums::GetEnumValueByName("ESettingsParam", std::string_view(p_Document["m_eSettingsParam"])));

	s_Object.m_fMultiplier = simdjson::from_json_float32(p_Document["m_fMultiplier"]);

	*reinterpret_cast<SSettingsParamMultiplier*>(p_Target) = s_Object;
}

void SSettingsParamMultiplier::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);

}

bool SSettingsParamMultiplier::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSettingsParamMultiplier*>(p_Left);
	auto* s_Right = reinterpret_cast<SSettingsParamMultiplier*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSettingsParamMultiplier::operator==(const SSettingsParamMultiplier& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSettingsParamMultiplier>)
		return false;

	if (m_eSettingsParam != p_Other.m_eSettingsParam) return false;
	if (m_fMultiplier != p_Other.m_fMultiplier) return false;

	return true;
}

ZHMTypeInfo SSituationConversationGroupSaveData::TypeInfo = ZHMTypeInfo("SSituationConversationGroupSaveData", sizeof(SSituationConversationGroupSaveData), alignof(SSituationConversationGroupSaveData), SSituationConversationGroupSaveData::WriteJson, SSituationConversationGroupSaveData::WriteSimpleJson, SSituationConversationGroupSaveData::FromSimpleJson, SSituationConversationGroupSaveData::Serialize, SSituationConversationGroupSaveData::Equals);

void SSituationConversationGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_members") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_members.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_members[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_members.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SSituationConversationGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_members") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_members.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_members[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_members.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSituationConversationGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationConversationGroupSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_members"])
	{
		s_Object.m_members.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SSituationConversationGroupSaveData*>(p_Target) = s_Object;
}

void SSituationConversationGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_members, p_Serializer, p_OwnOffset + offsetof(SSituationConversationGroupSaveData, m_members));
}

bool SSituationConversationGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationConversationGroupSaveData::operator==(const SSituationConversationGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationConversationGroupSaveData>)
		return false;

	if (m_members != p_Other.m_members) return false;

	return true;
}

ZHMTypeInfo SSituationOrderSaveData::TypeInfo = ZHMTypeInfo("SSituationOrderSaveData", sizeof(SSituationOrderSaveData), alignof(SSituationOrderSaveData), SSituationOrderSaveData::WriteJson, SSituationOrderSaveData::WriteSimpleJson, SSituationOrderSaveData::FromSimpleJson, SSituationOrderSaveData::Serialize, SSituationOrderSaveData::Equals);

void SSituationOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sClassTypeName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sClassTypeName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAISharedEventType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasPosition);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_CustomData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SSituationOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sClassTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sClassTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationOrderSaveData s_Object {};

	s_Object.m_sClassTypeName = std::string_view(p_Document["m_sClassTypeName"]);

	s_Object.m_eType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eType"])));

	s_Object.m_nTarget = simdjson::from_json_int32(p_Document["m_nTarget"]);

	s_Object.m_bHasPosition = simdjson::from_json_bool(p_Document["m_bHasPosition"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Item);
		s_Object.m_CustomData = s_Item;
	}

	*reinterpret_cast<SSituationOrderSaveData*>(p_Target) = s_Object;
}

void SSituationOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sClassTypeName, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_sClassTypeName));
	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_vPosition));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_CustomData));
}

bool SSituationOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationOrderSaveData::operator==(const SSituationOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationOrderSaveData>)
		return false;

	if (m_sClassTypeName != p_Other.m_sClassTypeName) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_nTarget != p_Other.m_nTarget) return false;
	if (m_bHasPosition != p_Other.m_bHasPosition) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

ZHMTypeInfo SSmuggleSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SSmuggleSituationActorStateSaveData", sizeof(SSmuggleSituationActorStateSaveData), alignof(SSmuggleSituationActorStateSaveData), SSmuggleSituationActorStateSaveData::WriteJson, SSmuggleSituationActorStateSaveData::WriteSimpleJson, SSmuggleSituationActorStateSaveData::FromSimpleJson, SSmuggleSituationActorStateSaveData::Serialize, SSmuggleSituationActorStateSaveData::Equals);

void SSmuggleSituationActorStateSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZSmuggleSituationEntity.ESmuggleState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSmuggleSituationEntity.ESmuggleState", static_cast<int>(s_Object->m_nState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStatePrevious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZSmuggleSituationEntity.ESmuggleState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nStatePrevious)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSmuggleSituationEntity.ESmuggleState", static_cast<int>(s_Object->m_nStatePrevious))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStateTimer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStateTimer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetLocationIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetLocationIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);
	p_Stream << "}";

	p_Stream << "}";
}

void SSmuggleSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSmuggleSituationEntity.ESmuggleState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSmuggleSituationEntity.ESmuggleState", static_cast<int>(s_Object->m_nStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStateTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStateTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetLocationIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetLocationIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);

	p_Stream << "}";
}

void SSmuggleSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSmuggleSituationActorStateSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_nState = static_cast<ZSmuggleSituationEntity_ESmuggleState>(ZHMEnums::GetEnumValueByName("ZSmuggleSituationEntity.ESmuggleState", std::string_view(p_Document["m_nState"])));

	s_Object.m_nStatePrevious = static_cast<ZSmuggleSituationEntity_ESmuggleState>(ZHMEnums::GetEnumValueByName("ZSmuggleSituationEntity.ESmuggleState", std::string_view(p_Document["m_nStatePrevious"])));

	s_Object.m_fStateTimer = simdjson::from_json_float32(p_Document["m_fStateTimer"]);

	s_Object.m_nTargetLocationIndex = simdjson::from_json_int32(p_Document["m_nTargetLocationIndex"]);

	s_Object.m_rScreenplay = simdjson::from_json_uint32(p_Document["m_rScreenplay"]);

	*reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Target) = s_Object;
}

void SSmuggleSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);

}

bool SSmuggleSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSmuggleSituationActorStateSaveData::operator==(const SSmuggleSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSmuggleSituationActorStateSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_nStatePrevious != p_Other.m_nStatePrevious) return false;
	if (m_fStateTimer != p_Other.m_fStateTimer) return false;
	if (m_nTargetLocationIndex != p_Other.m_nTargetLocationIndex) return false;
	if (m_rScreenplay != p_Other.m_rScreenplay) return false;

	return true;
}

ZHMTypeInfo SSmuggleSituationSaveData::TypeInfo = ZHMTypeInfo("SSmuggleSituationSaveData", sizeof(SSmuggleSituationSaveData), alignof(SSmuggleSituationSaveData), SSmuggleSituationSaveData::WriteJson, SSmuggleSituationSaveData::WriteSimpleJson, SSmuggleSituationSaveData::FromSimpleJson, SSmuggleSituationSaveData::Serialize, SSmuggleSituationSaveData::Equals);

void SSmuggleSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRunning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRunning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfPickups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfPickups);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorsSaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SSmuggleSituationActorStateSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorsSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorsSaveData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SSmuggleSituationActorStateSaveData") << ",\"$val\":";
		SSmuggleSituationActorStateSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aActorsSaveData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMoveToActs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMoveToActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMoveToActs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aMoveToActs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SSmuggleSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfPickups") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfPickups);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorsSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorsSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorsSaveData[i];
		SSmuggleSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorsSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMoveToActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMoveToActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMoveToActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aMoveToActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSmuggleSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSmuggleSituationSaveData s_Object {};

	s_Object.m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object.m_bIsRunning = simdjson::from_json_bool(p_Document["m_bIsRunning"]);

	s_Object.m_nNumberOfPickups = simdjson::from_json_int32(p_Document["m_nNumberOfPickups"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aActorsSaveData"])
	{
		SSmuggleSituationActorStateSaveData s_ArrayItem0;
		SSmuggleSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorsSaveData.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aMoveToActs"])
	{
		s_Object.m_aMoveToActs.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<SSmuggleSituationSaveData*>(p_Target) = s_Object;
}

void SSmuggleSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);

	TArray<SSmuggleSituationActorStateSaveData>::Serialize(&s_Object->m_aActorsSaveData, p_Serializer, p_OwnOffset + offsetof(SSmuggleSituationSaveData, m_aActorsSaveData));
	TArray<uint32>::Serialize(&s_Object->m_aMoveToActs, p_Serializer, p_OwnOffset + offsetof(SSmuggleSituationSaveData, m_aMoveToActs));
}

bool SSmuggleSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSmuggleSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSmuggleSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSmuggleSituationSaveData::operator==(const SSmuggleSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSmuggleSituationSaveData>)
		return false;

	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_bIsRunning != p_Other.m_bIsRunning) return false;
	if (m_nNumberOfPickups != p_Other.m_nNumberOfPickups) return false;
	if (m_aActorsSaveData != p_Other.m_aActorsSaveData) return false;
	if (m_aMoveToActs != p_Other.m_aMoveToActs) return false;

	return true;
}

ZHMTypeInfo SSniperCombatGroupSaveData::TypeInfo = ZHMTypeInfo("SSniperCombatGroupSaveData", sizeof(SSniperCombatGroupSaveData), alignof(SSniperCombatGroupSaveData), SSniperCombatGroupSaveData::WriteJson, SSniperCombatGroupSaveData::WriteSimpleJson, SSniperCombatGroupSaveData::FromSimpleJson, SSniperCombatGroupSaveData::Serialize, SSniperCombatGroupSaveData::Equals);

void SSniperCombatGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFailed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFailed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEscapeTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tEscapeTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTauntTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastTauntTime, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SSniperCombatGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEscapeTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEscapeTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTauntTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTauntTime, p_Stream);

	p_Stream << "}";
}

void SSniperCombatGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSniperCombatGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_bFailed = simdjson::from_json_bool(p_Document["m_bFailed"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tEscapeTime"], &s_Item);
		s_Object.m_tEscapeTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTauntTime"], &s_Item);
		s_Object.m_tLastTauntTime = s_Item;
	}

	*reinterpret_cast<SSniperCombatGroupSaveData*>(p_Target) = s_Object;
}

void SSniperCombatGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tEscapeTime, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_tEscapeTime));
	ZGameTime::Serialize(&s_Object->m_tLastTauntTime, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_tLastTauntTime));
}

bool SSniperCombatGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSniperCombatGroupSaveData::operator==(const SSniperCombatGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSniperCombatGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_bFailed != p_Other.m_bFailed) return false;
	if (m_tEscapeTime != p_Other.m_tEscapeTime) return false;
	if (m_tLastTauntTime != p_Other.m_tLastTauntTime) return false;

	return true;
}

ZHMTypeInfo SSpaceCollectionBehaviorConfiguration::TypeInfo = ZHMTypeInfo("SSpaceCollectionBehaviorConfiguration", sizeof(SSpaceCollectionBehaviorConfiguration), alignof(SSpaceCollectionBehaviorConfiguration), SSpaceCollectionBehaviorConfiguration::WriteJson, SSpaceCollectionBehaviorConfiguration::WriteSimpleJson, SSpaceCollectionBehaviorConfiguration::FromSimpleJson, SSpaceCollectionBehaviorConfiguration::Serialize, SSpaceCollectionBehaviorConfiguration::Equals);

void SSpaceCollectionBehaviorConfiguration::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bInclusive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInclusive);
	p_Stream << "}";

	p_Stream << "}";
}

void SSpaceCollectionBehaviorConfiguration::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bInclusive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInclusive);

	p_Stream << "}";
}

void SSpaceCollectionBehaviorConfiguration::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSpaceCollectionBehaviorConfiguration s_Object {};

	s_Object.m_bInclusive = simdjson::from_json_bool(p_Document["m_bInclusive"]);

	*reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Target) = s_Object;
}

void SSpaceCollectionBehaviorConfiguration::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);

}

bool SSpaceCollectionBehaviorConfiguration::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpaceCollectionBehaviorConfiguration::operator==(const SSpaceCollectionBehaviorConfiguration& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpaceCollectionBehaviorConfiguration>)
		return false;

	if (m_bInclusive != p_Other.m_bInclusive) return false;

	return true;
}

ZHMTypeInfo SSpatialMoverEntitySaveData::TypeInfo = ZHMTypeInfo("SSpatialMoverEntitySaveData", sizeof(SSpatialMoverEntitySaveData), alignof(SSpatialMoverEntitySaveData), SSpatialMoverEntitySaveData::WriteJson, SSpatialMoverEntitySaveData::WriteSimpleJson, SSpatialMoverEntitySaveData::FromSimpleJson, SSpatialMoverEntitySaveData::Serialize, SSpatialMoverEntitySaveData::Equals);

void SSpatialMoverEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpeed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBackwards") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBackwards);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFrameUpdateRegistered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFrameUpdateRegistered);
	p_Stream << "}";

	p_Stream << "}";
}

void SSpatialMoverEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBackwards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBackwards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFrameUpdateRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFrameUpdateRegistered);

	p_Stream << "}";
}

void SSpatialMoverEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSpatialMoverEntitySaveData s_Object {};

	s_Object.m_fSpeed = simdjson::from_json_float32(p_Document["m_fSpeed"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bBackwards = simdjson::from_json_bool(p_Document["m_bBackwards"]);

	s_Object.m_bIsFrameUpdateRegistered = simdjson::from_json_bool(p_Document["m_bIsFrameUpdateRegistered"]);

	*reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Target) = s_Object;
}

void SSpatialMoverEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSpatialMoverEntitySaveData, m_vPosition));
}

bool SSpatialMoverEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpatialMoverEntitySaveData::operator==(const SSpatialMoverEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpatialMoverEntitySaveData>)
		return false;

	if (m_fSpeed != p_Other.m_fSpeed) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bBackwards != p_Other.m_bBackwards) return false;
	if (m_bIsFrameUpdateRegistered != p_Other.m_bIsFrameUpdateRegistered) return false;

	return true;
}

ZHMTypeInfo SSpatialSaveData::TypeInfo = ZHMTypeInfo("SSpatialSaveData", sizeof(SSpatialSaveData), alignof(SSpatialSaveData), SSpatialSaveData::WriteJson, SSpatialSaveData::WriteSimpleJson, SSpatialSaveData::FromSimpleJson, SSpatialSaveData::Serialize, SSpatialSaveData::Equals);

void SSpatialSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternionRotation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vQuaternionRotation, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SSpatialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternionRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vQuaternionRotation, p_Stream);

	p_Stream << "}";
}

void SSpatialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSpatialSaveData s_Object {};

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vQuaternionRotation"], &s_Item);
		s_Object.m_vQuaternionRotation = s_Item;
	}

	*reinterpret_cast<SSpatialSaveData*>(p_Target) = s_Object;
}

void SSpatialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSpatialSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vQuaternionRotation, p_Serializer, p_OwnOffset + offsetof(SSpatialSaveData, m_vQuaternionRotation));
}

bool SSpatialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpatialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpatialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpatialSaveData::operator==(const SSpatialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpatialSaveData>)
		return false;

	if (m_bVisible != p_Other.m_bVisible) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vQuaternionRotation != p_Other.m_vQuaternionRotation) return false;

	return true;
}

ZHMTypeInfo SSpeakEntitySaveData::TypeInfo = ZHMTypeInfo("SSpeakEntitySaveData", sizeof(SSpeakEntitySaveData), alignof(SSpeakEntitySaveData), SSpeakEntitySaveData::WriteJson, SSpeakEntitySaveData::WriteSimpleJson, SSpeakEntitySaveData::FromSimpleJson, SSpeakEntitySaveData::Serialize, SSpeakEntitySaveData::Equals);

void SSpeakEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fSeekPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSeekPosition);
	p_Stream << "}";

	p_Stream << "}";
}

void SSpeakEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSeekPosition);

	p_Stream << "}";
}

void SSpeakEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSpeakEntitySaveData s_Object {};

	s_Object.m_fSeekPosition = simdjson::from_json_float32(p_Document["m_fSeekPosition"]);

	*reinterpret_cast<SSpeakEntitySaveData*>(p_Target) = s_Object;
}

void SSpeakEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);

}

bool SSpeakEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpeakEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpeakEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpeakEntitySaveData::operator==(const SSpeakEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpeakEntitySaveData>)
		return false;

	if (m_fSeekPosition != p_Other.m_fSeekPosition) return false;

	return true;
}

ZHMTypeInfo SStashPointSaveData::TypeInfo = ZHMTypeInfo("SStashPointSaveData", sizeof(SStashPointSaveData), alignof(SStashPointSaveData), SStashPointSaveData::WriteJson, SStashPointSaveData::WriteSimpleJson, SStashPointSaveData::FromSimpleJson, SStashPointSaveData::Serialize, SStashPointSaveData::Equals);

void SStashPointSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStashPointSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_arItems") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_arItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_arItems[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_arItems.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eContainedType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EStashpointContainedEntityType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eContainedType)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EStashpointContainedEntityType", static_cast<int>(s_Object->m_eContainedType))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MainItemID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->m_MainItemID, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SStashPointSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStashPointSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_arItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_arItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_arItems[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_arItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eContainedType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EStashpointContainedEntityType", static_cast<int>(s_Object->m_eContainedType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MainItemID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_MainItemID, p_Stream);

	p_Stream << "}";
}

void SStashPointSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStashPointSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_arItems"])
	{
		s_Object.m_arItems.push_back(simdjson::from_json_uint32(s_Item0));
	}

	s_Object.m_eContainedType = static_cast<EStashpointContainedEntityType>(ZHMEnums::GetEnumValueByName("EStashpointContainedEntityType", std::string_view(p_Document["m_eContainedType"])));

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_MainItemID"], &s_Item);
		s_Object.m_MainItemID = s_Item;
	}

	*reinterpret_cast<SStashPointSaveData*>(p_Target) = s_Object;
}

void SStashPointSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStashPointSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_arItems, p_Serializer, p_OwnOffset + offsetof(SStashPointSaveData, m_arItems));
	ZRepositoryID::Serialize(&s_Object->m_MainItemID, p_Serializer, p_OwnOffset + offsetof(SStashPointSaveData, m_MainItemID));
}

bool SStashPointSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStashPointSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStashPointSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStashPointSaveData::operator==(const SStashPointSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStashPointSaveData>)
		return false;

	if (m_arItems != p_Other.m_arItems) return false;
	if (m_eContainedType != p_Other.m_eContainedType) return false;
	if (m_MainItemID != p_Other.m_MainItemID) return false;

	return true;
}

ZHMTypeInfo SStateControllerSaveData::TypeInfo = ZHMTypeInfo("SStateControllerSaveData", sizeof(SStateControllerSaveData), alignof(SStateControllerSaveData), SStateControllerSaveData::WriteJson, SStateControllerSaveData::WriteSimpleJson, SStateControllerSaveData::FromSimpleJson, SStateControllerSaveData::Serialize, SStateControllerSaveData::Equals);

void SStateControllerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SStateControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SStateControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStateControllerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		s_Object.m_aData.push_back(simdjson::from_json_int32(s_Item0));
	}

	*reinterpret_cast<SStateControllerSaveData*>(p_Target) = s_Object;
}

void SStateControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SStateControllerSaveData, m_aEntities));
	TArray<int32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SStateControllerSaveData, m_aData));
}

bool SStateControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStateControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStateControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStateControllerSaveData::operator==(const SStateControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStateControllerSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SStepCounterEntitySaveData::TypeInfo = ZHMTypeInfo("SStepCounterEntitySaveData", sizeof(SStepCounterEntitySaveData), alignof(SStepCounterEntitySaveData), SStepCounterEntitySaveData::WriteJson, SStepCounterEntitySaveData::WriteSimpleJson, SStepCounterEntitySaveData::FromSimpleJson, SStepCounterEntitySaveData::Serialize, SStepCounterEntitySaveData::Equals);

void SStepCounterEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLoopIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLoopIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirst") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirst);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCountFrom") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCountFrom);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCountTo") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCountTo);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStepSize") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStepSize);
	p_Stream << "}";

	p_Stream << "}";
}

void SStepCounterEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLoopIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLoopIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirst") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirst);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCountFrom") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCountFrom);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCountTo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCountTo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStepSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStepSize);

	p_Stream << "}";
}

void SStepCounterEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStepCounterEntitySaveData s_Object {};

	s_Object.m_nIndex = simdjson::from_json_float32(p_Document["m_nIndex"]);

	s_Object.m_nLoopIndex = simdjson::from_json_int32(p_Document["m_nLoopIndex"]);

	s_Object.m_bFirst = simdjson::from_json_bool(p_Document["m_bFirst"]);

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_nCountFrom = simdjson::from_json_float32(p_Document["m_nCountFrom"]);

	s_Object.m_nCountTo = simdjson::from_json_float32(p_Document["m_nCountTo"]);

	s_Object.m_nStepSize = simdjson::from_json_float32(p_Document["m_nStepSize"]);

	*reinterpret_cast<SStepCounterEntitySaveData*>(p_Target) = s_Object;
}

void SStepCounterEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);

}

bool SStepCounterEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStepCounterEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStepCounterEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStepCounterEntitySaveData::operator==(const SStepCounterEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStepCounterEntitySaveData>)
		return false;

	if (m_nIndex != p_Other.m_nIndex) return false;
	if (m_nLoopIndex != p_Other.m_nLoopIndex) return false;
	if (m_bFirst != p_Other.m_bFirst) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_nCountFrom != p_Other.m_nCountFrom) return false;
	if (m_nCountTo != p_Other.m_nCountTo) return false;
	if (m_nStepSize != p_Other.m_nStepSize) return false;

	return true;
}

ZHMTypeInfo STargetInfoObjectiveCondition::TypeInfo = ZHMTypeInfo("STargetInfoObjectiveCondition", sizeof(STargetInfoObjectiveCondition), alignof(STargetInfoObjectiveCondition), STargetInfoObjectiveCondition::WriteJson, STargetInfoObjectiveCondition::WriteSimpleJson, STargetInfoObjectiveCondition::FromSimpleJson, STargetInfoObjectiveCondition::Serialize, STargetInfoObjectiveCondition::Equals);

void STargetInfoObjectiveCondition::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("header") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->header);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("title") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->title);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("hardCondition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->hardCondition);
	p_Stream << "}";

	p_Stream << "}";
}

void STargetInfoObjectiveCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("header") << ":";
	p_Stream << simdjson::as_json_string(s_Object->header);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("title") << ":";
	p_Stream << simdjson::as_json_string(s_Object->title);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("hardCondition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->hardCondition);

	p_Stream << "}";
}

void STargetInfoObjectiveCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetInfoObjectiveCondition s_Object {};

	s_Object.header = std::string_view(p_Document["header"]);

	s_Object.title = std::string_view(p_Document["title"]);

	s_Object.icon = std::string_view(p_Document["icon"]);

	s_Object.type = std::string_view(p_Document["type"]);

	s_Object.hardCondition = simdjson::from_json_bool(p_Document["hardCondition"]);

	*reinterpret_cast<STargetInfoObjectiveCondition*>(p_Target) = s_Object;
}

void STargetInfoObjectiveCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);

	ZString::Serialize(&s_Object->header, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, header));
	ZString::Serialize(&s_Object->title, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, title));
	ZString::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, icon));
	ZString::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, type));
}

bool STargetInfoObjectiveCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoObjectiveCondition::operator==(const STargetInfoObjectiveCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoObjectiveCondition>)
		return false;

	if (header != p_Other.header) return false;
	if (title != p_Other.title) return false;
	if (icon != p_Other.icon) return false;
	if (type != p_Other.type) return false;
	if (hardCondition != p_Other.hardCondition) return false;

	return true;
}

ZHMTypeInfo STargetInfoDisplayData::TypeInfo = ZHMTypeInfo("STargetInfoDisplayData", sizeof(STargetInfoDisplayData), alignof(STargetInfoDisplayData), STargetInfoDisplayData::WriteJson, STargetInfoDisplayData::WriteSimpleJson, STargetInfoDisplayData::FromSimpleJson, STargetInfoDisplayData::Serialize, STargetInfoDisplayData::Equals);

void STargetInfoDisplayData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("npcName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->npcName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("disguiseName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->disguiseName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->objectiveType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveConditions") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STargetInfoObjectiveCondition>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->objectiveConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->objectiveConditions[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STargetInfoObjectiveCondition") << ",\"$val\":";
		STargetInfoObjectiveCondition::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->objectiveConditions.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fX") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fX);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fY") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fY);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlpha") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fAlpha);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bIsTarget);
	p_Stream << "}";

	p_Stream << "}";
}

void STargetInfoDisplayData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("npcName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->npcName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("disguiseName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->disguiseName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->objectiveType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->objectiveConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->objectiveConditions[i];
		STargetInfoObjectiveCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->objectiveConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsTarget);

	p_Stream << "}";
}

void STargetInfoDisplayData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetInfoDisplayData s_Object {};

	s_Object.npcName = std::string_view(p_Document["npcName"]);

	s_Object.disguiseName = std::string_view(p_Document["disguiseName"]);

	s_Object.objectiveType = std::string_view(p_Document["objectiveType"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["objectiveConditions"])
	{
		STargetInfoObjectiveCondition s_ArrayItem0;
		STargetInfoObjectiveCondition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.objectiveConditions.push_back(s_ArrayItem0);
	}

	s_Object.fX = simdjson::from_json_int32(p_Document["fX"]);

	s_Object.fY = simdjson::from_json_int32(p_Document["fY"]);

	s_Object.fAlpha = simdjson::from_json_float32(p_Document["fAlpha"]);

	s_Object.bIsTarget = simdjson::from_json_bool(p_Document["bIsTarget"]);

	*reinterpret_cast<STargetInfoDisplayData*>(p_Target) = s_Object;
}

void STargetInfoDisplayData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);

	ZString::Serialize(&s_Object->npcName, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, npcName));
	ZString::Serialize(&s_Object->disguiseName, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, disguiseName));
	ZString::Serialize(&s_Object->objectiveType, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, objectiveType));
	TArray<STargetInfoObjectiveCondition>::Serialize(&s_Object->objectiveConditions, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, objectiveConditions));
}

bool STargetInfoDisplayData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoDisplayData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoDisplayData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoDisplayData::operator==(const STargetInfoDisplayData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoDisplayData>)
		return false;

	if (npcName != p_Other.npcName) return false;
	if (disguiseName != p_Other.disguiseName) return false;
	if (objectiveType != p_Other.objectiveType) return false;
	if (objectiveConditions != p_Other.objectiveConditions) return false;
	if (fX != p_Other.fX) return false;
	if (fY != p_Other.fY) return false;
	if (fAlpha != p_Other.fAlpha) return false;
	if (bIsTarget != p_Other.bIsTarget) return false;

	return true;
}

ZHMTypeInfo STargetInfoDisplayData_Dummy::TypeInfo = ZHMTypeInfo("STargetInfoDisplayData_Dummy", sizeof(STargetInfoDisplayData_Dummy), alignof(STargetInfoDisplayData_Dummy), STargetInfoDisplayData_Dummy::WriteJson, STargetInfoDisplayData_Dummy::WriteSimpleJson, STargetInfoDisplayData_Dummy::FromSimpleJson, STargetInfoDisplayData_Dummy::Serialize, STargetInfoDisplayData_Dummy::Equals);

void STargetInfoDisplayData_Dummy::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("__dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STargetInfoDisplayData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->__dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->__dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STargetInfoDisplayData") << ",\"$val\":";
		STargetInfoDisplayData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->__dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STargetInfoDisplayData_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("__dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->__dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->__dummy[i];
		STargetInfoDisplayData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->__dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STargetInfoDisplayData_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetInfoDisplayData_Dummy s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["__dummy"])
	{
		STargetInfoDisplayData s_ArrayItem0;
		STargetInfoDisplayData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.__dummy.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Target) = s_Object;
}

void STargetInfoDisplayData_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);

	TArray<STargetInfoDisplayData>::Serialize(&s_Object->__dummy, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData_Dummy, __dummy));
}

bool STargetInfoDisplayData_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoDisplayData_Dummy::operator==(const STargetInfoDisplayData_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoDisplayData_Dummy>)
		return false;

	if (__dummy != p_Other.__dummy) return false;

	return true;
}

ZHMTypeInfo STargetTrackingSaveData::TypeInfo = ZHMTypeInfo("STargetTrackingSaveData", sizeof(STargetTrackingSaveData), alignof(STargetTrackingSaveData), STargetTrackingSaveData::WriteJson, STargetTrackingSaveData::WriteSimpleJson, STargetTrackingSaveData::FromSimpleJson, STargetTrackingSaveData::Serialize, STargetTrackingSaveData::Equals);

void STargetTrackingSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sharedTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sharedTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_position") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_position, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_time") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_time, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void STargetTrackingSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sharedTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sharedTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_position") << ":";
	float4::WriteSimpleJson(&s_Object->m_position, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_time") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_time, p_Stream);

	p_Stream << "}";
}

void STargetTrackingSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetTrackingSaveData s_Object {};

	s_Object.m_sharedTarget = simdjson::from_json_int32(p_Document["m_sharedTarget"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_position"], &s_Item);
		s_Object.m_position = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_time"], &s_Item);
		s_Object.m_time = s_Item;
	}

	*reinterpret_cast<STargetTrackingSaveData*>(p_Target) = s_Object;
}

void STargetTrackingSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_position, p_Serializer, p_OwnOffset + offsetof(STargetTrackingSaveData, m_position));
	ZGameTime::Serialize(&s_Object->m_time, p_Serializer, p_OwnOffset + offsetof(STargetTrackingSaveData, m_time));
}

bool STargetTrackingSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetTrackingSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetTrackingSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetTrackingSaveData::operator==(const STargetTrackingSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetTrackingSaveData>)
		return false;

	if (m_sharedTarget != p_Other.m_sharedTarget) return false;
	if (m_position != p_Other.m_position) return false;
	if (m_time != p_Other.m_time) return false;

	return true;
}

ZHMTypeInfo STargetTrackingServiceSaveData::TypeInfo = ZHMTypeInfo("STargetTrackingServiceSaveData", sizeof(STargetTrackingServiceSaveData), alignof(STargetTrackingServiceSaveData), STargetTrackingServiceSaveData::WriteJson, STargetTrackingServiceSaveData::WriteSimpleJson, STargetTrackingServiceSaveData::FromSimpleJson, STargetTrackingServiceSaveData::Serialize, STargetTrackingServiceSaveData::Equals);

void STargetTrackingServiceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aTrackedTargets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STargetTrackingSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackedTargets.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackedTargets[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STargetTrackingSaveData") << ",\"$val\":";
		STargetTrackingSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aTrackedTargets.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STargetTrackingServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTrackedTargets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackedTargets.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackedTargets[i];
		STargetTrackingSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackedTargets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STargetTrackingServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetTrackingServiceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aTrackedTargets"])
	{
		STargetTrackingSaveData s_ArrayItem0;
		STargetTrackingSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTrackedTargets.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<STargetTrackingServiceSaveData*>(p_Target) = s_Object;
}

void STargetTrackingServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);

	TArray<STargetTrackingSaveData>::Serialize(&s_Object->m_aTrackedTargets, p_Serializer, p_OwnOffset + offsetof(STargetTrackingServiceSaveData, m_aTrackedTargets));
}

bool STargetTrackingServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetTrackingServiceSaveData::operator==(const STargetTrackingServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetTrackingServiceSaveData>)
		return false;

	if (m_aTrackedTargets != p_Other.m_aTrackedTargets) return false;

	return true;
}

ZHMTypeInfo STemplateSubEntity::TypeInfo = ZHMTypeInfo("STemplateSubEntity", sizeof(STemplateSubEntity), alignof(STemplateSubEntity), STemplateSubEntity::WriteJson, STemplateSubEntity::WriteSimpleJson, STemplateSubEntity::FromSimpleJson, STemplateSubEntity::Serialize, STemplateSubEntity::Equals);

void STemplateSubEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("logicalParent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateReference") << ",\"$val\":";
	SEntityTemplateReference::WriteJson(&s_Object->logicalParent, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplateProperty>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateProperty") << ",\"$val\":";
		SEntityTemplateProperty::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("postInitPropertyValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplateProperty>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->postInitPropertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->postInitPropertyValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateProperty") << ",\"$val\":";
		SEntityTemplateProperty::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->postInitPropertyValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STemplateSubEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("logicalParent") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->logicalParent, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("postInitPropertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->postInitPropertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->postInitPropertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->postInitPropertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateSubEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateSubEntity s_Object {};

	{
		SEntityTemplateReference s_Item {};
		SEntityTemplateReference::FromSimpleJson(p_Document["logicalParent"], &s_Item);
		s_Object.logicalParent = s_Item;
	}

	s_Object.entityTypeResourceIndex = simdjson::from_json_int32(p_Document["entityTypeResourceIndex"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["propertyValues"])
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyValues.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["postInitPropertyValues"])
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.postInitPropertyValues.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<STemplateSubEntity*>(p_Target) = s_Object;
}

void STemplateSubEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->logicalParent, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntity, logicalParent));
	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntity, propertyValues));
	TArray<SEntityTemplateProperty>::Serialize(&s_Object->postInitPropertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntity, postInitPropertyValues));
}

bool STemplateSubEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateSubEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateSubEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateSubEntity::operator==(const STemplateSubEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateSubEntity>)
		return false;

	if (logicalParent != p_Other.logicalParent) return false;
	if (entityTypeResourceIndex != p_Other.entityTypeResourceIndex) return false;
	if (propertyValues != p_Other.propertyValues) return false;
	if (postInitPropertyValues != p_Other.postInitPropertyValues) return false;

	return true;
}

ZHMTypeInfo STemplateEntity::TypeInfo = ZHMTypeInfo("STemplateEntity", sizeof(STemplateEntity), alignof(STemplateEntity), STemplateEntity::WriteJson, STemplateEntity::WriteSimpleJson, STemplateEntity::FromSimpleJson, STemplateEntity::Serialize, STemplateEntity::Equals);

void STemplateEntity::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("subType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->subType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STemplateSubEntity>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STemplateSubEntity") << ",\"$val\":";
		STemplateSubEntity::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyOverrides") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePropertyOverride>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyOverrides[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePropertyOverride") << ",\"$val\":";
		SEntityTemplatePropertyOverride::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->propertyOverrides.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneTypeIndicesInResourceHeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->externalSceneTypeIndicesInResourceHeader.size(); ++i)
	{
		auto& s_Item0 = s_Object->externalSceneTypeIndicesInResourceHeader[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->externalSceneTypeIndicesInResourceHeader.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STemplateEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("subType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->subType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		STemplateSubEntity::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyOverrides") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyOverrides[i];
		SEntityTemplatePropertyOverride::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyOverrides.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneTypeIndicesInResourceHeader") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->externalSceneTypeIndicesInResourceHeader.size(); ++i)
	{
		auto& s_Item0 = s_Object->externalSceneTypeIndicesInResourceHeader[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->externalSceneTypeIndicesInResourceHeader.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateEntity s_Object {};

	s_Object.subType = simdjson::from_json_int32(p_Document["subType"]);

	s_Object.blueprintIndexInResourceHeader = simdjson::from_json_int32(p_Document["blueprintIndexInResourceHeader"]);

	s_Object.rootEntityIndex = simdjson::from_json_int32(p_Document["rootEntityIndex"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["entityTemplates"])
	{
		STemplateSubEntity s_ArrayItem0;
		STemplateSubEntity::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.entityTemplates.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["propertyOverrides"])
	{
		SEntityTemplatePropertyOverride s_ArrayItem0;
		SEntityTemplatePropertyOverride::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyOverrides.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["externalSceneTypeIndicesInResourceHeader"])
	{
		s_Object.externalSceneTypeIndicesInResourceHeader.push_back(simdjson::from_json_int32(s_Item0));
	}

	*reinterpret_cast<STemplateEntity*>(p_Target) = s_Object;
}

void STemplateEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);

	TArray<STemplateSubEntity>::Serialize(&s_Object->entityTemplates, p_Serializer, p_OwnOffset + offsetof(STemplateEntity, entityTemplates));
	TArray<SEntityTemplatePropertyOverride>::Serialize(&s_Object->propertyOverrides, p_Serializer, p_OwnOffset + offsetof(STemplateEntity, propertyOverrides));
	TArray<int32>::Serialize(&s_Object->externalSceneTypeIndicesInResourceHeader, p_Serializer, p_OwnOffset + offsetof(STemplateEntity, externalSceneTypeIndicesInResourceHeader));
}

bool STemplateEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateEntity::operator==(const STemplateEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateEntity>)
		return false;

	if (subType != p_Other.subType) return false;
	if (blueprintIndexInResourceHeader != p_Other.blueprintIndexInResourceHeader) return false;
	if (rootEntityIndex != p_Other.rootEntityIndex) return false;
	if (entityTemplates != p_Other.entityTemplates) return false;
	if (propertyOverrides != p_Other.propertyOverrides) return false;
	if (externalSceneTypeIndicesInResourceHeader != p_Other.externalSceneTypeIndicesInResourceHeader) return false;

	return true;
}

ZHMTypeInfo STemplateSubEntityBlueprint::TypeInfo = ZHMTypeInfo("STemplateSubEntityBlueprint", sizeof(STemplateSubEntityBlueprint), alignof(STemplateSubEntityBlueprint), STemplateSubEntityBlueprint::WriteJson, STemplateSubEntityBlueprint::WriteSimpleJson, STemplateSubEntityBlueprint::FromSimpleJson, STemplateSubEntityBlueprint::Serialize, STemplateSubEntityBlueprint::Equals);

void STemplateSubEntityBlueprint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("logicalParent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateReference") << ",\"$val\":";
	SEntityTemplateReference::WriteJson(&s_Object->logicalParent, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->entityName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyAliases") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePropertyAlias>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyAliases.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyAliases[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePropertyAlias") << ",\"$val\":";
		SEntityTemplatePropertyAlias::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->propertyAliases.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TPair<ZString,SEntityTemplateReference>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TPair<ZString,SEntityTemplateReference>") << ",\"$val\":";
		TPair<ZString,SEntityTemplateReference>::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->exposedEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedInterfaces") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TPair<ZString,int32>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedInterfaces.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedInterfaces[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TPair<ZString,int32>") << ",\"$val\":";
		TPair<ZString,int32>::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->exposedInterfaces.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entitySubsets") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TPair<ZString,SEntityTemplateEntitySubset>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entitySubsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->entitySubsets[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TPair<ZString,SEntityTemplateEntitySubset>") << ",\"$val\":";
		TPair<ZString,SEntityTemplateEntitySubset>::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->entitySubsets.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STemplateSubEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("logicalParent") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->logicalParent, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyAliases") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyAliases.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyAliases[i];
		SEntityTemplatePropertyAlias::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyAliases.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedEntities[i];
		TPair<ZString,SEntityTemplateReference>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedInterfaces") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedInterfaces.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedInterfaces[i];
		TPair<ZString,int32>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedInterfaces.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entitySubsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entitySubsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->entitySubsets[i];
		TPair<ZString,SEntityTemplateEntitySubset>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entitySubsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateSubEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateSubEntityBlueprint s_Object {};

	{
		SEntityTemplateReference s_Item {};
		SEntityTemplateReference::FromSimpleJson(p_Document["logicalParent"], &s_Item);
		s_Object.logicalParent = s_Item;
	}

	s_Object.entityTypeResourceIndex = simdjson::from_json_int32(p_Document["entityTypeResourceIndex"]);

	s_Object.entityId = simdjson::from_json_uint64(p_Document["entityId"]);

	s_Object.entityName = std::string_view(p_Document["entityName"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["propertyAliases"])
	{
		SEntityTemplatePropertyAlias s_ArrayItem0;
		SEntityTemplatePropertyAlias::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyAliases.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["exposedEntities"])
	{
		TPair<ZString,SEntityTemplateReference> s_ArrayItem0;
		TPair<ZString,SEntityTemplateReference>::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.exposedEntities.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["exposedInterfaces"])
	{
		TPair<ZString,int32> s_ArrayItem0;
		TPair<ZString,int32>::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.exposedInterfaces.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["entitySubsets"])
	{
		TPair<ZString,SEntityTemplateEntitySubset> s_ArrayItem0;
		TPair<ZString,SEntityTemplateEntitySubset>::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.entitySubsets.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<STemplateSubEntityBlueprint*>(p_Target) = s_Object;
}

void STemplateSubEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->logicalParent, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, logicalParent));
	ZString::Serialize(&s_Object->entityName, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, entityName));
	TArray<SEntityTemplatePropertyAlias>::Serialize(&s_Object->propertyAliases, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, propertyAliases));
	TArray<TPair<ZString,SEntityTemplateReference>>::Serialize(&s_Object->exposedEntities, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, exposedEntities));
	TArray<TPair<ZString,int32>>::Serialize(&s_Object->exposedInterfaces, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, exposedInterfaces));
	TArray<TPair<ZString,SEntityTemplateEntitySubset>>::Serialize(&s_Object->entitySubsets, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, entitySubsets));
}

bool STemplateSubEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateSubEntityBlueprint::operator==(const STemplateSubEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateSubEntityBlueprint>)
		return false;

	if (logicalParent != p_Other.logicalParent) return false;
	if (entityTypeResourceIndex != p_Other.entityTypeResourceIndex) return false;
	if (entityId != p_Other.entityId) return false;
	if (entityName != p_Other.entityName) return false;
	if (propertyAliases != p_Other.propertyAliases) return false;
	if (exposedEntities != p_Other.exposedEntities) return false;
	if (exposedInterfaces != p_Other.exposedInterfaces) return false;
	if (entitySubsets != p_Other.entitySubsets) return false;

	return true;
}

ZHMTypeInfo STemplateEntityBlueprint::TypeInfo = ZHMTypeInfo("STemplateEntityBlueprint", sizeof(STemplateEntityBlueprint), alignof(STemplateEntityBlueprint), STemplateEntityBlueprint::WriteJson, STemplateEntityBlueprint::WriteSimpleJson, STemplateEntityBlueprint::FromSimpleJson, STemplateEntityBlueprint::Serialize, STemplateEntityBlueprint::Equals);

void STemplateEntityBlueprint::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("subType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->subType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STemplateSubEntityBlueprint>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STemplateSubEntityBlueprint") << ",\"$val\":";
		STemplateSubEntityBlueprint::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneTypeIndicesInResourceHeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->externalSceneTypeIndicesInResourceHeader.size(); ++i)
	{
		auto& s_Item0 = s_Object->externalSceneTypeIndicesInResourceHeader[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->externalSceneTypeIndicesInResourceHeader.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("pinConnections") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePinConnection>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pinConnections.size(); ++i)
	{
		auto& s_Item0 = s_Object->pinConnections[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePinConnection") << ",\"$val\":";
		SEntityTemplatePinConnection::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->pinConnections.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inputPinForwardings") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePinConnection>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->inputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->inputPinForwardings[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePinConnection") << ",\"$val\":";
		SEntityTemplatePinConnection::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->inputPinForwardings.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("outputPinForwardings") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplatePinConnection>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->outputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->outputPinForwardings[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplatePinConnection") << ",\"$val\":";
		SEntityTemplatePinConnection::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->outputPinForwardings.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("overrideDeletes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SEntityTemplateReference>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->overrideDeletes.size(); ++i)
	{
		auto& s_Item0 = s_Object->overrideDeletes[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SEntityTemplateReference") << ",\"$val\":";
		SEntityTemplateReference::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->overrideDeletes.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STemplateEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("subType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->subType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		STemplateSubEntityBlueprint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneTypeIndicesInResourceHeader") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->externalSceneTypeIndicesInResourceHeader.size(); ++i)
	{
		auto& s_Item0 = s_Object->externalSceneTypeIndicesInResourceHeader[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->externalSceneTypeIndicesInResourceHeader.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("pinConnections") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pinConnections.size(); ++i)
	{
		auto& s_Item0 = s_Object->pinConnections[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pinConnections.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inputPinForwardings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->inputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->inputPinForwardings[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->inputPinForwardings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("outputPinForwardings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->outputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->outputPinForwardings[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->outputPinForwardings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("overrideDeletes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->overrideDeletes.size(); ++i)
	{
		auto& s_Item0 = s_Object->overrideDeletes[i];
		SEntityTemplateReference::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->overrideDeletes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateEntityBlueprint s_Object {};

	s_Object.subType = simdjson::from_json_int32(p_Document["subType"]);

	s_Object.rootEntityIndex = simdjson::from_json_int32(p_Document["rootEntityIndex"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["entityTemplates"])
	{
		STemplateSubEntityBlueprint s_ArrayItem0;
		STemplateSubEntityBlueprint::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.entityTemplates.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["externalSceneTypeIndicesInResourceHeader"])
	{
		s_Object.externalSceneTypeIndicesInResourceHeader.push_back(simdjson::from_json_int32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["pinConnections"])
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.pinConnections.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["inputPinForwardings"])
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.inputPinForwardings.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["outputPinForwardings"])
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.outputPinForwardings.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["overrideDeletes"])
	{
		SEntityTemplateReference s_ArrayItem0;
		SEntityTemplateReference::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.overrideDeletes.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<STemplateEntityBlueprint*>(p_Target) = s_Object;
}

void STemplateEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	TArray<STemplateSubEntityBlueprint>::Serialize(&s_Object->entityTemplates, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, entityTemplates));
	TArray<int32>::Serialize(&s_Object->externalSceneTypeIndicesInResourceHeader, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, externalSceneTypeIndicesInResourceHeader));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->pinConnections, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, pinConnections));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->inputPinForwardings, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, inputPinForwardings));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->outputPinForwardings, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, outputPinForwardings));
	TArray<SEntityTemplateReference>::Serialize(&s_Object->overrideDeletes, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, overrideDeletes));
}

bool STemplateEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateEntityBlueprint::operator==(const STemplateEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateEntityBlueprint>)
		return false;

	if (subType != p_Other.subType) return false;
	if (rootEntityIndex != p_Other.rootEntityIndex) return false;
	if (entityTemplates != p_Other.entityTemplates) return false;
	if (externalSceneTypeIndicesInResourceHeader != p_Other.externalSceneTypeIndicesInResourceHeader) return false;
	if (pinConnections != p_Other.pinConnections) return false;
	if (inputPinForwardings != p_Other.inputPinForwardings) return false;
	if (outputPinForwardings != p_Other.outputPinForwardings) return false;
	if (overrideDeletes != p_Other.overrideDeletes) return false;

	return true;
}

ZHMTypeInfo STestMiniStruct::TypeInfo = ZHMTypeInfo("STestMiniStruct", sizeof(STestMiniStruct), alignof(STestMiniStruct), STestMiniStruct::WriteJson, STestMiniStruct::WriteSimpleJson, STestMiniStruct::FromSimpleJson, STestMiniStruct::Serialize, STestMiniStruct::Equals);

void STestMiniStruct::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iIntValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iIntValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFloatValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFloatValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);
	p_Stream << "}";

	p_Stream << "}";
}

void STestMiniStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iIntValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iIntValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFloatValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFloatValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);

	p_Stream << "}";
}

void STestMiniStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STestMiniStruct s_Object {};

	s_Object.m_iIntValue = simdjson::from_json_int32(p_Document["m_iIntValue"]);

	s_Object.m_fFloatValue = simdjson::from_json_float32(p_Document["m_fFloatValue"]);

	s_Object.m_sText = std::string_view(p_Document["m_sText"]);

	*reinterpret_cast<STestMiniStruct*>(p_Target) = s_Object;
}

void STestMiniStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);

	ZString::Serialize(&s_Object->m_sText, p_Serializer, p_OwnOffset + offsetof(STestMiniStruct, m_sText));
}

bool STestMiniStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestMiniStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<STestMiniStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestMiniStruct::operator==(const STestMiniStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestMiniStruct>)
		return false;

	if (m_iIntValue != p_Other.m_iIntValue) return false;
	if (m_fFloatValue != p_Other.m_fFloatValue) return false;
	if (m_sText != p_Other.m_sText) return false;

	return true;
}

ZHMTypeInfo STestStruct::TypeInfo = ZHMTypeInfo("STestStruct", sizeof(STestStruct), alignof(STestStruct), STestStruct::WriteJson, STestStruct::WriteSimpleJson, STestStruct::FromSimpleJson, STestStruct::Serialize, STestStruct::Equals);

void STestStruct::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("stringField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->stringField);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->intField);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("floatField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->floatField);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("enumField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STestStruct.ETestEnum") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->enumField)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("STestStruct.ETestEnum", static_cast<int>(s_Object->enumField))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void STestStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("stringField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->stringField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->intField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("floatField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->floatField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("enumField") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("STestStruct.ETestEnum", static_cast<int>(s_Object->enumField)));

	p_Stream << "}";
}

void STestStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STestStruct s_Object {};

	s_Object.stringField = std::string_view(p_Document["stringField"]);

	s_Object.intField = simdjson::from_json_uint32(p_Document["intField"]);

	s_Object.floatField = simdjson::from_json_float32(p_Document["floatField"]);

	s_Object.enumField = static_cast<STestStruct_ETestEnum>(ZHMEnums::GetEnumValueByName("STestStruct.ETestEnum", std::string_view(p_Document["enumField"])));

	*reinterpret_cast<STestStruct*>(p_Target) = s_Object;
}

void STestStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);

	ZString::Serialize(&s_Object->stringField, p_Serializer, p_OwnOffset + offsetof(STestStruct, stringField));
}

bool STestStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStruct::operator==(const STestStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStruct>)
		return false;

	if (stringField != p_Other.stringField) return false;
	if (intField != p_Other.intField) return false;
	if (floatField != p_Other.floatField) return false;
	if (enumField != p_Other.enumField) return false;

	return true;
}

ZHMTypeInfo STestStruct2::TypeInfo = ZHMTypeInfo("STestStruct2", sizeof(STestStruct2), alignof(STestStruct2), STestStruct2::WriteJson, STestStruct2::WriteSimpleJson, STestStruct2::FromSimpleJson, STestStruct2::Serialize, STestStruct2::Equals);

void STestStruct2::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("arrayField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STestStruct>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->arrayField.size(); ++i)
	{
		auto& s_Item0 = s_Object->arrayField[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STestStruct") << ",\"$val\":";
		STestStruct::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->arrayField.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("variantField") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->variantField, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void STestStruct2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("arrayField") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->arrayField.size(); ++i)
	{
		auto& s_Item0 = s_Object->arrayField[i];
		STestStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->arrayField.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("variantField") << ":";
	ZVariant::WriteSimpleJson(&s_Object->variantField, p_Stream);

	p_Stream << "}";
}

void STestStruct2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STestStruct2 s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["arrayField"])
	{
		STestStruct s_ArrayItem0;
		STestStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.arrayField.push_back(s_ArrayItem0);
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["variantField"], &s_Item);
		s_Object.variantField = s_Item;
	}

	*reinterpret_cast<STestStruct2*>(p_Target) = s_Object;
}

void STestStruct2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);

	TArray<STestStruct>::Serialize(&s_Object->arrayField, p_Serializer, p_OwnOffset + offsetof(STestStruct2, arrayField));
	ZVariant::Serialize(&s_Object->variantField, p_Serializer, p_OwnOffset + offsetof(STestStruct2, variantField));
}

bool STestStruct2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStruct2*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStruct2*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStruct2::operator==(const STestStruct2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStruct2>)
		return false;

	if (arrayField != p_Other.arrayField) return false;
	if (variantField != p_Other.variantField) return false;

	return true;
}

ZHMTypeInfo STestStructure::TypeInfo = ZHMTypeInfo("STestStructure", sizeof(STestStructure), alignof(STestStructure), STestStructure::WriteJson, STestStructure::WriteSimpleJson, STestStructure::FromSimpleJson, STestStructure::Serialize, STestStructure::Equals);

void STestStructure::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fWidth") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWidth);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHeight") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeight);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Mini") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STestMiniStruct") << ",\"$val\":";
	STestMiniStruct::WriteJson(&s_Object->m_Mini, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void STestStructure::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWidth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Mini") << ":";
	STestMiniStruct::WriteSimpleJson(&s_Object->m_Mini, p_Stream);

	p_Stream << "}";
}

void STestStructure::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STestStructure s_Object {};

	s_Object.m_fWidth = simdjson::from_json_float32(p_Document["m_fWidth"]);

	s_Object.m_fHeight = simdjson::from_json_float32(p_Document["m_fHeight"]);

	s_Object.m_fAngle = simdjson::from_json_float32(p_Document["m_fAngle"]);

	s_Object.m_sDescription = std::string_view(p_Document["m_sDescription"]);

	{
		STestMiniStruct s_Item {};
		STestMiniStruct::FromSimpleJson(p_Document["m_Mini"], &s_Item);
		s_Object.m_Mini = s_Item;
	}

	*reinterpret_cast<STestStructure*>(p_Target) = s_Object;
}

void STestStructure::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);

	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(STestStructure, m_sDescription));
	STestMiniStruct::Serialize(&s_Object->m_Mini, p_Serializer, p_OwnOffset + offsetof(STestStructure, m_Mini));
}

bool STestStructure::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStructure*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStructure*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStructure::operator==(const STestStructure& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStructure>)
		return false;

	if (m_fWidth != p_Other.m_fWidth) return false;
	if (m_fHeight != p_Other.m_fHeight) return false;
	if (m_fAngle != p_Other.m_fAngle) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_Mini != p_Other.m_Mini) return false;

	return true;
}

ZHMTypeInfo STimerEntitySaveData::TypeInfo = ZHMTypeInfo("STimerEntitySaveData", sizeof(STimerEntitySaveData), alignof(STimerEntitySaveData), STimerEntitySaveData::WriteJson, STimerEntitySaveData::WriteSimpleJson, STimerEntitySaveData::FromSimpleJson, STimerEntitySaveData::Serialize, STimerEntitySaveData::Equals);

void STimerEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeToNextEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeToNextEvent);
	p_Stream << "}";

	p_Stream << "}";
}

void STimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeToNextEvent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeToNextEvent);

	p_Stream << "}";
}

void STimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerEntitySaveData s_Object {};

	s_Object.m_nInterval = simdjson::from_json_int32(p_Document["m_nInterval"]);

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_fTimeToNextEvent = simdjson::from_json_float32(p_Document["m_fTimeToNextEvent"]);

	*reinterpret_cast<STimerEntitySaveData*>(p_Target) = s_Object;
}

void STimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);

}

bool STimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntitySaveData::operator==(const STimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntitySaveData>)
		return false;

	if (m_nInterval != p_Other.m_nInterval) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fTimeToNextEvent != p_Other.m_fTimeToNextEvent) return false;

	return true;
}

ZHMTypeInfo STimerEntitiesSaveData::TypeInfo = ZHMTypeInfo("STimerEntitiesSaveData", sizeof(STimerEntitiesSaveData), alignof(STimerEntitiesSaveData), STimerEntitiesSaveData::WriteJson, STimerEntitiesSaveData::WriteSimpleJson, STimerEntitiesSaveData::FromSimpleJson, STimerEntitiesSaveData::Serialize, STimerEntitiesSaveData::Equals);

void STimerEntitiesSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STimerEntitySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STimerEntitySaveData") << ",\"$val\":";
		STimerEntitySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STimerEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		STimerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STimerEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerEntitiesSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		STimerEntitySaveData s_ArrayItem0;
		STimerEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<STimerEntitiesSaveData*>(p_Target) = s_Object;
}

void STimerEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(STimerEntitiesSaveData, m_aEntities));
	TArray<STimerEntitySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(STimerEntitiesSaveData, m_aData));
}

bool STimerEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntitiesSaveData::operator==(const STimerEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo STimerManagerSaveData::TypeInfo = ZHMTypeInfo("STimerManagerSaveData", sizeof(STimerManagerSaveData), alignof(STimerManagerSaveData), STimerManagerSaveData::WriteJson, STimerManagerSaveData::WriteSimpleJson, STimerManagerSaveData::FromSimpleJson, STimerManagerSaveData::Serialize, STimerManagerSaveData::Equals);

void STimerManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_TimersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("STimerEntitiesSaveData") << ",\"$val\":";
	STimerEntitiesSaveData::WriteJson(&s_Object->m_TimersData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RandomTimersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SRandomTimerEntitiesSaveData") << ",\"$val\":";
	SRandomTimerEntitiesSaveData::WriteJson(&s_Object->m_RandomTimersData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GameTimersData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SGameTimersSaveData") << ",\"$val\":";
	SGameTimersSaveData::WriteJson(&s_Object->m_GameTimersData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void STimerManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_TimersData") << ":";
	STimerEntitiesSaveData::WriteSimpleJson(&s_Object->m_TimersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RandomTimersData") << ":";
	SRandomTimerEntitiesSaveData::WriteSimpleJson(&s_Object->m_RandomTimersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GameTimersData") << ":";
	SGameTimersSaveData::WriteSimpleJson(&s_Object->m_GameTimersData, p_Stream);

	p_Stream << "}";
}

void STimerManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerManagerSaveData s_Object {};

	{
		STimerEntitiesSaveData s_Item {};
		STimerEntitiesSaveData::FromSimpleJson(p_Document["m_TimersData"], &s_Item);
		s_Object.m_TimersData = s_Item;
	}

	{
		SRandomTimerEntitiesSaveData s_Item {};
		SRandomTimerEntitiesSaveData::FromSimpleJson(p_Document["m_RandomTimersData"], &s_Item);
		s_Object.m_RandomTimersData = s_Item;
	}

	{
		SGameTimersSaveData s_Item {};
		SGameTimersSaveData::FromSimpleJson(p_Document["m_GameTimersData"], &s_Item);
		s_Object.m_GameTimersData = s_Item;
	}

	*reinterpret_cast<STimerManagerSaveData*>(p_Target) = s_Object;
}

void STimerManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);

	STimerEntitiesSaveData::Serialize(&s_Object->m_TimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_TimersData));
	SRandomTimerEntitiesSaveData::Serialize(&s_Object->m_RandomTimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_RandomTimersData));
	SGameTimersSaveData::Serialize(&s_Object->m_GameTimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_GameTimersData));
}

bool STimerManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerManagerSaveData::operator==(const STimerManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerManagerSaveData>)
		return false;

	if (m_TimersData != p_Other.m_TimersData) return false;
	if (m_RandomTimersData != p_Other.m_RandomTimersData) return false;
	if (m_GameTimersData != p_Other.m_GameTimersData) return false;

	return true;
}

ZHMTypeInfo STokenID::TypeInfo = ZHMTypeInfo("STokenID", sizeof(STokenID), alignof(STokenID), STokenID::WriteJson, STokenID::WriteSimpleJson, STokenID::FromSimpleJson, STokenID::Serialize, STokenID::Equals);

void STokenID::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_iValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValid);
	p_Stream << "}";

	p_Stream << "}";
}

void STokenID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValid);

	p_Stream << "}";
}

void STokenID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STokenID s_Object {};

	s_Object.m_iValue = simdjson::from_json_uint32(p_Document["m_iValue"]);

	s_Object.m_bValid = simdjson::from_json_bool(p_Document["m_bValid"]);

	*reinterpret_cast<STokenID*>(p_Target) = s_Object;
}

void STokenID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

}

bool STokenID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STokenID*>(p_Left);
	auto* s_Right = reinterpret_cast<STokenID*>(p_Right);

	return *s_Left == *s_Right;
}

bool STokenID::operator==(const STokenID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STokenID>)
		return false;

	if (m_iValue != p_Other.m_iValue) return false;
	if (m_bValid != p_Other.m_bValid) return false;

	return true;
}

ZHMTypeInfo STrackDollyControllerSaveData::TypeInfo = ZHMTypeInfo("STrackDollyControllerSaveData", sizeof(STrackDollyControllerSaveData), alignof(STrackDollyControllerSaveData), STrackDollyControllerSaveData::WriteJson, STrackDollyControllerSaveData::WriteSimpleJson, STrackDollyControllerSaveData::FromSimpleJson, STrackDollyControllerSaveData::Serialize, STrackDollyControllerSaveData::Equals);

void STrackDollyControllerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rTrackEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTrackEntity);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTrackPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTrackPosition);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDollyAttached") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDollyAttached);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDollyPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector3") << ",\"$val\":";
	SVector3::WriteJson(&s_Object->m_vDollyPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDollyRotation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SVector4") << ",\"$val\":";
	SVector4::WriteJson(&s_Object->m_vDollyRotation, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void STrackDollyControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTrackEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTrackEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTrackPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTrackPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDollyAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDollyAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDollyPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vDollyPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDollyRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vDollyRotation, p_Stream);

	p_Stream << "}";
}

void STrackDollyControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrackDollyControllerSaveData s_Object {};

	s_Object.m_rTrackEntity = simdjson::from_json_uint32(p_Document["m_rTrackEntity"]);

	s_Object.m_fTrackPosition = simdjson::from_json_float32(p_Document["m_fTrackPosition"]);

	s_Object.m_bIsDollyAttached = simdjson::from_json_bool(p_Document["m_bIsDollyAttached"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vDollyPosition"], &s_Item);
		s_Object.m_vDollyPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vDollyRotation"], &s_Item);
		s_Object.m_vDollyRotation = s_Item;
	}

	*reinterpret_cast<STrackDollyControllerSaveData*>(p_Target) = s_Object;
}

void STrackDollyControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vDollyPosition, p_Serializer, p_OwnOffset + offsetof(STrackDollyControllerSaveData, m_vDollyPosition));
	SVector4::Serialize(&s_Object->m_vDollyRotation, p_Serializer, p_OwnOffset + offsetof(STrackDollyControllerSaveData, m_vDollyRotation));
}

bool STrackDollyControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackDollyControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackDollyControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackDollyControllerSaveData::operator==(const STrackDollyControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackDollyControllerSaveData>)
		return false;

	if (m_rTrackEntity != p_Other.m_rTrackEntity) return false;
	if (m_fTrackPosition != p_Other.m_fTrackPosition) return false;
	if (m_bIsDollyAttached != p_Other.m_bIsDollyAttached) return false;
	if (m_vDollyPosition != p_Other.m_vDollyPosition) return false;
	if (m_vDollyRotation != p_Other.m_vDollyRotation) return false;

	return true;
}

ZHMTypeInfo STrackerEntitySaveData::TypeInfo = ZHMTypeInfo("STrackerEntitySaveData", sizeof(STrackerEntitySaveData), alignof(STrackerEntitySaveData), STrackerEntitySaveData::WriteJson, STrackerEntitySaveData::WriteSimpleJson, STrackerEntitySaveData::FromSimpleJson, STrackerEntitySaveData::Serialize, STrackerEntitySaveData::Equals);

void STrackerEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rTracker") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTracker);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpatialVisibility") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpatialVisibility);
	p_Stream << "}";

	p_Stream << "}";
}

void STrackerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTracker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTracker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpatialVisibility") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpatialVisibility);

	p_Stream << "}";
}

void STrackerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrackerEntitySaveData s_Object {};

	s_Object.m_rTracker = simdjson::from_json_uint32(p_Document["m_rTracker"]);

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	s_Object.m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object.m_bSpatialVisibility = simdjson::from_json_bool(p_Document["m_bSpatialVisibility"]);

	*reinterpret_cast<STrackerEntitySaveData*>(p_Target) = s_Object;
}

void STrackerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);

}

bool STrackerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackerEntitySaveData::operator==(const STrackerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackerEntitySaveData>)
		return false;

	if (m_rTracker != p_Other.m_rTracker) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;
	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_bSpatialVisibility != p_Other.m_bSpatialVisibility) return false;

	return true;
}

ZHMTypeInfo STrackerManagerSaveData::TypeInfo = ZHMTypeInfo("STrackerManagerSaveData", sizeof(STrackerManagerSaveData), alignof(STrackerManagerSaveData), STrackerManagerSaveData::WriteJson, STrackerManagerSaveData::WriteSimpleJson, STrackerManagerSaveData::FromSimpleJson, STrackerManagerSaveData::Serialize, STrackerManagerSaveData::Equals);

void STrackerManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aTrackerData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<STrackerEntitySaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackerData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackerData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("STrackerEntitySaveData") << ",\"$val\":";
		STrackerEntitySaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aTrackerData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STrackerManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTrackerData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackerData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackerData[i];
		STrackerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackerData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrackerManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrackerManagerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aTrackerData"])
	{
		STrackerEntitySaveData s_ArrayItem0;
		STrackerEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTrackerData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<STrackerManagerSaveData*>(p_Target) = s_Object;
}

void STrackerManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);

	TArray<STrackerEntitySaveData>::Serialize(&s_Object->m_aTrackerData, p_Serializer, p_OwnOffset + offsetof(STrackerManagerSaveData, m_aTrackerData));
}

bool STrackerManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackerManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackerManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackerManagerSaveData::operator==(const STrackerManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackerManagerSaveData>)
		return false;

	if (m_aTrackerData != p_Other.m_aTrackerData) return false;

	return true;
}

ZHMTypeInfo STrajectoryTrackSaveData::TypeInfo = ZHMTypeInfo("STrajectoryTrackSaveData", sizeof(STrajectoryTrackSaveData), alignof(STrajectoryTrackSaveData), STrajectoryTrackSaveData::WriteJson, STrajectoryTrackSaveData::WriteSimpleJson, STrajectoryTrackSaveData::FromSimpleJson, STrajectoryTrackSaveData::Serialize, STrajectoryTrackSaveData::Equals);

void STrajectoryTrackSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vOriginalEntityTransform") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMatrix") << ",\"$val\":";
	SMatrix::WriteJson(&s_Object->m_vOriginalEntityTransform, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTargetStartTransform") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SMatrix") << ",\"$val\":";
	SMatrix::WriteJson(&s_Object->m_vTargetStartTransform, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void STrajectoryTrackSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vOriginalEntityTransform") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_vOriginalEntityTransform, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTargetStartTransform") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_vTargetStartTransform, p_Stream);

	p_Stream << "}";
}

void STrajectoryTrackSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrajectoryTrackSaveData s_Object {};

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_vOriginalEntityTransform"], &s_Item);
		s_Object.m_vOriginalEntityTransform = s_Item;
	}

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_vTargetStartTransform"], &s_Item);
		s_Object.m_vTargetStartTransform = s_Item;
	}

	*reinterpret_cast<STrajectoryTrackSaveData*>(p_Target) = s_Object;
}

void STrajectoryTrackSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);

	SMatrix::Serialize(&s_Object->m_vOriginalEntityTransform, p_Serializer, p_OwnOffset + offsetof(STrajectoryTrackSaveData, m_vOriginalEntityTransform));
	SMatrix::Serialize(&s_Object->m_vTargetStartTransform, p_Serializer, p_OwnOffset + offsetof(STrajectoryTrackSaveData, m_vTargetStartTransform));
}

bool STrajectoryTrackSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrajectoryTrackSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrajectoryTrackSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrajectoryTrackSaveData::operator==(const STrajectoryTrackSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrajectoryTrackSaveData>)
		return false;

	if (m_vOriginalEntityTransform != p_Other.m_vOriginalEntityTransform) return false;
	if (m_vTargetStartTransform != p_Other.m_vTargetStartTransform) return false;

	return true;
}

ZHMTypeInfo STrespassingRuleEntitySaveData::TypeInfo = ZHMTypeInfo("STrespassingRuleEntitySaveData", sizeof(STrespassingRuleEntitySaveData), alignof(STrespassingRuleEntitySaveData), STrespassingRuleEntitySaveData::WriteJson, STrespassingRuleEntitySaveData::WriteSimpleJson, STrespassingRuleEntitySaveData::FromSimpleJson, STrespassingRuleEntitySaveData::Serialize, STrespassingRuleEntitySaveData::Equals);

void STrespassingRuleEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aAllowedProfessionsDisabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAllowedProfessionsDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAllowedProfessionsDisabled[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aAllowedProfessionsDisabled.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void STrespassingRuleEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAllowedProfessionsDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAllowedProfessionsDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAllowedProfessionsDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAllowedProfessionsDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrespassingRuleEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrespassingRuleEntitySaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAllowedProfessionsDisabled"])
	{
		s_Object.m_aAllowedProfessionsDisabled.push_back(simdjson::from_json_bool(s_Item0));
	}

	*reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Target) = s_Object;
}

void STrespassingRuleEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);

	TArray<bool>::Serialize(&s_Object->m_aAllowedProfessionsDisabled, p_Serializer, p_OwnOffset + offsetof(STrespassingRuleEntitySaveData, m_aAllowedProfessionsDisabled));
}

bool STrespassingRuleEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrespassingRuleEntitySaveData::operator==(const STrespassingRuleEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrespassingRuleEntitySaveData>)
		return false;

	if (m_aAllowedProfessionsDisabled != p_Other.m_aAllowedProfessionsDisabled) return false;

	return true;
}

ZHMTypeInfo STriggerAlarmGroupSaveData::TypeInfo = ZHMTypeInfo("STriggerAlarmGroupSaveData", sizeof(STriggerAlarmGroupSaveData), alignof(STriggerAlarmGroupSaveData), STriggerAlarmGroupSaveData::WriteJson, STriggerAlarmGroupSaveData::WriteSimpleJson, STriggerAlarmGroupSaveData::FromSimpleJson, STriggerAlarmGroupSaveData::Serialize, STriggerAlarmGroupSaveData::Equals);

void STriggerAlarmGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rAlarm") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAlarm);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggeredAlarm") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggeredAlarm);
	p_Stream << "}";

	p_Stream << "}";
}

void STriggerAlarmGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggeredAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggeredAlarm);

	p_Stream << "}";
}

void STriggerAlarmGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STriggerAlarmGroupSaveData s_Object {};

	s_Object.m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object.m_rAlarm = simdjson::from_json_uint32(p_Document["m_rAlarm"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_bTriggeredAlarm = simdjson::from_json_bool(p_Document["m_bTriggeredAlarm"]);

	*reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Target) = s_Object;
}

void STriggerAlarmGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(STriggerAlarmGroupSaveData, m_fsmState));
}

bool STriggerAlarmGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STriggerAlarmGroupSaveData::operator==(const STriggerAlarmGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STriggerAlarmGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_rAlarm != p_Other.m_rAlarm) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_bTriggeredAlarm != p_Other.m_bTriggeredAlarm) return false;

	return true;
}

ZHMTypeInfo SUIGridCellPosition::TypeInfo = ZHMTypeInfo("SUIGridCellPosition", sizeof(SUIGridCellPosition), alignof(SUIGridCellPosition), SUIGridCellPosition::WriteJson, SUIGridCellPosition::WriteSimpleJson, SUIGridCellPosition::FromSimpleJson, SUIGridCellPosition::Serialize, SUIGridCellPosition::Equals);

void SUIGridCellPosition::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("nColumnIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nColumnIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nRowIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nRowIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nColumnSpan") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nColumnSpan);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nRowSpan") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nRowSpan);
	p_Stream << "}";

	p_Stream << "}";
}

void SUIGridCellPosition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nColumnIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColumnIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nRowIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nRowIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nColumnSpan") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColumnSpan);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nRowSpan") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nRowSpan);

	p_Stream << "}";
}

void SUIGridCellPosition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIGridCellPosition s_Object {};

	s_Object.nColumnIndex = simdjson::from_json_int32(p_Document["nColumnIndex"]);

	s_Object.nRowIndex = simdjson::from_json_int32(p_Document["nRowIndex"]);

	s_Object.nColumnSpan = simdjson::from_json_int32(p_Document["nColumnSpan"]);

	s_Object.nRowSpan = simdjson::from_json_int32(p_Document["nRowSpan"]);

	*reinterpret_cast<SUIGridCellPosition*>(p_Target) = s_Object;
}

void SUIGridCellPosition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);

}

bool SUIGridCellPosition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIGridCellPosition*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIGridCellPosition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIGridCellPosition::operator==(const SUIGridCellPosition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIGridCellPosition>)
		return false;

	if (nColumnIndex != p_Other.nColumnIndex) return false;
	if (nRowIndex != p_Other.nRowIndex) return false;
	if (nColumnSpan != p_Other.nColumnSpan) return false;
	if (nRowSpan != p_Other.nRowSpan) return false;

	return true;
}

ZHMTypeInfo SUIOptionsSaveData::TypeInfo = ZHMTypeInfo("SUIOptionsSaveData", sizeof(SUIOptionsSaveData), alignof(SUIOptionsSaveData), SUIOptionsSaveData::WriteJson, SUIOptionsSaveData::WriteSimpleJson, SUIOptionsSaveData::FromSimpleJson, SUIOptionsSaveData::Serialize, SUIOptionsSaveData::Equals);

void SUIOptionsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aKeys") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<_EUIOptionKey>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeys[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("_EUIOptionKey") << ",\"$val\":";
		p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Item0)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("_EUIOptionKey", static_cast<int>(s_Item0))) << "}";
		p_Stream << "}";

		if (i < s_Object->m_aKeys.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SOptionValueSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SOptionValueSaveData") << ",\"$val\":";
		SOptionValueSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SUIOptionsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKeys") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeys[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("_EUIOptionKey", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aKeys.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		SOptionValueSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUIOptionsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIOptionsSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aKeys"])
	{
		s_Object.m_aKeys.push_back(static_cast<_EUIOptionKey>(ZHMEnums::GetEnumValueByName("_EUIOptionKey", std::string_view(s_Item0))));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aValues"])
	{
		SOptionValueSaveData s_ArrayItem0;
		SOptionValueSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aValues.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SUIOptionsSaveData*>(p_Target) = s_Object;
}

void SUIOptionsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);

	TArray<_EUIOptionKey>::Serialize(&s_Object->m_aKeys, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, m_aKeys));
	TArray<SOptionValueSaveData>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, m_aValues));
}

bool SUIOptionsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIOptionsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIOptionsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIOptionsSaveData::operator==(const SUIOptionsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIOptionsSaveData>)
		return false;

	if (m_aKeys != p_Other.m_aKeys) return false;
	if (m_aValues != p_Other.m_aValues) return false;

	return true;
}

ZHMTypeInfo SUITestData_SSubSubStruct::TypeInfo = ZHMTypeInfo("SUITestData.SSubSubStruct", sizeof(SUITestData_SSubSubStruct), alignof(SUITestData_SSubSubStruct), SUITestData_SSubSubStruct::WriteJson, SUITestData_SSubSubStruct::WriteSimpleJson, SUITestData_SSubSubStruct::FromSimpleJson, SUITestData_SSubSubStruct::Serialize, SUITestData_SSubSubStruct::Equals);

void SUITestData_SSubSubStruct::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("sDeepString") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sDeepString);
	p_Stream << "}";

	p_Stream << "}";
}

void SUITestData_SSubSubStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sDeepString") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDeepString);

	p_Stream << "}";
}

void SUITestData_SSubSubStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUITestData_SSubSubStruct s_Object {};

	s_Object.sDeepString = std::string_view(p_Document["sDeepString"]);

	*reinterpret_cast<SUITestData_SSubSubStruct*>(p_Target) = s_Object;
}

void SUITestData_SSubSubStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Object);

	ZString::Serialize(&s_Object->sDeepString, p_Serializer, p_OwnOffset + offsetof(SUITestData_SSubSubStruct, sDeepString));
}

bool SUITestData_SSubSubStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData_SSubSubStruct::operator==(const SUITestData_SSubSubStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData_SSubSubStruct>)
		return false;

	if (sDeepString != p_Other.sDeepString) return false;

	return true;
}

ZHMTypeInfo SUITestData_SSubStruct::TypeInfo = ZHMTypeInfo("SUITestData.SSubStruct", sizeof(SUITestData_SSubStruct), alignof(SUITestData_SSubStruct), SUITestData_SSubStruct::WriteJson, SUITestData_SSubStruct::WriteSimpleJson, SUITestData_SSubStruct::FromSimpleJson, SUITestData_SSubStruct::Serialize, SUITestData_SSubStruct::Equals);

void SUITestData_SSubStruct::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubStruct*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("aSubSubStructs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SUITestData.SSubSubStruct>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSubSubStructs.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSubSubStructs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SUITestData.SSubSubStruct") << ",\"$val\":";
		SUITestData_SSubSubStruct::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->aSubSubStructs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SUITestData_SSubStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("aSubSubStructs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSubSubStructs.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSubSubStructs[i];
		SUITestData_SSubSubStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aSubSubStructs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUITestData_SSubStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUITestData_SSubStruct s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["aSubSubStructs"])
	{
		SUITestData_SSubSubStruct s_ArrayItem0;
		SUITestData_SSubSubStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aSubSubStructs.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SUITestData_SSubStruct*>(p_Target) = s_Object;
}

void SUITestData_SSubStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubStruct*>(p_Object);

	TArray<SUITestData_SSubSubStruct>::Serialize(&s_Object->aSubSubStructs, p_Serializer, p_OwnOffset + offsetof(SUITestData_SSubStruct, aSubSubStructs));
}

bool SUITestData_SSubStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData_SSubStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData_SSubStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData_SSubStruct::operator==(const SUITestData_SSubStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData_SSubStruct>)
		return false;

	if (aSubSubStructs != p_Other.aSubSubStructs) return false;

	return true;
}

ZHMTypeInfo SUITestData::TypeInfo = ZHMTypeInfo("SUITestData", sizeof(SUITestData), alignof(SUITestData), SUITestData::WriteJson, SUITestData::WriteSimpleJson, SUITestData::FromSimpleJson, SUITestData::Serialize, SUITestData::Equals);

void SUITestData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("nIntProp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nIntProp);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fInt16Prop") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int16") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fInt16Prop);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fUInt32Prop") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fUInt32Prop);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFloatProp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fFloatProp);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sStringProp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sStringProp);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eEnumProp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SUITestData.ETestEnum") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->eEnumProp)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SUITestData.ETestEnum", static_cast<int>(s_Object->eEnumProp))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ridProp") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->ridProp, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aStringArray") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZString>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aStringArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aStringArray[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->aStringArray.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aSubStructArray") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SUITestData.SSubStruct>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSubStructArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSubStructArray[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SUITestData.SSubStruct") << ",\"$val\":";
		SUITestData_SSubStruct::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->aSubStructArray.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aFixedArray") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aFixedArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aFixedArray[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->aFixedArray.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SUITestData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nIntProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nIntProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fInt16Prop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fInt16Prop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fUInt32Prop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fUInt32Prop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFloatProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFloatProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sStringProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sStringProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eEnumProp") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SUITestData.ETestEnum", static_cast<int>(s_Object->eEnumProp)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ridProp") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->ridProp, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aStringArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aStringArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aStringArray[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aStringArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aSubStructArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSubStructArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSubStructArray[i];
		SUITestData_SSubStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aSubStructArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aFixedArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aFixedArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aFixedArray[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aFixedArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUITestData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUITestData s_Object {};

	s_Object.nIntProp = simdjson::from_json_int32(p_Document["nIntProp"]);

	s_Object.fInt16Prop = simdjson::from_json_int16(p_Document["fInt16Prop"]);

	s_Object.fUInt32Prop = simdjson::from_json_uint32(p_Document["fUInt32Prop"]);

	s_Object.fFloatProp = simdjson::from_json_float32(p_Document["fFloatProp"]);

	s_Object.sStringProp = std::string_view(p_Document["sStringProp"]);

	s_Object.eEnumProp = static_cast<SUITestData_ETestEnum>(ZHMEnums::GetEnumValueByName("SUITestData.ETestEnum", std::string_view(p_Document["eEnumProp"])));

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["ridProp"], &s_Item);
		s_Object.ridProp = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["aStringArray"])
	{
		s_Object.aStringArray.push_back(std::string_view(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["aSubStructArray"])
	{
		SUITestData_SSubStruct s_ArrayItem0;
		SUITestData_SSubStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aSubStructArray.push_back(s_ArrayItem0);
	}

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["aFixedArray"])
	{
		s_Object.aFixedArray[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	*reinterpret_cast<SUITestData*>(p_Target) = s_Object;
}

void SUITestData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);

	ZString::Serialize(&s_Object->sStringProp, p_Serializer, p_OwnOffset + offsetof(SUITestData, sStringProp));
	ZRuntimeResourceID::Serialize(&s_Object->ridProp, p_Serializer, p_OwnOffset + offsetof(SUITestData, ridProp));
	TArray<ZString>::Serialize(&s_Object->aStringArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aStringArray));
	TArray<SUITestData_SSubStruct>::Serialize(&s_Object->aSubStructArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aSubStructArray));
	TFixedArray<int32, 3>::Serialize(&s_Object->aFixedArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aFixedArray));
}

bool SUITestData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData::operator==(const SUITestData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData>)
		return false;

	if (nIntProp != p_Other.nIntProp) return false;
	if (fInt16Prop != p_Other.fInt16Prop) return false;
	if (fUInt32Prop != p_Other.fUInt32Prop) return false;
	if (fFloatProp != p_Other.fFloatProp) return false;
	if (sStringProp != p_Other.sStringProp) return false;
	if (eEnumProp != p_Other.eEnumProp) return false;
	if (ridProp != p_Other.ridProp) return false;
	if (aStringArray != p_Other.aStringArray) return false;
	if (aSubStructArray != p_Other.aSubStructArray) return false;
	if (aFixedArray != p_Other.aFixedArray) return false;

	return true;
}

ZHMTypeInfo SVIPInvestigateGroupSaveData::TypeInfo = ZHMTypeInfo("SVIPInvestigateGroupSaveData", sizeof(SVIPInvestigateGroupSaveData), alignof(SVIPInvestigateGroupSaveData), SVIPInvestigateGroupSaveData::WriteJson, SVIPInvestigateGroupSaveData::WriteSimpleJson, SVIPInvestigateGroupSaveData::FromSimpleJson, SVIPInvestigateGroupSaveData::Serialize, SVIPInvestigateGroupSaveData::Equals);

void SVIPInvestigateGroupSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SFSMSaveData") << ",\"$val\":";
	SFSMSaveData::WriteJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIP") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIP);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSelectedBodyguard") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSelectedBodyguard);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInvestigator") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInvestigator);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSelectedBodyguardActor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSelectedBodyguardActor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EVIPInvestigateReason") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eReason)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EVIPInvestigateReason", static_cast<int>(s_Object->m_eReason))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBodyguardNotFound") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBodyguardNotFound);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOrderDialogStarted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOrderDialogStarted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReporting") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReporting);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWait") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWait);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginalVIPPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vOriginalVIPPosition, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SVIPInvestigateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIP") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIP);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSelectedBodyguard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSelectedBodyguard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInvestigator") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInvestigator);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSelectedBodyguardActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSelectedBodyguardActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EVIPInvestigateReason", static_cast<int>(s_Object->m_eReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBodyguardNotFound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBodyguardNotFound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOrderDialogStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOrderDialogStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReporting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReporting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWait") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWait);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginalVIPPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vOriginalVIPPosition, p_Stream);

	p_Stream << "}";
}

void SVIPInvestigateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVIPInvestigateGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	s_Object.m_rVIP = simdjson::from_json_uint32(p_Document["m_rVIP"]);

	s_Object.m_rSelectedBodyguard = simdjson::from_json_uint32(p_Document["m_rSelectedBodyguard"]);

	s_Object.m_rInvestigator = simdjson::from_json_uint32(p_Document["m_rInvestigator"]);

	s_Object.m_rSelectedBodyguardActor = simdjson::from_json_uint32(p_Document["m_rSelectedBodyguardActor"]);

	s_Object.m_eReason = static_cast<EVIPInvestigateReason>(ZHMEnums::GetEnumValueByName("EVIPInvestigateReason", std::string_view(p_Document["m_eReason"])));

	s_Object.m_bBodyguardNotFound = simdjson::from_json_bool(p_Document["m_bBodyguardNotFound"]);

	s_Object.m_bOrderDialogStarted = simdjson::from_json_bool(p_Document["m_bOrderDialogStarted"]);

	s_Object.m_bReporting = simdjson::from_json_bool(p_Document["m_bReporting"]);

	s_Object.m_bWait = simdjson::from_json_bool(p_Document["m_bWait"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vOriginalVIPPosition"], &s_Item);
		s_Object.m_vOriginalVIPPosition = s_Item;
	}

	*reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Target) = s_Object;
}

void SVIPInvestigateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SVIPInvestigateGroupSaveData, m_fsmState));
	float4::Serialize(&s_Object->m_vOriginalVIPPosition, p_Serializer, p_OwnOffset + offsetof(SVIPInvestigateGroupSaveData, m_vOriginalVIPPosition));
}

bool SVIPInvestigateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVIPInvestigateGroupSaveData::operator==(const SVIPInvestigateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVIPInvestigateGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_rVIP != p_Other.m_rVIP) return false;
	if (m_rSelectedBodyguard != p_Other.m_rSelectedBodyguard) return false;
	if (m_rInvestigator != p_Other.m_rInvestigator) return false;
	if (m_rSelectedBodyguardActor != p_Other.m_rSelectedBodyguardActor) return false;
	if (m_eReason != p_Other.m_eReason) return false;
	if (m_bBodyguardNotFound != p_Other.m_bBodyguardNotFound) return false;
	if (m_bOrderDialogStarted != p_Other.m_bOrderDialogStarted) return false;
	if (m_bReporting != p_Other.m_bReporting) return false;
	if (m_bWait != p_Other.m_bWait) return false;
	if (m_vOriginalVIPPosition != p_Other.m_vOriginalVIPPosition) return false;

	return true;
}

ZHMTypeInfo SValueBoolsSaveData::TypeInfo = ZHMTypeInfo("SValueBoolsSaveData", sizeof(SValueBoolsSaveData), alignof(SValueBoolsSaveData), SValueBoolsSaveData::WriteJson, SValueBoolsSaveData::WriteSimpleJson, SValueBoolsSaveData::FromSimpleJson, SValueBoolsSaveData::Serialize, SValueBoolsSaveData::Equals);

void SValueBoolsSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<bool>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SValueBoolsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueBoolsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueBoolsSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		s_Object.m_aData.push_back(simdjson::from_json_bool(s_Item0));
	}

	*reinterpret_cast<SValueBoolsSaveData*>(p_Target) = s_Object;
}

void SValueBoolsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueBoolsSaveData, m_aEntities));
	TArray<bool>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueBoolsSaveData, m_aData));
}

bool SValueBoolsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueBoolsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueBoolsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueBoolsSaveData::operator==(const SValueBoolsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueBoolsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SValueFloatSaveData::TypeInfo = ZHMTypeInfo("SValueFloatSaveData", sizeof(SValueFloatSaveData), alignof(SValueFloatSaveData), SValueFloatSaveData::WriteJson, SValueFloatSaveData::WriteSimpleJson, SValueFloatSaveData::FromSimpleJson, SValueFloatSaveData::Serialize, SValueFloatSaveData::Equals);

void SValueFloatSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SValueFloatSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueFloatSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueFloatSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		s_Object.m_aData.push_back(simdjson::from_json_float32(s_Item0));
	}

	*reinterpret_cast<SValueFloatSaveData*>(p_Target) = s_Object;
}

void SValueFloatSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueFloatSaveData, m_aEntities));
	TArray<float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueFloatSaveData, m_aData));
}

bool SValueFloatSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueFloatSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueFloatSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueFloatSaveData::operator==(const SValueFloatSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueFloatSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SValueIntSaveData::TypeInfo = ZHMTypeInfo("SValueIntSaveData", sizeof(SValueIntSaveData), alignof(SValueIntSaveData), SValueIntSaveData::WriteJson, SValueIntSaveData::WriteSimpleJson, SValueIntSaveData::FromSimpleJson, SValueIntSaveData::Serialize, SValueIntSaveData::Equals);

void SValueIntSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SValueIntSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueIntSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueIntSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aEntities"])
	{
		s_Object.m_aEntities.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aData"])
	{
		s_Object.m_aData.push_back(simdjson::from_json_int32(s_Item0));
	}

	*reinterpret_cast<SValueIntSaveData*>(p_Target) = s_Object;
}

void SValueIntSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueIntSaveData, m_aEntities));
	TArray<int32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueIntSaveData, m_aData));
}

bool SValueIntSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueIntSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueIntSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueIntSaveData::operator==(const SValueIntSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueIntSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

ZHMTypeInfo SValueSaveData::TypeInfo = ZHMTypeInfo("SValueSaveData", sizeof(SValueSaveData), alignof(SValueSaveData), SValueSaveData::WriteJson, SValueSaveData::WriteSimpleJson, SValueSaveData::FromSimpleJson, SValueSaveData::Serialize, SValueSaveData::Equals);

void SValueSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_ValueBool") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SValueBoolsSaveData") << ",\"$val\":";
	SValueBoolsSaveData::WriteJson(&s_Object->m_ValueBool, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueFloat") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SValueFloatSaveData") << ",\"$val\":";
	SValueFloatSaveData::WriteJson(&s_Object->m_ValueFloat, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueInt") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SValueIntSaveData") << ",\"$val\":";
	SValueIntSaveData::WriteJson(&s_Object->m_ValueInt, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StateController") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SStateControllerSaveData") << ",\"$val\":";
	SStateControllerSaveData::WriteJson(&s_Object->m_StateController, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueColorRGB") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SColorRGBSaveData") << ",\"$val\":";
	SColorRGBSaveData::WriteJson(&s_Object->m_ValueColorRGB, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SValueSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ValueBool") << ":";
	SValueBoolsSaveData::WriteSimpleJson(&s_Object->m_ValueBool, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueFloat") << ":";
	SValueFloatSaveData::WriteSimpleJson(&s_Object->m_ValueFloat, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueInt") << ":";
	SValueIntSaveData::WriteSimpleJson(&s_Object->m_ValueInt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StateController") << ":";
	SStateControllerSaveData::WriteSimpleJson(&s_Object->m_StateController, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueColorRGB") << ":";
	SColorRGBSaveData::WriteSimpleJson(&s_Object->m_ValueColorRGB, p_Stream);

	p_Stream << "}";
}

void SValueSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueSaveData s_Object {};

	{
		SValueBoolsSaveData s_Item {};
		SValueBoolsSaveData::FromSimpleJson(p_Document["m_ValueBool"], &s_Item);
		s_Object.m_ValueBool = s_Item;
	}

	{
		SValueFloatSaveData s_Item {};
		SValueFloatSaveData::FromSimpleJson(p_Document["m_ValueFloat"], &s_Item);
		s_Object.m_ValueFloat = s_Item;
	}

	{
		SValueIntSaveData s_Item {};
		SValueIntSaveData::FromSimpleJson(p_Document["m_ValueInt"], &s_Item);
		s_Object.m_ValueInt = s_Item;
	}

	{
		SStateControllerSaveData s_Item {};
		SStateControllerSaveData::FromSimpleJson(p_Document["m_StateController"], &s_Item);
		s_Object.m_StateController = s_Item;
	}

	{
		SColorRGBSaveData s_Item {};
		SColorRGBSaveData::FromSimpleJson(p_Document["m_ValueColorRGB"], &s_Item);
		s_Object.m_ValueColorRGB = s_Item;
	}

	*reinterpret_cast<SValueSaveData*>(p_Target) = s_Object;
}

void SValueSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);

	SValueBoolsSaveData::Serialize(&s_Object->m_ValueBool, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueBool));
	SValueFloatSaveData::Serialize(&s_Object->m_ValueFloat, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueFloat));
	SValueIntSaveData::Serialize(&s_Object->m_ValueInt, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueInt));
	SStateControllerSaveData::Serialize(&s_Object->m_StateController, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_StateController));
	SColorRGBSaveData::Serialize(&s_Object->m_ValueColorRGB, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueColorRGB));
}

bool SValueSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueSaveData::operator==(const SValueSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueSaveData>)
		return false;

	if (m_ValueBool != p_Other.m_ValueBool) return false;
	if (m_ValueFloat != p_Other.m_ValueFloat) return false;
	if (m_ValueInt != p_Other.m_ValueInt) return false;
	if (m_StateController != p_Other.m_StateController) return false;
	if (m_ValueColorRGB != p_Other.m_ValueColorRGB) return false;

	return true;
}

ZHMTypeInfo SVideoDatabaseEntry::TypeInfo = ZHMTypeInfo("SVideoDatabaseEntry", sizeof(SVideoDatabaseEntry), alignof(SVideoDatabaseEntry), SVideoDatabaseEntry::WriteJson, SVideoDatabaseEntry::WriteSimpleJson, SVideoDatabaseEntry::FromSimpleJson, SVideoDatabaseEntry::Serialize, SVideoDatabaseEntry::Equals);

void SVideoDatabaseEntry::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("VideoId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->VideoId);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("RuntimeLocalizedVideoRid") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->RuntimeLocalizedVideoRid, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void SVideoDatabaseEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("VideoId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->VideoId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("RuntimeLocalizedVideoRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->RuntimeLocalizedVideoRid, p_Stream);

	p_Stream << "}";
}

void SVideoDatabaseEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVideoDatabaseEntry s_Object {};

	s_Object.VideoId = std::string_view(p_Document["VideoId"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["RuntimeLocalizedVideoRid"], &s_Item);
		s_Object.RuntimeLocalizedVideoRid = s_Item;
	}

	*reinterpret_cast<SVideoDatabaseEntry*>(p_Target) = s_Object;
}

void SVideoDatabaseEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);

	ZString::Serialize(&s_Object->VideoId, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseEntry, VideoId));
	ZRuntimeResourceID::Serialize(&s_Object->RuntimeLocalizedVideoRid, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseEntry, RuntimeLocalizedVideoRid));
}

bool SVideoDatabaseEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVideoDatabaseEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SVideoDatabaseEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVideoDatabaseEntry::operator==(const SVideoDatabaseEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVideoDatabaseEntry>)
		return false;

	if (VideoId != p_Other.VideoId) return false;
	if (RuntimeLocalizedVideoRid != p_Other.RuntimeLocalizedVideoRid) return false;

	return true;
}

ZHMTypeInfo SVideoDatabaseData::TypeInfo = ZHMTypeInfo("SVideoDatabaseData", sizeof(SVideoDatabaseData), alignof(SVideoDatabaseData), SVideoDatabaseData::WriteJson, SVideoDatabaseData::WriteSimpleJson, SVideoDatabaseData::FromSimpleJson, SVideoDatabaseData::Serialize, SVideoDatabaseData::Equals);

void SVideoDatabaseData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("Videos") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SVideoDatabaseEntry>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Videos.size(); ++i)
	{
		auto& s_Item0 = s_Object->Videos[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SVideoDatabaseEntry") << ",\"$val\":";
		SVideoDatabaseEntry::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->Videos.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SVideoDatabaseData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Videos") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Videos.size(); ++i)
	{
		auto& s_Item0 = s_Object->Videos[i];
		SVideoDatabaseEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->Videos.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVideoDatabaseData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVideoDatabaseData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["Videos"])
	{
		SVideoDatabaseEntry s_ArrayItem0;
		SVideoDatabaseEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.Videos.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SVideoDatabaseData*>(p_Target) = s_Object;
}

void SVideoDatabaseData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);

	TArray<SVideoDatabaseEntry>::Serialize(&s_Object->Videos, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseData, Videos));
}

bool SVideoDatabaseData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVideoDatabaseData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVideoDatabaseData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVideoDatabaseData::operator==(const SVideoDatabaseData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVideoDatabaseData>)
		return false;

	if (Videos != p_Other.Videos) return false;

	return true;
}

ZHMTypeInfo SVisibilitySaveData::TypeInfo = ZHMTypeInfo("SVisibilitySaveData", sizeof(SVisibilitySaveData), alignof(SVisibilitySaveData), SVisibilitySaveData::WriteJson, SVisibilitySaveData::WriteSimpleJson, SVisibilitySaveData::FromSimpleJson, SVisibilitySaveData::Serialize, SVisibilitySaveData::Equals);

void SVisibilitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << "}";

	p_Stream << "}";
}

void SVisibilitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);

	p_Stream << "}";
}

void SVisibilitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVisibilitySaveData s_Object {};

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	*reinterpret_cast<SVisibilitySaveData*>(p_Target) = s_Object;
}

void SVisibilitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);

}

bool SVisibilitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVisibilitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVisibilitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVisibilitySaveData::operator==(const SVisibilitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVisibilitySaveData>)
		return false;

	if (m_bIsVisible != p_Other.m_bIsVisible) return false;

	return true;
}

ZHMTypeInfo SVoidSignalEntitySaveData::TypeInfo = ZHMTypeInfo("SVoidSignalEntitySaveData", sizeof(SVoidSignalEntitySaveData), alignof(SVoidSignalEntitySaveData), SVoidSignalEntitySaveData::WriteJson, SVoidSignalEntitySaveData::WriteSimpleJson, SVoidSignalEntitySaveData::FromSimpleJson, SVoidSignalEntitySaveData::Serialize, SVoidSignalEntitySaveData::Equals);

void SVoidSignalEntitySaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bSignaling") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSignaling);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFiredAtTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFiredAtTime);
	p_Stream << "}";

	p_Stream << "}";
}

void SVoidSignalEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSignaling") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSignaling);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFiredAtTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFiredAtTime);

	p_Stream << "}";
}

void SVoidSignalEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVoidSignalEntitySaveData s_Object {};

	s_Object.m_bSignaling = simdjson::from_json_bool(p_Document["m_bSignaling"]);

	s_Object.m_fFiredAtTime = simdjson::from_json_float32(p_Document["m_fFiredAtTime"]);

	*reinterpret_cast<SVoidSignalEntitySaveData*>(p_Target) = s_Object;
}

void SVoidSignalEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);

}

bool SVoidSignalEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVoidSignalEntitySaveData::operator==(const SVoidSignalEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVoidSignalEntitySaveData>)
		return false;

	if (m_bSignaling != p_Other.m_bSignaling) return false;
	if (m_fFiredAtTime != p_Other.m_fFiredAtTime) return false;

	return true;
}

ZHMTypeInfo SWaveformGeneratorSaveData::TypeInfo = ZHMTypeInfo("SWaveformGeneratorSaveData", sizeof(SWaveformGeneratorSaveData), alignof(SWaveformGeneratorSaveData), SWaveformGeneratorSaveData::WriteJson, SWaveformGeneratorSaveData::WriteSimpleJson, SWaveformGeneratorSaveData::FromSimpleJson, SWaveformGeneratorSaveData::Serialize, SWaveformGeneratorSaveData::Equals);

void SWaveformGeneratorSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFrequency") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFrequency);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOffset") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOffset);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fScale") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fScale);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStartTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCount);
	p_Stream << "}";

	p_Stream << "}";
}

void SWaveformGeneratorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFrequency") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFrequency);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStartTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStartTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCount);

	p_Stream << "}";
}

void SWaveformGeneratorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWaveformGeneratorSaveData s_Object {};

	s_Object.m_fTime = simdjson::from_json_float32(p_Document["m_fTime"]);

	s_Object.m_fFrequency = simdjson::from_json_float32(p_Document["m_fFrequency"]);

	s_Object.m_fOffset = simdjson::from_json_float32(p_Document["m_fOffset"]);

	s_Object.m_fScale = simdjson::from_json_float32(p_Document["m_fScale"]);

	s_Object.m_fStartTime = simdjson::from_json_float32(p_Document["m_fStartTime"]);

	s_Object.m_nCount = simdjson::from_json_uint32(p_Document["m_nCount"]);

	*reinterpret_cast<SWaveformGeneratorSaveData*>(p_Target) = s_Object;
}

void SWaveformGeneratorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);

}

bool SWaveformGeneratorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWaveformGeneratorSaveData::operator==(const SWaveformGeneratorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWaveformGeneratorSaveData>)
		return false;

	if (m_fTime != p_Other.m_fTime) return false;
	if (m_fFrequency != p_Other.m_fFrequency) return false;
	if (m_fOffset != p_Other.m_fOffset) return false;
	if (m_fScale != p_Other.m_fScale) return false;
	if (m_fStartTime != p_Other.m_fStartTime) return false;
	if (m_nCount != p_Other.m_nCount) return false;

	return true;
}

ZHMTypeInfo SWaveformGeneratorManagerSaveData::TypeInfo = ZHMTypeInfo("SWaveformGeneratorManagerSaveData", sizeof(SWaveformGeneratorManagerSaveData), alignof(SWaveformGeneratorManagerSaveData), SWaveformGeneratorManagerSaveData::WriteJson, SWaveformGeneratorManagerSaveData::WriteSimpleJson, SWaveformGeneratorManagerSaveData::FromSimpleJson, SWaveformGeneratorManagerSaveData::Serialize, SWaveformGeneratorManagerSaveData::Equals);

void SWaveformGeneratorManagerSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aGenerators") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGenerators.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGenerators[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aGenerators.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGeneratorData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SWaveformGeneratorSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGeneratorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGeneratorData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SWaveformGeneratorSaveData") << ",\"$val\":";
		SWaveformGeneratorSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aGeneratorData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SWaveformGeneratorManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aGenerators") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGenerators.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGenerators[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aGenerators.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGeneratorData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGeneratorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGeneratorData[i];
		SWaveformGeneratorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGeneratorData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SWaveformGeneratorManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWaveformGeneratorManagerSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGenerators"])
	{
		s_Object.m_aGenerators.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGeneratorData"])
	{
		SWaveformGeneratorSaveData s_ArrayItem0;
		SWaveformGeneratorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGeneratorData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Target) = s_Object;
}

void SWaveformGeneratorManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aGenerators, p_Serializer, p_OwnOffset + offsetof(SWaveformGeneratorManagerSaveData, m_aGenerators));
	TArray<SWaveformGeneratorSaveData>::Serialize(&s_Object->m_aGeneratorData, p_Serializer, p_OwnOffset + offsetof(SWaveformGeneratorManagerSaveData, m_aGeneratorData));
}

bool SWaveformGeneratorManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWaveformGeneratorManagerSaveData::operator==(const SWaveformGeneratorManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWaveformGeneratorManagerSaveData>)
		return false;

	if (m_aGenerators != p_Other.m_aGenerators) return false;
	if (m_aGeneratorData != p_Other.m_aGeneratorData) return false;

	return true;
}

ZHMTypeInfo SWeaponSoundDefs::TypeInfo = ZHMTypeInfo("SWeaponSoundDefs", sizeof(SWeaponSoundDefs), alignof(SWeaponSoundDefs), SWeaponSoundDefs::WriteJson, SWeaponSoundDefs::WriteSimpleJson, SWeaponSoundDefs::FromSimpleJson, SWeaponSoundDefs::Serialize, SWeaponSoundDefs::Equals);

void SWeaponSoundDefs::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void SWeaponSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SWeaponSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWeaponSoundDefs s_Object {};

	*reinterpret_cast<SWeaponSoundDefs*>(p_Target) = s_Object;
}

void SWeaponSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);

}

bool SWeaponSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWeaponSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SWeaponSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWeaponSoundDefs::operator==(const SWeaponSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWeaponSoundDefs>)
		return false;


	return true;
}

ZHMTypeInfo SWeaponStatusUIData::TypeInfo = ZHMTypeInfo("SWeaponStatusUIData", sizeof(SWeaponStatusUIData), alignof(SWeaponStatusUIData), SWeaponStatusUIData::WriteJson, SWeaponStatusUIData::WriteSimpleJson, SWeaponStatusUIData::FromSimpleJson, SWeaponStatusUIData::Serialize, SWeaponStatusUIData::Equals);

void SWeaponStatusUIData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponStatusUIData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->icon, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedIcon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->containedIcon, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sWeaponName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sWeaponName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContainedWeaponName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sContainedWeaponName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSilenced") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bSilenced);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsFirearm") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bIsFirearm);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHolstered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bHolstered);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHasItemToShow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bHasItemToShow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fPointShootingGaunge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->fPointShootingGaunge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedItemRepoId") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->containedItemRepoId, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSuspicious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bSuspicious);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIllegal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bIllegal);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bCanReload") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bCanReload);
	p_Stream << "}";

	p_Stream << "}";
}

void SWeaponStatusUIData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponStatusUIData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedIcon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->containedIcon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sWeaponName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sWeaponName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContainedWeaponName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContainedWeaponName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSilenced") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSilenced);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsFirearm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsFirearm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHolstered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHolstered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHasItemToShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHasItemToShow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fPointShootingGaunge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fPointShootingGaunge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedItemRepoId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->containedItemRepoId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bCanReload") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bCanReload);

	p_Stream << "}";
}

void SWeaponStatusUIData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWeaponStatusUIData s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["containedIcon"], &s_Item);
		s_Object.containedIcon = s_Item;
	}

	s_Object.sWeaponName = std::string_view(p_Document["sWeaponName"]);

	s_Object.sContainedWeaponName = std::string_view(p_Document["sContainedWeaponName"]);

	s_Object.nWeaponType = simdjson::from_json_int32(p_Document["nWeaponType"]);

	s_Object.nAmmoRemaining = simdjson::from_json_int32(p_Document["nAmmoRemaining"]);

	s_Object.nAmmoTotal = simdjson::from_json_int32(p_Document["nAmmoTotal"]);

	s_Object.nAmmoInClip = simdjson::from_json_int32(p_Document["nAmmoInClip"]);

	s_Object.bSilenced = simdjson::from_json_bool(p_Document["bSilenced"]);

	s_Object.bIsFirearm = simdjson::from_json_bool(p_Document["bIsFirearm"]);

	s_Object.bHolstered = simdjson::from_json_bool(p_Document["bHolstered"]);

	s_Object.bHasItemToShow = simdjson::from_json_bool(p_Document["bHasItemToShow"]);

	s_Object.fPointShootingGaunge = simdjson::from_json_float32(p_Document["fPointShootingGaunge"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["containedItemRepoId"], &s_Item);
		s_Object.containedItemRepoId = s_Item;
	}

	s_Object.bSuspicious = simdjson::from_json_bool(p_Document["bSuspicious"]);

	s_Object.bIllegal = simdjson::from_json_bool(p_Document["bIllegal"]);

	s_Object.bCanReload = simdjson::from_json_bool(p_Document["bCanReload"]);

	*reinterpret_cast<SWeaponStatusUIData*>(p_Target) = s_Object;
}

void SWeaponStatusUIData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWeaponStatusUIData*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, icon));
	ZRuntimeResourceID::Serialize(&s_Object->containedIcon, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, containedIcon));
	ZString::Serialize(&s_Object->sWeaponName, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, sWeaponName));
	ZString::Serialize(&s_Object->sContainedWeaponName, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, sContainedWeaponName));
	ZRepositoryID::Serialize(&s_Object->containedItemRepoId, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, containedItemRepoId));
}

bool SWeaponStatusUIData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWeaponStatusUIData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWeaponStatusUIData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWeaponStatusUIData::operator==(const SWeaponStatusUIData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWeaponStatusUIData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (containedIcon != p_Other.containedIcon) return false;
	if (sWeaponName != p_Other.sWeaponName) return false;
	if (sContainedWeaponName != p_Other.sContainedWeaponName) return false;
	if (nWeaponType != p_Other.nWeaponType) return false;
	if (nAmmoRemaining != p_Other.nAmmoRemaining) return false;
	if (nAmmoTotal != p_Other.nAmmoTotal) return false;
	if (nAmmoInClip != p_Other.nAmmoInClip) return false;
	if (bSilenced != p_Other.bSilenced) return false;
	if (bIsFirearm != p_Other.bIsFirearm) return false;
	if (bHolstered != p_Other.bHolstered) return false;
	if (bHasItemToShow != p_Other.bHasItemToShow) return false;
	if (fPointShootingGaunge != p_Other.fPointShootingGaunge) return false;
	if (containedItemRepoId != p_Other.containedItemRepoId) return false;
	if (bSuspicious != p_Other.bSuspicious) return false;
	if (bIllegal != p_Other.bIllegal) return false;
	if (bCanReload != p_Other.bCanReload) return false;

	return true;
}

ZHMTypeInfo SWorldInventoryInstanceSaveData::TypeInfo = ZHMTypeInfo("SWorldInventoryInstanceSaveData", sizeof(SWorldInventoryInstanceSaveData), alignof(SWorldInventoryInstanceSaveData), SWorldInventoryInstanceSaveData::WriteJson, SWorldInventoryInstanceSaveData::WriteSimpleJson, SWorldInventoryInstanceSaveData::FromSimpleJson, SWorldInventoryInstanceSaveData::Serialize, SWorldInventoryInstanceSaveData::Equals);

void SWorldInventoryInstanceSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aItemInstanceSaveData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SItemInstanceSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemInstanceSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemInstanceSaveData[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SItemInstanceSaveData") << ",\"$val\":";
		SItemInstanceSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aItemInstanceSaveData.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void SWorldInventoryInstanceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItemInstanceSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemInstanceSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemInstanceSaveData[i];
		SItemInstanceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItemInstanceSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SWorldInventoryInstanceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWorldInventoryInstanceSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aItemInstanceSaveData"])
	{
		SItemInstanceSaveData s_ArrayItem0;
		SItemInstanceSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItemInstanceSaveData.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Target) = s_Object;
}

void SWorldInventoryInstanceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Object);

	TArray<SItemInstanceSaveData>::Serialize(&s_Object->m_aItemInstanceSaveData, p_Serializer, p_OwnOffset + offsetof(SWorldInventoryInstanceSaveData, m_aItemInstanceSaveData));
}

bool SWorldInventoryInstanceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWorldInventoryInstanceSaveData::operator==(const SWorldInventoryInstanceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWorldInventoryInstanceSaveData>)
		return false;

	if (m_aItemInstanceSaveData != p_Other.m_aItemInstanceSaveData) return false;

	return true;
}

ZHMTypeInfo ZAMDEvent::TypeInfo = ZHMTypeInfo("ZAMDEvent", sizeof(ZAMDEvent), alignof(ZAMDEvent), ZAMDEvent::WriteJson, ZAMDEvent::WriteSimpleJson, ZAMDEvent::FromSimpleJson, ZAMDEvent::Serialize, ZAMDEvent::Equals);

void ZAMDEvent::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStartFraction") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStartFraction);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_customData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_customData, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void ZAMDEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStartFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStartFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_customData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_customData, p_Stream);

	p_Stream << "}";
}

void ZAMDEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAMDEvent s_Object {};

	s_Object.m_nEventID = simdjson::from_json_uint32(p_Document["m_nEventID"]);

	s_Object.m_fStartFraction = simdjson::from_json_float32(p_Document["m_fStartFraction"]);

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_customData"], &s_Item);
		s_Object.m_customData = s_Item;
	}

	*reinterpret_cast<ZAMDEvent*>(p_Target) = s_Object;
}

void ZAMDEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);

	ZVariant::Serialize(&s_Object->m_customData, p_Serializer, p_OwnOffset + offsetof(ZAMDEvent, m_customData));
}

bool ZAMDEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDEvent::operator==(const ZAMDEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDEvent>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;
	if (m_fStartFraction != p_Other.m_fStartFraction) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_customData != p_Other.m_customData) return false;

	return true;
}

ZHMTypeInfo ZAMDEventTrack::TypeInfo = ZHMTypeInfo("ZAMDEventTrack", sizeof(ZAMDEventTrack), alignof(ZAMDEventTrack), ZAMDEventTrack::WriteJson, ZAMDEventTrack::WriteSimpleJson, ZAMDEventTrack::FromSimpleJson, ZAMDEventTrack::Serialize, ZAMDEventTrack::Equals);

void ZAMDEventTrack::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_events") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZAMDEvent>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_events.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_events[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZAMDEvent") << ",\"$val\":";
		ZAMDEvent::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_events.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZAMDEventTrack::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_events") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_events.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_events[i];
		ZAMDEvent::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_events.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZAMDEventTrack::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAMDEventTrack s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_events"])
	{
		ZAMDEvent s_ArrayItem0;
		ZAMDEvent::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_events.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<ZAMDEventTrack*>(p_Target) = s_Object;
}

void ZAMDEventTrack::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(ZAMDEventTrack, m_sName));
	TArray<ZAMDEvent>::Serialize(&s_Object->m_events, p_Serializer, p_OwnOffset + offsetof(ZAMDEventTrack, m_events));
}

bool ZAMDEventTrack::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDEventTrack*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDEventTrack*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDEventTrack::operator==(const ZAMDEventTrack& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDEventTrack>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_events != p_Other.m_events) return false;

	return true;
}

ZHMTypeInfo ZAMDTake::TypeInfo = ZHMTypeInfo("ZAMDTake", sizeof(ZAMDTake), alignof(ZAMDTake), ZAMDTake::WriteJson, ZAMDTake::WriteSimpleJson, ZAMDTake::FromSimpleJson, ZAMDTake::Serialize, ZAMDTake::Equals);

void ZAMDTake::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eventTracks") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZAMDEventTrack>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_eventTracks.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_eventTracks[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZAMDEventTrack") << ",\"$val\":";
		ZAMDEventTrack::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_eventTracks.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_customData") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
	ZVariant::WriteJson(&s_Object->m_customData, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSyncTrackIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSyncTrackIndex);
	p_Stream << "}";

	p_Stream << "}";
}

void ZAMDTake::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eventTracks") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_eventTracks.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_eventTracks[i];
		ZAMDEventTrack::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_eventTracks.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_customData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_customData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSyncTrackIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSyncTrackIndex);

	p_Stream << "}";
}

void ZAMDTake::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAMDTake s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_eventTracks"])
	{
		ZAMDEventTrack s_ArrayItem0;
		ZAMDEventTrack::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_eventTracks.push_back(s_ArrayItem0);
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_customData"], &s_Item);
		s_Object.m_customData = s_Item;
	}

	s_Object.m_nSyncTrackIndex = simdjson::from_json_int32(p_Document["m_nSyncTrackIndex"]);

	*reinterpret_cast<ZAMDTake*>(p_Target) = s_Object;
}

void ZAMDTake::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);

	TArray<ZAMDEventTrack>::Serialize(&s_Object->m_eventTracks, p_Serializer, p_OwnOffset + offsetof(ZAMDTake, m_eventTracks));
	ZVariant::Serialize(&s_Object->m_customData, p_Serializer, p_OwnOffset + offsetof(ZAMDTake, m_customData));
}

bool ZAMDTake::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDTake*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDTake*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDTake::operator==(const ZAMDTake& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDTake>)
		return false;

	if (m_eventTracks != p_Other.m_eventTracks) return false;
	if (m_customData != p_Other.m_customData) return false;
	if (m_nSyncTrackIndex != p_Other.m_nSyncTrackIndex) return false;

	return true;
}

ZHMTypeInfo ZAT2Controller_SEventPreviewInfo::TypeInfo = ZHMTypeInfo("ZAT2Controller.SEventPreviewInfo", sizeof(ZAT2Controller_SEventPreviewInfo), alignof(ZAT2Controller_SEventPreviewInfo), ZAT2Controller_SEventPreviewInfo::WriteJson, ZAT2Controller_SEventPreviewInfo::WriteSimpleJson, ZAT2Controller_SEventPreviewInfo::FromSimpleJson, ZAT2Controller_SEventPreviewInfo::Serialize, ZAT2Controller_SEventPreviewInfo::Equals);

void ZAT2Controller_SEventPreviewInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sConsumerID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sConsumerID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExtraDataTypeName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExtraDataTypeName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_extraDataProperties") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TMap<ZString,ZVariant>") << ",\"$val\":";
	TMap<ZString,ZVariant>::WriteJson(&s_Object->m_extraDataProperties, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void ZAT2Controller_SEventPreviewInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sConsumerID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sConsumerID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExtraDataTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExtraDataTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_extraDataProperties") << ":";
	TMap<ZString,ZVariant>::WriteSimpleJson(&s_Object->m_extraDataProperties, p_Stream);

	p_Stream << "}";
}

void ZAT2Controller_SEventPreviewInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAT2Controller_SEventPreviewInfo s_Object {};

	s_Object.m_nEventID = simdjson::from_json_int32(p_Document["m_nEventID"]);

	s_Object.m_sConsumerID = std::string_view(p_Document["m_sConsumerID"]);

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object.m_sExtraDataTypeName = std::string_view(p_Document["m_sExtraDataTypeName"]);

	{
		TMap<ZString,ZVariant> s_Item {};
		TMap<ZString,ZVariant>::FromSimpleJson(p_Document["m_extraDataProperties"], &s_Item);
		s_Object.m_extraDataProperties = s_Item;
	}

	*reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Target) = s_Object;
}

void ZAT2Controller_SEventPreviewInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Object);

	ZString::Serialize(&s_Object->m_sConsumerID, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller_SEventPreviewInfo, m_sConsumerID));
	ZString::Serialize(&s_Object->m_sExtraDataTypeName, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller_SEventPreviewInfo, m_sExtraDataTypeName));
	TMap<ZString,ZVariant>::Serialize(&s_Object->m_extraDataProperties, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller_SEventPreviewInfo, m_extraDataProperties));
}

bool ZAT2Controller_SEventPreviewInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAT2Controller_SEventPreviewInfo::operator==(const ZAT2Controller_SEventPreviewInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAT2Controller_SEventPreviewInfo>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;
	if (m_sConsumerID != p_Other.m_sConsumerID) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_sExtraDataTypeName != p_Other.m_sExtraDataTypeName) return false;
	if (m_extraDataProperties != p_Other.m_extraDataProperties) return false;

	return true;
}

ZHMTypeInfo ZAT2Controller_SGeneratedFootstepEvent::TypeInfo = ZHMTypeInfo("ZAT2Controller.SGeneratedFootstepEvent", sizeof(ZAT2Controller_SGeneratedFootstepEvent), alignof(ZAT2Controller_SGeneratedFootstepEvent), ZAT2Controller_SGeneratedFootstepEvent::WriteJson, ZAT2Controller_SGeneratedFootstepEvent::WriteSimpleJson, ZAT2Controller_SGeneratedFootstepEvent::FromSimpleJson, ZAT2Controller_SGeneratedFootstepEvent::Serialize, ZAT2Controller_SGeneratedFootstepEvent::Equals);

void ZAT2Controller_SGeneratedFootstepEvent::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eFoot") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZAT2Controller.EFoot") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eFoot)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZAT2Controller.EFoot", static_cast<int>(s_Object->m_eFoot))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFrame") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFrame);
	p_Stream << "}";

	p_Stream << "}";
}

void ZAT2Controller_SGeneratedFootstepEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFoot") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZAT2Controller.EFoot", static_cast<int>(s_Object->m_eFoot)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFrame") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFrame);

	p_Stream << "}";
}

void ZAT2Controller_SGeneratedFootstepEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAT2Controller_SGeneratedFootstepEvent s_Object {};

	s_Object.m_eFoot = static_cast<ZAT2Controller_EFoot>(ZHMEnums::GetEnumValueByName("ZAT2Controller.EFoot", std::string_view(p_Document["m_eFoot"])));

	s_Object.m_fFrame = simdjson::from_json_float32(p_Document["m_fFrame"]);

	*reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Target) = s_Object;
}

void ZAT2Controller_SGeneratedFootstepEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Object);

}

bool ZAT2Controller_SGeneratedFootstepEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAT2Controller_SGeneratedFootstepEvent::operator==(const ZAT2Controller_SGeneratedFootstepEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAT2Controller_SGeneratedFootstepEvent>)
		return false;

	if (m_eFoot != p_Other.m_eFoot) return false;
	if (m_fFrame != p_Other.m_fFrame) return false;

	return true;
}

ZHMTypeInfo ZApproachOrder_SApproachOrderSaveData::TypeInfo = ZHMTypeInfo("ZApproachOrder.SApproachOrderSaveData", sizeof(ZApproachOrder_SApproachOrderSaveData), alignof(ZApproachOrder_SApproachOrderSaveData), ZApproachOrder_SApproachOrderSaveData::WriteJson, ZApproachOrder_SApproachOrderSaveData::WriteSimpleJson, ZApproachOrder_SApproachOrderSaveData::FromSimpleJson, ZApproachOrder_SApproachOrderSaveData::Serialize, ZApproachOrder_SApproachOrderSaveData::Equals);

void ZApproachOrder_SApproachOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_style") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZApproachOrder.EApproachStyle") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_style)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZApproachOrder.EApproachStyle", static_cast<int>(s_Object->m_style))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceStand") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceStand);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << "}";

	p_Stream << "}";
}

void ZApproachOrder_SApproachOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_style") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZApproachOrder.EApproachStyle", static_cast<int>(s_Object->m_style)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceStand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceStand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);

	p_Stream << "}";
}

void ZApproachOrder_SApproachOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZApproachOrder_SApproachOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Item);
		s_Object.m_vStopDirection = s_Item;
	}

	s_Object.m_style = static_cast<ZApproachOrder_EApproachStyle>(ZHMEnums::GetEnumValueByName("ZApproachOrder.EApproachStyle", std::string_view(p_Document["m_style"])));

	s_Object.m_bForceStand = simdjson::from_json_bool(p_Document["m_bForceStand"]);

	s_Object.m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

	*reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Target) = s_Object;
}

void ZApproachOrder_SApproachOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZApproachOrder_SApproachOrderSaveData, m_vStopDirection));
}

bool ZApproachOrder_SApproachOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZApproachOrder_SApproachOrderSaveData::operator==(const ZApproachOrder_SApproachOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZApproachOrder_SApproachOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_style != p_Other.m_style) return false;
	if (m_bForceStand != p_Other.m_bForceStand) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;

	return true;
}

ZHMTypeInfo ZAutoNullEntityRef::TypeInfo = ZHMTypeInfo("ZAutoNullEntityRef", sizeof(ZAutoNullEntityRef), alignof(ZAutoNullEntityRef), ZAutoNullEntityRef::WriteJson, ZAutoNullEntityRef::WriteSimpleJson, ZAutoNullEntityRef::FromSimpleJson, ZAutoNullEntityRef::Serialize, ZAutoNullEntityRef::Equals);

void ZAutoNullEntityRef::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZAutoNullEntityRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZAutoNullEntityRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAutoNullEntityRef s_Object {};

	*reinterpret_cast<ZAutoNullEntityRef*>(p_Target) = s_Object;
}

void ZAutoNullEntityRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);

}

bool ZAutoNullEntityRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAutoNullEntityRef*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAutoNullEntityRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAutoNullEntityRef::operator==(const ZAutoNullEntityRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAutoNullEntityRef>)
		return false;


	return true;
}

ZHMTypeInfo ZAvoidDangerousAreaSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZAvoidDangerousAreaSituation.SSituationSaveData", sizeof(ZAvoidDangerousAreaSituation_SSituationSaveData), alignof(ZAvoidDangerousAreaSituation_SSituationSaveData), ZAvoidDangerousAreaSituation_SSituationSaveData::WriteJson, ZAvoidDangerousAreaSituation_SSituationSaveData::WriteSimpleJson, ZAvoidDangerousAreaSituation_SSituationSaveData::FromSimpleJson, ZAvoidDangerousAreaSituation_SSituationSaveData::Serialize, ZAvoidDangerousAreaSituation_SSituationSaveData::Equals);

void ZAvoidDangerousAreaSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aAvoidDangerousAreaGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerousAreaGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerousAreaGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aAvoidDangerousAreaGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZAvoidDangerousAreaSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerousAreaGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerousAreaGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerousAreaGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerousAreaGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZAvoidDangerousAreaSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAvoidDangerousAreaSituation_SSituationSaveData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAvoidDangerousAreaGroups"])
	{
		s_Object.m_aAvoidDangerousAreaGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	*reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZAvoidDangerousAreaSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerousAreaGroups, p_Serializer, p_OwnOffset + offsetof(ZAvoidDangerousAreaSituation_SSituationSaveData, m_aAvoidDangerousAreaGroups));
}

bool ZAvoidDangerousAreaSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAvoidDangerousAreaSituation_SSituationSaveData::operator==(const ZAvoidDangerousAreaSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAvoidDangerousAreaSituation_SSituationSaveData>)
		return false;

	if (m_aAvoidDangerousAreaGroups != p_Other.m_aAvoidDangerousAreaGroups) return false;

	return true;
}

ZHMTypeInfo ZCloseCombatDef_SActorNoise::TypeInfo = ZHMTypeInfo("ZCloseCombatDef.SActorNoise", sizeof(ZCloseCombatDef_SActorNoise), alignof(ZCloseCombatDef_SActorNoise), ZCloseCombatDef_SActorNoise::WriteJson, ZCloseCombatDef_SActorNoise::WriteSimpleJson, ZCloseCombatDef_SActorNoise::FromSimpleJson, ZCloseCombatDef_SActorNoise::Serialize, ZCloseCombatDef_SActorNoise::Equals);

void ZCloseCombatDef_SActorNoise::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_iSpeak") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SActorSoundDefs.EDefinition") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_iSpeak)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_iSpeak))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAIEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAIEventType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eAIEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eAIEvent))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAIEventDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAIEventDistance);
	p_Stream << "}";

	p_Stream << "}";
}

void ZCloseCombatDef_SActorNoise::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iSpeak") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_iSpeak)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAIEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eAIEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAIEventDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAIEventDistance);

	p_Stream << "}";
}

void ZCloseCombatDef_SActorNoise::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZCloseCombatDef_SActorNoise s_Object {};

	s_Object.m_iSpeak = static_cast<SActorSoundDefs_EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_iSpeak"])));

	s_Object.m_eAIEvent = static_cast<EAIEventType>(ZHMEnums::GetEnumValueByName("EAIEventType", std::string_view(p_Document["m_eAIEvent"])));

	s_Object.m_fAIEventDistance = simdjson::from_json_float32(p_Document["m_fAIEventDistance"]);

	*reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Target) = s_Object;
}

void ZCloseCombatDef_SActorNoise::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Object);

}

bool ZCloseCombatDef_SActorNoise::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCloseCombatDef_SActorNoise*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCloseCombatDef_SActorNoise::operator==(const ZCloseCombatDef_SActorNoise& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCloseCombatDef_SActorNoise>)
		return false;

	if (m_iSpeak != p_Other.m_iSpeak) return false;
	if (m_eAIEvent != p_Other.m_eAIEvent) return false;
	if (m_fAIEventDistance != p_Other.m_fAIEventDistance) return false;

	return true;
}

ZHMTypeInfo ZComponentCreator::TypeInfo = ZHMTypeInfo("ZComponentCreator", sizeof(ZComponentCreator), alignof(ZComponentCreator), ZComponentCreator::WriteJson, ZComponentCreator::WriteSimpleJson, ZComponentCreator::FromSimpleJson, ZComponentCreator::Serialize, ZComponentCreator::Equals);

void ZComponentCreator::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sComponentName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sComponentName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aArgs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZVariant>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aArgs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aArgs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZVariant") << ",\"$val\":";
		ZVariant::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aArgs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZComponentCreator::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sComponentName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sComponentName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aArgs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aArgs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aArgs[i];
		ZVariant::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aArgs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZComponentCreator::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZComponentCreator s_Object {};

	s_Object.m_sComponentName = std::string_view(p_Document["m_sComponentName"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aArgs"])
	{
		ZVariant s_ArrayItem0;
		ZVariant::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aArgs.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<ZComponentCreator*>(p_Target) = s_Object;
}

void ZComponentCreator::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	ZString::Serialize(&s_Object->m_sComponentName, p_Serializer, p_OwnOffset + offsetof(ZComponentCreator, m_sComponentName));
	TArray<ZVariant>::Serialize(&s_Object->m_aArgs, p_Serializer, p_OwnOffset + offsetof(ZComponentCreator, m_aArgs));
}

bool ZComponentCreator::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZComponentCreator*>(p_Left);
	auto* s_Right = reinterpret_cast<ZComponentCreator*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZComponentCreator::operator==(const ZComponentCreator& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZComponentCreator>)
		return false;

	if (m_sComponentName != p_Other.m_sComponentName) return false;
	if (m_aArgs != p_Other.m_aArgs) return false;

	return true;
}

ZHMTypeInfo ZContractEvaluationContext::TypeInfo = ZHMTypeInfo("ZContractEvaluationContext", sizeof(ZContractEvaluationContext), alignof(ZContractEvaluationContext), ZContractEvaluationContext::WriteJson, ZContractEvaluationContext::WriteSimpleJson, ZContractEvaluationContext::FromSimpleJson, ZContractEvaluationContext::Serialize, ZContractEvaluationContext::Equals);

void ZContractEvaluationContext::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZContractEvaluationContext::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZContractEvaluationContext::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZContractEvaluationContext s_Object {};

	*reinterpret_cast<ZContractEvaluationContext*>(p_Target) = s_Object;
}

void ZContractEvaluationContext::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);

}

bool ZContractEvaluationContext::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZContractEvaluationContext*>(p_Left);
	auto* s_Right = reinterpret_cast<ZContractEvaluationContext*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZContractEvaluationContext::operator==(const ZContractEvaluationContext& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZContractEvaluationContext>)
		return false;


	return true;
}

ZHMTypeInfo ZCurve::TypeInfo = ZHMTypeInfo("ZCurve", sizeof(ZCurve), alignof(ZCurve), ZCurve::WriteJson, ZCurve::WriteSimpleJson, ZCurve::FromSimpleJson, ZCurve::Serialize, ZCurve::Equals);

void ZCurve::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<TFixedArray<float32>>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->data.size(); ++i)
	{
		auto& s_Item0 = s_Object->data[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("TFixedArray<float32>") << ",\"$val\":";
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
			p_Stream << simdjson::as_json_string(s_Item1);
			p_Stream << "}";

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}
		p_Stream << "]";
		p_Stream << "}";

		if (i < s_Object->data.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZCurve::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->data.size(); ++i)
	{
		auto& s_Item0 = s_Object->data[i];
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << simdjson::as_json_string(s_Item1);

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}

		p_Stream << "]";

		if (i < s_Object->data.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZCurve::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZCurve s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["data"])
	{
		TFixedArray<float32, 8> s_ArrayItem0;
		{
		size_t s_Index1 = 0;
		for (simdjson::ondemand::value s_Item1 : s_Item0)
		{
			s_ArrayItem0[s_Index1] = simdjson::from_json_float32(s_Item1);
			++s_Index1;
		}
		}
		s_Object.data.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<ZCurve*>(p_Target) = s_Object;
}

void ZCurve::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	TArray<TFixedArray<float32, 8>>::Serialize(&s_Object->data, p_Serializer, p_OwnOffset + offsetof(ZCurve, data));
}

bool ZCurve::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCurve*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCurve*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCurve::operator==(const ZCurve& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCurve>)
		return false;

	if (data != p_Other.data) return false;

	return true;
}

ZHMTypeInfo ZDeadBodySituation_SIncidentSaveData::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SIncidentSaveData", sizeof(ZDeadBodySituation_SIncidentSaveData), alignof(ZDeadBodySituation_SIncidentSaveData), ZDeadBodySituation_SIncidentSaveData::WriteJson, ZDeadBodySituation_SIncidentSaveData::WriteSimpleJson, ZDeadBodySituation_SIncidentSaveData::FromSimpleJson, ZDeadBodySituation_SIncidentSaveData::Serialize, ZDeadBodySituation_SIncidentSaveData::Equals);

void ZDeadBodySituation_SIncidentSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_body") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_body);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_blood") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_blood);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAccident") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAccident);
	p_Stream << "}";

	p_Stream << "}";
}

void ZDeadBodySituation_SIncidentSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_body") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_body);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_blood") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_blood);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAccident") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAccident);

	p_Stream << "}";
}

void ZDeadBodySituation_SIncidentSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDeadBodySituation_SIncidentSaveData s_Object {};

	s_Object.m_body = simdjson::from_json_uint32(p_Document["m_body"]);

	s_Object.m_blood = simdjson::from_json_uint32(p_Document["m_blood"]);

	s_Object.m_bAccident = simdjson::from_json_bool(p_Document["m_bAccident"]);

	*reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Target) = s_Object;
}

void ZDeadBodySituation_SIncidentSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Object);

}

bool ZDeadBodySituation_SIncidentSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation_SIncidentSaveData::operator==(const ZDeadBodySituation_SIncidentSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation_SIncidentSaveData>)
		return false;

	if (m_body != p_Other.m_body) return false;
	if (m_blood != p_Other.m_blood) return false;
	if (m_bAccident != p_Other.m_bAccident) return false;

	return true;
}

ZHMTypeInfo ZDeadBodySituation_SState::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SState", sizeof(ZDeadBodySituation_SState), alignof(ZDeadBodySituation_SState), ZDeadBodySituation_SState::WriteJson, ZDeadBodySituation_SState::WriteSimpleJson, ZDeadBodySituation_SState::FromSimpleJson, ZDeadBodySituation_SState::Serialize, ZDeadBodySituation_SState::Equals);

void ZDeadBodySituation_SState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eFlavor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDeadBodySituation.ESituationFlavor") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eFlavor)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZDeadBodySituation.ESituationFlavor", static_cast<int>(s_Object->m_eFlavor))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNextStanddownTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tNextStanddownTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSuspiciousDeaths") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSuspiciousDeaths);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAcknowledged") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAcknowledged);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInspected") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInspected);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAccidentsResolved") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAccidentsResolved);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStanddownComplete") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStanddownComplete);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandDownUnconscious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandDownUnconscious);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalateUnconscious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalateUnconscious);
	p_Stream << "}";

	p_Stream << "}";
}

void ZDeadBodySituation_SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFlavor") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZDeadBodySituation.ESituationFlavor", static_cast<int>(s_Object->m_eFlavor)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNextStanddownTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNextStanddownTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSuspiciousDeaths") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSuspiciousDeaths);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAcknowledged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAcknowledged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInspected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInspected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAccidentsResolved") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAccidentsResolved);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStanddownComplete") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStanddownComplete);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandDownUnconscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandDownUnconscious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalateUnconscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalateUnconscious);

	p_Stream << "}";
}

void ZDeadBodySituation_SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDeadBodySituation_SState s_Object {};

	s_Object.m_eFlavor = static_cast<ZDeadBodySituation_ESituationFlavor>(ZHMEnums::GetEnumValueByName("ZDeadBodySituation.ESituationFlavor", std::string_view(p_Document["m_eFlavor"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Item);
		s_Object.m_tLastEscalateOrder = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tNextStanddownTime"], &s_Item);
		s_Object.m_tNextStanddownTime = s_Item;
	}

	s_Object.m_nSuspiciousDeaths = simdjson::from_json_int32(p_Document["m_nSuspiciousDeaths"]);

	s_Object.m_bAcknowledged = simdjson::from_json_bool(p_Document["m_bAcknowledged"]);

	s_Object.m_bInspected = simdjson::from_json_bool(p_Document["m_bInspected"]);

	s_Object.m_bAccidentsResolved = simdjson::from_json_bool(p_Document["m_bAccidentsResolved"]);

	s_Object.m_bStanddownComplete = simdjson::from_json_bool(p_Document["m_bStanddownComplete"]);

	s_Object.m_bStandDownUnconscious = simdjson::from_json_bool(p_Document["m_bStandDownUnconscious"]);

	s_Object.m_bEscalateUnconscious = simdjson::from_json_bool(p_Document["m_bEscalateUnconscious"]);

	*reinterpret_cast<ZDeadBodySituation_SState*>(p_Target) = s_Object;
}

void ZDeadBodySituation_SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation_SState, m_tLastEscalateOrder));
	ZGameTime::Serialize(&s_Object->m_tNextStanddownTime, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation_SState, m_tNextStanddownTime));
}

bool ZDeadBodySituation_SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation_SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation_SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation_SState::operator==(const ZDeadBodySituation_SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation_SState>)
		return false;

	if (m_eFlavor != p_Other.m_eFlavor) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_tNextStanddownTime != p_Other.m_tNextStanddownTime) return false;
	if (m_nSuspiciousDeaths != p_Other.m_nSuspiciousDeaths) return false;
	if (m_bAcknowledged != p_Other.m_bAcknowledged) return false;
	if (m_bInspected != p_Other.m_bInspected) return false;
	if (m_bAccidentsResolved != p_Other.m_bAccidentsResolved) return false;
	if (m_bStanddownComplete != p_Other.m_bStanddownComplete) return false;
	if (m_bStandDownUnconscious != p_Other.m_bStandDownUnconscious) return false;
	if (m_bEscalateUnconscious != p_Other.m_bEscalateUnconscious) return false;

	return true;
}

ZHMTypeInfo ZDeadBodySituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SSituationSaveData", sizeof(ZDeadBodySituation_SSituationSaveData), alignof(ZDeadBodySituation_SSituationSaveData), ZDeadBodySituation_SSituationSaveData::WriteJson, ZDeadBodySituation_SSituationSaveData::WriteSimpleJson, ZDeadBodySituation_SSituationSaveData::FromSimpleJson, ZDeadBodySituation_SSituationSaveData::Serialize, ZDeadBodySituation_SSituationSaveData::Equals);

void ZDeadBodySituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_State") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDeadBodySituation.SState") << ",\"$val\":";
	ZDeadBodySituation_SState::WriteJson(&s_Object->m_State, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIncidents") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZDeadBodySituation.SIncidentSaveData>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIncidents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIncidents[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDeadBodySituation.SIncidentSaveData") << ",\"$val\":";
		ZDeadBodySituation_SIncidentSaveData::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aIncidents.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pObserversGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pObserversGroup);
	p_Stream << "}";

	p_Stream << "}";
}

void ZDeadBodySituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZDeadBodySituation_SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIncidents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIncidents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIncidents[i];
		ZDeadBodySituation_SIncidentSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aIncidents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pObserversGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pObserversGroup);

	p_Stream << "}";
}

void ZDeadBodySituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDeadBodySituation_SSituationSaveData s_Object {};

	{
		ZDeadBodySituation_SState s_Item {};
		ZDeadBodySituation_SState::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aIncidents"])
	{
		ZDeadBodySituation_SIncidentSaveData s_ArrayItem0;
		ZDeadBodySituation_SIncidentSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aIncidents.push_back(s_ArrayItem0);
	}

	s_Object.m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	s_Object.m_pObserversGroup = simdjson::from_json_int32(p_Document["m_pObserversGroup"]);

	*reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZDeadBodySituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Object);

	ZDeadBodySituation_SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation_SSituationSaveData, m_State));
	TArray<ZDeadBodySituation_SIncidentSaveData>::Serialize(&s_Object->m_aIncidents, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation_SSituationSaveData, m_aIncidents));
}

bool ZDeadBodySituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation_SSituationSaveData::operator==(const ZDeadBodySituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation_SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_aIncidents != p_Other.m_aIncidents) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_pObserversGroup != p_Other.m_pObserversGroup) return false;

	return true;
}

ZHMTypeInfo ZDetectedInPrivateSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDetectedInPrivateSituation.SSituationSaveData", sizeof(ZDetectedInPrivateSituation_SSituationSaveData), alignof(ZDetectedInPrivateSituation_SSituationSaveData), ZDetectedInPrivateSituation_SSituationSaveData::WriteJson, ZDetectedInPrivateSituation_SSituationSaveData::WriteSimpleJson, ZDetectedInPrivateSituation_SSituationSaveData::FromSimpleJson, ZDetectedInPrivateSituation_SSituationSaveData::Serialize, ZDetectedInPrivateSituation_SSituationSaveData::Equals);

void ZDetectedInPrivateSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pDetectedInPrivateGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pDetectedInPrivateGroup);
	p_Stream << "}";

	p_Stream << "}";
}

void ZDetectedInPrivateSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pDetectedInPrivateGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pDetectedInPrivateGroup);

	p_Stream << "}";
}

void ZDetectedInPrivateSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDetectedInPrivateSituation_SSituationSaveData s_Object {};

	s_Object.m_pDetectedInPrivateGroup = simdjson::from_json_int32(p_Document["m_pDetectedInPrivateGroup"]);

	*reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZDetectedInPrivateSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Object);

}

bool ZDetectedInPrivateSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDetectedInPrivateSituation_SSituationSaveData::operator==(const ZDetectedInPrivateSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDetectedInPrivateSituation_SSituationSaveData>)
		return false;

	if (m_pDetectedInPrivateGroup != p_Other.m_pDetectedInPrivateGroup) return false;

	return true;
}

ZHMTypeInfo ZDialogEventItemTypedIndex::TypeInfo = ZHMTypeInfo("ZDialogEventItemTypedIndex", sizeof(ZDialogEventItemTypedIndex), alignof(ZDialogEventItemTypedIndex), ZDialogEventItemTypedIndex::WriteJson, ZDialogEventItemTypedIndex::WriteSimpleJson, ZDialogEventItemTypedIndex::FromSimpleJson, ZDialogEventItemTypedIndex::Serialize, ZDialogEventItemTypedIndex::Equals);

void ZDialogEventItemTypedIndex::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZDialogEventItemTypedIndex::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZDialogEventItemTypedIndex::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDialogEventItemTypedIndex s_Object {};

	*reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Target) = s_Object;
}

void ZDialogEventItemTypedIndex::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);

}

bool ZDialogEventItemTypedIndex::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDialogEventItemTypedIndex::operator==(const ZDialogEventItemTypedIndex& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDialogEventItemTypedIndex>)
		return false;


	return true;
}

ZHMTypeInfo ZDisguiseSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDisguiseSituation.SSituationSaveData", sizeof(ZDisguiseSituation_SSituationSaveData), alignof(ZDisguiseSituation_SSituationSaveData), ZDisguiseSituation_SSituationSaveData::WriteJson, ZDisguiseSituation_SSituationSaveData::WriteSimpleJson, ZDisguiseSituation_SSituationSaveData::FromSimpleJson, ZDisguiseSituation_SSituationSaveData::Serialize, ZDisguiseSituation_SSituationSaveData::Equals);

void ZDisguiseSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aInvestigateDisguiseGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aInvestigateDisguiseGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aInvestigateDisguiseGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aInvestigateDisguiseGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEventSetOnEscalation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EAISharedEventType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eEventSetOnEscalation)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eEventSetOnEscalation))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZDisguiseSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aInvestigateDisguiseGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aInvestigateDisguiseGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aInvestigateDisguiseGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aInvestigateDisguiseGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEventSetOnEscalation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eEventSetOnEscalation)));

	p_Stream << "}";
}

void ZDisguiseSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDisguiseSituation_SSituationSaveData s_Object {};

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aInvestigateDisguiseGroups"])
	{
		s_Object.m_aInvestigateDisguiseGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	s_Object.m_eEventSetOnEscalation = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eEventSetOnEscalation"])));

	*reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZDisguiseSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aInvestigateDisguiseGroups, p_Serializer, p_OwnOffset + offsetof(ZDisguiseSituation_SSituationSaveData, m_aInvestigateDisguiseGroups));
}

bool ZDisguiseSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDisguiseSituation_SSituationSaveData::operator==(const ZDisguiseSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDisguiseSituation_SSituationSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_aInvestigateDisguiseGroups != p_Other.m_aInvestigateDisguiseGroups) return false;
	if (m_eEventSetOnEscalation != p_Other.m_eEventSetOnEscalation) return false;

	return true;
}

ZHMTypeInfo ZDynamicObject_SArrayTypesRegistrar::TypeInfo = ZHMTypeInfo("ZDynamicObject.SArrayTypesRegistrar", sizeof(ZDynamicObject_SArrayTypesRegistrar), alignof(ZDynamicObject_SArrayTypesRegistrar), ZDynamicObject_SArrayTypesRegistrar::WriteJson, ZDynamicObject_SArrayTypesRegistrar::WriteSimpleJson, ZDynamicObject_SArrayTypesRegistrar::FromSimpleJson, ZDynamicObject_SArrayTypesRegistrar::Serialize, ZDynamicObject_SArrayTypesRegistrar::Equals);

void ZDynamicObject_SArrayTypesRegistrar::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("_dummy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<SDynamicObjectKeyValuePair>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->_dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->_dummy[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("SDynamicObjectKeyValuePair") << ",\"$val\":";
		SDynamicObjectKeyValuePair::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->_dummy.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_dummy2") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZDynamicObject>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->_dummy2.size(); ++i)
	{
		auto& s_Item0 = s_Object->_dummy2[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZDynamicObject") << ",\"$val\":";
		ZDynamicObject::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->_dummy2.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZDynamicObject_SArrayTypesRegistrar::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("_dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->_dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->_dummy[i];
		SDynamicObjectKeyValuePair::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->_dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_dummy2") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->_dummy2.size(); ++i)
	{
		auto& s_Item0 = s_Object->_dummy2[i];
		ZDynamicObject::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->_dummy2.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZDynamicObject_SArrayTypesRegistrar::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDynamicObject_SArrayTypesRegistrar s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["_dummy"])
	{
		SDynamicObjectKeyValuePair s_ArrayItem0;
		SDynamicObjectKeyValuePair::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object._dummy.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["_dummy2"])
	{
		ZDynamicObject s_ArrayItem0;
		ZDynamicObject::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object._dummy2.push_back(s_ArrayItem0);
	}

	*reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Target) = s_Object;
}

void ZDynamicObject_SArrayTypesRegistrar::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Object);

	TArray<SDynamicObjectKeyValuePair>::Serialize(&s_Object->_dummy, p_Serializer, p_OwnOffset + offsetof(ZDynamicObject_SArrayTypesRegistrar, _dummy));
	TArray<ZDynamicObject>::Serialize(&s_Object->_dummy2, p_Serializer, p_OwnOffset + offsetof(ZDynamicObject_SArrayTypesRegistrar, _dummy2));
}

bool ZDynamicObject_SArrayTypesRegistrar::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDynamicObject_SArrayTypesRegistrar::operator==(const ZDynamicObject_SArrayTypesRegistrar& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDynamicObject_SArrayTypesRegistrar>)
		return false;

	if (_dummy != p_Other._dummy) return false;
	if (_dummy2 != p_Other._dummy2) return false;

	return true;
}

ZHMTypeInfo ZER64::TypeInfo = ZHMTypeInfo("ZER64", sizeof(ZER64), alignof(ZER64), ZER64::WriteJson, ZER64::WriteSimpleJson, ZER64::FromSimpleJson, ZER64::Serialize, ZER64::Equals);

void ZER64::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEntityID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEntityID);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);
	p_Stream << "}";

	p_Stream << "}";
}

void ZER64::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEntityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEntityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);

	p_Stream << "}";
}

void ZER64::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZER64 s_Object {};

	s_Object.m_nEntityID = simdjson::from_json_uint64(p_Document["m_nEntityID"]);

	s_Object.m_sExposedEntity = std::string_view(p_Document["m_sExposedEntity"]);

	*reinterpret_cast<ZER64*>(p_Target) = s_Object;
}

void ZER64::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);

	ZString::Serialize(&s_Object->m_sExposedEntity, p_Serializer, p_OwnOffset + offsetof(ZER64, m_sExposedEntity));
}

bool ZER64::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZER64*>(p_Left);
	auto* s_Right = reinterpret_cast<ZER64*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZER64::operator==(const ZER64& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZER64>)
		return false;

	if (m_nEntityID != p_Other.m_nEntityID) return false;
	if (m_sExposedEntity != p_Other.m_sExposedEntity) return false;

	return true;
}

ZHMTypeInfo ZEntityID::TypeInfo = ZHMTypeInfo("ZEntityID", sizeof(ZEntityID), alignof(ZEntityID), ZEntityID::WriteJson, ZEntityID::WriteSimpleJson, ZEntityID::FromSimpleJson, ZEntityID::Serialize, ZEntityID::Equals);

void ZEntityID::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sStr") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sStr);
	p_Stream << "}";

	p_Stream << "}";
}

void ZEntityID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sStr") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sStr);

	p_Stream << "}";
}

void ZEntityID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityID s_Object {};

	s_Object.m_sStr = std::string_view(p_Document["m_sStr"]);

	*reinterpret_cast<ZEntityID*>(p_Target) = s_Object;
}

void ZEntityID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	ZString::Serialize(&s_Object->m_sStr, p_Serializer, p_OwnOffset + offsetof(ZEntityID, m_sStr));
}

bool ZEntityID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityID::operator==(const ZEntityID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityID>)
		return false;

	if (m_sStr != p_Other.m_sStr) return false;

	return true;
}

ZHMTypeInfo ZEntityRef::TypeInfo = ZHMTypeInfo("ZEntityRef", sizeof(ZEntityRef), alignof(ZEntityRef), ZEntityRef::WriteJson, ZEntityRef::WriteSimpleJson, ZEntityRef::FromSimpleJson, ZEntityRef::Serialize, ZEntityRef::Equals);

void ZEntityRef::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZEntityRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZEntityRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityRef s_Object {};

	*reinterpret_cast<ZEntityRef*>(p_Target) = s_Object;
}

void ZEntityRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

}

bool ZEntityRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityRef*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityRef::operator==(const ZEntityRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityRef>)
		return false;


	return true;
}

ZHMTypeInfo ZEntityReference::TypeInfo = ZHMTypeInfo("ZEntityReference", sizeof(ZEntityReference), alignof(ZEntityReference), ZEntityReference::WriteJson, ZEntityReference::WriteSimpleJson, ZEntityReference::FromSimpleJson, ZEntityReference::Serialize, ZEntityReference::Equals);

void ZEntityReference::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_EntityID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZEntityID") << ",\"$val\":";
	ZEntityID::WriteJson(&s_Object->m_EntityID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);
	p_Stream << "}";

	p_Stream << "}";
}

void ZEntityReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EntityID") << ":";
	ZEntityID::WriteSimpleJson(&s_Object->m_EntityID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);

	p_Stream << "}";
}

void ZEntityReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityReference s_Object {};

	{
		ZEntityID s_Item {};
		ZEntityID::FromSimpleJson(p_Document["m_EntityID"], &s_Item);
		s_Object.m_EntityID = s_Item;
	}

	s_Object.m_sExposedEntity = std::string_view(p_Document["m_sExposedEntity"]);

	*reinterpret_cast<ZEntityReference*>(p_Target) = s_Object;
}

void ZEntityReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	ZEntityID::Serialize(&s_Object->m_EntityID, p_Serializer, p_OwnOffset + offsetof(ZEntityReference, m_EntityID));
	ZString::Serialize(&s_Object->m_sExposedEntity, p_Serializer, p_OwnOffset + offsetof(ZEntityReference, m_sExposedEntity));
}

bool ZEntityReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityReference*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityReference::operator==(const ZEntityReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityReference>)
		return false;

	if (m_EntityID != p_Other.m_EntityID) return false;
	if (m_sExposedEntity != p_Other.m_sExposedEntity) return false;

	return true;
}

ZHMTypeInfo ZFormationMoveOrder_SFormationMoveOrderSaveData::TypeInfo = ZHMTypeInfo("ZFormationMoveOrder.SFormationMoveOrderSaveData", sizeof(ZFormationMoveOrder_SFormationMoveOrderSaveData), alignof(ZFormationMoveOrder_SFormationMoveOrderSaveData), ZFormationMoveOrder_SFormationMoveOrderSaveData::WriteJson, ZFormationMoveOrder_SFormationMoveOrderSaveData::WriteSimpleJson, ZFormationMoveOrder_SFormationMoveOrderSaveData::FromSimpleJson, ZFormationMoveOrder_SFormationMoveOrderSaveData::Serialize, ZFormationMoveOrder_SFormationMoveOrderSaveData::Equals);

void ZFormationMoveOrder_SFormationMoveOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleBlockageFlags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleBlockageFlags);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMoveSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EMoveSpeed") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eMoveSpeed)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EMoveSpeed", static_cast<int>(s_Object->m_eMoveSpeed))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZFormationMoveOrder_SFormationMoveOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleBlockageFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleBlockageFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EMoveSpeed", static_cast<int>(s_Object->m_eMoveSpeed)));

	p_Stream << "}";
}

void ZFormationMoveOrder_SFormationMoveOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZFormationMoveOrder_SFormationMoveOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Item);
		s_Object.m_vStopDirection = s_Item;
	}

	s_Object.m_nObstacleBlockageFlags = simdjson::from_json_uint32(p_Document["m_nObstacleBlockageFlags"]);

	s_Object.m_eMoveSpeed = static_cast<EMoveSpeed>(ZHMEnums::GetEnumValueByName("EMoveSpeed", std::string_view(p_Document["m_eMoveSpeed"])));

	*reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Target) = s_Object;
}

void ZFormationMoveOrder_SFormationMoveOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZFormationMoveOrder_SFormationMoveOrderSaveData, m_vStopDirection));
}

bool ZFormationMoveOrder_SFormationMoveOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZFormationMoveOrder_SFormationMoveOrderSaveData::operator==(const ZFormationMoveOrder_SFormationMoveOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZFormationMoveOrder_SFormationMoveOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_nObstacleBlockageFlags != p_Other.m_nObstacleBlockageFlags) return false;
	if (m_eMoveSpeed != p_Other.m_eMoveSpeed) return false;

	return true;
}

ZHMTypeInfo ZGfxValueWrapper::TypeInfo = ZHMTypeInfo("ZGfxValueWrapper", sizeof(ZGfxValueWrapper), alignof(ZGfxValueWrapper), ZGfxValueWrapper::WriteJson, ZGfxValueWrapper::WriteSimpleJson, ZGfxValueWrapper::FromSimpleJson, ZGfxValueWrapper::Serialize, ZGfxValueWrapper::Equals);

void ZGfxValueWrapper::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZGfxValueWrapper::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZGfxValueWrapper::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGfxValueWrapper s_Object {};

	*reinterpret_cast<ZGfxValueWrapper*>(p_Target) = s_Object;
}

void ZGfxValueWrapper::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);

}

bool ZGfxValueWrapper::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGfxValueWrapper*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGfxValueWrapper*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGfxValueWrapper::operator==(const ZGfxValueWrapper& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGfxValueWrapper>)
		return false;


	return true;
}

ZHMTypeInfo ZGridFloatField::TypeInfo = ZHMTypeInfo("ZGridFloatField", sizeof(ZGridFloatField), alignof(ZGridFloatField), ZGridFloatField::WriteJson, ZGridFloatField::WriteSimpleJson, ZGridFloatField::FromSimpleJson, ZGridFloatField::Serialize, ZGridFloatField::Equals);

void ZGridFloatField::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_field") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_field.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_field[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_field.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_field") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_field.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_field[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_field.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGridFloatField s_Object {};

	s_Object.m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_field"])
	{
		s_Object.m_field.push_back(simdjson::from_json_float32(s_Item0));
	}

	*reinterpret_cast<ZGridFloatField*>(p_Target) = s_Object;
}

void ZGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);

	TArray<float32>::Serialize(&s_Object->m_field, p_Serializer, p_OwnOffset + offsetof(ZGridFloatField, m_field));
}

bool ZGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGridFloatField::operator==(const ZGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGridFloatField>)
		return false;

	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_field != p_Other.m_field) return false;

	return true;
}

ZHMTypeInfo ZHM5AgilityEventConsumer_SAgilityEventData::TypeInfo = ZHMTypeInfo("ZHM5AgilityEventConsumer.SAgilityEventData", sizeof(ZHM5AgilityEventConsumer_SAgilityEventData), alignof(ZHM5AgilityEventConsumer_SAgilityEventData), ZHM5AgilityEventConsumer_SAgilityEventData::WriteJson, ZHM5AgilityEventConsumer_SAgilityEventData::WriteSimpleJson, ZHM5AgilityEventConsumer_SAgilityEventData::FromSimpleJson, ZHM5AgilityEventConsumer_SAgilityEventData::Serialize, ZHM5AgilityEventConsumer_SAgilityEventData::Equals);

void ZHM5AgilityEventConsumer_SAgilityEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5AgilityEventConsumer.EEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5AgilityEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5AgilityEventConsumer_SAgilityEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5AgilityEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5AgilityEventConsumer_SAgilityEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5AgilityEventConsumer_SAgilityEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5AgilityEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5AgilityEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Target) = s_Object;
}

void ZHM5AgilityEventConsumer_SAgilityEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Object);

}

bool ZHM5AgilityEventConsumer_SAgilityEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5AgilityEventConsumer_SAgilityEventData::operator==(const ZHM5AgilityEventConsumer_SAgilityEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5AgilityEventConsumer_SAgilityEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZResourcePtr::TypeInfo = ZHMTypeInfo("ZResourcePtr", sizeof(ZResourcePtr), alignof(ZResourcePtr), ZResourcePtr::WriteJson, ZResourcePtr::WriteSimpleJson, ZResourcePtr::FromSimpleJson, ZResourcePtr::Serialize, ZResourcePtr::Equals);

void ZResourcePtr::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZResourcePtr::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZResourcePtr::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZResourcePtr s_Object {};

	*reinterpret_cast<ZResourcePtr*>(p_Target) = s_Object;
}

void ZResourcePtr::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

}

bool ZResourcePtr::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZResourcePtr*>(p_Left);
	auto* s_Right = reinterpret_cast<ZResourcePtr*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZResourcePtr::operator==(const ZResourcePtr& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZResourcePtr>)
		return false;


	return true;
}

ZHMTypeInfo ZHM5AudioEventConsumer_SAudioAnimationEventData::TypeInfo = ZHMTypeInfo("ZHM5AudioEventConsumer.SAudioAnimationEventData", sizeof(ZHM5AudioEventConsumer_SAudioAnimationEventData), alignof(ZHM5AudioEventConsumer_SAudioAnimationEventData), ZHM5AudioEventConsumer_SAudioAnimationEventData::WriteJson, ZHM5AudioEventConsumer_SAudioAnimationEventData::WriteSimpleJson, ZHM5AudioEventConsumer_SAudioAnimationEventData::FromSimpleJson, ZHM5AudioEventConsumer_SAudioAnimationEventData::Serialize, ZHM5AudioEventConsumer_SAudioAnimationEventData::Equals);

void ZHM5AudioEventConsumer_SAudioAnimationEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pAudioEventRes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourcePtr") << ",\"$val\":";
	ZResourcePtr::WriteJson(&s_Object->m_pAudioEventRes, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5AudioEventConsumer_SAudioAnimationEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pAudioEventRes") << ":";
	ZResourcePtr::WriteSimpleJson(&s_Object->m_pAudioEventRes, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5AudioEventConsumer_SAudioAnimationEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5AudioEventConsumer_SAudioAnimationEventData s_Object {};

	{
		ZResourcePtr s_Item {};
		ZResourcePtr::FromSimpleJson(p_Document["m_pAudioEventRes"], &s_Item);
		s_Object.m_pAudioEventRes = s_Item;
	}

	s_Object.m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object.m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

	*reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Target) = s_Object;
}

void ZHM5AudioEventConsumer_SAudioAnimationEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Object);

	ZResourcePtr::Serialize(&s_Object->m_pAudioEventRes, p_Serializer, p_OwnOffset + offsetof(ZHM5AudioEventConsumer_SAudioAnimationEventData, m_pAudioEventRes));
}

bool ZHM5AudioEventConsumer_SAudioAnimationEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5AudioEventConsumer_SAudioAnimationEventData::operator==(const ZHM5AudioEventConsumer_SAudioAnimationEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5AudioEventConsumer_SAudioAnimationEventData>)
		return false;

	if (m_pAudioEventRes != p_Other.m_pAudioEventRes) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

ZHMTypeInfo ZHM5BodySoundEventConsumer_SBodySoundEventData::TypeInfo = ZHMTypeInfo("ZHM5BodySoundEventConsumer.SBodySoundEventData", sizeof(ZHM5BodySoundEventConsumer_SBodySoundEventData), alignof(ZHM5BodySoundEventConsumer_SBodySoundEventData), ZHM5BodySoundEventConsumer_SBodySoundEventData::WriteJson, ZHM5BodySoundEventConsumer_SBodySoundEventData::WriteSimpleJson, ZHM5BodySoundEventConsumer_SBodySoundEventData::FromSimpleJson, ZHM5BodySoundEventConsumer_SBodySoundEventData::Serialize, ZHM5BodySoundEventConsumer_SBodySoundEventData::Equals);

void ZHM5BodySoundEventConsumer_SBodySoundEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5BodySoundEventConsumer.EAnimSoundBody") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5BodySoundEventConsumer.EAnimSoundBody", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5BodySoundEventConsumer_SBodySoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5BodySoundEventConsumer.EAnimSoundBody", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5BodySoundEventConsumer_SBodySoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5BodySoundEventConsumer_SBodySoundEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5BodySoundEventConsumer_EAnimSoundBody>(ZHMEnums::GetEnumValueByName("ZHM5BodySoundEventConsumer.EAnimSoundBody", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Target) = s_Object;
}

void ZHM5BodySoundEventConsumer_SBodySoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Object);

}

bool ZHM5BodySoundEventConsumer_SBodySoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5BodySoundEventConsumer_SBodySoundEventData::operator==(const ZHM5BodySoundEventConsumer_SBodySoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5BodySoundEventConsumer_SBodySoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5CloseCombatEventConsumer.SCloseCombatSoundEventData", sizeof(ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData), alignof(ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData), ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::WriteJson, ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::WriteSimpleJson, ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::FromSimpleJson, ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Serialize, ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Equals);

void ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EHM5SoundCloseCombatEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHM5SoundCloseCombatEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHM5SoundCloseCombatEvent", static_cast<int>(s_Object->m_nEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData s_Object {};

	s_Object.m_nEvent = static_cast<EHM5SoundCloseCombatEvent>(ZHMEnums::GetEnumValueByName("EHM5SoundCloseCombatEvent", std::string_view(p_Document["m_nEvent"])));

	s_Object.m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object.m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

	*reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Target) = s_Object;
}

void ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Object);

}

bool ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::operator==(const ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

ZHMTypeInfo ZHM5CrowdEventConsumer_SCrowdSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5CrowdEventConsumer.SCrowdSoundEventData", sizeof(ZHM5CrowdEventConsumer_SCrowdSoundEventData), alignof(ZHM5CrowdEventConsumer_SCrowdSoundEventData), ZHM5CrowdEventConsumer_SCrowdSoundEventData::WriteJson, ZHM5CrowdEventConsumer_SCrowdSoundEventData::WriteSimpleJson, ZHM5CrowdEventConsumer_SCrowdSoundEventData::FromSimpleJson, ZHM5CrowdEventConsumer_SCrowdSoundEventData::Serialize, ZHM5CrowdEventConsumer_SCrowdSoundEventData::Equals);

void ZHM5CrowdEventConsumer_SCrowdSoundEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_pAudioEventRes") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZResourcePtr") << ",\"$val\":";
	ZResourcePtr::WriteJson(&s_Object->m_pAudioEventRes, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5CrowdEventConsumer_SCrowdSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pAudioEventRes") << ":";
	ZResourcePtr::WriteSimpleJson(&s_Object->m_pAudioEventRes, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5CrowdEventConsumer_SCrowdSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5CrowdEventConsumer_SCrowdSoundEventData s_Object {};

	{
		ZResourcePtr s_Item {};
		ZResourcePtr::FromSimpleJson(p_Document["m_pAudioEventRes"], &s_Item);
		s_Object.m_pAudioEventRes = s_Item;
	}

	s_Object.m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object.m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

	*reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Target) = s_Object;
}

void ZHM5CrowdEventConsumer_SCrowdSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Object);

	ZResourcePtr::Serialize(&s_Object->m_pAudioEventRes, p_Serializer, p_OwnOffset + offsetof(ZHM5CrowdEventConsumer_SCrowdSoundEventData, m_pAudioEventRes));
}

bool ZHM5CrowdEventConsumer_SCrowdSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CrowdEventConsumer_SCrowdSoundEventData::operator==(const ZHM5CrowdEventConsumer_SCrowdSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CrowdEventConsumer_SCrowdSoundEventData>)
		return false;

	if (m_pAudioEventRes != p_Other.m_pAudioEventRes) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

ZHMTypeInfo ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::TypeInfo = ZHMTypeInfo("ZHM5CrowdGenericEventConsumer.SCrowdSoundGenericEventData", sizeof(ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData), alignof(ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData), ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::WriteJson, ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::WriteSimpleJson, ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::FromSimpleJson, ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Serialize, ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Equals);

void ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5CrowdGenericEventConsumer.EEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5CrowdGenericEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5CrowdGenericEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5CrowdGenericEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5CrowdGenericEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Target) = s_Object;
}

void ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Object);

}

bool ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::operator==(const ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::TypeInfo = ZHMTypeInfo("ZHM5FaceFXReactionEventConsumer.SFaceFXEventData", sizeof(ZHM5FaceFXReactionEventConsumer_SFaceFXEventData), alignof(ZHM5FaceFXReactionEventConsumer_SFaceFXEventData), ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::WriteJson, ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::WriteSimpleJson, ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::FromSimpleJson, ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Serialize, ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Equals);

void ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5FaceFXReactionEventConsumer.EEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5FaceFXReactionEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5FaceFXReactionEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5FaceFXReactionEventConsumer_SFaceFXEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5FaceFXReactionEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5FaceFXReactionEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Target) = s_Object;
}

void ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Object);

}

bool ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::operator==(const ZHM5FaceFXReactionEventConsumer_SFaceFXEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::TypeInfo = ZHMTypeInfo("ZHM5FaceFXSpecificEventConsumer.SFaceFXEventData", sizeof(ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData), alignof(ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData), ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::WriteJson, ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::WriteSimpleJson, ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::FromSimpleJson, ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Serialize, ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Equals);

void ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5FaceFXSpecificEventConsumer.EEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5FaceFXSpecificEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sFaceExpression") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sFaceExpression);
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5FaceFXSpecificEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sFaceExpression") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sFaceExpression);

	p_Stream << "}";
}

void ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5FaceFXSpecificEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5FaceFXSpecificEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	s_Object.m_sFaceExpression = std::string_view(p_Document["m_sFaceExpression"]);

	*reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Target) = s_Object;
}

void ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Object);

	ZString::Serialize(&s_Object->m_sFaceExpression, p_Serializer, p_OwnOffset + offsetof(ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData, m_sFaceExpression));
}

bool ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::operator==(const ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;
	if (m_sFaceExpression != p_Other.m_sFaceExpression) return false;

	return true;
}

ZHMTypeInfo ZHM5FootstepEventConsumer_SFootstepSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5FootstepEventConsumer.SFootstepSoundEventData", sizeof(ZHM5FootstepEventConsumer_SFootstepSoundEventData), alignof(ZHM5FootstepEventConsumer_SFootstepSoundEventData), ZHM5FootstepEventConsumer_SFootstepSoundEventData::WriteJson, ZHM5FootstepEventConsumer_SFootstepSoundEventData::WriteSimpleJson, ZHM5FootstepEventConsumer_SFootstepSoundEventData::FromSimpleJson, ZHM5FootstepEventConsumer_SFootstepSoundEventData::Serialize, ZHM5FootstepEventConsumer_SFootstepSoundEventData::Equals);

void ZHM5FootstepEventConsumer_SFootstepSoundEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EHM5SoundFootstepEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHM5SoundFootstepEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5FootstepEventConsumer_SFootstepSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHM5SoundFootstepEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5FootstepEventConsumer_SFootstepSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5FootstepEventConsumer_SFootstepSoundEventData s_Object {};

	s_Object.m_nEvent = static_cast<EHM5SoundFootstepEvent>(ZHMEnums::GetEnumValueByName("EHM5SoundFootstepEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Target) = s_Object;
}

void ZHM5FootstepEventConsumer_SFootstepSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Object);

}

bool ZHM5FootstepEventConsumer_SFootstepSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FootstepEventConsumer_SFootstepSoundEventData::operator==(const ZHM5FootstepEventConsumer_SFootstepSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FootstepEventConsumer_SFootstepSoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZHM5GenericEventConsumer_SGenericEventData::TypeInfo = ZHMTypeInfo("ZHM5GenericEventConsumer.SGenericEventData", sizeof(ZHM5GenericEventConsumer_SGenericEventData), alignof(ZHM5GenericEventConsumer_SGenericEventData), ZHM5GenericEventConsumer_SGenericEventData::WriteJson, ZHM5GenericEventConsumer_SGenericEventData::WriteSimpleJson, ZHM5GenericEventConsumer_SGenericEventData::FromSimpleJson, ZHM5GenericEventConsumer_SGenericEventData::Serialize, ZHM5GenericEventConsumer_SGenericEventData::Equals);

void ZHM5GenericEventConsumer_SGenericEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5GenericEventConsumer.EEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5GenericEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5GenericEventConsumer_SGenericEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5GenericEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5GenericEventConsumer_SGenericEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5GenericEventConsumer_SGenericEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5GenericEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5GenericEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Target) = s_Object;
}

void ZHM5GenericEventConsumer_SGenericEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Object);

}

bool ZHM5GenericEventConsumer_SGenericEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5GenericEventConsumer_SGenericEventData::operator==(const ZHM5GenericEventConsumer_SGenericEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5GenericEventConsumer_SGenericEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZHM5HIKEventConsumer_SZHM5HIKEventData::TypeInfo = ZHMTypeInfo("ZHM5HIKEventConsumer.SZHM5HIKEventData", sizeof(ZHM5HIKEventConsumer_SZHM5HIKEventData), alignof(ZHM5HIKEventConsumer_SZHM5HIKEventData), ZHM5HIKEventConsumer_SZHM5HIKEventData::WriteJson, ZHM5HIKEventConsumer_SZHM5HIKEventData::WriteSimpleJson, ZHM5HIKEventConsumer_SZHM5HIKEventData::FromSimpleJson, ZHM5HIKEventConsumer_SZHM5HIKEventData::Serialize, ZHM5HIKEventConsumer_SZHM5HIKEventData::Equals);

void ZHM5HIKEventConsumer_SZHM5HIKEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEffector") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5HIKEventConsumer.EEffector") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEffector)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5HIKEventConsumer.EEffector", static_cast<int>(s_Object->m_nEffector))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBlend") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5HIKEventConsumer.EBlend") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nBlend)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5HIKEventConsumer.EBlend", static_cast<int>(s_Object->m_nBlend))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5HIKEventConsumer_SZHM5HIKEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEffector") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5HIKEventConsumer.EEffector", static_cast<int>(s_Object->m_nEffector)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBlend") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5HIKEventConsumer.EBlend", static_cast<int>(s_Object->m_nBlend)));

	p_Stream << "}";
}

void ZHM5HIKEventConsumer_SZHM5HIKEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5HIKEventConsumer_SZHM5HIKEventData s_Object {};

	s_Object.m_nEffector = static_cast<ZHM5HIKEventConsumer_EEffector>(ZHMEnums::GetEnumValueByName("ZHM5HIKEventConsumer.EEffector", std::string_view(p_Document["m_nEffector"])));

	s_Object.m_nBlend = static_cast<ZHM5HIKEventConsumer_EBlend>(ZHMEnums::GetEnumValueByName("ZHM5HIKEventConsumer.EBlend", std::string_view(p_Document["m_nBlend"])));

	*reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Target) = s_Object;
}

void ZHM5HIKEventConsumer_SZHM5HIKEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Object);

}

bool ZHM5HIKEventConsumer_SZHM5HIKEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5HIKEventConsumer_SZHM5HIKEventData::operator==(const ZHM5HIKEventConsumer_SZHM5HIKEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5HIKEventConsumer_SZHM5HIKEventData>)
		return false;

	if (m_nEffector != p_Other.m_nEffector) return false;
	if (m_nBlend != p_Other.m_nBlend) return false;

	return true;
}

ZHMTypeInfo ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::TypeInfo = ZHMTypeInfo("ZHM5ItemInteractionEventConsumer.SItemInteractionEventData", sizeof(ZHM5ItemInteractionEventConsumer_SItemInteractionEventData), alignof(ZHM5ItemInteractionEventConsumer_SItemInteractionEventData), ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::WriteJson, ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::WriteSimpleJson, ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::FromSimpleJson, ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Serialize, ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Equals);

void ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5ItemInteractionEventConsumer.EHM5SoundItemInteractionEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5ItemInteractionEventConsumer.EHM5SoundItemInteractionEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5ItemInteractionEventConsumer.EHM5SoundItemInteractionEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5ItemInteractionEventConsumer_SItemInteractionEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent>(ZHMEnums::GetEnumValueByName("ZHM5ItemInteractionEventConsumer.EHM5SoundItemInteractionEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Target) = s_Object;
}

void ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Object);

}

bool ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::operator==(const ZHM5ItemInteractionEventConsumer_SItemInteractionEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZHM5WeaponEventConsumer_SWeaponEventData::TypeInfo = ZHMTypeInfo("ZHM5WeaponEventConsumer.SWeaponEventData", sizeof(ZHM5WeaponEventConsumer_SWeaponEventData), alignof(ZHM5WeaponEventConsumer_SWeaponEventData), ZHM5WeaponEventConsumer_SWeaponEventData::WriteJson, ZHM5WeaponEventConsumer_SWeaponEventData::WriteSimpleJson, ZHM5WeaponEventConsumer_SWeaponEventData::FromSimpleJson, ZHM5WeaponEventConsumer_SWeaponEventData::Serialize, ZHM5WeaponEventConsumer_SWeaponEventData::Equals);

void ZHM5WeaponEventConsumer_SWeaponEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZHM5WeaponEventConsumer.EAnimWeapon") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5WeaponEventConsumer.EAnimWeapon", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZHM5WeaponEventConsumer_SWeaponEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5WeaponEventConsumer.EAnimWeapon", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5WeaponEventConsumer_SWeaponEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5WeaponEventConsumer_SWeaponEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5WeaponEventConsumer_EAnimWeapon>(ZHMEnums::GetEnumValueByName("ZHM5WeaponEventConsumer.EAnimWeapon", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Target) = s_Object;
}

void ZHM5WeaponEventConsumer_SWeaponEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Object);

}

bool ZHM5WeaponEventConsumer_SWeaponEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5WeaponEventConsumer_SWeaponEventData::operator==(const ZHM5WeaponEventConsumer_SWeaponEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5WeaponEventConsumer_SWeaponEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZHUDAIGuide_SData::TypeInfo = ZHMTypeInfo("ZHUDAIGuide.SData", sizeof(ZHUDAIGuide_SData), alignof(ZHUDAIGuide_SData), ZHUDAIGuide_SData::WriteJson, ZHUDAIGuide_SData::WriteSimpleJson, ZHUDAIGuide_SData::FromSimpleJson, ZHUDAIGuide_SData::Serialize, ZHUDAIGuide_SData::Equals);

void ZHUDAIGuide_SData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide_SData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("bDisguiseBroken") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bDisguiseBroken);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bTrespassing") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bTrespassing);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInsideCrimeScene") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bInsideCrimeScene);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bNearDeadBody") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bNearDeadBody);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bVisiblyArmed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bVisiblyArmed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDisguiseSuspicious") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bDisguiseSuspicious);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDeepTrespassing") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bDeepTrespassing);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG);
	p_Stream << "}";

	p_Stream << "}";
}

void ZHUDAIGuide_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("bDisguiseBroken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDisguiseBroken);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInsideCrimeScene") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInsideCrimeScene);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bNearDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bNearDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bVisiblyArmed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bVisiblyArmed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDisguiseSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDisguiseSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDeepTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDeepTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG);

	p_Stream << "}";
}

void ZHUDAIGuide_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDAIGuide_SData s_Object {};

	s_Object.bDisguiseBroken = simdjson::from_json_bool(p_Document["bDisguiseBroken"]);

	s_Object.bTrespassing = simdjson::from_json_bool(p_Document["bTrespassing"]);

	s_Object.bInsideCrimeScene = simdjson::from_json_bool(p_Document["bInsideCrimeScene"]);

	s_Object.bNearDeadBody = simdjson::from_json_bool(p_Document["bNearDeadBody"]);

	s_Object.bVisiblyArmed = simdjson::from_json_bool(p_Document["bVisiblyArmed"]);

	s_Object.bDisguiseSuspicious = simdjson::from_json_bool(p_Document["bDisguiseSuspicious"]);

	s_Object.bDeepTrespassing = simdjson::from_json_bool(p_Document["bDeepTrespassing"]);

	s_Object.bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG = simdjson::from_json_bool(p_Document["bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG"]);

	*reinterpret_cast<ZHUDAIGuide_SData*>(p_Target) = s_Object;
}

void ZHUDAIGuide_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide_SData*>(p_Object);

}

bool ZHUDAIGuide_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDAIGuide_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDAIGuide_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDAIGuide_SData::operator==(const ZHUDAIGuide_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDAIGuide_SData>)
		return false;

	if (bDisguiseBroken != p_Other.bDisguiseBroken) return false;
	if (bTrespassing != p_Other.bTrespassing) return false;
	if (bInsideCrimeScene != p_Other.bInsideCrimeScene) return false;
	if (bNearDeadBody != p_Other.bNearDeadBody) return false;
	if (bVisiblyArmed != p_Other.bVisiblyArmed) return false;
	if (bDisguiseSuspicious != p_Other.bDisguiseSuspicious) return false;
	if (bDeepTrespassing != p_Other.bDeepTrespassing) return false;
	if (bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG != p_Other.bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG) return false;

	return true;
}

ZHMTypeInfo ZHUDHintController_SData::TypeInfo = ZHMTypeInfo("ZHUDHintController.SData", sizeof(ZHUDHintController_SData), alignof(ZHUDHintController_SData), ZHUDHintController_SData::WriteJson, ZHUDHintController_SData::WriteSimpleJson, ZHUDHintController_SData::FromSimpleJson, ZHUDHintController_SData::Serialize, ZHUDHintController_SData::Equals);

void ZHUDHintController_SData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController_SData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_sTitleText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sTitleText);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyText);
	p_Stream << "}";

	p_Stream << "}";
}

void ZHUDHintController_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sTitleText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sTitleText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyText);

	p_Stream << "}";
}

void ZHUDHintController_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDHintController_SData s_Object {};

	s_Object.m_sTitleText = std::string_view(p_Document["m_sTitleText"]);

	s_Object.m_sBodyText = std::string_view(p_Document["m_sBodyText"]);

	*reinterpret_cast<ZHUDHintController_SData*>(p_Target) = s_Object;
}

void ZHUDHintController_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController_SData*>(p_Object);

	ZString::Serialize(&s_Object->m_sTitleText, p_Serializer, p_OwnOffset + offsetof(ZHUDHintController_SData, m_sTitleText));
	ZString::Serialize(&s_Object->m_sBodyText, p_Serializer, p_OwnOffset + offsetof(ZHUDHintController_SData, m_sBodyText));
}

bool ZHUDHintController_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDHintController_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDHintController_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDHintController_SData::operator==(const ZHUDHintController_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDHintController_SData>)
		return false;

	if (m_sTitleText != p_Other.m_sTitleText) return false;
	if (m_sBodyText != p_Other.m_sBodyText) return false;

	return true;
}

ZHMTypeInfo ZHUDUIControllerEntity_SIntelData::TypeInfo = ZHMTypeInfo("ZHUDUIControllerEntity.SIntelData", sizeof(ZHUDUIControllerEntity_SIntelData), alignof(ZHUDUIControllerEntity_SIntelData), ZHUDUIControllerEntity_SIntelData::WriteJson, ZHUDUIControllerEntity_SIntelData::WriteSimpleJson, ZHUDUIControllerEntity_SIntelData::FromSimpleJson, ZHUDUIControllerEntity_SIntelData::Serialize, ZHUDUIControllerEntity_SIntelData::Equals);

void ZHUDUIControllerEntity_SIntelData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("intelHeadline") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->intelHeadline);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repoID") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->repoID, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intelType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->intelType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("showDuration") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->showDuration);
	p_Stream << "}";

	p_Stream << "}";
}

void ZHUDUIControllerEntity_SIntelData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("intelHeadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->intelHeadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repoID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->repoID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intelType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->intelType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("showDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->showDuration);

	p_Stream << "}";
}

void ZHUDUIControllerEntity_SIntelData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDUIControllerEntity_SIntelData s_Object {};

	s_Object.intelHeadline = std::string_view(p_Document["intelHeadline"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["repoID"], &s_Item);
		s_Object.repoID = s_Item;
	}

	s_Object.intelType = simdjson::from_json_int32(p_Document["intelType"]);

	s_Object.showDuration = simdjson::from_json_float32(p_Document["showDuration"]);

	*reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Target) = s_Object;
}

void ZHUDUIControllerEntity_SIntelData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Object);

	ZString::Serialize(&s_Object->intelHeadline, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SIntelData, intelHeadline));
	ZRepositoryID::Serialize(&s_Object->repoID, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SIntelData, repoID));
}

bool ZHUDUIControllerEntity_SIntelData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDUIControllerEntity_SIntelData::operator==(const ZHUDUIControllerEntity_SIntelData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDUIControllerEntity_SIntelData>)
		return false;

	if (intelHeadline != p_Other.intelHeadline) return false;
	if (repoID != p_Other.repoID) return false;
	if (intelType != p_Other.intelType) return false;
	if (showDuration != p_Other.showDuration) return false;

	return true;
}

ZHMTypeInfo ZHUDUIControllerEntity_SWeaponViewData::TypeInfo = ZHMTypeInfo("ZHUDUIControllerEntity.SWeaponViewData", sizeof(ZHUDUIControllerEntity_SWeaponViewData), alignof(ZHUDUIControllerEntity_SWeaponViewData), ZHUDUIControllerEntity_SWeaponViewData::WriteJson, ZHUDUIControllerEntity_SWeaponViewData::WriteSimpleJson, ZHUDUIControllerEntity_SWeaponViewData::FromSimpleJson, ZHUDUIControllerEntity_SWeaponViewData::Serialize, ZHUDUIControllerEntity_SWeaponViewData::Equals);

void ZHUDUIControllerEntity_SWeaponViewData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("weaponStatus") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SWeaponStatusUIData") << ",\"$val\":";
	SWeaponStatusUIData::WriteJson(&s_Object->weaponStatus, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemOnBackStatus") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("SItemOnBackUIData") << ",\"$val\":";
	SItemOnBackUIData::WriteJson(&s_Object->itemOnBackStatus, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bShowHolstered") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bShowHolstered);
	p_Stream << "}";

	p_Stream << "}";
}

void ZHUDUIControllerEntity_SWeaponViewData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("weaponStatus") << ":";
	SWeaponStatusUIData::WriteSimpleJson(&s_Object->weaponStatus, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemOnBackStatus") << ":";
	SItemOnBackUIData::WriteSimpleJson(&s_Object->itemOnBackStatus, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bShowHolstered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bShowHolstered);

	p_Stream << "}";
}

void ZHUDUIControllerEntity_SWeaponViewData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDUIControllerEntity_SWeaponViewData s_Object {};

	{
		SWeaponStatusUIData s_Item {};
		SWeaponStatusUIData::FromSimpleJson(p_Document["weaponStatus"], &s_Item);
		s_Object.weaponStatus = s_Item;
	}

	{
		SItemOnBackUIData s_Item {};
		SItemOnBackUIData::FromSimpleJson(p_Document["itemOnBackStatus"], &s_Item);
		s_Object.itemOnBackStatus = s_Item;
	}

	s_Object.bShowHolstered = simdjson::from_json_bool(p_Document["bShowHolstered"]);

	*reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Target) = s_Object;
}

void ZHUDUIControllerEntity_SWeaponViewData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Object);

	SWeaponStatusUIData::Serialize(&s_Object->weaponStatus, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SWeaponViewData, weaponStatus));
	SItemOnBackUIData::Serialize(&s_Object->itemOnBackStatus, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SWeaponViewData, itemOnBackStatus));
}

bool ZHUDUIControllerEntity_SWeaponViewData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDUIControllerEntity_SWeaponViewData::operator==(const ZHUDUIControllerEntity_SWeaponViewData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDUIControllerEntity_SWeaponViewData>)
		return false;

	if (weaponStatus != p_Other.weaponStatus) return false;
	if (itemOnBackStatus != p_Other.itemOnBackStatus) return false;
	if (bShowHolstered != p_Other.bShowHolstered) return false;

	return true;
}

ZHMTypeInfo ZHttpUrl::TypeInfo = ZHMTypeInfo("ZHttpUrl", sizeof(ZHttpUrl), alignof(ZHttpUrl), ZHttpUrl::WriteJson, ZHttpUrl::WriteSimpleJson, ZHttpUrl::FromSimpleJson, ZHttpUrl::Serialize, ZHttpUrl::Equals);

void ZHttpUrl::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZHttpUrl::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZHttpUrl::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHttpUrl s_Object {};

	*reinterpret_cast<ZHttpUrl*>(p_Target) = s_Object;
}

void ZHttpUrl::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);

}

bool ZHttpUrl::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHttpUrl*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHttpUrl*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHttpUrl::operator==(const ZHttpUrl& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHttpUrl>)
		return false;


	return true;
}

ZHMTypeInfo ZInteractionData::TypeInfo = ZHMTypeInfo("ZInteractionData", sizeof(ZInteractionData), alignof(ZInteractionData), ZInteractionData::WriteJson, ZInteractionData::WriteSimpleJson, ZInteractionData::FromSimpleJson, ZInteractionData::Serialize, ZInteractionData::Equals);

void ZInteractionData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZInteractionData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInteractionData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInteractionData s_Object {};

	*reinterpret_cast<ZInteractionData*>(p_Target) = s_Object;
}

void ZInteractionData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);

}

bool ZInteractionData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionData::operator==(const ZInteractionData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionData>)
		return false;


	return true;
}

ZHMTypeInfo ZInteractionEventConsumer_SInteractionEventData::TypeInfo = ZHMTypeInfo("ZInteractionEventConsumer.SInteractionEventData", sizeof(ZInteractionEventConsumer_SInteractionEventData), alignof(ZInteractionEventConsumer_SInteractionEventData), ZInteractionEventConsumer_SInteractionEventData::WriteJson, ZInteractionEventConsumer_SInteractionEventData::WriteSimpleJson, ZInteractionEventConsumer_SInteractionEventData::FromSimpleJson, ZInteractionEventConsumer_SInteractionEventData::Serialize, ZInteractionEventConsumer_SInteractionEventData::Equals);

void ZInteractionEventConsumer_SInteractionEventData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInteractionEventConsumer.EEvent") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_nEvent)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInteractionEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZInteractionEventConsumer_SInteractionEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInteractionEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZInteractionEventConsumer_SInteractionEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInteractionEventConsumer_SInteractionEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZInteractionEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZInteractionEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Target) = s_Object;
}

void ZInteractionEventConsumer_SInteractionEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Object);

}

bool ZInteractionEventConsumer_SInteractionEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionEventConsumer_SInteractionEventData::operator==(const ZInteractionEventConsumer_SInteractionEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionEventConsumer_SInteractionEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

ZHMTypeInfo ZInteractionGuideData::TypeInfo = ZHMTypeInfo("ZInteractionGuideData", sizeof(ZInteractionGuideData), alignof(ZInteractionGuideData), ZInteractionGuideData::WriteJson, ZInteractionGuideData::WriteSimpleJson, ZInteractionGuideData::FromSimpleJson, ZInteractionGuideData::Serialize, ZInteractionGuideData::Equals);

void ZInteractionGuideData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZInteractionGuideData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInteractionGuideData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInteractionGuideData s_Object {};

	*reinterpret_cast<ZInteractionGuideData*>(p_Target) = s_Object;
}

void ZInteractionGuideData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);

}

bool ZInteractionGuideData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionGuideData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionGuideData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionGuideData::operator==(const ZInteractionGuideData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionGuideData>)
		return false;


	return true;
}

ZHMTypeInfo ZInventorySlot::TypeInfo = ZHMTypeInfo("ZInventorySlot", sizeof(ZInventorySlot), alignof(ZInventorySlot), ZInventorySlot::WriteJson, ZInventorySlot::WriteSimpleJson, ZInventorySlot::FromSimpleJson, ZInventorySlot::Serialize, ZInventorySlot::Equals);

void ZInventorySlot::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZInventorySlot::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInventorySlot::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInventorySlot s_Object {};

	*reinterpret_cast<ZInventorySlot*>(p_Target) = s_Object;
}

void ZInventorySlot::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);

}

bool ZInventorySlot::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInventorySlot*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInventorySlot*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInventorySlot::operator==(const ZInventorySlot& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInventorySlot>)
		return false;


	return true;
}

ZHMTypeInfo ZInvestigateStandingSituation_SState::TypeInfo = ZHMTypeInfo("ZInvestigateStandingSituation.SState", sizeof(ZInvestigateStandingSituation_SState), alignof(ZInvestigateStandingSituation_SState), ZInvestigateStandingSituation_SState::WriteJson, ZInvestigateStandingSituation_SState::WriteSimpleJson, ZInvestigateStandingSituation_SState::FromSimpleJson, ZInvestigateStandingSituation_SState::Serialize, ZInvestigateStandingSituation_SState::Equals);

void ZInvestigateStandingSituation_SState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation_SState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bHitmanInvadingPrivacy") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanInvadingPrivacy);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanBizarre") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanBizarre);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanWasBizarre") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanWasBizarre);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanWarned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanWarned);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldReactToWeaponPickup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldReactToWeaponPickup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReactedToWeaponPickup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReactedToWeaponPickup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInvestigateStandingSituation.ESituationState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSituationState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateStandingSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eFlavor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInvestigateStandingSituation.ESituationFlavor") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eFlavor)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateStandingSituation.ESituationFlavor", static_cast<int>(s_Object->m_eFlavor))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHitmanBizarre") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tHitmanBizarre, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastComment") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastComment, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastBump") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastBump, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void ZInvestigateStandingSituation_SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation_SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bHitmanInvadingPrivacy") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanInvadingPrivacy);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanBizarre") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanBizarre);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanWasBizarre") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanWasBizarre);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanWarned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanWarned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldReactToWeaponPickup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldReactToWeaponPickup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReactedToWeaponPickup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReactedToWeaponPickup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateStandingSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eFlavor") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateStandingSituation.ESituationFlavor", static_cast<int>(s_Object->m_eFlavor)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHitmanBizarre") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tHitmanBizarre, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastComment") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastComment, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastBump") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastBump, p_Stream);

	p_Stream << "}";
}

void ZInvestigateStandingSituation_SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInvestigateStandingSituation_SState s_Object {};

	s_Object.m_bHitmanInvadingPrivacy = simdjson::from_json_bool(p_Document["m_bHitmanInvadingPrivacy"]);

	s_Object.m_bHitmanBizarre = simdjson::from_json_bool(p_Document["m_bHitmanBizarre"]);

	s_Object.m_bHitmanWasBizarre = simdjson::from_json_bool(p_Document["m_bHitmanWasBizarre"]);

	s_Object.m_bHitmanWarned = simdjson::from_json_bool(p_Document["m_bHitmanWarned"]);

	s_Object.m_bShouldReactToWeaponPickup = simdjson::from_json_bool(p_Document["m_bShouldReactToWeaponPickup"]);

	s_Object.m_bReactedToWeaponPickup = simdjson::from_json_bool(p_Document["m_bReactedToWeaponPickup"]);

	s_Object.m_eSituationState = static_cast<ZInvestigateStandingSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZInvestigateStandingSituation.ESituationState", std::string_view(p_Document["m_eSituationState"])));

	s_Object.m_eFlavor = static_cast<ZInvestigateStandingSituation_ESituationFlavor>(ZHMEnums::GetEnumValueByName("ZInvestigateStandingSituation.ESituationFlavor", std::string_view(p_Document["m_eFlavor"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tHitmanBizarre"], &s_Item);
		s_Object.m_tHitmanBizarre = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastComment"], &s_Item);
		s_Object.m_tLastComment = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastBump"], &s_Item);
		s_Object.m_tLastBump = s_Item;
	}

	*reinterpret_cast<ZInvestigateStandingSituation_SState*>(p_Target) = s_Object;
}

void ZInvestigateStandingSituation_SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation_SState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tHitmanBizarre, p_Serializer, p_OwnOffset + offsetof(ZInvestigateStandingSituation_SState, m_tHitmanBizarre));
	ZGameTime::Serialize(&s_Object->m_tLastComment, p_Serializer, p_OwnOffset + offsetof(ZInvestigateStandingSituation_SState, m_tLastComment));
	ZGameTime::Serialize(&s_Object->m_tLastBump, p_Serializer, p_OwnOffset + offsetof(ZInvestigateStandingSituation_SState, m_tLastBump));
}

bool ZInvestigateStandingSituation_SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateStandingSituation_SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateStandingSituation_SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateStandingSituation_SState::operator==(const ZInvestigateStandingSituation_SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateStandingSituation_SState>)
		return false;

	if (m_bHitmanInvadingPrivacy != p_Other.m_bHitmanInvadingPrivacy) return false;
	if (m_bHitmanBizarre != p_Other.m_bHitmanBizarre) return false;
	if (m_bHitmanWasBizarre != p_Other.m_bHitmanWasBizarre) return false;
	if (m_bHitmanWarned != p_Other.m_bHitmanWarned) return false;
	if (m_bShouldReactToWeaponPickup != p_Other.m_bShouldReactToWeaponPickup) return false;
	if (m_bReactedToWeaponPickup != p_Other.m_bReactedToWeaponPickup) return false;
	if (m_eSituationState != p_Other.m_eSituationState) return false;
	if (m_eFlavor != p_Other.m_eFlavor) return false;
	if (m_tHitmanBizarre != p_Other.m_tHitmanBizarre) return false;
	if (m_tLastComment != p_Other.m_tLastComment) return false;
	if (m_tLastBump != p_Other.m_tLastBump) return false;

	return true;
}

ZHMTypeInfo ZInvestigateStandingSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZInvestigateStandingSituation.SSituationSaveData", sizeof(ZInvestigateStandingSituation_SSituationSaveData), alignof(ZInvestigateStandingSituation_SSituationSaveData), ZInvestigateStandingSituation_SSituationSaveData::WriteJson, ZInvestigateStandingSituation_SSituationSaveData::WriteSimpleJson, ZInvestigateStandingSituation_SSituationSaveData::FromSimpleJson, ZInvestigateStandingSituation_SSituationSaveData::Serialize, ZInvestigateStandingSituation_SSituationSaveData::Equals);

void ZInvestigateStandingSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_State") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZInvestigateStandingSituation.SState") << ",\"$val\":";
	ZInvestigateStandingSituation_SState::WriteJson(&s_Object->m_State, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << "}";

	p_Stream << "}";
}

void ZInvestigateStandingSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZInvestigateStandingSituation_SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);

	p_Stream << "}";
}

void ZInvestigateStandingSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInvestigateStandingSituation_SSituationSaveData s_Object {};

	{
		ZInvestigateStandingSituation_SState s_Item {};
		ZInvestigateStandingSituation_SState::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	*reinterpret_cast<ZInvestigateStandingSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZInvestigateStandingSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation_SSituationSaveData*>(p_Object);

	ZInvestigateStandingSituation_SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZInvestigateStandingSituation_SSituationSaveData, m_State));
}

bool ZInvestigateStandingSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateStandingSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateStandingSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateStandingSituation_SSituationSaveData::operator==(const ZInvestigateStandingSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateStandingSituation_SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;

	return true;
}

ZHMTypeInfo ZInvestigateWeaponSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZInvestigateWeaponSituation.SSituationSaveData", sizeof(ZInvestigateWeaponSituation_SSituationSaveData), alignof(ZInvestigateWeaponSituation_SSituationSaveData), ZInvestigateWeaponSituation_SSituationSaveData::WriteJson, ZInvestigateWeaponSituation_SSituationSaveData::WriteSimpleJson, ZInvestigateWeaponSituation_SSituationSaveData::FromSimpleJson, ZInvestigateWeaponSituation_SSituationSaveData::Serialize, ZInvestigateWeaponSituation_SSituationSaveData::Equals);

void ZInvestigateWeaponSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nCurrentState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentState);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mainStateStartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_mainStateStartTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastStandDown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nActiveInvestigationGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nActiveInvestigationGroup);
	p_Stream << "}";

	p_Stream << "}";
}

void ZInvestigateWeaponSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nCurrentState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mainStateStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_mainStateStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nActiveInvestigationGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nActiveInvestigationGroup);

	p_Stream << "}";
}

void ZInvestigateWeaponSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInvestigateWeaponSituation_SSituationSaveData s_Object {};

	s_Object.m_nCurrentState = simdjson::from_json_int32(p_Document["m_nCurrentState"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_mainStateStartTime"], &s_Item);
		s_Object.m_mainStateStartTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastStandDown"], &s_Item);
		s_Object.m_tLastStandDown = s_Item;
	}

	s_Object.m_nActiveInvestigationGroup = simdjson::from_json_int32(p_Document["m_nActiveInvestigationGroup"]);

	*reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZInvestigateWeaponSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_mainStateStartTime, p_Serializer, p_OwnOffset + offsetof(ZInvestigateWeaponSituation_SSituationSaveData, m_mainStateStartTime));
	ZGameTime::Serialize(&s_Object->m_tLastStandDown, p_Serializer, p_OwnOffset + offsetof(ZInvestigateWeaponSituation_SSituationSaveData, m_tLastStandDown));
}

bool ZInvestigateWeaponSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateWeaponSituation_SSituationSaveData::operator==(const ZInvestigateWeaponSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateWeaponSituation_SSituationSaveData>)
		return false;

	if (m_nCurrentState != p_Other.m_nCurrentState) return false;
	if (m_mainStateStartTime != p_Other.m_mainStateStartTime) return false;
	if (m_tLastStandDown != p_Other.m_tLastStandDown) return false;
	if (m_nActiveInvestigationGroup != p_Other.m_nActiveInvestigationGroup) return false;

	return true;
}

ZHMTypeInfo ZJumpToOrder_SJumpToOrderSaveData::TypeInfo = ZHMTypeInfo("ZJumpToOrder.SJumpToOrderSaveData", sizeof(ZJumpToOrder_SJumpToOrderSaveData), alignof(ZJumpToOrder_SJumpToOrderSaveData), ZJumpToOrder_SJumpToOrderSaveData::WriteJson, ZJumpToOrder_SJumpToOrderSaveData::WriteSimpleJson, ZJumpToOrder_SJumpToOrderSaveData::FromSimpleJson, ZJumpToOrder_SJumpToOrderSaveData::Serialize, ZJumpToOrder_SJumpToOrderSaveData::Equals);

void ZJumpToOrder_SJumpToOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTargetPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vTargetPosition, p_Stream);
	p_Stream << "}";

	p_Stream << "}";
}

void ZJumpToOrder_SJumpToOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTargetPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vTargetPosition, p_Stream);

	p_Stream << "}";
}

void ZJumpToOrder_SJumpToOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZJumpToOrder_SJumpToOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Item);
		s_Object.m_vStopDirection = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vTargetPosition"], &s_Item);
		s_Object.m_vTargetPosition = s_Item;
	}

	*reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Target) = s_Object;
}

void ZJumpToOrder_SJumpToOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZJumpToOrder_SJumpToOrderSaveData, m_vStopDirection));
	float4::Serialize(&s_Object->m_vTargetPosition, p_Serializer, p_OwnOffset + offsetof(ZJumpToOrder_SJumpToOrderSaveData, m_vTargetPosition));
}

bool ZJumpToOrder_SJumpToOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZJumpToOrder_SJumpToOrderSaveData::operator==(const ZJumpToOrder_SJumpToOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZJumpToOrder_SJumpToOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_vTargetPosition != p_Other.m_vTargetPosition) return false;

	return true;
}

ZHMTypeInfo ZMoveToOrder_SMoveToOrderSaveData::TypeInfo = ZHMTypeInfo("ZMoveToOrder.SMoveToOrderSaveData", sizeof(ZMoveToOrder_SMoveToOrderSaveData), alignof(ZMoveToOrder_SMoveToOrderSaveData), ZMoveToOrder_SMoveToOrderSaveData::WriteJson, ZMoveToOrder_SMoveToOrderSaveData::WriteSimpleJson, ZMoveToOrder_SMoveToOrderSaveData::FromSimpleJson, ZMoveToOrder_SMoveToOrderSaveData::Serialize, ZMoveToOrder_SMoveToOrderSaveData::Equals);

void ZMoveToOrder_SMoveToOrderSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStopDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStopDistance);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fWalkDistance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWalkDistance);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleBlockageFlags") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleBlockageFlags);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMoveSpeed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZMoveToOrder.EMoveSpeed") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eMoveSpeed)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZMoveToOrder.EMoveSpeed", static_cast<int>(s_Object->m_eMoveSpeed))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreEndCollision") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreEndCollision);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPrecisePositioning") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPrecisePositioning);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceStand") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceStand);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLookAtTargetMustBeInSight") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAtTargetMustBeInSight);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseKnownPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseKnownPosition);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStrafe") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStrafe);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEndStanding") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEndStanding);
	p_Stream << "}";

	p_Stream << "}";
}

void ZMoveToOrder_SMoveToOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStopDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStopDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fWalkDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWalkDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleBlockageFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleBlockageFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZMoveToOrder.EMoveSpeed", static_cast<int>(s_Object->m_eMoveSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreEndCollision") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreEndCollision);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPrecisePositioning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPrecisePositioning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceStand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceStand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLookAtTargetMustBeInSight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAtTargetMustBeInSight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseKnownPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseKnownPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStrafe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStrafe);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEndStanding") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEndStanding);

	p_Stream << "}";
}

void ZMoveToOrder_SMoveToOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZMoveToOrder_SMoveToOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Item);
		s_Object.m_vStopDirection = s_Item;
	}

	s_Object.m_fStopDistance = simdjson::from_json_float32(p_Document["m_fStopDistance"]);

	s_Object.m_fWalkDistance = simdjson::from_json_float32(p_Document["m_fWalkDistance"]);

	s_Object.m_nObstacleBlockageFlags = simdjson::from_json_uint32(p_Document["m_nObstacleBlockageFlags"]);

	s_Object.m_eMoveSpeed = static_cast<ZMoveToOrder_EMoveSpeed>(ZHMEnums::GetEnumValueByName("ZMoveToOrder.EMoveSpeed", std::string_view(p_Document["m_eMoveSpeed"])));

	s_Object.m_bIgnoreEndCollision = simdjson::from_json_bool(p_Document["m_bIgnoreEndCollision"]);

	s_Object.m_bPrecisePositioning = simdjson::from_json_bool(p_Document["m_bPrecisePositioning"]);

	s_Object.m_bForceStand = simdjson::from_json_bool(p_Document["m_bForceStand"]);

	s_Object.m_bLookAtTargetMustBeInSight = simdjson::from_json_bool(p_Document["m_bLookAtTargetMustBeInSight"]);

	s_Object.m_bUseKnownPosition = simdjson::from_json_bool(p_Document["m_bUseKnownPosition"]);

	s_Object.m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

	s_Object.m_bStrafe = simdjson::from_json_bool(p_Document["m_bStrafe"]);

	s_Object.m_bEndStanding = simdjson::from_json_bool(p_Document["m_bEndStanding"]);

	*reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Target) = s_Object;
}

void ZMoveToOrder_SMoveToOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZMoveToOrder_SMoveToOrderSaveData, m_vStopDirection));
}

bool ZMoveToOrder_SMoveToOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZMoveToOrder_SMoveToOrderSaveData::operator==(const ZMoveToOrder_SMoveToOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZMoveToOrder_SMoveToOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_fStopDistance != p_Other.m_fStopDistance) return false;
	if (m_fWalkDistance != p_Other.m_fWalkDistance) return false;
	if (m_nObstacleBlockageFlags != p_Other.m_nObstacleBlockageFlags) return false;
	if (m_eMoveSpeed != p_Other.m_eMoveSpeed) return false;
	if (m_bIgnoreEndCollision != p_Other.m_bIgnoreEndCollision) return false;
	if (m_bPrecisePositioning != p_Other.m_bPrecisePositioning) return false;
	if (m_bForceStand != p_Other.m_bForceStand) return false;
	if (m_bLookAtTargetMustBeInSight != p_Other.m_bLookAtTargetMustBeInSight) return false;
	if (m_bUseKnownPosition != p_Other.m_bUseKnownPosition) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;
	if (m_bStrafe != p_Other.m_bStrafe) return false;
	if (m_bEndStanding != p_Other.m_bEndStanding) return false;

	return true;
}

ZHMTypeInfo ZPlanningObjectiveInfoBuilder::TypeInfo = ZHMTypeInfo("ZPlanningObjectiveInfoBuilder", sizeof(ZPlanningObjectiveInfoBuilder), alignof(ZPlanningObjectiveInfoBuilder), ZPlanningObjectiveInfoBuilder::WriteJson, ZPlanningObjectiveInfoBuilder::WriteSimpleJson, ZPlanningObjectiveInfoBuilder::FromSimpleJson, ZPlanningObjectiveInfoBuilder::Serialize, ZPlanningObjectiveInfoBuilder::Equals);

void ZPlanningObjectiveInfoBuilder::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZPlanningObjectiveInfoBuilder::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZPlanningObjectiveInfoBuilder::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPlanningObjectiveInfoBuilder s_Object {};

	*reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Target) = s_Object;
}

void ZPlanningObjectiveInfoBuilder::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);

}

bool ZPlanningObjectiveInfoBuilder::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPlanningObjectiveInfoBuilder::operator==(const ZPlanningObjectiveInfoBuilder& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPlanningObjectiveInfoBuilder>)
		return false;


	return true;
}

ZHMTypeInfo ZPostfilterGraphBaseNode::TypeInfo = ZHMTypeInfo("ZPostfilterGraphBaseNode", sizeof(ZPostfilterGraphBaseNode), alignof(ZPostfilterGraphBaseNode), ZPostfilterGraphBaseNode::WriteJson, ZPostfilterGraphBaseNode::WriteSimpleJson, ZPostfilterGraphBaseNode::FromSimpleJson, ZPostfilterGraphBaseNode::Serialize, ZPostfilterGraphBaseNode::Equals);

void ZPostfilterGraphBaseNode::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZPostfilterGraphBaseNode::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZPostfilterGraphBaseNode::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPostfilterGraphBaseNode s_Object {};

	*reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Target) = s_Object;
}

void ZPostfilterGraphBaseNode::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

}

bool ZPostfilterGraphBaseNode::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPostfilterGraphBaseNode::operator==(const ZPostfilterGraphBaseNode& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPostfilterGraphBaseNode>)
		return false;


	return true;
}

ZHMTypeInfo ZRayQueryInput::TypeInfo = ZHMTypeInfo("ZRayQueryInput", sizeof(ZRayQueryInput), alignof(ZRayQueryInput), ZRayQueryInput::WriteJson, ZRayQueryInput::WriteSimpleJson, ZRayQueryInput::FromSimpleJson, ZRayQueryInput::Serialize, ZRayQueryInput::Equals);

void ZRayQueryInput::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZRayQueryInput::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZRayQueryInput::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRayQueryInput s_Object {};

	*reinterpret_cast<ZRayQueryInput*>(p_Target) = s_Object;
}

void ZRayQueryInput::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

}

bool ZRayQueryInput::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRayQueryInput*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRayQueryInput*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRayQueryInput::operator==(const ZRayQueryInput& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRayQueryInput>)
		return false;


	return true;
}

ZHMTypeInfo ZRecoverUnconsciousSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZRecoverUnconsciousSituation.SSituationSaveData", sizeof(ZRecoverUnconsciousSituation_SSituationSaveData), alignof(ZRecoverUnconsciousSituation_SSituationSaveData), ZRecoverUnconsciousSituation_SSituationSaveData::WriteJson, ZRecoverUnconsciousSituation_SSituationSaveData::WriteSimpleJson, ZRecoverUnconsciousSituation_SSituationSaveData::FromSimpleJson, ZRecoverUnconsciousSituation_SSituationSaveData::Serialize, ZRecoverUnconsciousSituation_SSituationSaveData::Equals);

void ZRecoverUnconsciousSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rVictim") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVictim);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pRecoverUnconsciousGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pRecoverUnconsciousGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pObserversGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pObserversGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalate") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalate);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVictimPacified") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVictimPacified);
	p_Stream << "}";

	p_Stream << "}";
}

void ZRecoverUnconsciousSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pRecoverUnconsciousGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pRecoverUnconsciousGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pObserversGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pObserversGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVictimPacified") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVictimPacified);

	p_Stream << "}";
}

void ZRecoverUnconsciousSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRecoverUnconsciousSituation_SSituationSaveData s_Object {};

	s_Object.m_rVictim = simdjson::from_json_uint32(p_Document["m_rVictim"]);

	s_Object.m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	s_Object.m_pRecoverUnconsciousGroup = simdjson::from_json_int32(p_Document["m_pRecoverUnconsciousGroup"]);

	s_Object.m_pObserversGroup = simdjson::from_json_int32(p_Document["m_pObserversGroup"]);

	s_Object.m_bEscalate = simdjson::from_json_bool(p_Document["m_bEscalate"]);

	s_Object.m_bVictimPacified = simdjson::from_json_bool(p_Document["m_bVictimPacified"]);

	*reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZRecoverUnconsciousSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Object);

}

bool ZRecoverUnconsciousSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRecoverUnconsciousSituation_SSituationSaveData::operator==(const ZRecoverUnconsciousSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRecoverUnconsciousSituation_SSituationSaveData>)
		return false;

	if (m_rVictim != p_Other.m_rVictim) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_pRecoverUnconsciousGroup != p_Other.m_pRecoverUnconsciousGroup) return false;
	if (m_pObserversGroup != p_Other.m_pObserversGroup) return false;
	if (m_bEscalate != p_Other.m_bEscalate) return false;
	if (m_bVictimPacified != p_Other.m_bVictimPacified) return false;

	return true;
}

ZHMTypeInfo ZScopedER64::TypeInfo = ZHMTypeInfo("ZScopedER64", sizeof(ZScopedER64), alignof(ZScopedER64), ZScopedER64::WriteJson, ZScopedER64::WriteSimpleJson, ZScopedER64::FromSimpleJson, ZScopedER64::Serialize, ZScopedER64::Equals);

void ZScopedER64::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_er64") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZER64") << ",\"$val\":";
	ZER64::WriteJson(&s_Object->m_er64, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aScopePath") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint64>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aScopePath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aScopePath[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aScopePath.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZScopedER64::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_er64") << ":";
	ZER64::WriteSimpleJson(&s_Object->m_er64, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aScopePath") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aScopePath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aScopePath[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aScopePath.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZScopedER64::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZScopedER64 s_Object {};

	{
		ZER64 s_Item {};
		ZER64::FromSimpleJson(p_Document["m_er64"], &s_Item);
		s_Object.m_er64 = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aScopePath"])
	{
		s_Object.m_aScopePath.push_back(simdjson::from_json_uint64(s_Item0));
	}

	*reinterpret_cast<ZScopedER64*>(p_Target) = s_Object;
}

void ZScopedER64::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);

	ZER64::Serialize(&s_Object->m_er64, p_Serializer, p_OwnOffset + offsetof(ZScopedER64, m_er64));
	TArray<uint64>::Serialize(&s_Object->m_aScopePath, p_Serializer, p_OwnOffset + offsetof(ZScopedER64, m_aScopePath));
}

bool ZScopedER64::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZScopedER64*>(p_Left);
	auto* s_Right = reinterpret_cast<ZScopedER64*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZScopedER64::operator==(const ZScopedER64& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZScopedER64>)
		return false;

	if (m_er64 != p_Other.m_er64) return false;
	if (m_aScopePath != p_Other.m_aScopePath) return false;

	return true;
}

ZHMTypeInfo ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::TypeInfo = ZHMTypeInfo("ZSecuritySystemCameraConfiguration.SDeadBodyVisibleEscalationRule", sizeof(ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule), alignof(ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule), ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::WriteJson, ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::WriteSimpleJson, ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::FromSimpleJson, ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Serialize, ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Equals);

void ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_NrGuardsToSend") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_NrGuardsToSend);
	p_Stream << "}";

	p_Stream << "}";
}

void ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_NrGuardsToSend") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_NrGuardsToSend);

	p_Stream << "}";
}

void ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule s_Object {};

	s_Object.m_NrGuardsToSend = simdjson::from_json_int32(p_Document["m_NrGuardsToSend"]);

	*reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Target) = s_Object;
}

void ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Object);

}

bool ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::operator==(const ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule>)
		return false;

	if (m_NrGuardsToSend != p_Other.m_NrGuardsToSend) return false;

	return true;
}

ZHMTypeInfo ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::TypeInfo = ZHMTypeInfo("ZSecuritySystemCameraConfiguration.SHitmanVisibleEscalationRule", sizeof(ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule), alignof(ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule), ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::WriteJson, ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::WriteSimpleJson, ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::FromSimpleJson, ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Serialize, ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Equals);

void ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_NrGuardsToSend") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_NrGuardsToSend);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Situation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZSecuritySystemCameraConfiguration.ECameraEscalationSituations") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_Situation)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSecuritySystemCameraConfiguration.ECameraEscalationSituations", static_cast<int>(s_Object->m_Situation))) << "}";
	p_Stream << "}";

	p_Stream << "}";
}

void ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_NrGuardsToSend") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_NrGuardsToSend);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Situation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSecuritySystemCameraConfiguration.ECameraEscalationSituations", static_cast<int>(s_Object->m_Situation)));

	p_Stream << "}";
}

void ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule s_Object {};

	s_Object.m_NrGuardsToSend = simdjson::from_json_int32(p_Document["m_NrGuardsToSend"]);

	s_Object.m_Situation = static_cast<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations>(ZHMEnums::GetEnumValueByName("ZSecuritySystemCameraConfiguration.ECameraEscalationSituations", std::string_view(p_Document["m_Situation"])));

	*reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Target) = s_Object;
}

void ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Object);

}

bool ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::operator==(const ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule>)
		return false;

	if (m_NrGuardsToSend != p_Other.m_NrGuardsToSend) return false;
	if (m_Situation != p_Other.m_Situation) return false;

	return true;
}

ZHMTypeInfo ZSetPieceIconEntity_SIconData::TypeInfo = ZHMTypeInfo("ZSetPieceIconEntity.SIconData", sizeof(ZSetPieceIconEntity_SIconData), alignof(ZSetPieceIconEntity_SIconData), ZSetPieceIconEntity_SIconData::WriteJson, ZSetPieceIconEntity_SIconData::WriteSimpleJson, ZSetPieceIconEntity_SIconData::FromSimpleJson, ZSetPieceIconEntity_SIconData::Serialize, ZSetPieceIconEntity_SIconData::Equals);

void ZSetPieceIconEntity_SIconData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("iCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->iCategory);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction1") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction1);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction2") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction2);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction3") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction3);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sMissingToolText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->sMissingToolText);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bShowMissingTool") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->bShowMissingTool);
	p_Stream << "}";

	p_Stream << "}";
}

void ZSetPieceIconEntity_SIconData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("iCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction1") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction1);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction2") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction2);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction3") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction3);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sMissingToolText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sMissingToolText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bShowMissingTool") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bShowMissingTool);

	p_Stream << "}";
}

void ZSetPieceIconEntity_SIconData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSetPieceIconEntity_SIconData s_Object {};

	s_Object.iCategory = std::string_view(p_Document["iCategory"]);

	s_Object.iInteraction1 = std::string_view(p_Document["iInteraction1"]);

	s_Object.iInteraction2 = std::string_view(p_Document["iInteraction2"]);

	s_Object.iInteraction3 = std::string_view(p_Document["iInteraction3"]);

	s_Object.sMissingToolText = std::string_view(p_Document["sMissingToolText"]);

	s_Object.bShowMissingTool = simdjson::from_json_bool(p_Document["bShowMissingTool"]);

	*reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Target) = s_Object;
}

void ZSetPieceIconEntity_SIconData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Object);

	ZString::Serialize(&s_Object->iCategory, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, iCategory));
	ZString::Serialize(&s_Object->iInteraction1, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, iInteraction1));
	ZString::Serialize(&s_Object->iInteraction2, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, iInteraction2));
	ZString::Serialize(&s_Object->iInteraction3, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, iInteraction3));
	ZString::Serialize(&s_Object->sMissingToolText, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, sMissingToolText));
}

bool ZSetPieceIconEntity_SIconData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSetPieceIconEntity_SIconData::operator==(const ZSetPieceIconEntity_SIconData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSetPieceIconEntity_SIconData>)
		return false;

	if (iCategory != p_Other.iCategory) return false;
	if (iInteraction1 != p_Other.iInteraction1) return false;
	if (iInteraction2 != p_Other.iInteraction2) return false;
	if (iInteraction3 != p_Other.iInteraction3) return false;
	if (sMissingToolText != p_Other.sMissingToolText) return false;
	if (bShowMissingTool != p_Other.bShowMissingTool) return false;

	return true;
}

ZHMTypeInfo ZSharedSensorDef_SVisibilitySetting::TypeInfo = ZHMTypeInfo("ZSharedSensorDef.SVisibilitySetting", sizeof(ZSharedSensorDef_SVisibilitySetting), alignof(ZSharedSensorDef_SVisibilitySetting), ZSharedSensorDef_SVisibilitySetting::WriteJson, ZSharedSensorDef_SVisibilitySetting::WriteSimpleJson, ZSharedSensorDef_SVisibilitySetting::FromSimpleJson, ZSharedSensorDef_SVisibilitySetting::Serialize, ZSharedSensorDef_SVisibilitySetting::Equals);

void ZSharedSensorDef_SVisibilitySetting::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eSensitivity") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EActorPerceptionSensitivity") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSensitivity)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorPerceptionSensitivity", static_cast<int>(s_Object->m_eSensitivity))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCloseRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCloseRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngleWhileMoving") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngleWhileMoving);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralHigh") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralHigh);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralLow") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralLow);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeWidthAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeWidthAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeHeightAngle") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeHeightAngle);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeBackWidth") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeBackWidth);
	p_Stream << "}";

	p_Stream << "}";
}

void ZSharedSensorDef_SVisibilitySetting::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSensitivity") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorPerceptionSensitivity", static_cast<int>(s_Object->m_eSensitivity)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCloseRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCloseRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngleWhileMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngleWhileMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralHigh") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralHigh);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralLow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralLow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeWidthAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeWidthAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeHeightAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeHeightAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeBackWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeBackWidth);

	p_Stream << "}";
}

void ZSharedSensorDef_SVisibilitySetting::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSharedSensorDef_SVisibilitySetting s_Object {};

	s_Object.m_eSensitivity = static_cast<EActorPerceptionSensitivity>(ZHMEnums::GetEnumValueByName("EActorPerceptionSensitivity", std::string_view(p_Document["m_eSensitivity"])));

	s_Object.m_fCloseRange = simdjson::from_json_float32(p_Document["m_fCloseRange"]);

	s_Object.m_fPeripheralAngle = simdjson::from_json_float32(p_Document["m_fPeripheralAngle"]);

	s_Object.m_fPeripheralAngleWhileMoving = simdjson::from_json_float32(p_Document["m_fPeripheralAngleWhileMoving"]);

	s_Object.m_fPeripheralHigh = simdjson::from_json_float32(p_Document["m_fPeripheralHigh"]);

	s_Object.m_fPeripheralLow = simdjson::from_json_float32(p_Document["m_fPeripheralLow"]);

	s_Object.m_fFocusConeWidthAngle = simdjson::from_json_float32(p_Document["m_fFocusConeWidthAngle"]);

	s_Object.m_fFocusConeHeightAngle = simdjson::from_json_float32(p_Document["m_fFocusConeHeightAngle"]);

	s_Object.m_fFocusConeRange = simdjson::from_json_float32(p_Document["m_fFocusConeRange"]);

	s_Object.m_fFocusConeBackWidth = simdjson::from_json_float32(p_Document["m_fFocusConeBackWidth"]);

	*reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Target) = s_Object;
}

void ZSharedSensorDef_SVisibilitySetting::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);

}

bool ZSharedSensorDef_SVisibilitySetting::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSharedSensorDef_SVisibilitySetting::operator==(const ZSharedSensorDef_SVisibilitySetting& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSharedSensorDef_SVisibilitySetting>)
		return false;

	if (m_eSensitivity != p_Other.m_eSensitivity) return false;
	if (m_fCloseRange != p_Other.m_fCloseRange) return false;
	if (m_fPeripheralAngle != p_Other.m_fPeripheralAngle) return false;
	if (m_fPeripheralAngleWhileMoving != p_Other.m_fPeripheralAngleWhileMoving) return false;
	if (m_fPeripheralHigh != p_Other.m_fPeripheralHigh) return false;
	if (m_fPeripheralLow != p_Other.m_fPeripheralLow) return false;
	if (m_fFocusConeWidthAngle != p_Other.m_fFocusConeWidthAngle) return false;
	if (m_fFocusConeHeightAngle != p_Other.m_fFocusConeHeightAngle) return false;
	if (m_fFocusConeRange != p_Other.m_fFocusConeRange) return false;
	if (m_fFocusConeBackWidth != p_Other.m_fFocusConeBackWidth) return false;

	return true;
}

ZHMTypeInfo ZSituationGroup::TypeInfo = ZHMTypeInfo("ZSituationGroup", sizeof(ZSituationGroup), alignof(ZSituationGroup), ZSituationGroup::WriteJson, ZSituationGroup::WriteSimpleJson, ZSituationGroup::FromSimpleJson, ZSituationGroup::Serialize, ZSituationGroup::Equals);

void ZSituationGroup::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZSituationGroup::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSituationGroup::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSituationGroup s_Object {};

	*reinterpret_cast<ZSituationGroup*>(p_Target) = s_Object;
}

void ZSituationGroup::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);

}

bool ZSituationGroup::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSituationGroup*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSituationGroup*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSituationGroup::operator==(const ZSituationGroup& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSituationGroup>)
		return false;


	return true;
}

ZHMTypeInfo ZSituationOrder::TypeInfo = ZHMTypeInfo("ZSituationOrder", sizeof(ZSituationOrder), alignof(ZSituationOrder), ZSituationOrder::WriteJson, ZSituationOrder::WriteSimpleJson, ZSituationOrder::FromSimpleJson, ZSituationOrder::Serialize, ZSituationOrder::Equals);

void ZSituationOrder::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZSituationOrder::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSituationOrder::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSituationOrder s_Object {};

	*reinterpret_cast<ZSituationOrder*>(p_Target) = s_Object;
}

void ZSituationOrder::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);

}

bool ZSituationOrder::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSituationOrder*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSituationOrder*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSituationOrder::operator==(const ZSituationOrder& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSituationOrder>)
		return false;


	return true;
}

ZHMTypeInfo ZSniperCombatSituation_SSniperSuspiciousArea::TypeInfo = ZHMTypeInfo("ZSniperCombatSituation.SSniperSuspiciousArea", sizeof(ZSniperCombatSituation_SSniperSuspiciousArea), alignof(ZSniperCombatSituation_SSniperSuspiciousArea), ZSniperCombatSituation_SSniperSuspiciousArea::WriteJson, ZSniperCombatSituation_SSniperSuspiciousArea::WriteSimpleJson, ZSniperCombatSituation_SSniperSuspiciousArea::FromSimpleJson, ZSniperCombatSituation_SSniperSuspiciousArea::Serialize, ZSniperCombatSituation_SSniperSuspiciousArea::Equals);

void ZSniperCombatSituation_SSniperSuspiciousArea::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRange") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRange);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsIslandEntrance") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsIslandEntrance);
	p_Stream << "}";

	p_Stream << "}";
}

void ZSniperCombatSituation_SSniperSuspiciousArea::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsIslandEntrance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsIslandEntrance);

	p_Stream << "}";
}

void ZSniperCombatSituation_SSniperSuspiciousArea::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSniperCombatSituation_SSniperSuspiciousArea s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	s_Object.m_fRange = simdjson::from_json_float32(p_Document["m_fRange"]);

	s_Object.m_bIsIslandEntrance = simdjson::from_json_bool(p_Document["m_bIsIslandEntrance"]);

	*reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Target) = s_Object;
}

void ZSniperCombatSituation_SSniperSuspiciousArea::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSniperSuspiciousArea, m_vPosition));
}

bool ZSniperCombatSituation_SSniperSuspiciousArea::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSniperCombatSituation_SSniperSuspiciousArea::operator==(const ZSniperCombatSituation_SSniperSuspiciousArea& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSniperCombatSituation_SSniperSuspiciousArea>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_fRange != p_Other.m_fRange) return false;
	if (m_bIsIslandEntrance != p_Other.m_bIsIslandEntrance) return false;

	return true;
}

ZHMTypeInfo ZSniperCombatSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZSniperCombatSituation.SSituationSaveData", sizeof(ZSniperCombatSituation_SSituationSaveData), alignof(ZSniperCombatSituation_SSituationSaveData), ZSniperCombatSituation_SSituationSaveData::WriteJson, ZSniperCombatSituation_SSituationSaveData::WriteSimpleJson, ZSniperCombatSituation_SSituationSaveData::FromSimpleJson, ZSniperCombatSituation_SSituationSaveData::Serialize, ZSniperCombatSituation_SSituationSaveData::Equals);

void ZSniperCombatSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_rSniperLocation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSniperLocation);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSniperCombatGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSniperCombatGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSniperCombatGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aSniperCombatGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAggressive") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAggressive);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKiller") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKiller);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rIsland") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rIsland);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSuspiciousAreas") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZSniperCombatSituation.SSniperSuspiciousArea>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSuspiciousAreas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSuspiciousAreas[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZSniperCombatSituation.SSniperSuspiciousArea") << ",\"$val\":";
		ZSniperCombatSituation_SSniperSuspiciousArea::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->m_aSuspiciousAreas.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingGuards") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingGuards[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aWaitingGuards.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFleeCandidates") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFleeCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFleeCandidates[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aFleeCandidates.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasFailed") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasFailed);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZSniperCombatSituation.ESituationState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSniperCombatSituation.ESituationState", static_cast<int>(s_Object->m_eState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGuards") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGuards);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZSniperCombatSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSniperLocation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSniperLocation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSniperCombatGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSniperCombatGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSniperCombatGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSniperCombatGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAggressive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAggressive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKiller") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKiller);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rIsland") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rIsland);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSuspiciousAreas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSuspiciousAreas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSuspiciousAreas[i];
		ZSniperCombatSituation_SSniperSuspiciousArea::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSuspiciousAreas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aWaitingGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFleeCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFleeCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFleeCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFleeCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSniperCombatSituation.ESituationState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGuards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGuards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSniperCombatSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSniperCombatSituation_SSituationSaveData s_Object {};

	s_Object.m_rSniperLocation = simdjson::from_json_uint32(p_Document["m_rSniperLocation"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSniperCombatGroups"])
	{
		s_Object.m_aSniperCombatGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	s_Object.m_bAggressive = simdjson::from_json_bool(p_Document["m_bAggressive"]);

	s_Object.m_bKiller = simdjson::from_json_bool(p_Document["m_bKiller"]);

	s_Object.m_rIsland = simdjson::from_json_uint32(p_Document["m_rIsland"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSuspiciousAreas"])
	{
		ZSniperCombatSituation_SSniperSuspiciousArea s_ArrayItem0;
		ZSniperCombatSituation_SSniperSuspiciousArea::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSuspiciousAreas.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aWaitingGuards"])
	{
		s_Object.m_aWaitingGuards.push_back(simdjson::from_json_uint32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aFleeCandidates"])
	{
		s_Object.m_aFleeCandidates.push_back(simdjson::from_json_uint32(s_Item0));
	}

	s_Object.m_bHasFailed = simdjson::from_json_bool(p_Document["m_bHasFailed"]);

	s_Object.m_eState = static_cast<ZSniperCombatSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZSniperCombatSituation.ESituationState", std::string_view(p_Document["m_eState"])));

	s_Object.m_nGuards = simdjson::from_json_uint32(p_Document["m_nGuards"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAvoidDangerGroups"])
	{
		s_Object.m_aAvoidDangerGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	*reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZSniperCombatSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aSniperCombatGroups, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aSniperCombatGroups));
	TArray<ZSniperCombatSituation_SSniperSuspiciousArea>::Serialize(&s_Object->m_aSuspiciousAreas, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aSuspiciousAreas));
	TArray<uint32>::Serialize(&s_Object->m_aWaitingGuards, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aWaitingGuards));
	TArray<uint32>::Serialize(&s_Object->m_aFleeCandidates, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aFleeCandidates));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aAvoidDangerGroups));
}

bool ZSniperCombatSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSniperCombatSituation_SSituationSaveData::operator==(const ZSniperCombatSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSniperCombatSituation_SSituationSaveData>)
		return false;

	if (m_rSniperLocation != p_Other.m_rSniperLocation) return false;
	if (m_aSniperCombatGroups != p_Other.m_aSniperCombatGroups) return false;
	if (m_bAggressive != p_Other.m_bAggressive) return false;
	if (m_bKiller != p_Other.m_bKiller) return false;
	if (m_rIsland != p_Other.m_rIsland) return false;
	if (m_aSuspiciousAreas != p_Other.m_aSuspiciousAreas) return false;
	if (m_aWaitingGuards != p_Other.m_aWaitingGuards) return false;
	if (m_aFleeCandidates != p_Other.m_aFleeCandidates) return false;
	if (m_bHasFailed != p_Other.m_bHasFailed) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_nGuards != p_Other.m_nGuards) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;

	return true;
}

ZHMTypeInfo ZSoundCollisionInfo::TypeInfo = ZHMTypeInfo("ZSoundCollisionInfo", sizeof(ZSoundCollisionInfo), alignof(ZSoundCollisionInfo), ZSoundCollisionInfo::WriteJson, ZSoundCollisionInfo::WriteSimpleJson, ZSoundCollisionInfo::FromSimpleJson, ZSoundCollisionInfo::Serialize, ZSoundCollisionInfo::Equals);

void ZSoundCollisionInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZSoundCollisionInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSoundCollisionInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSoundCollisionInfo s_Object {};

	*reinterpret_cast<ZSoundCollisionInfo*>(p_Target) = s_Object;
}

void ZSoundCollisionInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);

}

bool ZSoundCollisionInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSoundCollisionInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSoundCollisionInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSoundCollisionInfo::operator==(const ZSoundCollisionInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSoundCollisionInfo>)
		return false;


	return true;
}

ZHMTypeInfo ZSpeakerLevels::TypeInfo = ZHMTypeInfo("ZSpeakerLevels", sizeof(ZSpeakerLevels), alignof(ZSpeakerLevels), ZSpeakerLevels::WriteJson, ZSpeakerLevels::WriteSimpleJson, ZSpeakerLevels::FromSimpleJson, ZSpeakerLevels::Serialize, ZSpeakerLevels::Equals);

void ZSpeakerLevels::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_aSpeakerMatrix") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<float32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpeakerMatrix.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpeakerMatrix[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aSpeakerMatrix.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZSpeakerLevels::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSpeakerMatrix") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpeakerMatrix.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpeakerMatrix[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSpeakerMatrix.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSpeakerLevels::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSpeakerLevels s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aSpeakerMatrix"])
	{
		s_Object.m_aSpeakerMatrix.push_back(simdjson::from_json_float32(s_Item0));
	}

	*reinterpret_cast<ZSpeakerLevels*>(p_Target) = s_Object;
}

void ZSpeakerLevels::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);

	TArray<float32>::Serialize(&s_Object->m_aSpeakerMatrix, p_Serializer, p_OwnOffset + offsetof(ZSpeakerLevels, m_aSpeakerMatrix));
}

bool ZSpeakerLevels::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSpeakerLevels*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSpeakerLevels*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSpeakerLevels::operator==(const ZSpeakerLevels& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSpeakerLevels>)
		return false;

	if (m_aSpeakerMatrix != p_Other.m_aSpeakerMatrix) return false;

	return true;
}

ZHMTypeInfo ZSpectatorSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZSpectatorSituation.SSituationSaveData", sizeof(ZSpectatorSituation_SSituationSaveData), alignof(ZSpectatorSituation_SSituationSaveData), ZSpectatorSituation_SSituationSaveData::WriteJson, ZSpectatorSituation_SSituationSaveData::WriteSimpleJson, ZSpectatorSituation_SSituationSaveData::FromSimpleJson, ZSpectatorSituation_SSituationSaveData::Serialize, ZSpectatorSituation_SSituationSaveData::Equals);

void ZSpectatorSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_bStandingDown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandingDown);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aObserverGroupIDs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aObserverGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aObserverGroupIDs[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aObserverGroupIDs.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aNonObserverMembers") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<uint32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aNonObserverMembers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aNonObserverMembers[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aNonObserverMembers.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZSpectatorSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStandingDown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandingDown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aObserverGroupIDs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aObserverGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aObserverGroupIDs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aObserverGroupIDs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aNonObserverMembers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aNonObserverMembers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aNonObserverMembers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aNonObserverMembers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSpectatorSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSpectatorSituation_SSituationSaveData s_Object {};

	s_Object.m_bStandingDown = simdjson::from_json_bool(p_Document["m_bStandingDown"]);

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aObserverGroupIDs"])
	{
		s_Object.m_aObserverGroupIDs.push_back(simdjson::from_json_int32(s_Item0));
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aNonObserverMembers"])
	{
		s_Object.m_aNonObserverMembers.push_back(simdjson::from_json_uint32(s_Item0));
	}

	*reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZSpectatorSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aObserverGroupIDs, p_Serializer, p_OwnOffset + offsetof(ZSpectatorSituation_SSituationSaveData, m_aObserverGroupIDs));
	TArray<uint32>::Serialize(&s_Object->m_aNonObserverMembers, p_Serializer, p_OwnOffset + offsetof(ZSpectatorSituation_SSituationSaveData, m_aNonObserverMembers));
}

bool ZSpectatorSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSpectatorSituation_SSituationSaveData::operator==(const ZSpectatorSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSpectatorSituation_SSituationSaveData>)
		return false;

	if (m_bStandingDown != p_Other.m_bStandingDown) return false;
	if (m_aObserverGroupIDs != p_Other.m_aObserverGroupIDs) return false;
	if (m_aNonObserverMembers != p_Other.m_aNonObserverMembers) return false;

	return true;
}

ZHMTypeInfo ZStandOffSituation_SState::TypeInfo = ZHMTypeInfo("ZStandOffSituation.SState", sizeof(ZStandOffSituation_SState), alignof(ZStandOffSituation_SState), ZStandOffSituation_SState::WriteJson, ZStandOffSituation_SState::WriteSimpleJson, ZStandOffSituation_SState::FromSimpleJson, ZStandOffSituation_SState::Serialize, ZStandOffSituation_SState::Equals);

void ZStandOffSituation_SState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZStandOffSituation.ESituationState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSituationState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZStandOffSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eArrestReason") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("EDisturbanceType") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eArrestReason)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eArrestReason))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningPriority") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningPriority);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nResetCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nResetCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bArrestReasonStated") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bArrestReasonStated);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetOnStairs") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetOnStairs);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateApproachPositions") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateApproachPositions);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHelpOrderAssigned") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHelpOrderAssigned);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCivilianTransferredKnowledge") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCivilianTransferredKnowledge);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetLost") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetLost);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGetHelpGroupStarted") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGetHelpGroupStarted);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastKnownPosition") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vLastKnownPosition, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMovingTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMovingTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRunningTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRunningTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEquippedWeaponTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEquippedWeaponTime);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarning3Given") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarning3Given);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mainStateStartTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_mainStateStartTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeTargetLOS") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastTimeTargetLOS, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeGuardHadLOS") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastTimeGuardHadLOS, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNextCivBark") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tNextCivBark, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartSearchCountdown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStartSearchCountdown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDialogState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZStandOffSituation.EDialogState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eDialogState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZStandOffSituation.EDialogState", static_cast<int>(s_Object->m_eDialogState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopWarningGiven") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopWarningGiven);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_reportedTarget") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_reportedTarget);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggeredBySecurityCameras") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggeredBySecurityCameras);
	p_Stream << "}";

	p_Stream << "}";
}

void ZStandOffSituation_SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZStandOffSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningPriority") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningPriority);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nResetCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nResetCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bArrestReasonStated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bArrestReasonStated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetOnStairs") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetOnStairs);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateApproachPositions") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateApproachPositions);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHelpOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHelpOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCivilianTransferredKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCivilianTransferredKnowledge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetLost") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetLost);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGetHelpGroupStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGetHelpGroupStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastKnownPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vLastKnownPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEquippedWeaponTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEquippedWeaponTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarning3Given") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarning3Given);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mainStateStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_mainStateStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeTargetLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeTargetLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeGuardHadLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeGuardHadLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNextCivBark") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNextCivBark, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartSearchCountdown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartSearchCountdown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDialogState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZStandOffSituation.EDialogState", static_cast<int>(s_Object->m_eDialogState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopWarningGiven") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopWarningGiven);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_reportedTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_reportedTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggeredBySecurityCameras") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggeredBySecurityCameras);

	p_Stream << "}";
}

void ZStandOffSituation_SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZStandOffSituation_SState s_Object {};

	s_Object.m_eSituationState = static_cast<ZStandOffSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZStandOffSituation.ESituationState", std::string_view(p_Document["m_eSituationState"])));

	s_Object.m_eArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eArrestReason"])));

	s_Object.m_nWarningPriority = simdjson::from_json_uint32(p_Document["m_nWarningPriority"]);

	s_Object.m_nResetCount = simdjson::from_json_int32(p_Document["m_nResetCount"]);

	s_Object.m_bArrestReasonStated = simdjson::from_json_bool(p_Document["m_bArrestReasonStated"]);

	s_Object.m_bTargetOnStairs = simdjson::from_json_bool(p_Document["m_bTargetOnStairs"]);

	s_Object.m_bUpdateApproachPositions = simdjson::from_json_bool(p_Document["m_bUpdateApproachPositions"]);

	s_Object.m_bHelpOrderAssigned = simdjson::from_json_bool(p_Document["m_bHelpOrderAssigned"]);

	s_Object.m_bCivilianTransferredKnowledge = simdjson::from_json_bool(p_Document["m_bCivilianTransferredKnowledge"]);

	s_Object.m_bTargetLost = simdjson::from_json_bool(p_Document["m_bTargetLost"]);

	s_Object.m_bGetHelpGroupStarted = simdjson::from_json_bool(p_Document["m_bGetHelpGroupStarted"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vLastKnownPosition"], &s_Item);
		s_Object.m_vLastKnownPosition = s_Item;
	}

	s_Object.m_fMovingTime = simdjson::from_json_float32(p_Document["m_fMovingTime"]);

	s_Object.m_fRunningTime = simdjson::from_json_float32(p_Document["m_fRunningTime"]);

	s_Object.m_fEquippedWeaponTime = simdjson::from_json_float32(p_Document["m_fEquippedWeaponTime"]);

	s_Object.m_bWarning3Given = simdjson::from_json_bool(p_Document["m_bWarning3Given"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_mainStateStartTime"], &s_Item);
		s_Object.m_mainStateStartTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTimeTargetLOS"], &s_Item);
		s_Object.m_tLastTimeTargetLOS = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTimeGuardHadLOS"], &s_Item);
		s_Object.m_tLastTimeGuardHadLOS = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tNextCivBark"], &s_Item);
		s_Object.m_tNextCivBark = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStartSearchCountdown"], &s_Item);
		s_Object.m_tStartSearchCountdown = s_Item;
	}

	s_Object.m_eDialogState = static_cast<ZStandOffSituation_EDialogState>(ZHMEnums::GetEnumValueByName("ZStandOffSituation.EDialogState", std::string_view(p_Document["m_eDialogState"])));

	s_Object.m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	s_Object.m_bStopWarningGiven = simdjson::from_json_bool(p_Document["m_bStopWarningGiven"]);

	s_Object.m_reportedTarget = simdjson::from_json_bool(p_Document["m_reportedTarget"]);

	s_Object.m_bTriggeredBySecurityCameras = simdjson::from_json_bool(p_Document["m_bTriggeredBySecurityCameras"]);

	*reinterpret_cast<ZStandOffSituation_SState*>(p_Target) = s_Object;
}

void ZStandOffSituation_SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SState*>(p_Object);

	float4::Serialize(&s_Object->m_vLastKnownPosition, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_vLastKnownPosition));
	ZGameTime::Serialize(&s_Object->m_mainStateStartTime, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_mainStateStartTime));
	ZGameTime::Serialize(&s_Object->m_tLastTimeTargetLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_tLastTimeTargetLOS));
	ZGameTime::Serialize(&s_Object->m_tLastTimeGuardHadLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_tLastTimeGuardHadLOS));
	ZGameTime::Serialize(&s_Object->m_tNextCivBark, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_tNextCivBark));
	ZGameTime::Serialize(&s_Object->m_tStartSearchCountdown, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_tStartSearchCountdown));
}

bool ZStandOffSituation_SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZStandOffSituation_SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZStandOffSituation_SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZStandOffSituation_SState::operator==(const ZStandOffSituation_SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZStandOffSituation_SState>)
		return false;

	if (m_eSituationState != p_Other.m_eSituationState) return false;
	if (m_eArrestReason != p_Other.m_eArrestReason) return false;
	if (m_nWarningPriority != p_Other.m_nWarningPriority) return false;
	if (m_nResetCount != p_Other.m_nResetCount) return false;
	if (m_bArrestReasonStated != p_Other.m_bArrestReasonStated) return false;
	if (m_bTargetOnStairs != p_Other.m_bTargetOnStairs) return false;
	if (m_bUpdateApproachPositions != p_Other.m_bUpdateApproachPositions) return false;
	if (m_bHelpOrderAssigned != p_Other.m_bHelpOrderAssigned) return false;
	if (m_bCivilianTransferredKnowledge != p_Other.m_bCivilianTransferredKnowledge) return false;
	if (m_bTargetLost != p_Other.m_bTargetLost) return false;
	if (m_bGetHelpGroupStarted != p_Other.m_bGetHelpGroupStarted) return false;
	if (m_vLastKnownPosition != p_Other.m_vLastKnownPosition) return false;
	if (m_fMovingTime != p_Other.m_fMovingTime) return false;
	if (m_fRunningTime != p_Other.m_fRunningTime) return false;
	if (m_fEquippedWeaponTime != p_Other.m_fEquippedWeaponTime) return false;
	if (m_bWarning3Given != p_Other.m_bWarning3Given) return false;
	if (m_mainStateStartTime != p_Other.m_mainStateStartTime) return false;
	if (m_tLastTimeTargetLOS != p_Other.m_tLastTimeTargetLOS) return false;
	if (m_tLastTimeGuardHadLOS != p_Other.m_tLastTimeGuardHadLOS) return false;
	if (m_tNextCivBark != p_Other.m_tNextCivBark) return false;
	if (m_tStartSearchCountdown != p_Other.m_tStartSearchCountdown) return false;
	if (m_eDialogState != p_Other.m_eDialogState) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_bStopWarningGiven != p_Other.m_bStopWarningGiven) return false;
	if (m_reportedTarget != p_Other.m_reportedTarget) return false;
	if (m_bTriggeredBySecurityCameras != p_Other.m_bTriggeredBySecurityCameras) return false;

	return true;
}

ZHMTypeInfo ZStandOffSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZStandOffSituation.SSituationSaveData", sizeof(ZStandOffSituation_SSituationSaveData), alignof(ZStandOffSituation_SSituationSaveData), ZStandOffSituation_SSituationSaveData::WriteJson, ZStandOffSituation_SSituationSaveData::WriteSimpleJson, ZStandOffSituation_SSituationSaveData::FromSimpleJson, ZStandOffSituation_SSituationSaveData::Serialize, ZStandOffSituation_SSituationSaveData::Equals);

void ZStandOffSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_State") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZStandOffSituation.SState") << ",\"$val\":";
	ZStandOffSituation_SState::WriteJson(&s_Object->m_State, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pArrestor") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pArrestor);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pSpeaker") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pSpeaker);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rIsland") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rIsland);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeTargetLOS") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastTimeTargetLOS, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<int32>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
		p_Stream << simdjson::as_json_string(s_Item0);
		p_Stream << "}";

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";

	p_Stream << "}";
}

void ZStandOffSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZStandOffSituation_SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pArrestor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pArrestor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pSpeaker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pSpeaker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rIsland") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rIsland);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeTargetLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeTargetLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZStandOffSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZStandOffSituation_SSituationSaveData s_Object {};

	{
		ZStandOffSituation_SState s_Item {};
		ZStandOffSituation_SState::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	s_Object.m_pArrestor = simdjson::from_json_uint32(p_Document["m_pArrestor"]);

	s_Object.m_pSpeaker = simdjson::from_json_uint32(p_Document["m_pSpeaker"]);

	s_Object.m_pGetHelpGroup = simdjson::from_json_int32(p_Document["m_pGetHelpGroup"]);

	s_Object.m_rIsland = simdjson::from_json_uint32(p_Document["m_rIsland"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTimeTargetLOS"], &s_Item);
		s_Object.m_tLastTimeTargetLOS = s_Item;
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["m_aAvoidDangerGroups"])
	{
		s_Object.m_aAvoidDangerGroups.push_back(simdjson::from_json_int32(s_Item0));
	}

	*reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZStandOffSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Object);

	ZStandOffSituation_SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SSituationSaveData, m_State));
	ZGameTime::Serialize(&s_Object->m_tLastTimeTargetLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SSituationSaveData, m_tLastTimeTargetLOS));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SSituationSaveData, m_aAvoidDangerGroups));
}

bool ZStandOffSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZStandOffSituation_SSituationSaveData::operator==(const ZStandOffSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZStandOffSituation_SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_pArrestor != p_Other.m_pArrestor) return false;
	if (m_pSpeaker != p_Other.m_pSpeaker) return false;
	if (m_pGetHelpGroup != p_Other.m_pGetHelpGroup) return false;
	if (m_rIsland != p_Other.m_rIsland) return false;
	if (m_tLastTimeTargetLOS != p_Other.m_tLastTimeTargetLOS) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;

	return true;
}

ZHMTypeInfo ZTime::TypeInfo = ZHMTypeInfo("ZTime", sizeof(ZTime), alignof(ZTime), ZTime::WriteJson, ZTime::WriteSimpleJson, ZTime::FromSimpleJson, ZTime::Serialize, ZTime::Equals);

void ZTime::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_nValue") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint64") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nValue);
	p_Stream << "}";

	p_Stream << "}";
}

void ZTime::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nValue);

	p_Stream << "}";
}

void ZTime::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZTime s_Object {};

	s_Object.m_nValue = simdjson::from_json_uint64(p_Document["m_nValue"]);

	*reinterpret_cast<ZTime*>(p_Target) = s_Object;
}

void ZTime::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

}

bool ZTime::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTime*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTime*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTime::operator==(const ZTime& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTime>)
		return false;

	if (m_nValue != p_Other.m_nValue) return false;

	return true;
}

ZHMTypeInfo ZTrespassingSituation_SState::TypeInfo = ZHMTypeInfo("ZTrespassingSituation.SState", sizeof(ZTrespassingSituation_SState), alignof(ZTrespassingSituation_SState), ZTrespassingSituation_SState::WriteJson, ZTrespassingSituation_SState::WriteSimpleJson, ZTrespassingSituation_SState::FromSimpleJson, ZTrespassingSituation_SState::Serialize, ZTrespassingSituation_SState::Equals);

void ZTrespassingSituation_SState::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SState*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZTrespassingSituation.ESituationState") << ",\"$val\":";
	p_Stream << "{\"$enumVal\":" << simdjson::as_json_string(static_cast<int64_t>(s_Object->m_eSituationState)) << ",\"$enumValName\":" << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZTrespassingSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState))) << "}";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tDeepTrespassingTime") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tDeepTrespassingTime, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartStandDown") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tStartStandDown, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTargetVisible") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZGameTime") << ",\"$val\":";
	ZGameTime::WriteJson(&s_Object->m_tLastTargetVisible, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopWarningGiven") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopWarningGiven);
	p_Stream << "}";

	p_Stream << "}";
}

void ZTrespassingSituation_SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZTrespassingSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tDeepTrespassingTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tDeepTrespassingTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTargetVisible") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTargetVisible, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopWarningGiven") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopWarningGiven);

	p_Stream << "}";
}

void ZTrespassingSituation_SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZTrespassingSituation_SState s_Object {};

	s_Object.m_eSituationState = static_cast<ZTrespassingSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZTrespassingSituation.ESituationState", std::string_view(p_Document["m_eSituationState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tDeepTrespassingTime"], &s_Item);
		s_Object.m_tDeepTrespassingTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStartStandDown"], &s_Item);
		s_Object.m_tStartStandDown = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTargetVisible"], &s_Item);
		s_Object.m_tLastTargetVisible = s_Item;
	}

	s_Object.m_bStopWarningGiven = simdjson::from_json_bool(p_Document["m_bStopWarningGiven"]);

	*reinterpret_cast<ZTrespassingSituation_SState*>(p_Target) = s_Object;
}

void ZTrespassingSituation_SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tDeepTrespassingTime, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SState, m_tDeepTrespassingTime));
	ZGameTime::Serialize(&s_Object->m_tStartStandDown, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SState, m_tStartStandDown));
	ZGameTime::Serialize(&s_Object->m_tLastTargetVisible, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SState, m_tLastTargetVisible));
}

bool ZTrespassingSituation_SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTrespassingSituation_SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTrespassingSituation_SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTrespassingSituation_SState::operator==(const ZTrespassingSituation_SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTrespassingSituation_SState>)
		return false;

	if (m_eSituationState != p_Other.m_eSituationState) return false;
	if (m_tDeepTrespassingTime != p_Other.m_tDeepTrespassingTime) return false;
	if (m_tStartStandDown != p_Other.m_tStartStandDown) return false;
	if (m_tLastTargetVisible != p_Other.m_tLastTargetVisible) return false;
	if (m_bStopWarningGiven != p_Other.m_bStopWarningGiven) return false;

	return true;
}

ZHMTypeInfo ZTrespassingSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZTrespassingSituation.SSituationSaveData", sizeof(ZTrespassingSituation_SSituationSaveData), alignof(ZTrespassingSituation_SSituationSaveData), ZTrespassingSituation_SSituationSaveData::WriteJson, ZTrespassingSituation_SSituationSaveData::WriteSimpleJson, ZTrespassingSituation_SSituationSaveData::FromSimpleJson, ZTrespassingSituation_SSituationSaveData::Serialize, ZTrespassingSituation_SSituationSaveData::Equals);

void ZTrespassingSituation_SSituationSaveData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("m_State") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZTrespassingSituation.SState") << ",\"$val\":";
	ZTrespassingSituation_SState::WriteJson(&s_Object->m_State, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEscortingMember") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEscortingMember);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHelpingGuardMember") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("uint32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHelpingGuardMember);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vEscortOutExitLocation") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("float4") << ",\"$val\":";
	float4::WriteJson(&s_Object->m_vEscortOutExitLocation, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGetHelpGroup") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGetHelpGroup);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPropagationEnabled") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPropagationEnabled);
	p_Stream << "}";

	p_Stream << "}";
}

void ZTrespassingSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZTrespassingSituation_SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEscortingMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEscortingMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHelpingGuardMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHelpingGuardMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vEscortOutExitLocation") << ":";
	float4::WriteSimpleJson(&s_Object->m_vEscortOutExitLocation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPropagationEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPropagationEnabled);

	p_Stream << "}";
}

void ZTrespassingSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZTrespassingSituation_SSituationSaveData s_Object {};

	{
		ZTrespassingSituation_SState s_Item {};
		ZTrespassingSituation_SState::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	s_Object.m_rEscortingMember = simdjson::from_json_uint32(p_Document["m_rEscortingMember"]);

	s_Object.m_rHelpingGuardMember = simdjson::from_json_uint32(p_Document["m_rHelpingGuardMember"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vEscortOutExitLocation"], &s_Item);
		s_Object.m_vEscortOutExitLocation = s_Item;
	}

	s_Object.m_nGetHelpGroup = simdjson::from_json_int32(p_Document["m_nGetHelpGroup"]);

	s_Object.m_bPropagationEnabled = simdjson::from_json_bool(p_Document["m_bPropagationEnabled"]);

	*reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZTrespassingSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Object);

	ZTrespassingSituation_SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SSituationSaveData, m_State));
	float4::Serialize(&s_Object->m_vEscortOutExitLocation, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SSituationSaveData, m_vEscortOutExitLocation));
}

bool ZTrespassingSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTrespassingSituation_SSituationSaveData::operator==(const ZTrespassingSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTrespassingSituation_SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_rEscortingMember != p_Other.m_rEscortingMember) return false;
	if (m_rHelpingGuardMember != p_Other.m_rHelpingGuardMember) return false;
	if (m_vEscortOutExitLocation != p_Other.m_vEscortOutExitLocation) return false;
	if (m_nGetHelpGroup != p_Other.m_nGetHelpGroup) return false;
	if (m_bPropagationEnabled != p_Other.m_bPropagationEnabled) return false;

	return true;
}

ZHMTypeInfo ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::TypeInfo = ZHMTypeInfo("ZUIActionSelectorNavigationInventoryEntity.SActionSelectorSlotDisplayInfo", sizeof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo), alignof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo), ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Serialize, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Equals);

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->icon, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedIcon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRuntimeResourceID") << ",\"$val\":";
	ZRuntimeResourceID::WriteJson(&s_Object->containedIcon, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedLabel") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->containedLabel);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("silencer") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->silencer);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("count") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->count);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ammo") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->ammo);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("id") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZRepositoryID") << ",\"$val\":";
	ZRepositoryID::WriteJson(&s_Object->id, p_Stream);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("weaponCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->weaponCategory);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategory);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategoryLKey") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategoryLKey);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inventoryCategoryIcon") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->inventoryCategoryIcon);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("notininventory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->notininventory);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isIllegal") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->isIllegal);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("actionName") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->actionName);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("longDescription") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->longDescription);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("missingText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->missingText);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("warningText") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("ZString") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->warningText);
	p_Stream << "}";

	p_Stream << "}";
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedIcon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->containedIcon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->containedLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("silencer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->silencer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("count") << ":";
	p_Stream << simdjson::as_json_string(s_Object->count);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ammo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ammo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("id") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("weaponCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->weaponCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategoryLKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategoryLKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inventoryCategoryIcon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->inventoryCategoryIcon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("notininventory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->notininventory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("actionName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->actionName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("longDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->longDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("missingText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->missingText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("warningText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->warningText);

	p_Stream << "}";
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["containedIcon"], &s_Item);
		s_Object.containedIcon = s_Item;
	}

	s_Object.label = std::string_view(p_Document["label"]);

	s_Object.containedLabel = std::string_view(p_Document["containedLabel"]);

	s_Object.silencer = simdjson::from_json_bool(p_Document["silencer"]);

	s_Object.count = simdjson::from_json_int32(p_Document["count"]);

	s_Object.ammo = simdjson::from_json_int32(p_Document["ammo"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["id"], &s_Item);
		s_Object.id = s_Item;
	}

	s_Object.weaponCategory = std::string_view(p_Document["weaponCategory"]);

	s_Object.nAmmoRemaining = simdjson::from_json_int32(p_Document["nAmmoRemaining"]);

	s_Object.nAmmoTotal = simdjson::from_json_int32(p_Document["nAmmoTotal"]);

	s_Object.nAmmoInClip = simdjson::from_json_int32(p_Document["nAmmoInClip"]);

	s_Object.nWeaponType = simdjson::from_json_int32(p_Document["nWeaponType"]);

	s_Object.itemCategory = std::string_view(p_Document["itemCategory"]);

	s_Object.itemCategoryLKey = std::string_view(p_Document["itemCategoryLKey"]);

	s_Object.inventoryCategoryIcon = std::string_view(p_Document["inventoryCategoryIcon"]);

	s_Object.notininventory = simdjson::from_json_bool(p_Document["notininventory"]);

	s_Object.isIllegal = simdjson::from_json_bool(p_Document["isIllegal"]);

	s_Object.actionName = std::string_view(p_Document["actionName"]);

	s_Object.longDescription = std::string_view(p_Document["longDescription"]);

	s_Object.missingText = std::string_view(p_Document["missingText"]);

	s_Object.warningText = std::string_view(p_Document["warningText"]);

	*reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Target) = s_Object;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, icon));
	ZRuntimeResourceID::Serialize(&s_Object->containedIcon, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, containedIcon));
	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, label));
	ZString::Serialize(&s_Object->containedLabel, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, containedLabel));
	ZRepositoryID::Serialize(&s_Object->id, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, id));
	ZString::Serialize(&s_Object->weaponCategory, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, weaponCategory));
	ZString::Serialize(&s_Object->itemCategory, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, itemCategory));
	ZString::Serialize(&s_Object->itemCategoryLKey, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, itemCategoryLKey));
	ZString::Serialize(&s_Object->inventoryCategoryIcon, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, inventoryCategoryIcon));
	ZString::Serialize(&s_Object->actionName, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, actionName));
	ZString::Serialize(&s_Object->longDescription, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, longDescription));
	ZString::Serialize(&s_Object->missingText, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, missingText));
	ZString::Serialize(&s_Object->warningText, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, warningText));
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::operator==(const ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo>)
		return false;

	if (icon != p_Other.icon) return false;
	if (containedIcon != p_Other.containedIcon) return false;
	if (label != p_Other.label) return false;
	if (containedLabel != p_Other.containedLabel) return false;
	if (silencer != p_Other.silencer) return false;
	if (count != p_Other.count) return false;
	if (ammo != p_Other.ammo) return false;
	if (id != p_Other.id) return false;
	if (weaponCategory != p_Other.weaponCategory) return false;
	if (nAmmoRemaining != p_Other.nAmmoRemaining) return false;
	if (nAmmoTotal != p_Other.nAmmoTotal) return false;
	if (nAmmoInClip != p_Other.nAmmoInClip) return false;
	if (nWeaponType != p_Other.nWeaponType) return false;
	if (itemCategory != p_Other.itemCategory) return false;
	if (itemCategoryLKey != p_Other.itemCategoryLKey) return false;
	if (inventoryCategoryIcon != p_Other.inventoryCategoryIcon) return false;
	if (notininventory != p_Other.notininventory) return false;
	if (isIllegal != p_Other.isIllegal) return false;
	if (actionName != p_Other.actionName) return false;
	if (longDescription != p_Other.longDescription) return false;
	if (missingText != p_Other.missingText) return false;
	if (warningText != p_Other.warningText) return false;

	return true;
}

ZHMTypeInfo ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::TypeInfo = ZHMTypeInfo("ZUIActionSelectorNavigationInventoryEntity.SActionSelectorInvokeData", sizeof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData), alignof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData), ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::WriteJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::WriteSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::FromSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Serialize, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Equals);

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Object);

	p_Stream << "{";
	p_Stream << simdjson::as_json_string("mainslots") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZUIActionSelectorNavigationInventoryEntity.SActionSelectorSlotDisplayInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslots[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZUIActionSelectorNavigationInventoryEntity.SActionSelectorSlotDisplayInfo") << ",\"$val\":";
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->mainslots.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslots") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("TArray<ZUIActionSelectorNavigationInventoryEntity.SActionSelectorSlotDisplayInfo>") << ",\"$val\":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->otherslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->otherslots[i];
		p_Stream << "{\"$type\":" << simdjson::as_json_string("ZUIActionSelectorNavigationInventoryEntity.SActionSelectorSlotDisplayInfo") << ",\"$val\":";
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteJson(&s_Item0, p_Stream);
		p_Stream << "}";

		if (i < s_Object->otherslots.size() - 1)
			p_Stream << ",";
	}
	p_Stream << "]";
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selectedIndex") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("int32") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->selectedIndex);
	p_Stream << "}";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isActionInventory") << ":";
	p_Stream << "{\"$type\":" << simdjson::as_json_string("bool") << ",\"$val\":";
	p_Stream << simdjson::as_json_string(s_Object->isActionInventory);
	p_Stream << "}";

	p_Stream << "}";
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mainslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslots[i];
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->mainslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->otherslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->otherslots[i];
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->otherslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selectedIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->selectedIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isActionInventory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isActionInventory);

	p_Stream << "}";
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData s_Object {};

	for (simdjson::ondemand::value s_Item0 : p_Document["mainslots"])
	{
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo s_ArrayItem0;
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.mainslots.push_back(s_ArrayItem0);
	}

	for (simdjson::ondemand::value s_Item0 : p_Document["otherslots"])
	{
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo s_ArrayItem0;
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.otherslots.push_back(s_ArrayItem0);
	}

	s_Object.selectedIndex = simdjson::from_json_int32(p_Document["selectedIndex"]);

	s_Object.isActionInventory = simdjson::from_json_bool(p_Document["isActionInventory"]);

	*reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Target) = s_Object;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Object);

	TArray<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo>::Serialize(&s_Object->mainslots, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData, mainslots));
	TArray<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo>::Serialize(&s_Object->otherslots, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData, otherslots));
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::operator==(const ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData>)
		return false;

	if (mainslots != p_Other.mainslots) return false;
	if (otherslots != p_Other.otherslots) return false;
	if (selectedIndex != p_Other.selectedIndex) return false;
	if (isActionInventory != p_Other.isActionInventory) return false;

	return true;
}

ZHMTypeInfo ZUIDataProvider::TypeInfo = ZHMTypeInfo("ZUIDataProvider", sizeof(ZUIDataProvider), alignof(ZUIDataProvider), ZUIDataProvider::WriteJson, ZUIDataProvider::WriteSimpleJson, ZUIDataProvider::FromSimpleJson, ZUIDataProvider::Serialize, ZUIDataProvider::Equals);

void ZUIDataProvider::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZUIDataProvider::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZUIDataProvider::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIDataProvider s_Object {};

	*reinterpret_cast<ZUIDataProvider*>(p_Target) = s_Object;
}

void ZUIDataProvider::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);

}

bool ZUIDataProvider::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIDataProvider*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIDataProvider*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIDataProvider::operator==(const ZUIDataProvider& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIDataProvider>)
		return false;


	return true;
}

ZHMTypeInfo ZWorldMapMetaData::TypeInfo = ZHMTypeInfo("ZWorldMapMetaData", sizeof(ZWorldMapMetaData), alignof(ZWorldMapMetaData), ZWorldMapMetaData::WriteJson, ZWorldMapMetaData::WriteSimpleJson, ZWorldMapMetaData::FromSimpleJson, ZWorldMapMetaData::Serialize, ZWorldMapMetaData::Equals);

void ZWorldMapMetaData::WriteJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);

	p_Stream << "{";
	p_Stream << "}";
}

void ZWorldMapMetaData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZWorldMapMetaData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZWorldMapMetaData s_Object {};

	*reinterpret_cast<ZWorldMapMetaData*>(p_Target) = s_Object;
}

void ZWorldMapMetaData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);

}

bool ZWorldMapMetaData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZWorldMapMetaData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZWorldMapMetaData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZWorldMapMetaData::operator==(const ZWorldMapMetaData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZWorldMapMetaData>)
		return false;


	return true;
}

