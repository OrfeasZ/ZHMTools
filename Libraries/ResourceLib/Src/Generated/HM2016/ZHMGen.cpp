/*
 * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing.
 *
 * If you wish to regenerate this file because of a game update use the ZHMTools CodeGen tool:
 * https://github.com/OrfeasZ/ZHMTools/releases
 */

#include "ZHMGen.h"
#include "ZHMProperties.h"
#include "ZHMEnums.h"
#include <External/simdjson_helpers.h>
#include <utility>

ZHMTypeInfo AnimationEventDataTypes::SBlend::TypeInfo = ZHMTypeInfo("AnimationEventDataTypes.SBlend", sizeof(AnimationEventDataTypes::SBlend), alignof(AnimationEventDataTypes::SBlend), AnimationEventDataTypes::SBlend::WriteSimpleJson, AnimationEventDataTypes::SBlend::FromSimpleJson, AnimationEventDataTypes::SBlend::Serialize, AnimationEventDataTypes::SBlend::Equals, AnimationEventDataTypes::SBlend::Destroy);

void AnimationEventDataTypes::SBlend::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes::SBlend*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fBlendTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fBlendTime);

	p_Stream << "}";
}

void AnimationEventDataTypes::SBlend::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<AnimationEventDataTypes::SBlend*>(p_Target);

	s_Object->m_fBlendTime = simdjson::from_json_float32(p_Document["m_fBlendTime"]);

}

void AnimationEventDataTypes::SBlend::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes::SBlend*>(p_Object);

}

bool AnimationEventDataTypes::SBlend::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationEventDataTypes::SBlend*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationEventDataTypes::SBlend*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationEventDataTypes::SBlend::operator==(const AnimationEventDataTypes::SBlend& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationEventDataTypes::SBlend>)
		return false;

	if (m_fBlendTime != p_Other.m_fBlendTime) return false;

	return true;
}

void AnimationEventDataTypes::SBlend::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes::SBlend*>(p_Object);
	s_Object->~SBlend();
}

ZHMTypeInfo AnimationEventDataTypes::SLegacy::TypeInfo = ZHMTypeInfo("AnimationEventDataTypes.SLegacy", sizeof(AnimationEventDataTypes::SLegacy), alignof(AnimationEventDataTypes::SLegacy), AnimationEventDataTypes::SLegacy::WriteSimpleJson, AnimationEventDataTypes::SLegacy::FromSimpleJson, AnimationEventDataTypes::SLegacy::Serialize, AnimationEventDataTypes::SLegacy::Equals, AnimationEventDataTypes::SLegacy::Destroy);

void AnimationEventDataTypes::SLegacy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes::SLegacy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);

	p_Stream << "}";
}

void AnimationEventDataTypes::SLegacy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<AnimationEventDataTypes::SLegacy*>(p_Target);

	s_Object->m_nEventID = simdjson::from_json_int32(p_Document["m_nEventID"]);

}

void AnimationEventDataTypes::SLegacy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes::SLegacy*>(p_Object);

}

bool AnimationEventDataTypes::SLegacy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationEventDataTypes::SLegacy*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationEventDataTypes::SLegacy*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationEventDataTypes::SLegacy::operator==(const AnimationEventDataTypes::SLegacy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationEventDataTypes::SLegacy>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;

	return true;
}

void AnimationEventDataTypes::SLegacy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes::SLegacy*>(p_Object);
	s_Object->~SLegacy();
}

ZHMTypeInfo ZRuntimeResourceID::TypeInfo = ZHMTypeInfo("ZRuntimeResourceID", sizeof(ZRuntimeResourceID), alignof(ZRuntimeResourceID), ZRuntimeResourceID::WriteSimpleJson, ZRuntimeResourceID::FromSimpleJson, ZRuntimeResourceID::Serialize, ZRuntimeResourceID::Equals, ZRuntimeResourceID::Destroy);

void ZRuntimeResourceID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_IDHigh") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDHigh);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IDLow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDLow);

	p_Stream << "}";
}

void ZRuntimeResourceID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Target);

	s_Object->m_IDHigh = simdjson::from_json_uint32(p_Document["m_IDHigh"]);

	s_Object->m_IDLow = simdjson::from_json_uint32(p_Document["m_IDLow"]);

}

void ZRuntimeResourceID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Serializer.RegisterRuntimeResourceId(p_OwnOffset);
}

bool ZRuntimeResourceID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRuntimeResourceID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRuntimeResourceID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRuntimeResourceID::operator==(const ZRuntimeResourceID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRuntimeResourceID>)
		return false;

	if (m_IDHigh != p_Other.m_IDHigh) return false;
	if (m_IDLow != p_Other.m_IDLow) return false;

	return true;
}

void ZRuntimeResourceID::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);
	s_Object->~ZRuntimeResourceID();
}

ZHMTypeInfo AnimationTakeDataTypes::SGeneric::TypeInfo = ZHMTypeInfo("AnimationTakeDataTypes.SGeneric", sizeof(AnimationTakeDataTypes::SGeneric), alignof(AnimationTakeDataTypes::SGeneric), AnimationTakeDataTypes::SGeneric::WriteSimpleJson, AnimationTakeDataTypes::SGeneric::FromSimpleJson, AnimationTakeDataTypes::SGeneric::Serialize, AnimationTakeDataTypes::SGeneric::Equals, AnimationTakeDataTypes::SGeneric::Destroy);

void AnimationTakeDataTypes::SGeneric::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes::SGeneric*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fTest") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTest);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fResourceTest") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->m_fResourceTest, p_Stream);

	p_Stream << "}";
}

void AnimationTakeDataTypes::SGeneric::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<AnimationTakeDataTypes::SGeneric*>(p_Target);

	s_Object->m_fTest = simdjson::from_json_float32(p_Document["m_fTest"]);

	ZRuntimeResourceID::FromSimpleJson(p_Document["m_fResourceTest"], &s_Object->m_fResourceTest);

}

void AnimationTakeDataTypes::SGeneric::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes::SGeneric*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->m_fResourceTest, p_Serializer, p_OwnOffset + offsetof(AnimationTakeDataTypes::SGeneric, m_fResourceTest));
}

bool AnimationTakeDataTypes::SGeneric::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationTakeDataTypes::SGeneric*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationTakeDataTypes::SGeneric*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationTakeDataTypes::SGeneric::operator==(const AnimationTakeDataTypes::SGeneric& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationTakeDataTypes::SGeneric>)
		return false;

	if (m_fTest != p_Other.m_fTest) return false;
	if (m_fResourceTest != p_Other.m_fResourceTest) return false;

	return true;
}

void AnimationTakeDataTypes::SGeneric::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes::SGeneric*>(p_Object);
	s_Object->~SGeneric();
}

ZHMTypeInfo BoneId::TypeInfo = ZHMTypeInfo("BoneId", sizeof(BoneId), alignof(BoneId), BoneId::WriteSimpleJson, BoneId::FromSimpleJson, BoneId::Serialize, BoneId::Equals, BoneId::Destroy);

void BoneId::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void BoneId::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<BoneId*>(p_Target);

}

void BoneId::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

}

bool BoneId::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<BoneId*>(p_Left);
	auto* s_Right = reinterpret_cast<BoneId*>(p_Right);

	return *s_Left == *s_Right;
}

bool BoneId::operator==(const BoneId& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<BoneId>)
		return false;


	return true;
}

void BoneId::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);
	s_Object->~BoneId();
}

ZHMTypeInfo ZResourcePtr::TypeInfo = ZHMTypeInfo("ZResourcePtr", sizeof(ZResourcePtr), alignof(ZResourcePtr), ZResourcePtr::WriteSimpleJson, ZResourcePtr::FromSimpleJson, ZResourcePtr::Serialize, ZResourcePtr::Equals, ZResourcePtr::Destroy);

void ZResourcePtr::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZResourcePtr::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZResourcePtr*>(p_Target);

}

void ZResourcePtr::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

}

bool ZResourcePtr::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZResourcePtr*>(p_Left);
	auto* s_Right = reinterpret_cast<ZResourcePtr*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZResourcePtr::operator==(const ZResourcePtr& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZResourcePtr>)
		return false;


	return true;
}

void ZResourcePtr::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);
	s_Object->~ZResourcePtr();
}

ZHMTypeInfo SVector3::TypeInfo = ZHMTypeInfo("SVector3", sizeof(SVector3), alignof(SVector3), SVector3::WriteSimpleJson, SVector3::FromSimpleJson, SVector3::Serialize, SVector3::Equals, SVector3::Destroy);

void SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);

	p_Stream << "}";
}

void SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVector3*>(p_Target);

	s_Object->x = simdjson::from_json_float32(p_Document["x"]);

	s_Object->y = simdjson::from_json_float32(p_Document["y"]);

	s_Object->z = simdjson::from_json_float32(p_Document["z"]);

}

void SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

}

bool SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector3::operator==(const SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector3>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;

	return true;
}

void SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);
	s_Object->~SVector3();
}

ZHMTypeInfo IBoneAnimator::TypeInfo = ZHMTypeInfo("IBoneAnimator", sizeof(IBoneAnimator), alignof(IBoneAnimator), IBoneAnimator::WriteSimpleJson, IBoneAnimator::FromSimpleJson, IBoneAnimator::Serialize, IBoneAnimator::Equals, IBoneAnimator::Destroy);

void IBoneAnimator::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBoneAnimator::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IBoneAnimator*>(p_Target);

}

void IBoneAnimator::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

}

bool IBoneAnimator::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBoneAnimator*>(p_Left);
	auto* s_Right = reinterpret_cast<IBoneAnimator*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBoneAnimator::operator==(const IBoneAnimator& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBoneAnimator>)
		return false;


	return true;
}

void IBoneAnimator::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);
	s_Object->~IBoneAnimator();
}

ZHMTypeInfo ZEntityRef::TypeInfo = ZHMTypeInfo("ZEntityRef", sizeof(ZEntityRef), alignof(ZEntityRef), ZEntityRef::WriteSimpleJson, ZEntityRef::FromSimpleJson, ZEntityRef::Serialize, ZEntityRef::Equals, ZEntityRef::Destroy);

void ZEntityRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZEntityRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZEntityRef*>(p_Target);

}

void ZEntityRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

}

bool ZEntityRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityRef*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityRef::operator==(const ZEntityRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityRef>)
		return false;


	return true;
}

void ZEntityRef::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);
	s_Object->~ZEntityRef();
}

ZHMTypeInfo SMatrix43::TypeInfo = ZHMTypeInfo("SMatrix43", sizeof(SMatrix43), alignof(SMatrix43), SMatrix43::WriteSimpleJson, SMatrix43::FromSimpleJson, SMatrix43::Serialize, SMatrix43::Equals, SMatrix43::Destroy);

void SMatrix43::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->ZAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	SVector3::WriteSimpleJson(&s_Object->Trans, p_Stream);

	p_Stream << "}";
}

void SMatrix43::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMatrix43*>(p_Target);

	SVector3::FromSimpleJson(p_Document["XAxis"], &s_Object->XAxis);

	SVector3::FromSimpleJson(p_Document["YAxis"], &s_Object->YAxis);

	SVector3::FromSimpleJson(p_Document["ZAxis"], &s_Object->ZAxis);

	SVector3::FromSimpleJson(p_Document["Trans"], &s_Object->Trans);

}

void SMatrix43::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	SVector3::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, XAxis));
	SVector3::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, YAxis));
	SVector3::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, ZAxis));
	SVector3::Serialize(&s_Object->Trans, p_Serializer, p_OwnOffset + offsetof(SMatrix43, Trans));
}

bool SMatrix43::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix43*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix43*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix43::operator==(const SMatrix43& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix43>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;
	if (Trans != p_Other.Trans) return false;

	return true;
}

void SMatrix43::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);
	s_Object->~SMatrix43();
}

ZHMTypeInfo IComponentInterface::TypeInfo = ZHMTypeInfo("IComponentInterface", sizeof(IComponentInterface), alignof(IComponentInterface), IComponentInterface::WriteSimpleJson, IComponentInterface::FromSimpleJson, IComponentInterface::Serialize, IComponentInterface::Equals, IComponentInterface::Destroy);

void IComponentInterface::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IComponentInterface::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IComponentInterface*>(p_Target);

}

void IComponentInterface::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

}

bool IComponentInterface::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IComponentInterface*>(p_Left);
	auto* s_Right = reinterpret_cast<IComponentInterface*>(p_Right);

	return *s_Left == *s_Right;
}

bool IComponentInterface::operator==(const IComponentInterface& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IComponentInterface>)
		return false;


	return true;
}

void IComponentInterface::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);
	s_Object->~IComponentInterface();
}

ZHMTypeInfo IActor::TypeInfo = ZHMTypeInfo("IActor", sizeof(IActor), alignof(IActor), IActor::WriteSimpleJson, IActor::FromSimpleJson, IActor::Serialize, IActor::Equals, IActor::Destroy);

void IActor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IActor*>(p_Target);

}

void IActor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);

}

bool IActor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActor*>(p_Left);
	auto* s_Right = reinterpret_cast<IActor*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActor::operator==(const IActor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActor>)
		return false;


	return true;
}

void IActor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);
	s_Object->~IActor();
}

ZHMTypeInfo IActorProvider::TypeInfo = ZHMTypeInfo("IActorProvider", sizeof(IActorProvider), alignof(IActorProvider), IActorProvider::WriteSimpleJson, IActorProvider::FromSimpleJson, IActorProvider::Serialize, IActorProvider::Equals, IActorProvider::Destroy);

void IActorProvider::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActorProvider::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IActorProvider*>(p_Target);

}

void IActorProvider::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);

}

bool IActorProvider::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActorProvider*>(p_Left);
	auto* s_Right = reinterpret_cast<IActorProvider*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActorProvider::operator==(const IActorProvider& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActorProvider>)
		return false;


	return true;
}

void IActorProvider::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);
	s_Object->~IActorProvider();
}

ZHMTypeInfo IActorProviderFilter::TypeInfo = ZHMTypeInfo("IActorProviderFilter", sizeof(IActorProviderFilter), alignof(IActorProviderFilter), IActorProviderFilter::WriteSimpleJson, IActorProviderFilter::FromSimpleJson, IActorProviderFilter::Serialize, IActorProviderFilter::Equals, IActorProviderFilter::Destroy);

void IActorProviderFilter::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActorProviderFilter::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IActorProviderFilter*>(p_Target);

}

void IActorProviderFilter::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);

}

bool IActorProviderFilter::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActorProviderFilter*>(p_Left);
	auto* s_Right = reinterpret_cast<IActorProviderFilter*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActorProviderFilter::operator==(const IActorProviderFilter& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActorProviderFilter>)
		return false;


	return true;
}

void IActorProviderFilter::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);
	s_Object->~IActorProviderFilter();
}

ZHMTypeInfo IAnimPlayerEntity::TypeInfo = ZHMTypeInfo("IAnimPlayerEntity", sizeof(IAnimPlayerEntity), alignof(IAnimPlayerEntity), IAnimPlayerEntity::WriteSimpleJson, IAnimPlayerEntity::FromSimpleJson, IAnimPlayerEntity::Serialize, IAnimPlayerEntity::Equals, IAnimPlayerEntity::Destroy);

void IAnimPlayerEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IAnimPlayerEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Target);

}

void IAnimPlayerEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

}

bool IAnimPlayerEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IAnimPlayerEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IAnimPlayerEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IAnimPlayerEntity::operator==(const IAnimPlayerEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IAnimPlayerEntity>)
		return false;


	return true;
}

void IAnimPlayerEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);
	s_Object->~IAnimPlayerEntity();
}

ZHMTypeInfo IAudioEmitter::TypeInfo = ZHMTypeInfo("IAudioEmitter", sizeof(IAudioEmitter), alignof(IAudioEmitter), IAudioEmitter::WriteSimpleJson, IAudioEmitter::FromSimpleJson, IAudioEmitter::Serialize, IAudioEmitter::Equals, IAudioEmitter::Destroy);

void IAudioEmitter::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAudioEmitter*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IAudioEmitter::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IAudioEmitter*>(p_Target);

}

void IAudioEmitter::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IAudioEmitter*>(p_Object);

}

bool IAudioEmitter::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IAudioEmitter*>(p_Left);
	auto* s_Right = reinterpret_cast<IAudioEmitter*>(p_Right);

	return *s_Left == *s_Right;
}

bool IAudioEmitter::operator==(const IAudioEmitter& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IAudioEmitter>)
		return false;


	return true;
}

void IAudioEmitter::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IAudioEmitter*>(p_Object);
	s_Object->~IAudioEmitter();
}

ZHMTypeInfo IBodybagEntity::TypeInfo = ZHMTypeInfo("IBodybagEntity", sizeof(IBodybagEntity), alignof(IBodybagEntity), IBodybagEntity::WriteSimpleJson, IBodybagEntity::FromSimpleJson, IBodybagEntity::Serialize, IBodybagEntity::Equals, IBodybagEntity::Destroy);

void IBodybagEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBodybagEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IBodybagEntity*>(p_Target);

}

void IBodybagEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);

}

bool IBodybagEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBodybagEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IBodybagEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBodybagEntity::operator==(const IBodybagEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBodybagEntity>)
		return false;


	return true;
}

void IBodybagEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);
	s_Object->~IBodybagEntity();
}

ZHMTypeInfo IBoneCollidable::TypeInfo = ZHMTypeInfo("IBoneCollidable", sizeof(IBoneCollidable), alignof(IBoneCollidable), IBoneCollidable::WriteSimpleJson, IBoneCollidable::FromSimpleJson, IBoneCollidable::Serialize, IBoneCollidable::Equals, IBoneCollidable::Destroy);

void IBoneCollidable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBoneCollidable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IBoneCollidable*>(p_Target);

}

void IBoneCollidable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

}

bool IBoneCollidable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBoneCollidable*>(p_Left);
	auto* s_Right = reinterpret_cast<IBoneCollidable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBoneCollidable::operator==(const IBoneCollidable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBoneCollidable>)
		return false;


	return true;
}

void IBoneCollidable::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);
	s_Object->~IBoneCollidable();
}

ZHMTypeInfo IBulletImpactListener::TypeInfo = ZHMTypeInfo("IBulletImpactListener", sizeof(IBulletImpactListener), alignof(IBulletImpactListener), IBulletImpactListener::WriteSimpleJson, IBulletImpactListener::FromSimpleJson, IBulletImpactListener::Serialize, IBulletImpactListener::Equals, IBulletImpactListener::Destroy);

void IBulletImpactListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBulletImpactListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IBulletImpactListener*>(p_Target);

}

void IBulletImpactListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);

}

bool IBulletImpactListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBulletImpactListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IBulletImpactListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBulletImpactListener::operator==(const IBulletImpactListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBulletImpactListener>)
		return false;


	return true;
}

void IBulletImpactListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);
	s_Object->~IBulletImpactListener();
}

ZHMTypeInfo IContractEvaluationContextListener::TypeInfo = ZHMTypeInfo("IContractEvaluationContextListener", sizeof(IContractEvaluationContextListener), alignof(IContractEvaluationContextListener), IContractEvaluationContextListener::WriteSimpleJson, IContractEvaluationContextListener::FromSimpleJson, IContractEvaluationContextListener::Serialize, IContractEvaluationContextListener::Equals, IContractEvaluationContextListener::Destroy);

void IContractEvaluationContextListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IContractEvaluationContextListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Target);

}

void IContractEvaluationContextListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);

}

bool IContractEvaluationContextListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractEvaluationContextListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractEvaluationContextListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractEvaluationContextListener::operator==(const IContractEvaluationContextListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractEvaluationContextListener>)
		return false;


	return true;
}

void IContractEvaluationContextListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);
	s_Object->~IContractEvaluationContextListener();
}

ZHMTypeInfo ZGuid::TypeInfo = ZHMTypeInfo("ZGuid", sizeof(ZGuid), alignof(ZGuid), ZGuid::WriteSimpleJson, ZGuid::FromSimpleJson, ZGuid::Serialize, ZGuid::Equals, ZGuid::Destroy);

void ZGuid::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("_a") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_a);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_b);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_c") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_c);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_d") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_d);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_e") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_e);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_f") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_f);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_h") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_h);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_i") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_i);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_j") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_j);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_k") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_k);

	p_Stream << "}";
}

void ZGuid::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZGuid*>(p_Target);

	s_Object->_a = simdjson::from_json_uint32(p_Document["_a"]);

	s_Object->_b = simdjson::from_json_uint16(p_Document["_b"]);

	s_Object->_c = simdjson::from_json_uint16(p_Document["_c"]);

	s_Object->_d = simdjson::from_json_uint8(p_Document["_d"]);

	s_Object->_e = simdjson::from_json_uint8(p_Document["_e"]);

	s_Object->_f = simdjson::from_json_uint8(p_Document["_f"]);

	s_Object->_g = simdjson::from_json_uint8(p_Document["_g"]);

	s_Object->_h = simdjson::from_json_uint8(p_Document["_h"]);

	s_Object->_i = simdjson::from_json_uint8(p_Document["_i"]);

	s_Object->_j = simdjson::from_json_uint8(p_Document["_j"]);

	s_Object->_k = simdjson::from_json_uint8(p_Document["_k"]);

}

void ZGuid::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);

}

bool ZGuid::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGuid*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGuid*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGuid::operator==(const ZGuid& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGuid>)
		return false;

	if (_a != p_Other._a) return false;
	if (_b != p_Other._b) return false;
	if (_c != p_Other._c) return false;
	if (_d != p_Other._d) return false;
	if (_e != p_Other._e) return false;
	if (_f != p_Other._f) return false;
	if (_g != p_Other._g) return false;
	if (_h != p_Other._h) return false;
	if (_i != p_Other._i) return false;
	if (_j != p_Other._j) return false;
	if (_k != p_Other._k) return false;

	return true;
}

void ZGuid::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);
	s_Object->~ZGuid();
}

ZHMTypeInfo IContractObjective::TypeInfo = ZHMTypeInfo("IContractObjective", sizeof(IContractObjective), alignof(IContractObjective), IContractObjective::WriteSimpleJson, IContractObjective::FromSimpleJson, IContractObjective::Serialize, IContractObjective::Equals, IContractObjective::Destroy);

void IContractObjective::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IContractObjective::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IContractObjective*>(p_Target);

}

void IContractObjective::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);

}

bool IContractObjective::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractObjective*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractObjective*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractObjective::operator==(const IContractObjective& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractObjective>)
		return false;


	return true;
}

void IContractObjective::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);
	s_Object->~IContractObjective();
}

ZHMTypeInfo IEscortOutSituation::TypeInfo = ZHMTypeInfo("IEscortOutSituation", sizeof(IEscortOutSituation), alignof(IEscortOutSituation), IEscortOutSituation::WriteSimpleJson, IEscortOutSituation::FromSimpleJson, IEscortOutSituation::Serialize, IEscortOutSituation::Equals, IEscortOutSituation::Destroy);

void IEscortOutSituation::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IEscortOutSituation::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IEscortOutSituation*>(p_Target);

}

void IEscortOutSituation::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);

}

bool IEscortOutSituation::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IEscortOutSituation*>(p_Left);
	auto* s_Right = reinterpret_cast<IEscortOutSituation*>(p_Right);

	return *s_Left == *s_Right;
}

bool IEscortOutSituation::operator==(const IEscortOutSituation& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IEscortOutSituation>)
		return false;


	return true;
}

void IEscortOutSituation::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);
	s_Object->~IEscortOutSituation();
}

ZHMTypeInfo IEventConsumerCollection::TypeInfo = ZHMTypeInfo("IEventConsumerCollection", sizeof(IEventConsumerCollection), alignof(IEventConsumerCollection), IEventConsumerCollection::WriteSimpleJson, IEventConsumerCollection::FromSimpleJson, IEventConsumerCollection::Serialize, IEventConsumerCollection::Equals, IEventConsumerCollection::Destroy);

void IEventConsumerCollection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IEventConsumerCollection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Target);

}

void IEventConsumerCollection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

}

bool IEventConsumerCollection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IEventConsumerCollection*>(p_Left);
	auto* s_Right = reinterpret_cast<IEventConsumerCollection*>(p_Right);

	return *s_Left == *s_Right;
}

bool IEventConsumerCollection::operator==(const IEventConsumerCollection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IEventConsumerCollection>)
		return false;


	return true;
}

void IEventConsumerCollection::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);
	s_Object->~IEventConsumerCollection();
}

ZHMTypeInfo IFreeCameraControl::TypeInfo = ZHMTypeInfo("IFreeCameraControl", sizeof(IFreeCameraControl), alignof(IFreeCameraControl), IFreeCameraControl::WriteSimpleJson, IFreeCameraControl::FromSimpleJson, IFreeCameraControl::Serialize, IFreeCameraControl::Equals, IFreeCameraControl::Destroy);

void IFreeCameraControl::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IFreeCameraControl::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IFreeCameraControl*>(p_Target);

}

void IFreeCameraControl::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);

}

bool IFreeCameraControl::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IFreeCameraControl*>(p_Left);
	auto* s_Right = reinterpret_cast<IFreeCameraControl*>(p_Right);

	return *s_Left == *s_Right;
}

bool IFreeCameraControl::operator==(const IFreeCameraControl& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IFreeCameraControl>)
		return false;


	return true;
}

void IFreeCameraControl::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);
	s_Object->~IFreeCameraControl();
}

ZHMTypeInfo IHM5Door::TypeInfo = ZHMTypeInfo("IHM5Door", sizeof(IHM5Door), alignof(IHM5Door), IHM5Door::WriteSimpleJson, IHM5Door::FromSimpleJson, IHM5Door::Serialize, IHM5Door::Equals, IHM5Door::Destroy);

void IHM5Door::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHM5Door::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IHM5Door*>(p_Target);

}

void IHM5Door::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);

}

bool IHM5Door::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHM5Door*>(p_Left);
	auto* s_Right = reinterpret_cast<IHM5Door*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHM5Door::operator==(const IHM5Door& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHM5Door>)
		return false;


	return true;
}

void IHM5Door::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IHM5Door*>(p_Object);
	s_Object->~IHM5Door();
}

ZHMTypeInfo IHM5WeaponInventory::TypeInfo = ZHMTypeInfo("IHM5WeaponInventory", sizeof(IHM5WeaponInventory), alignof(IHM5WeaponInventory), IHM5WeaponInventory::WriteSimpleJson, IHM5WeaponInventory::FromSimpleJson, IHM5WeaponInventory::Serialize, IHM5WeaponInventory::Equals, IHM5WeaponInventory::Destroy);

void IHM5WeaponInventory::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHM5WeaponInventory::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Target);

}

void IHM5WeaponInventory::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

}

bool IHM5WeaponInventory::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHM5WeaponInventory*>(p_Left);
	auto* s_Right = reinterpret_cast<IHM5WeaponInventory*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHM5WeaponInventory::operator==(const IHM5WeaponInventory& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHM5WeaponInventory>)
		return false;


	return true;
}

void IHM5WeaponInventory::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);
	s_Object->~IHM5WeaponInventory();
}

ZHMTypeInfo IHumanBody::TypeInfo = ZHMTypeInfo("IHumanBody", sizeof(IHumanBody), alignof(IHumanBody), IHumanBody::WriteSimpleJson, IHumanBody::FromSimpleJson, IHumanBody::Serialize, IHumanBody::Equals, IHumanBody::Destroy);

void IHumanBody::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHumanBody::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IHumanBody*>(p_Target);

}

void IHumanBody::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);

}

bool IHumanBody::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHumanBody*>(p_Left);
	auto* s_Right = reinterpret_cast<IHumanBody*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHumanBody::operator==(const IHumanBody& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHumanBody>)
		return false;


	return true;
}

void IHumanBody::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);
	s_Object->~IHumanBody();
}

ZHMTypeInfo IMetricValue::TypeInfo = ZHMTypeInfo("IMetricValue", sizeof(IMetricValue), alignof(IMetricValue), IMetricValue::WriteSimpleJson, IMetricValue::FromSimpleJson, IMetricValue::Serialize, IMetricValue::Equals, IMetricValue::Destroy);

void IMetricValue::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMetricValue::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IMetricValue*>(p_Target);

}

void IMetricValue::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);

}

bool IMetricValue::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMetricValue*>(p_Left);
	auto* s_Right = reinterpret_cast<IMetricValue*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMetricValue::operator==(const IMetricValue& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMetricValue>)
		return false;


	return true;
}

void IMetricValue::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);
	s_Object->~IMetricValue();
}

ZHMTypeInfo IMorphemeCutSequenceAnimatable::TypeInfo = ZHMTypeInfo("IMorphemeCutSequenceAnimatable", sizeof(IMorphemeCutSequenceAnimatable), alignof(IMorphemeCutSequenceAnimatable), IMorphemeCutSequenceAnimatable::WriteSimpleJson, IMorphemeCutSequenceAnimatable::FromSimpleJson, IMorphemeCutSequenceAnimatable::Serialize, IMorphemeCutSequenceAnimatable::Equals, IMorphemeCutSequenceAnimatable::Destroy);

void IMorphemeCutSequenceAnimatable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeCutSequenceAnimatable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Target);

}

void IMorphemeCutSequenceAnimatable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

}

bool IMorphemeCutSequenceAnimatable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeCutSequenceAnimatable::operator==(const IMorphemeCutSequenceAnimatable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeCutSequenceAnimatable>)
		return false;


	return true;
}

void IMorphemeCutSequenceAnimatable::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);
	s_Object->~IMorphemeCutSequenceAnimatable();
}

ZHMTypeInfo IMorphemeCutSequenceAnimationEntity::TypeInfo = ZHMTypeInfo("IMorphemeCutSequenceAnimationEntity", sizeof(IMorphemeCutSequenceAnimationEntity), alignof(IMorphemeCutSequenceAnimationEntity), IMorphemeCutSequenceAnimationEntity::WriteSimpleJson, IMorphemeCutSequenceAnimationEntity::FromSimpleJson, IMorphemeCutSequenceAnimationEntity::Serialize, IMorphemeCutSequenceAnimationEntity::Equals, IMorphemeCutSequenceAnimationEntity::Destroy);

void IMorphemeCutSequenceAnimationEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeCutSequenceAnimationEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Target);

}

void IMorphemeCutSequenceAnimationEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);

}

bool IMorphemeCutSequenceAnimationEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeCutSequenceAnimationEntity::operator==(const IMorphemeCutSequenceAnimationEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeCutSequenceAnimationEntity>)
		return false;


	return true;
}

void IMorphemeCutSequenceAnimationEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);
	s_Object->~IMorphemeCutSequenceAnimationEntity();
}

ZHMTypeInfo IMorphemeEventConsumer::TypeInfo = ZHMTypeInfo("IMorphemeEventConsumer", sizeof(IMorphemeEventConsumer), alignof(IMorphemeEventConsumer), IMorphemeEventConsumer::WriteSimpleJson, IMorphemeEventConsumer::FromSimpleJson, IMorphemeEventConsumer::Serialize, IMorphemeEventConsumer::Equals, IMorphemeEventConsumer::Destroy);

void IMorphemeEventConsumer::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeEventConsumer::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Target);

}

void IMorphemeEventConsumer::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

}

bool IMorphemeEventConsumer::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeEventConsumer*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeEventConsumer*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeEventConsumer::operator==(const IMorphemeEventConsumer& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeEventConsumer>)
		return false;


	return true;
}

void IMorphemeEventConsumer::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);
	s_Object->~IMorphemeEventConsumer();
}

ZHMTypeInfo IOnlineConfigurationListener::TypeInfo = ZHMTypeInfo("IOnlineConfigurationListener", sizeof(IOnlineConfigurationListener), alignof(IOnlineConfigurationListener), IOnlineConfigurationListener::WriteSimpleJson, IOnlineConfigurationListener::FromSimpleJson, IOnlineConfigurationListener::Serialize, IOnlineConfigurationListener::Equals, IOnlineConfigurationListener::Destroy);

void IOnlineConfigurationListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IOnlineConfigurationListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Target);

}

void IOnlineConfigurationListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);

}

bool IOnlineConfigurationListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IOnlineConfigurationListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IOnlineConfigurationListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IOnlineConfigurationListener::operator==(const IOnlineConfigurationListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IOnlineConfigurationListener>)
		return false;


	return true;
}

void IOnlineConfigurationListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);
	s_Object->~IOnlineConfigurationListener();
}

ZHMTypeInfo IPureWaterReflectable::TypeInfo = ZHMTypeInfo("IPureWaterReflectable", sizeof(IPureWaterReflectable), alignof(IPureWaterReflectable), IPureWaterReflectable::WriteSimpleJson, IPureWaterReflectable::FromSimpleJson, IPureWaterReflectable::Serialize, IPureWaterReflectable::Equals, IPureWaterReflectable::Destroy);

void IPureWaterReflectable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IPureWaterReflectable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Target);

}

void IPureWaterReflectable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);

}

bool IPureWaterReflectable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IPureWaterReflectable*>(p_Left);
	auto* s_Right = reinterpret_cast<IPureWaterReflectable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IPureWaterReflectable::operator==(const IPureWaterReflectable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IPureWaterReflectable>)
		return false;


	return true;
}

void IPureWaterReflectable::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);
	s_Object->~IPureWaterReflectable();
}

ZHMTypeInfo IRenderCompositorEntity::TypeInfo = ZHMTypeInfo("IRenderCompositorEntity", sizeof(IRenderCompositorEntity), alignof(IRenderCompositorEntity), IRenderCompositorEntity::WriteSimpleJson, IRenderCompositorEntity::FromSimpleJson, IRenderCompositorEntity::Serialize, IRenderCompositorEntity::Equals, IRenderCompositorEntity::Destroy);

void IRenderCompositorEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IRenderCompositorEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Target);

}

void IRenderCompositorEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

}

bool IRenderCompositorEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IRenderCompositorEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IRenderCompositorEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IRenderCompositorEntity::operator==(const IRenderCompositorEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IRenderCompositorEntity>)
		return false;


	return true;
}

void IRenderCompositorEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);
	s_Object->~IRenderCompositorEntity();
}

ZHMTypeInfo IRenderMaterialDescriptor::TypeInfo = ZHMTypeInfo("IRenderMaterialDescriptor", sizeof(IRenderMaterialDescriptor), alignof(IRenderMaterialDescriptor), IRenderMaterialDescriptor::WriteSimpleJson, IRenderMaterialDescriptor::FromSimpleJson, IRenderMaterialDescriptor::Serialize, IRenderMaterialDescriptor::Equals, IRenderMaterialDescriptor::Destroy);

void IRenderMaterialDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IRenderMaterialDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Target);

}

void IRenderMaterialDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);

}

bool IRenderMaterialDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IRenderMaterialDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<IRenderMaterialDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool IRenderMaterialDescriptor::operator==(const IRenderMaterialDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IRenderMaterialDescriptor>)
		return false;


	return true;
}

void IRenderMaterialDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IRenderMaterialDescriptor*>(p_Object);
	s_Object->~IRenderMaterialDescriptor();
}

ZHMTypeInfo ISequenceTarget::TypeInfo = ZHMTypeInfo("ISequenceTarget", sizeof(ISequenceTarget), alignof(ISequenceTarget), ISequenceTarget::WriteSimpleJson, ISequenceTarget::FromSimpleJson, ISequenceTarget::Serialize, ISequenceTarget::Equals, ISequenceTarget::Destroy);

void ISequenceTarget::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISequenceTarget::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ISequenceTarget*>(p_Target);

}

void ISequenceTarget::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);

}

bool ISequenceTarget::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISequenceTarget*>(p_Left);
	auto* s_Right = reinterpret_cast<ISequenceTarget*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISequenceTarget::operator==(const ISequenceTarget& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISequenceTarget>)
		return false;


	return true;
}

void ISequenceTarget::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);
	s_Object->~ISequenceTarget();
}

ZHMTypeInfo ISituation::TypeInfo = ZHMTypeInfo("ISituation", sizeof(ISituation), alignof(ISituation), ISituation::WriteSimpleJson, ISituation::FromSimpleJson, ISituation::Serialize, ISituation::Equals, ISituation::Destroy);

void ISituation::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISituation::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ISituation*>(p_Target);

}

void ISituation::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);

}

bool ISituation::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISituation*>(p_Left);
	auto* s_Right = reinterpret_cast<ISituation*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISituation::operator==(const ISituation& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISituation>)
		return false;


	return true;
}

void ISituation::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);
	s_Object->~ISituation();
}

ZHMTypeInfo ISoundMaterialDescriptor::TypeInfo = ZHMTypeInfo("ISoundMaterialDescriptor", sizeof(ISoundMaterialDescriptor), alignof(ISoundMaterialDescriptor), ISoundMaterialDescriptor::WriteSimpleJson, ISoundMaterialDescriptor::FromSimpleJson, ISoundMaterialDescriptor::Serialize, ISoundMaterialDescriptor::Equals, ISoundMaterialDescriptor::Destroy);

void ISoundMaterialDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISoundMaterialDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Target);

}

void ISoundMaterialDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);

}

bool ISoundMaterialDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISoundMaterialDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<ISoundMaterialDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISoundMaterialDescriptor::operator==(const ISoundMaterialDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISoundMaterialDescriptor>)
		return false;


	return true;
}

void ISoundMaterialDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);
	s_Object->~ISoundMaterialDescriptor();
}

ZHMTypeInfo ITriggerListener::TypeInfo = ZHMTypeInfo("ITriggerListener", sizeof(ITriggerListener), alignof(ITriggerListener), ITriggerListener::WriteSimpleJson, ITriggerListener::FromSimpleJson, ITriggerListener::Serialize, ITriggerListener::Equals, ITriggerListener::Destroy);

void ITriggerListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ITriggerListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ITriggerListener*>(p_Target);

}

void ITriggerListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

}

bool ITriggerListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ITriggerListener*>(p_Left);
	auto* s_Right = reinterpret_cast<ITriggerListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool ITriggerListener::operator==(const ITriggerListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ITriggerListener>)
		return false;


	return true;
}

void ITriggerListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);
	s_Object->~ITriggerListener();
}

ZHMTypeInfo IUIDataListener::TypeInfo = ZHMTypeInfo("IUIDataListener", sizeof(IUIDataListener), alignof(IUIDataListener), IUIDataListener::WriteSimpleJson, IUIDataListener::FromSimpleJson, IUIDataListener::Serialize, IUIDataListener::Equals, IUIDataListener::Destroy);

void IUIDataListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IUIDataListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IUIDataListener*>(p_Target);

}

void IUIDataListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);

}

bool IUIDataListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IUIDataListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IUIDataListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IUIDataListener::operator==(const IUIDataListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IUIDataListener>)
		return false;


	return true;
}

void IUIDataListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);
	s_Object->~IUIDataListener();
}

ZHMTypeInfo IValueEntity::TypeInfo = ZHMTypeInfo("IValueEntity", sizeof(IValueEntity), alignof(IValueEntity), IValueEntity::WriteSimpleJson, IValueEntity::FromSimpleJson, IValueEntity::Serialize, IValueEntity::Equals, IValueEntity::Destroy);

void IValueEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IValueEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IValueEntity*>(p_Target);

}

void IValueEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

}

bool IValueEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IValueEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IValueEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IValueEntity::operator==(const IValueEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IValueEntity>)
		return false;


	return true;
}

void IValueEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);
	s_Object->~IValueEntity();
}

ZHMTypeInfo IWorldMapMarker::TypeInfo = ZHMTypeInfo("IWorldMapMarker", sizeof(IWorldMapMarker), alignof(IWorldMapMarker), IWorldMapMarker::WriteSimpleJson, IWorldMapMarker::FromSimpleJson, IWorldMapMarker::Serialize, IWorldMapMarker::Equals, IWorldMapMarker::Destroy);

void IWorldMapMarker::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IWorldMapMarker::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<IWorldMapMarker*>(p_Target);

}

void IWorldMapMarker::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);

}

bool IWorldMapMarker::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IWorldMapMarker*>(p_Left);
	auto* s_Right = reinterpret_cast<IWorldMapMarker*>(p_Right);

	return *s_Left == *s_Right;
}

bool IWorldMapMarker::operator==(const IWorldMapMarker& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IWorldMapMarker>)
		return false;


	return true;
}

void IWorldMapMarker::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);
	s_Object->~IWorldMapMarker();
}

ZHMTypeInfo S25DProjectionSettings::TypeInfo = ZHMTypeInfo("S25DProjectionSettings", sizeof(S25DProjectionSettings), alignof(S25DProjectionSettings), S25DProjectionSettings::WriteSimpleJson, S25DProjectionSettings::FromSimpleJson, S25DProjectionSettings::Serialize, S25DProjectionSettings::Equals, S25DProjectionSettings::Destroy);

void S25DProjectionSettings::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fNearDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScaleFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fScaleFactor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlphaFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlphaFactor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eViewportLock") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EViewportLock", static_cast<int>(s_Object->eViewportLock)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fViewportGutter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fViewportGutter);

	p_Stream << "}";
}

void S25DProjectionSettings::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Target);

	s_Object->fNearDistance = simdjson::from_json_float32(p_Document["fNearDistance"]);

	s_Object->fFarDistance = simdjson::from_json_float32(p_Document["fFarDistance"]);

	s_Object->fNearScale = simdjson::from_json_float32(p_Document["fNearScale"]);

	s_Object->fFarScale = simdjson::from_json_float32(p_Document["fFarScale"]);

	s_Object->fScaleFactor = simdjson::from_json_float32(p_Document["fScaleFactor"]);

	s_Object->fNearAlpha = simdjson::from_json_float32(p_Document["fNearAlpha"]);

	s_Object->fFarAlpha = simdjson::from_json_float32(p_Document["fFarAlpha"]);

	s_Object->fAlphaFactor = simdjson::from_json_float32(p_Document["fAlphaFactor"]);

	s_Object->eViewportLock = static_cast<EViewportLock>(ZHMEnums::GetEnumValueByName("EViewportLock", std::string_view(p_Document["eViewportLock"])));

	s_Object->fViewportGutter = simdjson::from_json_float32(p_Document["fViewportGutter"]);

}

void S25DProjectionSettings::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);

}

bool S25DProjectionSettings::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<S25DProjectionSettings*>(p_Left);
	auto* s_Right = reinterpret_cast<S25DProjectionSettings*>(p_Right);

	return *s_Left == *s_Right;
}

bool S25DProjectionSettings::operator==(const S25DProjectionSettings& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<S25DProjectionSettings>)
		return false;

	if (fNearDistance != p_Other.fNearDistance) return false;
	if (fFarDistance != p_Other.fFarDistance) return false;
	if (fNearScale != p_Other.fNearScale) return false;
	if (fFarScale != p_Other.fFarScale) return false;
	if (fScaleFactor != p_Other.fScaleFactor) return false;
	if (fNearAlpha != p_Other.fNearAlpha) return false;
	if (fFarAlpha != p_Other.fFarAlpha) return false;
	if (fAlphaFactor != p_Other.fAlphaFactor) return false;
	if (eViewportLock != p_Other.eViewportLock) return false;
	if (fViewportGutter != p_Other.fViewportGutter) return false;

	return true;
}

void S25DProjectionSettings::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);
	s_Object->~S25DProjectionSettings();
}

ZHMTypeInfo S3rdPersonCameraSaveData::TypeInfo = ZHMTypeInfo("S3rdPersonCameraSaveData", sizeof(S3rdPersonCameraSaveData), alignof(S3rdPersonCameraSaveData), S3rdPersonCameraSaveData::WriteSimpleJson, S3rdPersonCameraSaveData::FromSimpleJson, S3rdPersonCameraSaveData::Serialize, S3rdPersonCameraSaveData::Equals, S3rdPersonCameraSaveData::Destroy);

void S3rdPersonCameraSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fAngleYaw") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngleYaw);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnglePitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnglePitch);

	p_Stream << "}";
}

void S3rdPersonCameraSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Target);

	s_Object->m_fAngleYaw = simdjson::from_json_float32(p_Document["m_fAngleYaw"]);

	s_Object->m_fAnglePitch = simdjson::from_json_float32(p_Document["m_fAnglePitch"]);

}

void S3rdPersonCameraSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);

}

bool S3rdPersonCameraSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool S3rdPersonCameraSaveData::operator==(const S3rdPersonCameraSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<S3rdPersonCameraSaveData>)
		return false;

	if (m_fAngleYaw != p_Other.m_fAngleYaw) return false;
	if (m_fAnglePitch != p_Other.m_fAnglePitch) return false;

	return true;
}

void S3rdPersonCameraSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);
	s_Object->~S3rdPersonCameraSaveData();
}

ZHMTypeInfo ZGameTime::TypeInfo = ZHMTypeInfo("ZGameTime", sizeof(ZGameTime), alignof(ZGameTime), ZGameTime::WriteSimpleJson, ZGameTime::FromSimpleJson, ZGameTime::Serialize, ZGameTime::Equals, ZGameTime::Destroy);

void ZGameTime::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nTicks") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTicks);

	p_Stream << "}";
}

void ZGameTime::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZGameTime*>(p_Target);

	s_Object->m_nTicks = simdjson::from_json_int64(p_Document["m_nTicks"]);

}

void ZGameTime::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

}

bool ZGameTime::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGameTime*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGameTime*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGameTime::operator==(const ZGameTime& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGameTime>)
		return false;

	if (m_nTicks != p_Other.m_nTicks) return false;

	return true;
}

void ZGameTime::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);
	s_Object->~ZGameTime();
}

ZHMTypeInfo SAIEventSaveData::TypeInfo = ZHMTypeInfo("SAIEventSaveData", sizeof(SAIEventSaveData), alignof(SAIEventSaveData), SAIEventSaveData::WriteSimpleJson, SAIEventSaveData::FromSimpleJson, SAIEventSaveData::Serialize, SAIEventSaveData::Equals, SAIEventSaveData::Destroy);

void SAIEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHandled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHandled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nEnd, p_Stream);

	p_Stream << "}";
}

void SAIEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAIEventSaveData*>(p_Target);

	s_Object->m_eType = static_cast<EAIEventType>(ZHMEnums::GetEnumValueByName("EAIEventType", std::string_view(p_Document["m_eType"])));

	s_Object->m_bHandled = simdjson::from_json_bool(p_Document["m_bHandled"]);

	ZGameTime::FromSimpleJson(p_Document["m_nStart"], &s_Object->m_nStart);

	ZGameTime::FromSimpleJson(p_Document["m_nEnd"], &s_Object->m_nEnd);

}

void SAIEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_nStart, p_Serializer, p_OwnOffset + offsetof(SAIEventSaveData, m_nStart));
	ZGameTime::Serialize(&s_Object->m_nEnd, p_Serializer, p_OwnOffset + offsetof(SAIEventSaveData, m_nEnd));
}

bool SAIEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIEventSaveData::operator==(const SAIEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIEventSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_bHandled != p_Other.m_bHandled) return false;
	if (m_nStart != p_Other.m_nStart) return false;
	if (m_nEnd != p_Other.m_nEnd) return false;

	return true;
}

void SAIEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);
	s_Object->~SAIEventSaveData();
}

ZHMTypeInfo SAIModifierServiceActorSaveData::TypeInfo = ZHMTypeInfo("SAIModifierServiceActorSaveData", sizeof(SAIModifierServiceActorSaveData), alignof(SAIModifierServiceActorSaveData), SAIModifierServiceActorSaveData::WriteSimpleJson, SAIModifierServiceActorSaveData::FromSimpleJson, SAIModifierServiceActorSaveData::Serialize, SAIModifierServiceActorSaveData::Equals, SAIModifierServiceActorSaveData::Destroy);

void SAIModifierServiceActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActorRef") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActorRef);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedsVolumeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedsVolumeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedsKnowledgeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedsKnowledgeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModVolume") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModVolume);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModRole") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModRole);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModOutfit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModOutfit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModOverride") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModOverride);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModStatus") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModStatus);

	p_Stream << "}";
}

void SAIModifierServiceActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Target);

	s_Object->m_rActorRef = simdjson::from_json_uint32(p_Document["m_rActorRef"]);

	s_Object->m_bNeedsVolumeUpdate = simdjson::from_json_bool(p_Document["m_bNeedsVolumeUpdate"]);

	s_Object->m_bNeedsKnowledgeUpdate = simdjson::from_json_bool(p_Document["m_bNeedsKnowledgeUpdate"]);

	s_Object->m_uiModVolume = simdjson::from_json_uint32(p_Document["m_uiModVolume"]);

	s_Object->m_uiModBehavior = simdjson::from_json_uint32(p_Document["m_uiModBehavior"]);

	s_Object->m_uiModRole = simdjson::from_json_uint32(p_Document["m_uiModRole"]);

	s_Object->m_uiModItem = simdjson::from_json_uint32(p_Document["m_uiModItem"]);

	s_Object->m_uiModSituation = simdjson::from_json_uint32(p_Document["m_uiModSituation"]);

	s_Object->m_uiModOutfit = simdjson::from_json_uint32(p_Document["m_uiModOutfit"]);

	s_Object->m_uiModOverride = simdjson::from_json_uint32(p_Document["m_uiModOverride"]);

	s_Object->m_uiModStatus = simdjson::from_json_uint32(p_Document["m_uiModStatus"]);

}

void SAIModifierServiceActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);

}

bool SAIModifierServiceActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIModifierServiceActorSaveData::operator==(const SAIModifierServiceActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIModifierServiceActorSaveData>)
		return false;

	if (m_rActorRef != p_Other.m_rActorRef) return false;
	if (m_bNeedsVolumeUpdate != p_Other.m_bNeedsVolumeUpdate) return false;
	if (m_bNeedsKnowledgeUpdate != p_Other.m_bNeedsKnowledgeUpdate) return false;
	if (m_uiModVolume != p_Other.m_uiModVolume) return false;
	if (m_uiModBehavior != p_Other.m_uiModBehavior) return false;
	if (m_uiModRole != p_Other.m_uiModRole) return false;
	if (m_uiModItem != p_Other.m_uiModItem) return false;
	if (m_uiModSituation != p_Other.m_uiModSituation) return false;
	if (m_uiModOutfit != p_Other.m_uiModOutfit) return false;
	if (m_uiModOverride != p_Other.m_uiModOverride) return false;
	if (m_uiModStatus != p_Other.m_uiModStatus) return false;

	return true;
}

void SAIModifierServiceActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);
	s_Object->~SAIModifierServiceActorSaveData();
}

ZHMTypeInfo SAIModifierServiceSaveData::TypeInfo = ZHMTypeInfo("SAIModifierServiceSaveData", sizeof(SAIModifierServiceSaveData), alignof(SAIModifierServiceSaveData), SAIModifierServiceSaveData::WriteSimpleJson, SAIModifierServiceSaveData::FromSimpleJson, SAIModifierServiceSaveData::Serialize, SAIModifierServiceSaveData::Equals, SAIModifierServiceSaveData::Destroy);

void SAIModifierServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bFullVolumeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFullVolumeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		SAIModifierServiceActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAIModifierServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Target);

	s_Object->m_bFullVolumeUpdate = simdjson::from_json_bool(p_Document["m_bFullVolumeUpdate"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActors"];
	s_Object->m_aActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAIModifierServiceActorSaveData::FromSimpleJson(s_Item0, &s_Object->m_aActors[s_Index0]);
		++s_Index0;
	}
	}

}

void SAIModifierServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);

	TArray<SAIModifierServiceActorSaveData>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SAIModifierServiceSaveData, m_aActors));
}

bool SAIModifierServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIModifierServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIModifierServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIModifierServiceSaveData::operator==(const SAIModifierServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIModifierServiceSaveData>)
		return false;

	if (m_bFullVolumeUpdate != p_Other.m_bFullVolumeUpdate) return false;
	if (m_aActors != p_Other.m_aActors) return false;

	return true;
}

void SAIModifierServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);
	s_Object->~SAIModifierServiceSaveData();
}

ZHMTypeInfo SAIPerceptibleEntitySaveData::TypeInfo = ZHMTypeInfo("SAIPerceptibleEntitySaveData", sizeof(SAIPerceptibleEntitySaveData), alignof(SAIPerceptibleEntitySaveData), SAIPerceptibleEntitySaveData::WriteSimpleJson, SAIPerceptibleEntitySaveData::FromSimpleJson, SAIPerceptibleEntitySaveData::Serialize, SAIPerceptibleEntitySaveData::Equals, SAIPerceptibleEntitySaveData::Destroy);

void SAIPerceptibleEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPerceptibleEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPerceptibleEnabled);

	p_Stream << "}";
}

void SAIPerceptibleEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Target);

	s_Object->m_bPerceptibleEnabled = simdjson::from_json_bool(p_Document["m_bPerceptibleEnabled"]);

}

void SAIPerceptibleEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);

}

bool SAIPerceptibleEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIPerceptibleEntitySaveData::operator==(const SAIPerceptibleEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIPerceptibleEntitySaveData>)
		return false;

	if (m_bPerceptibleEnabled != p_Other.m_bPerceptibleEnabled) return false;

	return true;
}

void SAIPerceptibleEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);
	s_Object->~SAIPerceptibleEntitySaveData();
}

ZHMTypeInfo SAIVisionBlockerSaveData::TypeInfo = ZHMTypeInfo("SAIVisionBlockerSaveData", sizeof(SAIVisionBlockerSaveData), alignof(SAIVisionBlockerSaveData), SAIVisionBlockerSaveData::WriteSimpleJson, SAIVisionBlockerSaveData::FromSimpleJson, SAIVisionBlockerSaveData::Serialize, SAIVisionBlockerSaveData::Equals, SAIVisionBlockerSaveData::Destroy);

void SAIVisionBlockerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SAIVisionBlockerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

}

void SAIVisionBlockerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);

}

bool SAIVisionBlockerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIVisionBlockerSaveData::operator==(const SAIVisionBlockerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIVisionBlockerSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SAIVisionBlockerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);
	s_Object->~SAIVisionBlockerSaveData();
}

ZHMTypeInfo SAccessoryItemSaveData::TypeInfo = ZHMTypeInfo("SAccessoryItemSaveData", sizeof(SAccessoryItemSaveData), alignof(SAccessoryItemSaveData), SAccessoryItemSaveData::WriteSimpleJson, SAccessoryItemSaveData::FromSimpleJson, SAccessoryItemSaveData::Serialize, SAccessoryItemSaveData::Equals, SAccessoryItemSaveData::Destroy);

void SAccessoryItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBoneId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBoneId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SAccessoryItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Target);

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object->m_nBoneId = simdjson::from_json_uint32(p_Document["m_nBoneId"]);

	s_Object->m_bAttached = simdjson::from_json_bool(p_Document["m_bAttached"]);

	s_Object->m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

}

void SAccessoryItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);

}

bool SAccessoryItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAccessoryItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAccessoryItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAccessoryItemSaveData::operator==(const SAccessoryItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAccessoryItemSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_nBoneId != p_Other.m_nBoneId) return false;
	if (m_bAttached != p_Other.m_bAttached) return false;
	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

void SAccessoryItemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);
	s_Object->~SAccessoryItemSaveData();
}

ZHMTypeInfo SColorRGB::TypeInfo = ZHMTypeInfo("SColorRGB", sizeof(SColorRGB), alignof(SColorRGB), SColorRGB::WriteSimpleJson, SColorRGB::FromSimpleJson, SColorRGB::Serialize, SColorRGB::Equals, SColorRGB::Destroy);

void SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->b);

	p_Stream << "}";
}

void SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SColorRGB*>(p_Target);

	s_Object->r = simdjson::from_json_float32(p_Document["r"]);

	s_Object->g = simdjson::from_json_float32(p_Document["g"]);

	s_Object->b = simdjson::from_json_float32(p_Document["b"]);

}

void SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

}

bool SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGB::operator==(const SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGB>)
		return false;

	if (r != p_Other.r) return false;
	if (g != p_Other.g) return false;
	if (b != p_Other.b) return false;

	return true;
}

void SColorRGB::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);
	s_Object->~SColorRGB();
}

ZHMTypeInfo SActBehaviorEntitySaveData::TypeInfo = ZHMTypeInfo("SActBehaviorEntitySaveData", sizeof(SActBehaviorEntitySaveData), alignof(SActBehaviorEntitySaveData), SActBehaviorEntitySaveData::WriteSimpleJson, SActBehaviorEntitySaveData::FromSimpleJson, SActBehaviorEntitySaveData::Serialize, SActBehaviorEntitySaveData::Equals, SActBehaviorEntitySaveData::Destroy);

void SActBehaviorEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStartedSignalSent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedSignalSent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReachedSignalSent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReachedSignalSent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_ActStartTime, p_Stream);

	p_Stream << "}";
}

void SActBehaviorEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Target);

	s_Object->m_bStartedSignalSent = simdjson::from_json_bool(p_Document["m_bStartedSignalSent"]);

	s_Object->m_bReachedSignalSent = simdjson::from_json_bool(p_Document["m_bReachedSignalSent"]);

	s_Object->m_nState = static_cast<ZActBehaviorEntity::EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_nState"])));

	ZGameTime::FromSimpleJson(p_Document["m_ActStartTime"], &s_Object->m_ActStartTime);

}

void SActBehaviorEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_ActStartTime, p_Serializer, p_OwnOffset + offsetof(SActBehaviorEntitySaveData, m_ActStartTime));
}

bool SActBehaviorEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActBehaviorEntitySaveData::operator==(const SActBehaviorEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActBehaviorEntitySaveData>)
		return false;

	if (m_bStartedSignalSent != p_Other.m_bStartedSignalSent) return false;
	if (m_bReachedSignalSent != p_Other.m_bReachedSignalSent) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_ActStartTime != p_Other.m_ActStartTime) return false;

	return true;
}

void SActBehaviorEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);
	s_Object->~SActBehaviorEntitySaveData();
}

ZHMTypeInfo float4::TypeInfo = ZHMTypeInfo("float4", sizeof(float4), alignof(float4), float4::WriteSimpleJson, float4::FromSimpleJson, float4::Serialize, float4::Equals, float4::Destroy);

void float4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void float4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<float4*>(p_Target);

	s_Object->x = simdjson::from_json_float32(p_Document["x"]);

	s_Object->y = simdjson::from_json_float32(p_Document["y"]);

	s_Object->z = simdjson::from_json_float32(p_Document["z"]);

	s_Object->w = simdjson::from_json_float32(p_Document["w"]);

}

void float4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

}

bool float4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<float4*>(p_Left);
	auto* s_Right = reinterpret_cast<float4*>(p_Right);

	return *s_Left == *s_Right;
}

bool float4::operator==(const float4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<float4>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;
	if (w != p_Other.w) return false;

	return true;
}

void float4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);
	s_Object->~float4();
}

ZHMTypeInfo SActOrderSaveData::TypeInfo = ZHMTypeInfo("SActOrderSaveData", sizeof(SActOrderSaveData), alignof(SActOrderSaveData), SActOrderSaveData::WriteSimpleJson, SActOrderSaveData::FromSimpleJson, SActOrderSaveData::Serialize, SActOrderSaveData::Equals, SActOrderSaveData::Destroy);

void SActOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_faceTarget") << ":";
	float4::WriteSimpleJson(&s_Object->m_faceTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlendOutImmediatelyUponTimeout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlendOutImmediatelyUponTimeout);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropCarriedItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropCarriedItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopCurrentActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopCurrentActFast);

	p_Stream << "}";
}

void SActOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActOrderSaveData*>(p_Target);

	s_Object->m_sAct = std::string_view(p_Document["m_sAct"]);

	s_Object->m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object->m_rChildNetworkEntity = simdjson::from_json_uint32(p_Document["m_rChildNetworkEntity"]);

	float4::FromSimpleJson(p_Document["m_faceTarget"], &s_Object->m_faceTarget);

	s_Object->m_bBlendOutImmediatelyUponTimeout = simdjson::from_json_bool(p_Document["m_bBlendOutImmediatelyUponTimeout"]);

	s_Object->m_bDropCarriedItems = simdjson::from_json_bool(p_Document["m_bDropCarriedItems"]);

	s_Object->m_bStopCurrentActFast = simdjson::from_json_bool(p_Document["m_bStopCurrentActFast"]);

}

void SActOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sAct, p_Serializer, p_OwnOffset + offsetof(SActOrderSaveData, m_sAct));
	float4::Serialize(&s_Object->m_faceTarget, p_Serializer, p_OwnOffset + offsetof(SActOrderSaveData, m_faceTarget));
}

bool SActOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActOrderSaveData::operator==(const SActOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActOrderSaveData>)
		return false;

	if (m_sAct != p_Other.m_sAct) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_rChildNetworkEntity != p_Other.m_rChildNetworkEntity) return false;
	if (m_faceTarget != p_Other.m_faceTarget) return false;
	if (m_bBlendOutImmediatelyUponTimeout != p_Other.m_bBlendOutImmediatelyUponTimeout) return false;
	if (m_bDropCarriedItems != p_Other.m_bDropCarriedItems) return false;
	if (m_bStopCurrentActFast != p_Other.m_bStopCurrentActFast) return false;

	return true;
}

void SActOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);
	s_Object->~SActOrderSaveData();
}

ZHMTypeInfo SActionRadialArcDisplayInfo::TypeInfo = ZHMTypeInfo("SActionRadialArcDisplayInfo", sizeof(SActionRadialArcDisplayInfo), alignof(SActionRadialArcDisplayInfo), SActionRadialArcDisplayInfo::WriteSimpleJson, SActionRadialArcDisplayInfo::FromSimpleJson, SActionRadialArcDisplayInfo::Serialize, SActionRadialArcDisplayInfo::Equals, SActionRadialArcDisplayInfo::Destroy);

void SActionRadialArcDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("hidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->hidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("locked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->locked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("illegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->illegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);

	p_Stream << "}";
}

void SActionRadialArcDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Target);

	s_Object->hidden = simdjson::from_json_bool(p_Document["hidden"]);

	s_Object->locked = simdjson::from_json_bool(p_Document["locked"]);

	s_Object->active = simdjson::from_json_bool(p_Document["active"]);

	s_Object->illegal = simdjson::from_json_bool(p_Document["illegal"]);

	s_Object->icon = simdjson::from_json_int32(p_Document["icon"]);

	s_Object->label = std::string_view(p_Document["label"]);

}

void SActionRadialArcDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SActionRadialArcDisplayInfo, label));
}

bool SActionRadialArcDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActionRadialArcDisplayInfo::operator==(const SActionRadialArcDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActionRadialArcDisplayInfo>)
		return false;

	if (hidden != p_Other.hidden) return false;
	if (locked != p_Other.locked) return false;
	if (active != p_Other.active) return false;
	if (illegal != p_Other.illegal) return false;
	if (icon != p_Other.icon) return false;
	if (label != p_Other.label) return false;

	return true;
}

void SActionRadialArcDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);
	s_Object->~SActionRadialArcDisplayInfo();
}

ZHMTypeInfo SActionRadialArcDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SActionRadialArcDisplayInfoArray_dummy", sizeof(SActionRadialArcDisplayInfoArray_dummy), alignof(SActionRadialArcDisplayInfoArray_dummy), SActionRadialArcDisplayInfoArray_dummy::WriteSimpleJson, SActionRadialArcDisplayInfoArray_dummy::FromSimpleJson, SActionRadialArcDisplayInfoArray_dummy::Serialize, SActionRadialArcDisplayInfoArray_dummy::Equals, SActionRadialArcDisplayInfoArray_dummy::Destroy);

void SActionRadialArcDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SActionRadialArcDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActionRadialArcDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object->dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActionRadialArcDisplayInfo::FromSimpleJson(s_Item0, &s_Object->dummy[s_Index0]);
		++s_Index0;
	}
	}

}

void SActionRadialArcDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);

	TArray<SActionRadialArcDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SActionRadialArcDisplayInfoArray_dummy, dummy));
}

bool SActionRadialArcDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActionRadialArcDisplayInfoArray_dummy::operator==(const SActionRadialArcDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActionRadialArcDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SActionRadialArcDisplayInfoArray_dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);
	s_Object->~SActionRadialArcDisplayInfoArray_dummy();
}

ZHMTypeInfo SActorAccessoryItemActionSaveData::TypeInfo = ZHMTypeInfo("SActorAccessoryItemActionSaveData", sizeof(SActorAccessoryItemActionSaveData), alignof(SActorAccessoryItemActionSaveData), SActorAccessoryItemActionSaveData::WriteSimpleJson, SActorAccessoryItemActionSaveData::FromSimpleJson, SActorAccessoryItemActionSaveData::Serialize, SActorAccessoryItemActionSaveData::Equals, SActorAccessoryItemActionSaveData::Destroy);

void SActorAccessoryItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorAccessoryItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SActorAccessoryItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);

}

bool SActorAccessoryItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorAccessoryItemActionSaveData::operator==(const SActorAccessoryItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorAccessoryItemActionSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorAccessoryItemActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);
	s_Object->~SActorAccessoryItemActionSaveData();
}

ZHMTypeInfo SActorAnimSetSaveData::TypeInfo = ZHMTypeInfo("SActorAnimSetSaveData", sizeof(SActorAnimSetSaveData), alignof(SActorAnimSetSaveData), SActorAnimSetSaveData::WriteSimpleJson, SActorAnimSetSaveData::FromSimpleJson, SActorAnimSetSaveData::Serialize, SActorAnimSetSaveData::Equals, SActorAnimSetSaveData::Destroy);

void SActorAnimSetSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eAnimSet") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetType", static_cast<int>(s_Object->m_eAnimSet)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCustomAnimationSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCustomAnimationSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eVariationResourceMaxTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eVariationResourceMaxTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eVariationResourceMaxEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eVariationResourceMaxEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAnimSetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetState", static_cast<int>(s_Object->m_eAnimSetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePreCustomAnimSet") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetType", static_cast<int>(s_Object->m_ePreCustomAnimSet)));

	p_Stream << "}";
}

void SActorAnimSetSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Target);

	s_Object->m_eAnimSet = static_cast<EAnimSetType>(ZHMEnums::GetEnumValueByName("EAnimSetType", std::string_view(p_Document["m_eAnimSet"])));

	s_Object->m_rCustomAnimationSet = simdjson::from_json_uint32(p_Document["m_rCustomAnimationSet"]);

	s_Object->m_eVariationResourceMaxTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eVariationResourceMaxTension"])));

	s_Object->m_eVariationResourceMaxEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eVariationResourceMaxEmotionState"])));

	s_Object->m_eAnimSetEmotionState = static_cast<EAnimSetState>(ZHMEnums::GetEnumValueByName("EAnimSetState", std::string_view(p_Document["m_eAnimSetEmotionState"])));

	s_Object->m_ePreCustomAnimSet = static_cast<EAnimSetType>(ZHMEnums::GetEnumValueByName("EAnimSetType", std::string_view(p_Document["m_ePreCustomAnimSet"])));

}

void SActorAnimSetSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);

}

bool SActorAnimSetSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorAnimSetSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorAnimSetSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorAnimSetSaveData::operator==(const SActorAnimSetSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorAnimSetSaveData>)
		return false;

	if (m_eAnimSet != p_Other.m_eAnimSet) return false;
	if (m_rCustomAnimationSet != p_Other.m_rCustomAnimationSet) return false;
	if (m_eVariationResourceMaxTension != p_Other.m_eVariationResourceMaxTension) return false;
	if (m_eVariationResourceMaxEmotionState != p_Other.m_eVariationResourceMaxEmotionState) return false;
	if (m_eAnimSetEmotionState != p_Other.m_eAnimSetEmotionState) return false;
	if (m_ePreCustomAnimSet != p_Other.m_ePreCustomAnimSet) return false;

	return true;
}

void SActorAnimSetSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);
	s_Object->~SActorAnimSetSaveData();
}

ZHMTypeInfo SActorBoneAttachSaveData::TypeInfo = ZHMTypeInfo("SActorBoneAttachSaveData", sizeof(SActorBoneAttachSaveData), alignof(SActorBoneAttachSaveData), SActorBoneAttachSaveData::WriteSimpleJson, SActorBoneAttachSaveData::FromSimpleJson, SActorBoneAttachSaveData::Serialize, SActorBoneAttachSaveData::Equals, SActorBoneAttachSaveData::Destroy);

void SActorBoneAttachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rAttachmentTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAttachmentTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAttached);

	p_Stream << "}";
}

void SActorBoneAttachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Target);

	s_Object->m_rAttachmentTarget = simdjson::from_json_uint32(p_Document["m_rAttachmentTarget"]);

	s_Object->m_bIsAttached = simdjson::from_json_bool(p_Document["m_bIsAttached"]);

}

void SActorBoneAttachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);

}

bool SActorBoneAttachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneAttachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneAttachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneAttachSaveData::operator==(const SActorBoneAttachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneAttachSaveData>)
		return false;

	if (m_rAttachmentTarget != p_Other.m_rAttachmentTarget) return false;
	if (m_bIsAttached != p_Other.m_bIsAttached) return false;

	return true;
}

void SActorBoneAttachSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);
	s_Object->~SActorBoneAttachSaveData();
}

ZHMTypeInfo SActorBoneAttachmentsSaveData::TypeInfo = ZHMTypeInfo("SActorBoneAttachmentsSaveData", sizeof(SActorBoneAttachmentsSaveData), alignof(SActorBoneAttachmentsSaveData), SActorBoneAttachmentsSaveData::WriteSimpleJson, SActorBoneAttachmentsSaveData::FromSimpleJson, SActorBoneAttachmentsSaveData::Serialize, SActorBoneAttachmentsSaveData::Equals, SActorBoneAttachmentsSaveData::Destroy);

void SActorBoneAttachmentsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorBoneAttachSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorBoneAttachmentsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorBoneAttachSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SActorBoneAttachmentsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorBoneAttachmentsSaveData, m_aEntities));
	TArray<SActorBoneAttachSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorBoneAttachmentsSaveData, m_aData));
}

bool SActorBoneAttachmentsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneAttachmentsSaveData::operator==(const SActorBoneAttachmentsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneAttachmentsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SActorBoneAttachmentsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);
	s_Object->~SActorBoneAttachmentsSaveData();
}

ZHMTypeInfo SVector4::TypeInfo = ZHMTypeInfo("SVector4", sizeof(SVector4), alignof(SVector4), SVector4::WriteSimpleJson, SVector4::FromSimpleJson, SVector4::Serialize, SVector4::Equals, SVector4::Destroy);

void SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVector4*>(p_Target);

	s_Object->x = simdjson::from_json_float32(p_Document["x"]);

	s_Object->y = simdjson::from_json_float32(p_Document["y"]);

	s_Object->z = simdjson::from_json_float32(p_Document["z"]);

	s_Object->w = simdjson::from_json_float32(p_Document["w"]);

}

void SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

}

bool SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector4::operator==(const SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector4>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;
	if (w != p_Other.w) return false;

	return true;
}

void SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);
	s_Object->~SVector4();
}

ZHMTypeInfo SActorBoneSaveData::TypeInfo = ZHMTypeInfo("SActorBoneSaveData", sizeof(SActorBoneSaveData), alignof(SActorBoneSaveData), SActorBoneSaveData::WriteSimpleJson, SActorBoneSaveData::FromSimpleJson, SActorBoneSaveData::Serialize, SActorBoneSaveData::Equals, SActorBoneSaveData::Destroy);

void SActorBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SActorBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Target);

	SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Object->mQuaterion);

	SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Object->mTranslation);

}

void SActorBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SActorBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SActorBoneSaveData, mTranslation));
}

bool SActorBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneSaveData::operator==(const SActorBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

void SActorBoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);
	s_Object->~SActorBoneSaveData();
}

ZHMTypeInfo SActorSoundDefs::TypeInfo = ZHMTypeInfo("SActorSoundDefs", sizeof(SActorSoundDefs), alignof(SActorSoundDefs), SActorSoundDefs::WriteSimpleJson, SActorSoundDefs::FromSimpleJson, SActorSoundDefs::Serialize, SActorSoundDefs::Equals, SActorSoundDefs::Destroy);

void SActorSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SActorSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorSoundDefs*>(p_Target);

}

void SActorSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

}

bool SActorSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSoundDefs::operator==(const SActorSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSoundDefs>)
		return false;


	return true;
}

void SActorSoundDefs::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);
	s_Object->~SActorSoundDefs();
}

ZHMTypeInfo SActorDynamicTemplateHandlerSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateHandlerSaveData", sizeof(SActorDynamicTemplateHandlerSaveData), alignof(SActorDynamicTemplateHandlerSaveData), SActorDynamicTemplateHandlerSaveData::WriteSimpleJson, SActorDynamicTemplateHandlerSaveData::FromSimpleJson, SActorDynamicTemplateHandlerSaveData::Serialize, SActorDynamicTemplateHandlerSaveData::Equals, SActorDynamicTemplateHandlerSaveData::Destroy);

void SActorDynamicTemplateHandlerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSetpiece") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSetpiece);

	p_Stream << "}";
}

void SActorDynamicTemplateHandlerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object->m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	s_Object->m_rSetpiece = simdjson::from_json_uint32(p_Document["m_rSetpiece"]);

}

void SActorDynamicTemplateHandlerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);

}

bool SActorDynamicTemplateHandlerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateHandlerSaveData::operator==(const SActorDynamicTemplateHandlerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateHandlerSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rItem != p_Other.m_rItem) return false;
	if (m_rSetpiece != p_Other.m_rSetpiece) return false;

	return true;
}

void SActorDynamicTemplateHandlerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);
	s_Object->~SActorDynamicTemplateHandlerSaveData();
}

ZHMTypeInfo SActorDynamicTemplateManipulatorSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateManipulatorSaveData", sizeof(SActorDynamicTemplateManipulatorSaveData), alignof(SActorDynamicTemplateManipulatorSaveData), SActorDynamicTemplateManipulatorSaveData::WriteSimpleJson, SActorDynamicTemplateManipulatorSaveData::FromSimpleJson, SActorDynamicTemplateManipulatorSaveData::Serialize, SActorDynamicTemplateManipulatorSaveData::Equals, SActorDynamicTemplateManipulatorSaveData::Destroy);

void SActorDynamicTemplateManipulatorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorDynamicTemplateManipulatorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SActorDynamicTemplateManipulatorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);

}

bool SActorDynamicTemplateManipulatorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateManipulatorSaveData::operator==(const SActorDynamicTemplateManipulatorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateManipulatorSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorDynamicTemplateManipulatorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);
	s_Object->~SActorDynamicTemplateManipulatorSaveData();
}

ZHMTypeInfo SActorDynamicTemplateSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateSaveData", sizeof(SActorDynamicTemplateSaveData), alignof(SActorDynamicTemplateSaveData), SActorDynamicTemplateSaveData::WriteSimpleJson, SActorDynamicTemplateSaveData::FromSimpleJson, SActorDynamicTemplateSaveData::Serialize, SActorDynamicTemplateSaveData::Equals, SActorDynamicTemplateSaveData::Destroy);

void SActorDynamicTemplateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTensionLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eTensionLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeLimit") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nTimeLimit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTensionRemoveLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eTensionRemoveLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionRemoveLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionRemoveLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeRemoveLimit") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nTimeRemoveLimit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_resourceID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_resourceID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInstance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInstance);

	p_Stream << "}";
}

void SActorDynamicTemplateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Target);

	s_Object->m_sName = std::string_view(p_Document["m_sName"]);

	s_Object->m_eTensionLimit = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eTensionLimit"])));

	s_Object->m_eEmotionLimit = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eEmotionLimit"])));

	ZGameTime::FromSimpleJson(p_Document["m_nTimeLimit"], &s_Object->m_nTimeLimit);

	s_Object->m_eTensionRemoveLimit = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eTensionRemoveLimit"])));

	s_Object->m_eEmotionRemoveLimit = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eEmotionRemoveLimit"])));

	ZGameTime::FromSimpleJson(p_Document["m_nTimeRemoveLimit"], &s_Object->m_nTimeRemoveLimit);

	s_Object->m_resourceID = simdjson::from_json_int64(p_Document["m_resourceID"]);

	s_Object->m_rInstance = simdjson::from_json_uint32(p_Document["m_rInstance"]);

}

void SActorDynamicTemplateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_sName));
	ZGameTime::Serialize(&s_Object->m_nTimeLimit, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_nTimeLimit));
	ZGameTime::Serialize(&s_Object->m_nTimeRemoveLimit, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_nTimeRemoveLimit));
}

bool SActorDynamicTemplateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateSaveData::operator==(const SActorDynamicTemplateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateSaveData>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_eTensionLimit != p_Other.m_eTensionLimit) return false;
	if (m_eEmotionLimit != p_Other.m_eEmotionLimit) return false;
	if (m_nTimeLimit != p_Other.m_nTimeLimit) return false;
	if (m_eTensionRemoveLimit != p_Other.m_eTensionRemoveLimit) return false;
	if (m_eEmotionRemoveLimit != p_Other.m_eEmotionRemoveLimit) return false;
	if (m_nTimeRemoveLimit != p_Other.m_nTimeRemoveLimit) return false;
	if (m_resourceID != p_Other.m_resourceID) return false;
	if (m_rInstance != p_Other.m_rInstance) return false;

	return true;
}

void SActorDynamicTemplateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);
	s_Object->~SActorDynamicTemplateSaveData();
}

ZHMTypeInfo SActorGoalSaveData::TypeInfo = ZHMTypeInfo("SActorGoalSaveData", sizeof(SActorGoalSaveData), alignof(SActorGoalSaveData), SActorGoalSaveData::WriteSimpleJson, SActorGoalSaveData::FromSimpleJson, SActorGoalSaveData::Serialize, SActorGoalSaveData::Equals, SActorGoalSaveData::Destroy);

void SActorGoalSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aHandled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHandled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHandled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aHandled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIsCurrent") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIsCurrent.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIsCurrent[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIsCurrent.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fExpiredTime") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_fExpiredTime.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_fExpiredTime[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_fExpiredTime.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorGoalSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aHandled"];
	s_Object->m_aHandled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aHandled[s_Index0] = simdjson::from_json_bool(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIsCurrent"];
	s_Object->m_aIsCurrent.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aIsCurrent[s_Index0] = simdjson::from_json_bool(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_fExpiredTime"];
	s_Object->m_fExpiredTime.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_fExpiredTime[s_Index0] = simdjson::from_json_float32(s_Item0);
		++s_Index0;
	}
	}

}

void SActorGoalSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aEntities));
	TArray<bool>::Serialize(&s_Object->m_aHandled, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aHandled));
	TArray<bool>::Serialize(&s_Object->m_aIsCurrent, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aIsCurrent));
	TArray<float32>::Serialize(&s_Object->m_fExpiredTime, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_fExpiredTime));
}

bool SActorGoalSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorGoalSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorGoalSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorGoalSaveData::operator==(const SActorGoalSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorGoalSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aHandled != p_Other.m_aHandled) return false;
	if (m_aIsCurrent != p_Other.m_aIsCurrent) return false;
	if (m_fExpiredTime != p_Other.m_fExpiredTime) return false;

	return true;
}

void SActorGoalSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);
	s_Object->~SActorGoalSaveData();
}

ZHMTypeInfo SActorInventoryItemSaveData::TypeInfo = ZHMTypeInfo("SActorInventoryItemSaveData", sizeof(SActorInventoryItemSaveData), alignof(SActorInventoryItemSaveData), SActorInventoryItemSaveData::WriteSimpleJson, SActorInventoryItemSaveData::FromSimpleJson, SActorInventoryItemSaveData::Serialize, SActorInventoryItemSaveData::Equals, SActorInventoryItemSaveData::Destroy);

void SActorInventoryItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAttachLocation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAttachLocation", static_cast<int>(s_Object->m_eAttachLocation)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMaxTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eMaxTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeftHand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeftHand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeapon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeapon);

	p_Stream << "}";
}

void SActorInventoryItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Target);

	s_Object->m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	s_Object->m_eAttachLocation = static_cast<EAttachLocation>(ZHMEnums::GetEnumValueByName("EAttachLocation", std::string_view(p_Document["m_eAttachLocation"])));

	s_Object->m_eMaxTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eMaxTension"])));

	s_Object->m_bLeftHand = simdjson::from_json_bool(p_Document["m_bLeftHand"]);

	s_Object->m_bWeapon = simdjson::from_json_bool(p_Document["m_bWeapon"]);

}

void SActorInventoryItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);

}

bool SActorInventoryItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorInventoryItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorInventoryItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorInventoryItemSaveData::operator==(const SActorInventoryItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorInventoryItemSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;
	if (m_eAttachLocation != p_Other.m_eAttachLocation) return false;
	if (m_eMaxTension != p_Other.m_eMaxTension) return false;
	if (m_bLeftHand != p_Other.m_bLeftHand) return false;
	if (m_bWeapon != p_Other.m_bWeapon) return false;

	return true;
}

void SActorInventoryItemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);
	s_Object->~SActorInventoryItemSaveData();
}

ZHMTypeInfo SActorInventorySaveData::TypeInfo = ZHMTypeInfo("SActorInventorySaveData", sizeof(SActorInventorySaveData), alignof(SActorInventorySaveData), SActorInventorySaveData::WriteSimpleJson, SActorInventorySaveData::FromSimpleJson, SActorInventorySaveData::Serialize, SActorInventorySaveData::Equals, SActorInventorySaveData::Destroy);

void SActorInventorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		SActorInventoryItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorInventorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aItems"];
	s_Object->m_aItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorInventoryItemSaveData::FromSimpleJson(s_Item0, &s_Object->m_aItems[s_Index0]);
		++s_Index0;
	}
	}

}

void SActorInventorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);

	TArray<SActorInventoryItemSaveData>::Serialize(&s_Object->m_aItems, p_Serializer, p_OwnOffset + offsetof(SActorInventorySaveData, m_aItems));
}

bool SActorInventorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorInventorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorInventorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorInventorySaveData::operator==(const SActorInventorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorInventorySaveData>)
		return false;

	if (m_aItems != p_Other.m_aItems) return false;

	return true;
}

void SActorInventorySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);
	s_Object->~SActorInventorySaveData();
}

ZHMTypeInfo SActorItemActionSaveData::TypeInfo = ZHMTypeInfo("SActorItemActionSaveData", sizeof(SActorItemActionSaveData), alignof(SActorItemActionSaveData), SActorItemActionSaveData::WriteSimpleJson, SActorItemActionSaveData::FromSimpleJson, SActorItemActionSaveData::Serialize, SActorItemActionSaveData::Equals, SActorItemActionSaveData::Destroy);

void SActorItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SActorItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object->m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

}

void SActorItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);

}

bool SActorItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorItemActionSaveData::operator==(const SActorItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorItemActionSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SActorItemActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);
	s_Object->~SActorItemActionSaveData();
}

ZHMTypeInfo SActorKeywordProxySaveData::TypeInfo = ZHMTypeInfo("SActorKeywordProxySaveData", sizeof(SActorKeywordProxySaveData), alignof(SActorKeywordProxySaveData), SActorKeywordProxySaveData::WriteSimpleJson, SActorKeywordProxySaveData::FromSimpleJson, SActorKeywordProxySaveData::Serialize, SActorKeywordProxySaveData::Equals, SActorKeywordProxySaveData::Destroy);

void SActorKeywordProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorKeywordProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SActorKeywordProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);

}

bool SActorKeywordProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorKeywordProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorKeywordProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorKeywordProxySaveData::operator==(const SActorKeywordProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorKeywordProxySaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorKeywordProxySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);
	s_Object->~SActorKeywordProxySaveData();
}

ZHMTypeInfo SActorKeywordProxiesSaveData::TypeInfo = ZHMTypeInfo("SActorKeywordProxiesSaveData", sizeof(SActorKeywordProxiesSaveData), alignof(SActorKeywordProxiesSaveData), SActorKeywordProxiesSaveData::WriteSimpleJson, SActorKeywordProxiesSaveData::FromSimpleJson, SActorKeywordProxiesSaveData::Serialize, SActorKeywordProxiesSaveData::Equals, SActorKeywordProxiesSaveData::Destroy);

void SActorKeywordProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorKeywordProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorKeywordProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorKeywordProxySaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SActorKeywordProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorKeywordProxiesSaveData, m_aEntities));
	TArray<SActorKeywordProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorKeywordProxiesSaveData, m_aData));
}

bool SActorKeywordProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorKeywordProxiesSaveData::operator==(const SActorKeywordProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorKeywordProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SActorKeywordProxiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);
	s_Object->~SActorKeywordProxiesSaveData();
}

ZHMTypeInfo SActorManagerReferencableData::TypeInfo = ZHMTypeInfo("SActorManagerReferencableData", sizeof(SActorManagerReferencableData), alignof(SActorManagerReferencableData), SActorManagerReferencableData::WriteSimpleJson, SActorManagerReferencableData::FromSimpleJson, SActorManagerReferencableData::Serialize, SActorManagerReferencableData::Equals, SActorManagerReferencableData::Destroy);

void SActorManagerReferencableData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSituationTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSituationTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSituationTypes[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationType", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aSituationTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorManagerReferencableData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSituationTypes"];
	s_Object->m_aSituationTypes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aSituationTypes[s_Index0] = static_cast<ESituationType>(ZHMEnums::GetEnumValueByName("ESituationType", std::string_view(s_Item0)));
		++s_Index0;
	}
	}

}

void SActorManagerReferencableData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);

	TArray<ESituationType>::Serialize(&s_Object->m_aSituationTypes, p_Serializer, p_OwnOffset + offsetof(SActorManagerReferencableData, m_aSituationTypes));
}

bool SActorManagerReferencableData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorManagerReferencableData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorManagerReferencableData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorManagerReferencableData::operator==(const SActorManagerReferencableData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorManagerReferencableData>)
		return false;

	if (m_aSituationTypes != p_Other.m_aSituationTypes) return false;

	return true;
}

void SActorManagerReferencableData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);
	s_Object->~SActorManagerReferencableData();
}

ZHMTypeInfo SMatrix::TypeInfo = ZHMTypeInfo("SMatrix", sizeof(SMatrix), alignof(SMatrix), SMatrix::WriteSimpleJson, SMatrix::FromSimpleJson, SMatrix::Serialize, SMatrix::Equals, SMatrix::Destroy);

void SMatrix::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	float4::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	float4::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	float4::WriteSimpleJson(&s_Object->ZAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	float4::WriteSimpleJson(&s_Object->Trans, p_Stream);

	p_Stream << "}";
}

void SMatrix::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMatrix*>(p_Target);

	float4::FromSimpleJson(p_Document["XAxis"], &s_Object->XAxis);

	float4::FromSimpleJson(p_Document["YAxis"], &s_Object->YAxis);

	float4::FromSimpleJson(p_Document["ZAxis"], &s_Object->ZAxis);

	float4::FromSimpleJson(p_Document["Trans"], &s_Object->Trans);

}

void SMatrix::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	float4::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, XAxis));
	float4::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, YAxis));
	float4::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, ZAxis));
	float4::Serialize(&s_Object->Trans, p_Serializer, p_OwnOffset + offsetof(SMatrix, Trans));
}

bool SMatrix::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix::operator==(const SMatrix& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;
	if (Trans != p_Other.Trans) return false;

	return true;
}

void SMatrix::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);
	s_Object->~SMatrix();
}

ZHMTypeInfo SEventSaveData::TypeInfo = ZHMTypeInfo("SEventSaveData", sizeof(SEventSaveData), alignof(SEventSaveData), SEventSaveData::WriteSimpleJson, SEventSaveData::FromSimpleJson, SEventSaveData::Serialize, SEventSaveData::Equals, SEventSaveData::Destroy);

void SEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_nType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nEnd, p_Stream);

	p_Stream << "}";
}

void SEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEventSaveData*>(p_Target);

	s_Object->m_nType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_nType"])));

	ZGameTime::FromSimpleJson(p_Document["m_nStart"], &s_Object->m_nStart);

	ZGameTime::FromSimpleJson(p_Document["m_nEnd"], &s_Object->m_nEnd);

}

void SEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_nStart, p_Serializer, p_OwnOffset + offsetof(SEventSaveData, m_nStart));
	ZGameTime::Serialize(&s_Object->m_nEnd, p_Serializer, p_OwnOffset + offsetof(SEventSaveData, m_nEnd));
}

bool SEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventSaveData::operator==(const SEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventSaveData>)
		return false;

	if (m_nType != p_Other.m_nType) return false;
	if (m_nStart != p_Other.m_nStart) return false;
	if (m_nEnd != p_Other.m_nEnd) return false;

	return true;
}

void SEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);
	s_Object->~SEventSaveData();
}

ZHMTypeInfo SSituationGroupSaveData::TypeInfo = ZHMTypeInfo("SSituationGroupSaveData", sizeof(SSituationGroupSaveData), alignof(SSituationGroupSaveData), SSituationGroupSaveData::WriteSimpleJson, SSituationGroupSaveData::FromSimpleJson, SSituationGroupSaveData::Serialize, SSituationGroupSaveData::Equals, SSituationGroupSaveData::Destroy);

void SSituationGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sClassTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sClassTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Target);

	s_Object->m_sClassTypeName = std::string_view(p_Document["m_sClassTypeName"]);

	s_Object->m_nSituation = simdjson::from_json_uint32(p_Document["m_nSituation"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActors"];
	s_Object->m_aActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aActors[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_nGroupID = simdjson::from_json_int32(p_Document["m_nGroupID"]);

	ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Object->m_CustomData);

}

void SSituationGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sClassTypeName, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_sClassTypeName));
	TArray<uint32>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_aActors));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_CustomData));
}

bool SSituationGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationGroupSaveData::operator==(const SSituationGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationGroupSaveData>)
		return false;

	if (m_sClassTypeName != p_Other.m_sClassTypeName) return false;
	if (m_nSituation != p_Other.m_nSituation) return false;
	if (m_aActors != p_Other.m_aActors) return false;
	if (m_nGroupID != p_Other.m_nGroupID) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

void SSituationGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);
	s_Object->~SSituationGroupSaveData();
}

ZHMTypeInfo SSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SSituationMemberSaveData", sizeof(SSituationMemberSaveData), alignof(SSituationMemberSaveData), SSituationMemberSaveData::WriteSimpleJson, SSituationMemberSaveData::FromSimpleJson, SSituationMemberSaveData::Serialize, SSituationMemberSaveData::Equals, SSituationMemberSaveData::Destroy);

void SSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eJoinReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationJoinReason", static_cast<int>(s_Object->m_eJoinReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOrderValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOrderValid);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_OrderData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PendingOrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_PendingOrderData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDramaRole") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDramaRole);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object->m_eJoinReason = static_cast<ESituationJoinReason>(ZHMEnums::GetEnumValueByName("ESituationJoinReason", std::string_view(p_Document["m_eJoinReason"])));

	s_Object->m_bIsOrderValid = simdjson::from_json_bool(p_Document["m_bIsOrderValid"]);

	ZVariant::FromSimpleJson(p_Document["m_OrderData"], &s_Object->m_OrderData);

	ZVariant::FromSimpleJson(p_Document["m_PendingOrderData"], &s_Object->m_PendingOrderData);

	s_Object->m_rDramaRole = simdjson::from_json_uint32(p_Document["m_rDramaRole"]);

	ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Object->m_CustomData);

}

void SSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_OrderData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_OrderData));
	ZVariant::Serialize(&s_Object->m_PendingOrderData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_PendingOrderData));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_CustomData));
}

bool SSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationMemberSaveData::operator==(const SSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationMemberSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_eJoinReason != p_Other.m_eJoinReason) return false;
	if (m_bIsOrderValid != p_Other.m_bIsOrderValid) return false;
	if (m_OrderData != p_Other.m_OrderData) return false;
	if (m_PendingOrderData != p_Other.m_PendingOrderData) return false;
	if (m_rDramaRole != p_Other.m_rDramaRole) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

void SSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);
	s_Object->~SSituationMemberSaveData();
}

ZHMTypeInfo SSituationSaveData::TypeInfo = ZHMTypeInfo("SSituationSaveData", sizeof(SSituationSaveData), alignof(SSituationSaveData), SSituationSaveData::WriteSimpleJson, SSituationSaveData::FromSimpleJson, SSituationSaveData::Serialize, SSituationSaveData::Equals, SSituationSaveData::Destroy);

void SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetSharedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetSharedEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMemberData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMemberData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMemberData[i];
		SSituationMemberSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aMemberData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGroupData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGroupData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGroupData[i];
		SSituationGroupSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGroupData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNextGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNextGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_situationStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_situationStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationEnded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationEnded);

	p_Stream << "}";
}

void SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSituationSaveData*>(p_Target);

	s_Object->m_rSituation = simdjson::from_json_uint32(p_Document["m_rSituation"]);

	s_Object->m_eType = static_cast<ESituationType>(ZHMEnums::GetEnumValueByName("ESituationType", std::string_view(p_Document["m_eType"])));

	s_Object->m_nTargetSharedEntity = simdjson::from_json_int32(p_Document["m_nTargetSharedEntity"]);

	ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Object->m_Data);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aMemberData"];
	s_Object->m_aMemberData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSituationMemberSaveData::FromSimpleJson(s_Item0, &s_Object->m_aMemberData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGroupData"];
	s_Object->m_aGroupData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSituationGroupSaveData::FromSimpleJson(s_Item0, &s_Object->m_aGroupData[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_nNextGroupID = simdjson::from_json_int32(p_Document["m_nNextGroupID"]);

	ZGameTime::FromSimpleJson(p_Document["m_situationStartTime"], &s_Object->m_situationStartTime);

	s_Object->m_bSituationEnded = simdjson::from_json_bool(p_Document["m_bSituationEnded"]);

}

void SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_Data));
	TArray<SSituationMemberSaveData>::Serialize(&s_Object->m_aMemberData, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_aMemberData));
	TArray<SSituationGroupSaveData>::Serialize(&s_Object->m_aGroupData, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_aGroupData));
	ZGameTime::Serialize(&s_Object->m_situationStartTime, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_situationStartTime));
}

bool SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationSaveData::operator==(const SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationSaveData>)
		return false;

	if (m_rSituation != p_Other.m_rSituation) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_nTargetSharedEntity != p_Other.m_nTargetSharedEntity) return false;
	if (m_Data != p_Other.m_Data) return false;
	if (m_aMemberData != p_Other.m_aMemberData) return false;
	if (m_aGroupData != p_Other.m_aGroupData) return false;
	if (m_nNextGroupID != p_Other.m_nNextGroupID) return false;
	if (m_situationStartTime != p_Other.m_situationStartTime) return false;
	if (m_bSituationEnded != p_Other.m_bSituationEnded) return false;

	return true;
}

void SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo SActorProviderApproachSaveData::TypeInfo = ZHMTypeInfo("SActorProviderApproachSaveData", sizeof(SActorProviderApproachSaveData), alignof(SActorProviderApproachSaveData), SActorProviderApproachSaveData::WriteSimpleJson, SActorProviderApproachSaveData::FromSimpleJson, SActorProviderApproachSaveData::Serialize, SActorProviderApproachSaveData::Equals, SActorProviderApproachSaveData::Destroy);

void SActorProviderApproachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCastActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCastActor);

	p_Stream << "}";
}

void SActorProviderApproachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Target);

	s_Object->m_rCastActor = simdjson::from_json_uint32(p_Document["m_rCastActor"]);

}

void SActorProviderApproachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);

}

bool SActorProviderApproachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProviderApproachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProviderApproachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProviderApproachSaveData::operator==(const SActorProviderApproachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProviderApproachSaveData>)
		return false;

	if (m_rCastActor != p_Other.m_rCastActor) return false;

	return true;
}

void SActorProviderApproachSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);
	s_Object->~SActorProviderApproachSaveData();
}

ZHMTypeInfo SKnownEntitySaveData::TypeInfo = ZHMTypeInfo("SKnownEntitySaveData", sizeof(SKnownEntitySaveData), alignof(SKnownEntitySaveData), SKnownEntitySaveData::WriteSimpleJson, SKnownEntitySaveData::FromSimpleJson, SKnownEntitySaveData::Serialize, SKnownEntitySaveData::Equals, SKnownEntitySaveData::Destroy);

void SKnownEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nSharedIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSharedIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEvents[i];
		SAIEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBooleanEvents") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBooleanEvents);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBooleanEventsHandled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBooleanEventsHandled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_knownWorldMatrix") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_knownWorldMatrix, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWorldMatrixUpdate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastWorldMatrixUpdate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGoals") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGoals);

	p_Stream << "}";
}

void SKnownEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Target);

	s_Object->m_nSharedIndex = simdjson::from_json_int32(p_Document["m_nSharedIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEvents"];
	s_Object->m_aEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAIEventSaveData::FromSimpleJson(s_Item0, &s_Object->m_aEvents[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_nBooleanEvents = simdjson::from_json_uint32(p_Document["m_nBooleanEvents"]);

	s_Object->m_nBooleanEventsHandled = simdjson::from_json_uint32(p_Document["m_nBooleanEventsHandled"]);

	SMatrix::FromSimpleJson(p_Document["m_knownWorldMatrix"], &s_Object->m_knownWorldMatrix);

	ZGameTime::FromSimpleJson(p_Document["m_tLastWorldMatrixUpdate"], &s_Object->m_tLastWorldMatrixUpdate);

	s_Object->m_nGoals = simdjson::from_json_uint16(p_Document["m_nGoals"]);

}

void SKnownEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);

	TArray<SAIEventSaveData>::Serialize(&s_Object->m_aEvents, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_aEvents));
	SMatrix::Serialize(&s_Object->m_knownWorldMatrix, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_knownWorldMatrix));
	ZGameTime::Serialize(&s_Object->m_tLastWorldMatrixUpdate, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_tLastWorldMatrixUpdate));
}

bool SKnownEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKnownEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKnownEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKnownEntitySaveData::operator==(const SKnownEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKnownEntitySaveData>)
		return false;

	if (m_nSharedIndex != p_Other.m_nSharedIndex) return false;
	if (m_aEvents != p_Other.m_aEvents) return false;
	if (m_nBooleanEvents != p_Other.m_nBooleanEvents) return false;
	if (m_nBooleanEventsHandled != p_Other.m_nBooleanEventsHandled) return false;
	if (m_knownWorldMatrix != p_Other.m_knownWorldMatrix) return false;
	if (m_tLastWorldMatrixUpdate != p_Other.m_tLastWorldMatrixUpdate) return false;
	if (m_nGoals != p_Other.m_nGoals) return false;

	return true;
}

void SKnownEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);
	s_Object->~SKnownEntitySaveData();
}

ZHMTypeInfo SKnowledgeSaveData::TypeInfo = ZHMTypeInfo("SKnowledgeSaveData", sizeof(SKnowledgeSaveData), alignof(SKnowledgeSaveData), SKnowledgeSaveData::WriteSimpleJson, SKnowledgeSaveData::FromSimpleJson, SKnowledgeSaveData::Serialize, SKnowledgeSaveData::Equals, SKnowledgeSaveData::Destroy);

void SKnowledgeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKnownEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKnownEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKnownEntities[i];
		SKnownEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aKnownEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGoalKeys") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGoalKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGoalKeys[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIGoal", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aGoalKeys.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGoals") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGoals.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGoals[i];
		SActorGoalSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGoals.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMAttentionLastUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMAttentionLastUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMDisguiseAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMDisguiseAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMTrespassingAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMTrespassingAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMLastTrespassingAttentionMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMLastTrespassingAttentionMax);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTrespassingAttentionGain") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTrespassingAttentionGain, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastAttentionEvaluate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastAttentionEvaluate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMWeaponAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMWeaponAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMWeaponAttentionChange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMWeaponAttentionChange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGameTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eGameTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAmbientStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAmbientStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tExpiredAIModifierSuppressSocialGreeting") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiredAIModifierSuppressSocialGreeting, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_behaviorModifiers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_behaviorModifiers);

	p_Stream << "}";
}

void SKnowledgeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKnownEntities"];
	s_Object->m_aKnownEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SKnownEntitySaveData::FromSimpleJson(s_Item0, &s_Object->m_aKnownEntities[s_Index0]);
		++s_Index0;
	}
	}

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGoalKeys"])
	{
		s_Object->m_aGoalKeys[s_Index0] = static_cast<EAIGoal>(ZHMEnums::GetEnumValueByName("EAIGoal", std::string_view(s_Item0)));
		++s_Index0;
	}
	}

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_aGoals"])
	{
		SActorGoalSaveData::FromSimpleJson(s_Item0, &s_Object->m_aGoals[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_fHMAttention = simdjson::from_json_float32(p_Document["m_fHMAttention"]);

	s_Object->m_fHMAttentionLastUpdate = simdjson::from_json_float32(p_Document["m_fHMAttentionLastUpdate"]);

	s_Object->m_fHMDisguiseAttention = simdjson::from_json_float32(p_Document["m_fHMDisguiseAttention"]);

	s_Object->m_fHMTrespassingAttention = simdjson::from_json_float32(p_Document["m_fHMTrespassingAttention"]);

	s_Object->m_fHMLastTrespassingAttentionMax = simdjson::from_json_float32(p_Document["m_fHMLastTrespassingAttentionMax"]);

	ZGameTime::FromSimpleJson(p_Document["m_tLastTrespassingAttentionGain"], &s_Object->m_tLastTrespassingAttentionGain);

	ZGameTime::FromSimpleJson(p_Document["m_tLastAttentionEvaluate"], &s_Object->m_tLastAttentionEvaluate);

	s_Object->m_fHMWeaponAttention = simdjson::from_json_float32(p_Document["m_fHMWeaponAttention"]);

	s_Object->m_fHMWeaponAttentionChange = simdjson::from_json_float32(p_Document["m_fHMWeaponAttentionChange"]);

	s_Object->m_eGameTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eGameTension"])));

	ZGameTime::FromSimpleJson(p_Document["m_tAmbientStartTime"], &s_Object->m_tAmbientStartTime);

	ZGameTime::FromSimpleJson(p_Document["m_tExpiredAIModifierSuppressSocialGreeting"], &s_Object->m_tExpiredAIModifierSuppressSocialGreeting);

	s_Object->m_behaviorModifiers = simdjson::from_json_uint32(p_Document["m_behaviorModifiers"]);

}

void SKnowledgeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);

	TArray<SKnownEntitySaveData>::Serialize(&s_Object->m_aKnownEntities, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aKnownEntities));
	TFixedArray<EAIGoal, 31>::Serialize(&s_Object->m_aGoalKeys, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aGoalKeys));
	TFixedArray<SActorGoalSaveData, 31>::Serialize(&s_Object->m_aGoals, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aGoals));
	ZGameTime::Serialize(&s_Object->m_tLastTrespassingAttentionGain, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tLastTrespassingAttentionGain));
	ZGameTime::Serialize(&s_Object->m_tLastAttentionEvaluate, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tLastAttentionEvaluate));
	ZGameTime::Serialize(&s_Object->m_tAmbientStartTime, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tAmbientStartTime));
	ZGameTime::Serialize(&s_Object->m_tExpiredAIModifierSuppressSocialGreeting, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tExpiredAIModifierSuppressSocialGreeting));
}

bool SKnowledgeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKnowledgeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKnowledgeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKnowledgeSaveData::operator==(const SKnowledgeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKnowledgeSaveData>)
		return false;

	if (m_aKnownEntities != p_Other.m_aKnownEntities) return false;
	if (m_aGoalKeys != p_Other.m_aGoalKeys) return false;
	if (m_aGoals != p_Other.m_aGoals) return false;
	if (m_fHMAttention != p_Other.m_fHMAttention) return false;
	if (m_fHMAttentionLastUpdate != p_Other.m_fHMAttentionLastUpdate) return false;
	if (m_fHMDisguiseAttention != p_Other.m_fHMDisguiseAttention) return false;
	if (m_fHMTrespassingAttention != p_Other.m_fHMTrespassingAttention) return false;
	if (m_fHMLastTrespassingAttentionMax != p_Other.m_fHMLastTrespassingAttentionMax) return false;
	if (m_tLastTrespassingAttentionGain != p_Other.m_tLastTrespassingAttentionGain) return false;
	if (m_tLastAttentionEvaluate != p_Other.m_tLastAttentionEvaluate) return false;
	if (m_fHMWeaponAttention != p_Other.m_fHMWeaponAttention) return false;
	if (m_fHMWeaponAttentionChange != p_Other.m_fHMWeaponAttentionChange) return false;
	if (m_eGameTension != p_Other.m_eGameTension) return false;
	if (m_tAmbientStartTime != p_Other.m_tAmbientStartTime) return false;
	if (m_tExpiredAIModifierSuppressSocialGreeting != p_Other.m_tExpiredAIModifierSuppressSocialGreeting) return false;
	if (m_behaviorModifiers != p_Other.m_behaviorModifiers) return false;

	return true;
}

void SKnowledgeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);
	s_Object->~SKnowledgeSaveData();
}

ZHMTypeInfo SEventHistorySaveData::TypeInfo = ZHMTypeInfo("SEventHistorySaveData", sizeof(SEventHistorySaveData), alignof(SEventHistorySaveData), SEventHistorySaveData::WriteSimpleJson, SEventHistorySaveData::FromSimpleJson, SEventHistorySaveData::Serialize, SEventHistorySaveData::Equals, SEventHistorySaveData::Destroy);

void SEventHistorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aOccurences") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aOccurences.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aOccurences[i];
		ZGameTime::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aOccurences.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEventHistorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aOccurences"];
	s_Object->m_aOccurences.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZGameTime::FromSimpleJson(s_Item0, &s_Object->m_aOccurences[s_Index0]);
		++s_Index0;
	}
	}

}

void SEventHistorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);

	TArray<ZGameTime>::Serialize(&s_Object->m_aOccurences, p_Serializer, p_OwnOffset + offsetof(SEventHistorySaveData, m_aOccurences));
}

bool SEventHistorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventHistorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventHistorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventHistorySaveData::operator==(const SEventHistorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventHistorySaveData>)
		return false;

	if (m_aOccurences != p_Other.m_aOccurences) return false;

	return true;
}

void SEventHistorySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);
	s_Object->~SEventHistorySaveData();
}

ZHMTypeInfo SActorRagdollPoseSaveData::TypeInfo = ZHMTypeInfo("SActorRagdollPoseSaveData", sizeof(SActorRagdollPoseSaveData), alignof(SActorRagdollPoseSaveData), SActorRagdollPoseSaveData::WriteSimpleJson, SActorRagdollPoseSaveData::FromSimpleJson, SActorRagdollPoseSaveData::Serialize, SActorRagdollPoseSaveData::Equals, SActorRagdollPoseSaveData::Destroy);

void SActorRagdollPoseSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vBodyVelocity") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vBodyVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SActorBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBoneIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorRagdollPoseSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Target);

	SVector3::FromSimpleJson(p_Document["m_vBodyVelocity"], &s_Object->m_vBodyVelocity);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBones"];
	s_Object->m_aBones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorBoneSaveData::FromSimpleJson(s_Item0, &s_Object->m_aBones[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneIndices"];
	s_Object->m_aBoneIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aBoneIndices[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SActorRagdollPoseSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vBodyVelocity, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_vBodyVelocity));
	TArray<SActorBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_aBones));
	TArray<uint32>::Serialize(&s_Object->m_aBoneIndices, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_aBoneIndices));
}

bool SActorRagdollPoseSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorRagdollPoseSaveData::operator==(const SActorRagdollPoseSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorRagdollPoseSaveData>)
		return false;

	if (m_vBodyVelocity != p_Other.m_vBodyVelocity) return false;
	if (m_aBones != p_Other.m_aBones) return false;
	if (m_aBoneIndices != p_Other.m_aBoneIndices) return false;

	return true;
}

void SActorRagdollPoseSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);
	s_Object->~SActorRagdollPoseSaveData();
}

ZHMTypeInfo SActorProviderDirectSaveData::TypeInfo = ZHMTypeInfo("SActorProviderDirectSaveData", sizeof(SActorProviderDirectSaveData), alignof(SActorProviderDirectSaveData), SActorProviderDirectSaveData::WriteSimpleJson, SActorProviderDirectSaveData::FromSimpleJson, SActorProviderDirectSaveData::Serialize, SActorProviderDirectSaveData::Equals, SActorProviderDirectSaveData::Destroy);

void SActorProviderDirectSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunning);

	p_Stream << "}";
}

void SActorProviderDirectSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActors"];
	s_Object->m_aActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aActors[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_bRunning = simdjson::from_json_bool(p_Document["m_bRunning"]);

}

void SActorProviderDirectSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SActorProviderDirectSaveData, m_aActors));
}

bool SActorProviderDirectSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProviderDirectSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProviderDirectSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProviderDirectSaveData::operator==(const SActorProviderDirectSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProviderDirectSaveData>)
		return false;

	if (m_aActors != p_Other.m_aActors) return false;
	if (m_bRunning != p_Other.m_bRunning) return false;

	return true;
}

void SActorProviderDirectSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);
	s_Object->~SActorProviderDirectSaveData();
}

ZHMTypeInfo SActorProxySaveData::TypeInfo = ZHMTypeInfo("SActorProxySaveData", sizeof(SActorProxySaveData), alignof(SActorProxySaveData), SActorProxySaveData::WriteSimpleJson, SActorProxySaveData::FromSimpleJson, SActorProxySaveData::Serialize, SActorProxySaveData::Equals, SActorProxySaveData::Destroy);

void SActorProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorProxySaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SActorProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);

}

bool SActorProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProxySaveData::operator==(const SActorProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProxySaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorProxySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);
	s_Object->~SActorProxySaveData();
}

ZHMTypeInfo SActorProxiesSaveData::TypeInfo = ZHMTypeInfo("SActorProxiesSaveData", sizeof(SActorProxiesSaveData), alignof(SActorProxiesSaveData), SActorProxiesSaveData::WriteSimpleJson, SActorProxiesSaveData::FromSimpleJson, SActorProxiesSaveData::Serialize, SActorProxiesSaveData::Equals, SActorProxiesSaveData::Destroy);

void SActorProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorProxySaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SActorProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorProxiesSaveData, m_aEntities));
	TArray<SActorProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorProxiesSaveData, m_aData));
}

bool SActorProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProxiesSaveData::operator==(const SActorProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SActorProxiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);
	s_Object->~SActorProxiesSaveData();
}

ZHMTypeInfo SActorSpreadControllerCandidateSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadControllerCandidateSaveData", sizeof(SActorSpreadControllerCandidateSaveData), alignof(SActorSpreadControllerCandidateSaveData), SActorSpreadControllerCandidateSaveData::WriteSimpleJson, SActorSpreadControllerCandidateSaveData::FromSimpleJson, SActorSpreadControllerCandidateSaveData::Serialize, SActorSpreadControllerCandidateSaveData::Equals, SActorSpreadControllerCandidateSaveData::Destroy);

void SActorSpreadControllerCandidateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CandidateActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CandidateActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CandidateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_CandidateTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidCandidate);

	p_Stream << "}";
}

void SActorSpreadControllerCandidateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Target);

	s_Object->m_CandidateActor = simdjson::from_json_uint32(p_Document["m_CandidateActor"]);

	ZGameTime::FromSimpleJson(p_Document["m_CandidateTime"], &s_Object->m_CandidateTime);

	s_Object->m_bValidCandidate = simdjson::from_json_bool(p_Document["m_bValidCandidate"]);

}

void SActorSpreadControllerCandidateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_CandidateTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerCandidateSaveData, m_CandidateTime));
}

bool SActorSpreadControllerCandidateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadControllerCandidateSaveData::operator==(const SActorSpreadControllerCandidateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadControllerCandidateSaveData>)
		return false;

	if (m_CandidateActor != p_Other.m_CandidateActor) return false;
	if (m_CandidateTime != p_Other.m_CandidateTime) return false;
	if (m_bValidCandidate != p_Other.m_bValidCandidate) return false;

	return true;
}

void SActorSpreadControllerCandidateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);
	s_Object->~SActorSpreadControllerCandidateSaveData();
}

ZHMTypeInfo SActorSpreadControllerSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadControllerSaveData", sizeof(SActorSpreadControllerSaveData), alignof(SActorSpreadControllerSaveData), SActorSpreadControllerSaveData::WriteSimpleJson, SActorSpreadControllerSaveData::FromSimpleJson, SActorSpreadControllerSaveData::Serialize, SActorSpreadControllerSaveData::Equals, SActorSpreadControllerSaveData::Destroy);

void SActorSpreadControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSpreadingActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpreadingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpreadingActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSpreadingActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSpreadingActorsAddedTime") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpreadingActorsAddedTime.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpreadingActorsAddedTime[i];
		ZGameTime::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSpreadingActorsAddedTime.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aNewCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aNewCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aNewCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aNewCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		SActorSpreadControllerCandidateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpreadingActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpreadingActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentActorIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerCheckEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerCheckEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerSpreading") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerSpreading);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerIsValidCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerIsValidCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerIsCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerIsCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PlayerCandidateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_PlayerCandidateTime, p_Stream);

	p_Stream << "}";
}

void SActorSpreadControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSpreadingActors"];
	s_Object->m_aSpreadingActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aSpreadingActors[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSpreadingActorsAddedTime"];
	s_Object->m_aSpreadingActorsAddedTime.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZGameTime::FromSimpleJson(s_Item0, &s_Object->m_aSpreadingActorsAddedTime[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aNewCandidates"];
	s_Object->m_aNewCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aNewCandidates[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCandidates"];
	s_Object->m_aCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorSpreadControllerCandidateSaveData::FromSimpleJson(s_Item0, &s_Object->m_aCandidates[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_rCurrentSpreadingActor = simdjson::from_json_uint32(p_Document["m_rCurrentSpreadingActor"]);

	s_Object->m_nCurrentActorIndex = simdjson::from_json_uint32(p_Document["m_nCurrentActorIndex"]);

	s_Object->m_bPlayerCheckEnabled = simdjson::from_json_bool(p_Document["m_bPlayerCheckEnabled"]);

	s_Object->m_bPlayerSpreading = simdjson::from_json_bool(p_Document["m_bPlayerSpreading"]);

	s_Object->m_bPlayerIsValidCandidate = simdjson::from_json_bool(p_Document["m_bPlayerIsValidCandidate"]);

	s_Object->m_bPlayerIsCandidate = simdjson::from_json_bool(p_Document["m_bPlayerIsCandidate"]);

	ZGameTime::FromSimpleJson(p_Document["m_PlayerCandidateTime"], &s_Object->m_PlayerCandidateTime);

}

void SActorSpreadControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aSpreadingActors, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aSpreadingActors));
	TArray<ZGameTime>::Serialize(&s_Object->m_aSpreadingActorsAddedTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aSpreadingActorsAddedTime));
	TArray<uint32>::Serialize(&s_Object->m_aNewCandidates, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aNewCandidates));
	TArray<SActorSpreadControllerCandidateSaveData>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aCandidates));
	ZGameTime::Serialize(&s_Object->m_PlayerCandidateTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_PlayerCandidateTime));
}

bool SActorSpreadControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadControllerSaveData::operator==(const SActorSpreadControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadControllerSaveData>)
		return false;

	if (m_aSpreadingActors != p_Other.m_aSpreadingActors) return false;
	if (m_aSpreadingActorsAddedTime != p_Other.m_aSpreadingActorsAddedTime) return false;
	if (m_aNewCandidates != p_Other.m_aNewCandidates) return false;
	if (m_aCandidates != p_Other.m_aCandidates) return false;
	if (m_rCurrentSpreadingActor != p_Other.m_rCurrentSpreadingActor) return false;
	if (m_nCurrentActorIndex != p_Other.m_nCurrentActorIndex) return false;
	if (m_bPlayerCheckEnabled != p_Other.m_bPlayerCheckEnabled) return false;
	if (m_bPlayerSpreading != p_Other.m_bPlayerSpreading) return false;
	if (m_bPlayerIsValidCandidate != p_Other.m_bPlayerIsValidCandidate) return false;
	if (m_bPlayerIsCandidate != p_Other.m_bPlayerIsCandidate) return false;
	if (m_PlayerCandidateTime != p_Other.m_PlayerCandidateTime) return false;

	return true;
}

void SActorSpreadControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);
	s_Object->~SActorSpreadControllerSaveData();
}

ZHMTypeInfo SActorSpreadTransitionOperatorMaterialActorSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadTransitionOperatorMaterialActorSaveData", sizeof(SActorSpreadTransitionOperatorMaterialActorSaveData), alignof(SActorSpreadTransitionOperatorMaterialActorSaveData), SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson, SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson, SActorSpreadTransitionOperatorMaterialActorSaveData::Serialize, SActorSpreadTransitionOperatorMaterialActorSaveData::Equals, SActorSpreadTransitionOperatorMaterialActorSaveData::Destroy);

void SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Actor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_Actor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpacity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpacity);

	p_Stream << "}";
}

void SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Target);

	s_Object->m_Actor = simdjson::from_json_uint32(p_Document["m_Actor"]);

	s_Object->m_fOpacity = simdjson::from_json_float32(p_Document["m_fOpacity"]);

}

void SActorSpreadTransitionOperatorMaterialActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);

}

bool SActorSpreadTransitionOperatorMaterialActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadTransitionOperatorMaterialActorSaveData::operator==(const SActorSpreadTransitionOperatorMaterialActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadTransitionOperatorMaterialActorSaveData>)
		return false;

	if (m_Actor != p_Other.m_Actor) return false;
	if (m_fOpacity != p_Other.m_fOpacity) return false;

	return true;
}

void SActorSpreadTransitionOperatorMaterialActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);
	s_Object->~SActorSpreadTransitionOperatorMaterialActorSaveData();
}

ZHMTypeInfo SActorSpreadTransitionOperatorMaterialSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadTransitionOperatorMaterialSaveData", sizeof(SActorSpreadTransitionOperatorMaterialSaveData), alignof(SActorSpreadTransitionOperatorMaterialSaveData), SActorSpreadTransitionOperatorMaterialSaveData::WriteSimpleJson, SActorSpreadTransitionOperatorMaterialSaveData::FromSimpleJson, SActorSpreadTransitionOperatorMaterialSaveData::Serialize, SActorSpreadTransitionOperatorMaterialSaveData::Equals, SActorSpreadTransitionOperatorMaterialSaveData::Destroy);

void SActorSpreadTransitionOperatorMaterialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aActorMaterialOverrides") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorMaterialOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorMaterialOverrides[i];
		SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorMaterialOverrides.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorSpreadTransitionOperatorMaterialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActorMaterialOverrides"];
	s_Object->m_aActorMaterialOverrides.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson(s_Item0, &s_Object->m_aActorMaterialOverrides[s_Index0]);
		++s_Index0;
	}
	}

}

void SActorSpreadTransitionOperatorMaterialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);

	TArray<SActorSpreadTransitionOperatorMaterialActorSaveData>::Serialize(&s_Object->m_aActorMaterialOverrides, p_Serializer, p_OwnOffset + offsetof(SActorSpreadTransitionOperatorMaterialSaveData, m_aActorMaterialOverrides));
}

bool SActorSpreadTransitionOperatorMaterialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadTransitionOperatorMaterialSaveData::operator==(const SActorSpreadTransitionOperatorMaterialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadTransitionOperatorMaterialSaveData>)
		return false;

	if (m_aActorMaterialOverrides != p_Other.m_aActorMaterialOverrides) return false;

	return true;
}

void SActorSpreadTransitionOperatorMaterialSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);
	s_Object->~SActorSpreadTransitionOperatorMaterialSaveData();
}

ZHMTypeInfo SActorStandInSaveData::TypeInfo = ZHMTypeInfo("SActorStandInSaveData", sizeof(SActorStandInSaveData), alignof(SActorStandInSaveData), SActorStandInSaveData::WriteSimpleJson, SActorStandInSaveData::FromSimpleJson, SActorStandInSaveData::Serialize, SActorStandInSaveData::Equals, SActorStandInSaveData::Destroy);

void SActorStandInSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorStandInSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SActorStandInSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);

}

bool SActorStandInSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorStandInSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorStandInSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorStandInSaveData::operator==(const SActorStandInSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorStandInSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorStandInSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);
	s_Object->~SActorStandInSaveData();
}

ZHMTypeInfo SActorStandInEntitiesSaveData::TypeInfo = ZHMTypeInfo("SActorStandInEntitiesSaveData", sizeof(SActorStandInEntitiesSaveData), alignof(SActorStandInEntitiesSaveData), SActorStandInEntitiesSaveData::WriteSimpleJson, SActorStandInEntitiesSaveData::FromSimpleJson, SActorStandInEntitiesSaveData::Serialize, SActorStandInEntitiesSaveData::Equals, SActorStandInEntitiesSaveData::Destroy);

void SActorStandInEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorStandInSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorStandInEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorStandInSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SActorStandInEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorStandInEntitiesSaveData, m_aEntities));
	TArray<SActorStandInSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorStandInEntitiesSaveData, m_aData));
}

bool SActorStandInEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorStandInEntitiesSaveData::operator==(const SActorStandInEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorStandInEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SActorStandInEntitiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);
	s_Object->~SActorStandInEntitiesSaveData();
}

ZHMTypeInfo SActorTagSaveData::TypeInfo = ZHMTypeInfo("SActorTagSaveData", sizeof(SActorTagSaveData), alignof(SActorTagSaveData), SActorTagSaveData::WriteSimpleJson, SActorTagSaveData::FromSimpleJson, SActorTagSaveData::Serialize, SActorTagSaveData::Equals, SActorTagSaveData::Destroy);

void SActorTagSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSeen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSeen);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTagged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTagged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rActorRef") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActorRef);

	p_Stream << "}";
}

void SActorTagSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorTagSaveData*>(p_Target);

	s_Object->m_bSeen = simdjson::from_json_bool(p_Document["m_bSeen"]);

	s_Object->m_bTagged = simdjson::from_json_bool(p_Document["m_bTagged"]);

	s_Object->m_rActorRef = simdjson::from_json_uint32(p_Document["m_rActorRef"]);

}

void SActorTagSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);

}

bool SActorTagSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorTagSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorTagSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorTagSaveData::operator==(const SActorTagSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorTagSaveData>)
		return false;

	if (m_bSeen != p_Other.m_bSeen) return false;
	if (m_bTagged != p_Other.m_bTagged) return false;
	if (m_rActorRef != p_Other.m_rActorRef) return false;

	return true;
}

void SActorTagSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);
	s_Object->~SActorTagSaveData();
}

ZHMTypeInfo SActorTagManagerSaveData::TypeInfo = ZHMTypeInfo("SActorTagManagerSaveData", sizeof(SActorTagManagerSaveData), alignof(SActorTagManagerSaveData), SActorTagManagerSaveData::WriteSimpleJson, SActorTagManagerSaveData::FromSimpleJson, SActorTagManagerSaveData::Serialize, SActorTagManagerSaveData::Equals, SActorTagManagerSaveData::Destroy);

void SActorTagManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bContractsCreationMode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContractsCreationMode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTagCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTagCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxTagCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxTagCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTaggingEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTaggingEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorTagData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorTagData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorTagData[i];
		SActorTagSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorTagData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorTagManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Target);

	s_Object->m_bContractsCreationMode = simdjson::from_json_bool(p_Document["m_bContractsCreationMode"]);

	s_Object->m_nTagCount = simdjson::from_json_int32(p_Document["m_nTagCount"]);

	s_Object->m_nMaxTagCount = simdjson::from_json_int32(p_Document["m_nMaxTagCount"]);

	s_Object->m_bTaggingEnabled = simdjson::from_json_bool(p_Document["m_bTaggingEnabled"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActorTagData"];
	s_Object->m_aActorTagData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorTagSaveData::FromSimpleJson(s_Item0, &s_Object->m_aActorTagData[s_Index0]);
		++s_Index0;
	}
	}

}

void SActorTagManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);

	TArray<SActorTagSaveData>::Serialize(&s_Object->m_aActorTagData, p_Serializer, p_OwnOffset + offsetof(SActorTagManagerSaveData, m_aActorTagData));
}

bool SActorTagManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorTagManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorTagManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorTagManagerSaveData::operator==(const SActorTagManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorTagManagerSaveData>)
		return false;

	if (m_bContractsCreationMode != p_Other.m_bContractsCreationMode) return false;
	if (m_nTagCount != p_Other.m_nTagCount) return false;
	if (m_nMaxTagCount != p_Other.m_nMaxTagCount) return false;
	if (m_bTaggingEnabled != p_Other.m_bTaggingEnabled) return false;
	if (m_aActorTagData != p_Other.m_aActorTagData) return false;

	return true;
}

void SActorTagManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);
	s_Object->~SActorTagManagerSaveData();
}

ZHMTypeInfo SAgitatedBystanderOrderSaveData::TypeInfo = ZHMTypeInfo("SAgitatedBystanderOrderSaveData", sizeof(SAgitatedBystanderOrderSaveData), alignof(SAgitatedBystanderOrderSaveData), SAgitatedBystanderOrderSaveData::WriteSimpleJson, SAgitatedBystanderOrderSaveData::FromSimpleJson, SAgitatedBystanderOrderSaveData::Serialize, SAgitatedBystanderOrderSaveData::Equals, SAgitatedBystanderOrderSaveData::Destroy);

void SAgitatedBystanderOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rBystanderPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBystanderPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCover") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCover, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCoverDir") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCoverDir, p_Stream);

	p_Stream << "}";
}

void SAgitatedBystanderOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Target);

	s_Object->m_rBystanderPoint = simdjson::from_json_uint32(p_Document["m_rBystanderPoint"]);

	float4::FromSimpleJson(p_Document["m_vCover"], &s_Object->m_vCover);

	float4::FromSimpleJson(p_Document["m_vCoverDir"], &s_Object->m_vCoverDir);

}

void SAgitatedBystanderOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vCover, p_Serializer, p_OwnOffset + offsetof(SAgitatedBystanderOrderSaveData, m_vCover));
	float4::Serialize(&s_Object->m_vCoverDir, p_Serializer, p_OwnOffset + offsetof(SAgitatedBystanderOrderSaveData, m_vCoverDir));
}

bool SAgitatedBystanderOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAgitatedBystanderOrderSaveData::operator==(const SAgitatedBystanderOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAgitatedBystanderOrderSaveData>)
		return false;

	if (m_rBystanderPoint != p_Other.m_rBystanderPoint) return false;
	if (m_vCover != p_Other.m_vCover) return false;
	if (m_vCoverDir != p_Other.m_vCoverDir) return false;

	return true;
}

void SAgitatedBystanderOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);
	s_Object->~SAgitatedBystanderOrderSaveData();
}

ZHMTypeInfo SBoneTransformSaveData::TypeInfo = ZHMTypeInfo("SBoneTransformSaveData", sizeof(SBoneTransformSaveData), alignof(SBoneTransformSaveData), SBoneTransformSaveData::WriteSimpleJson, SBoneTransformSaveData::FromSimpleJson, SBoneTransformSaveData::Serialize, SBoneTransformSaveData::Equals, SBoneTransformSaveData::Destroy);

void SBoneTransformSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SBoneTransformSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Target);

	SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Object->mQuaterion);

	SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Object->mTranslation);

}

void SBoneTransformSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SBoneTransformSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SBoneTransformSaveData, mTranslation));
}

bool SBoneTransformSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneTransformSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneTransformSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneTransformSaveData::operator==(const SBoneTransformSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneTransformSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

void SBoneTransformSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);
	s_Object->~SBoneTransformSaveData();
}

ZHMTypeInfo SAnimPlayerSaveData::TypeInfo = ZHMTypeInfo("SAnimPlayerSaveData", sizeof(SAnimPlayerSaveData), alignof(SAnimPlayerSaveData), SAnimPlayerSaveData::WriteSimpleJson, SAnimPlayerSaveData::FromSimpleJson, SAnimPlayerSaveData::Serialize, SAnimPlayerSaveData::Equals, SAnimPlayerSaveData::Destroy);

void SAnimPlayerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mTrajectoryQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTrajectoryQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTrajectoryTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTrajectoryTranslation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SBoneTransformSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAnimPlayerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Target);

	SVector4::FromSimpleJson(p_Document["mTrajectoryQuaterion"], &s_Object->mTrajectoryQuaterion);

	SVector4::FromSimpleJson(p_Document["mTrajectoryTranslation"], &s_Object->mTrajectoryTranslation);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBones"];
	s_Object->m_aBones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBoneTransformSaveData::FromSimpleJson(s_Item0, &s_Object->m_aBones[s_Index0]);
		++s_Index0;
	}
	}

}

void SAnimPlayerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mTrajectoryQuaterion, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, mTrajectoryQuaterion));
	SVector4::Serialize(&s_Object->mTrajectoryTranslation, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, mTrajectoryTranslation));
	TArray<SBoneTransformSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, m_aBones));
}

bool SAnimPlayerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimPlayerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimPlayerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimPlayerSaveData::operator==(const SAnimPlayerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimPlayerSaveData>)
		return false;

	if (mTrajectoryQuaterion != p_Other.mTrajectoryQuaterion) return false;
	if (mTrajectoryTranslation != p_Other.mTrajectoryTranslation) return false;
	if (m_aBones != p_Other.m_aBones) return false;

	return true;
}

void SAnimPlayerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);
	s_Object->~SAnimPlayerSaveData();
}

ZHMTypeInfo SAnimatedActorActOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorActOrderSaveData", sizeof(SAnimatedActorActOrderSaveData), alignof(SAnimatedActorActOrderSaveData), SAnimatedActorActOrderSaveData::WriteSimpleJson, SAnimatedActorActOrderSaveData::FromSimpleJson, SAnimatedActorActOrderSaveData::Serialize, SAnimatedActorActOrderSaveData::Equals, SAnimatedActorActOrderSaveData::Destroy);

void SAnimatedActorActOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bOverrideExistingAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOverrideExistingAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nForcedAnimationNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nForcedAnimationNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vOriginPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginQuaternion") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vOriginQuaternion, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorActOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Target);

	s_Object->m_bOverrideExistingAct = simdjson::from_json_bool(p_Document["m_bOverrideExistingAct"]);

	s_Object->m_nForcedAnimationNode = simdjson::from_json_uint32(p_Document["m_nForcedAnimationNode"]);

	s_Object->m_rChildNetworkAct = simdjson::from_json_uint32(p_Document["m_rChildNetworkAct"]);

	SVector3::FromSimpleJson(p_Document["m_vOriginPosition"], &s_Object->m_vOriginPosition);

	SVector4::FromSimpleJson(p_Document["m_vOriginQuaternion"], &s_Object->m_vOriginQuaternion);

}

void SAnimatedActorActOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vOriginPosition, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorActOrderSaveData, m_vOriginPosition));
	SVector4::Serialize(&s_Object->m_vOriginQuaternion, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorActOrderSaveData, m_vOriginQuaternion));
}

bool SAnimatedActorActOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorActOrderSaveData::operator==(const SAnimatedActorActOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorActOrderSaveData>)
		return false;

	if (m_bOverrideExistingAct != p_Other.m_bOverrideExistingAct) return false;
	if (m_nForcedAnimationNode != p_Other.m_nForcedAnimationNode) return false;
	if (m_rChildNetworkAct != p_Other.m_rChildNetworkAct) return false;
	if (m_vOriginPosition != p_Other.m_vOriginPosition) return false;
	if (m_vOriginQuaternion != p_Other.m_vOriginQuaternion) return false;

	return true;
}

void SAnimatedActorActOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorActOrderSaveData();
}

ZHMTypeInfo SAnimatedActorMoveOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorMoveOrderSaveData", sizeof(SAnimatedActorMoveOrderSaveData), alignof(SAnimatedActorMoveOrderSaveData), SAnimatedActorMoveOrderSaveData::WriteSimpleJson, SAnimatedActorMoveOrderSaveData::FromSimpleJson, SAnimatedActorMoveOrderSaveData::Serialize, SAnimatedActorMoveOrderSaveData::Equals, SAnimatedActorMoveOrderSaveData::Destroy);

void SAnimatedActorMoveOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPrecisePositioning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPrecisePositioning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPreciseOrientation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPreciseOrientation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreEndCollision") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreEndCollision);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForcedEnpointSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForcedEnpointSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStopMoveDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStopMoveDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vWaypoint") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vWaypoint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vFacingDirection") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFacingDirection, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorMoveOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Target);

	s_Object->m_bPrecisePositioning = simdjson::from_json_bool(p_Document["m_bPrecisePositioning"]);

	s_Object->m_bPreciseOrientation = simdjson::from_json_bool(p_Document["m_bPreciseOrientation"]);

	s_Object->m_bIgnoreEndCollision = simdjson::from_json_bool(p_Document["m_bIgnoreEndCollision"]);

	s_Object->m_bForcedEnpointSet = simdjson::from_json_bool(p_Document["m_bForcedEnpointSet"]);

	s_Object->m_fStopMoveDistance = simdjson::from_json_float32(p_Document["m_fStopMoveDistance"]);

	SVector3::FromSimpleJson(p_Document["m_vWaypoint"], &s_Object->m_vWaypoint);

	SVector3::FromSimpleJson(p_Document["m_vFacingDirection"], &s_Object->m_vFacingDirection);

}

void SAnimatedActorMoveOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vWaypoint, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorMoveOrderSaveData, m_vWaypoint));
	SVector3::Serialize(&s_Object->m_vFacingDirection, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorMoveOrderSaveData, m_vFacingDirection));
}

bool SAnimatedActorMoveOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorMoveOrderSaveData::operator==(const SAnimatedActorMoveOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorMoveOrderSaveData>)
		return false;

	if (m_bPrecisePositioning != p_Other.m_bPrecisePositioning) return false;
	if (m_bPreciseOrientation != p_Other.m_bPreciseOrientation) return false;
	if (m_bIgnoreEndCollision != p_Other.m_bIgnoreEndCollision) return false;
	if (m_bForcedEnpointSet != p_Other.m_bForcedEnpointSet) return false;
	if (m_fStopMoveDistance != p_Other.m_fStopMoveDistance) return false;
	if (m_vWaypoint != p_Other.m_vWaypoint) return false;
	if (m_vFacingDirection != p_Other.m_vFacingDirection) return false;

	return true;
}

void SAnimatedActorMoveOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorMoveOrderSaveData();
}

ZHMTypeInfo SAnimatedActorOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorOrderSaveData", sizeof(SAnimatedActorOrderSaveData), alignof(SAnimatedActorOrderSaveData), SAnimatedActorOrderSaveData::WriteSimpleJson, SAnimatedActorOrderSaveData::FromSimpleJson, SAnimatedActorOrderSaveData::Serialize, SAnimatedActorOrderSaveData::Equals, SAnimatedActorOrderSaveData::Destroy);

void SAnimatedActorOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eOrderType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorAnimationOrder", static_cast<int>(s_Object->m_eOrderType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_OrderData, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Target);

	s_Object->m_eOrderType = static_cast<EActorAnimationOrder>(ZHMEnums::GetEnumValueByName("EActorAnimationOrder", std::string_view(p_Document["m_eOrderType"])));

	ZVariant::FromSimpleJson(p_Document["m_OrderData"], &s_Object->m_OrderData);

}

void SAnimatedActorOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_OrderData, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorOrderSaveData, m_OrderData));
}

bool SAnimatedActorOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorOrderSaveData::operator==(const SAnimatedActorOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorOrderSaveData>)
		return false;

	if (m_eOrderType != p_Other.m_eOrderType) return false;
	if (m_OrderData != p_Other.m_OrderData) return false;

	return true;
}

void SAnimatedActorOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorOrderSaveData();
}

ZHMTypeInfo SAnimatedActorReactOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorReactOrderSaveData", sizeof(SAnimatedActorReactOrderSaveData), alignof(SAnimatedActorReactOrderSaveData), SAnimatedActorReactOrderSaveData::WriteSimpleJson, SAnimatedActorReactOrderSaveData::FromSimpleJson, SAnimatedActorReactOrderSaveData::Serialize, SAnimatedActorReactOrderSaveData::Equals, SAnimatedActorReactOrderSaveData::Destroy);

void SAnimatedActorReactOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vFaceTarget") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFaceTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLookAtTarget") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLookAtTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_targetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadbody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadbody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bExplosion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bExplosion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropCarriedItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropCarriedItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFaceTargetSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFaceTargetSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLookAtTargetSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAtTargetSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAct);

	p_Stream << "}";
}

void SAnimatedActorReactOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Target);

	SVector3::FromSimpleJson(p_Document["m_vFaceTarget"], &s_Object->m_vFaceTarget);

	SVector3::FromSimpleJson(p_Document["m_vLookAtTarget"], &s_Object->m_vLookAtTarget);

	s_Object->m_rChildNetworkEntity = simdjson::from_json_uint32(p_Document["m_rChildNetworkEntity"]);

	s_Object->m_targetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_targetEmotionState"])));

	s_Object->m_bDeadbody = simdjson::from_json_bool(p_Document["m_bDeadbody"]);

	s_Object->m_bExplosion = simdjson::from_json_bool(p_Document["m_bExplosion"]);

	s_Object->m_bTrespassing = simdjson::from_json_bool(p_Document["m_bTrespassing"]);

	s_Object->m_bDropCarriedItems = simdjson::from_json_bool(p_Document["m_bDropCarriedItems"]);

	s_Object->m_bFaceTargetSet = simdjson::from_json_bool(p_Document["m_bFaceTargetSet"]);

	s_Object->m_bLookAtTargetSet = simdjson::from_json_bool(p_Document["m_bLookAtTargetSet"]);

	s_Object->m_sAct = std::string_view(p_Document["m_sAct"]);

}

void SAnimatedActorReactOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vFaceTarget, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_vFaceTarget));
	SVector3::Serialize(&s_Object->m_vLookAtTarget, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_vLookAtTarget));
	ZString::Serialize(&s_Object->m_sAct, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_sAct));
}

bool SAnimatedActorReactOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorReactOrderSaveData::operator==(const SAnimatedActorReactOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorReactOrderSaveData>)
		return false;

	if (m_vFaceTarget != p_Other.m_vFaceTarget) return false;
	if (m_vLookAtTarget != p_Other.m_vLookAtTarget) return false;
	if (m_rChildNetworkEntity != p_Other.m_rChildNetworkEntity) return false;
	if (m_targetEmotionState != p_Other.m_targetEmotionState) return false;
	if (m_bDeadbody != p_Other.m_bDeadbody) return false;
	if (m_bExplosion != p_Other.m_bExplosion) return false;
	if (m_bTrespassing != p_Other.m_bTrespassing) return false;
	if (m_bDropCarriedItems != p_Other.m_bDropCarriedItems) return false;
	if (m_bFaceTargetSet != p_Other.m_bFaceTargetSet) return false;
	if (m_bLookAtTargetSet != p_Other.m_bLookAtTargetSet) return false;
	if (m_sAct != p_Other.m_sAct) return false;

	return true;
}

void SAnimatedActorReactOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorReactOrderSaveData();
}

ZHMTypeInfo SAnimatedActorStandOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorStandOrderSaveData", sizeof(SAnimatedActorStandOrderSaveData), alignof(SAnimatedActorStandOrderSaveData), SAnimatedActorStandOrderSaveData::WriteSimpleJson, SAnimatedActorStandOrderSaveData::FromSimpleJson, SAnimatedActorStandOrderSaveData::Serialize, SAnimatedActorStandOrderSaveData::Equals, SAnimatedActorStandOrderSaveData::Destroy);

void SAnimatedActorStandOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vFacingDirection") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFacingDirection, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorStandOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Target);

	SVector3::FromSimpleJson(p_Document["m_vFacingDirection"], &s_Object->m_vFacingDirection);

}

void SAnimatedActorStandOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vFacingDirection, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorStandOrderSaveData, m_vFacingDirection));
}

bool SAnimatedActorStandOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorStandOrderSaveData::operator==(const SAnimatedActorStandOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorStandOrderSaveData>)
		return false;

	if (m_vFacingDirection != p_Other.m_vFacingDirection) return false;

	return true;
}

void SAnimatedActorStandOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorStandOrderSaveData();
}

ZHMTypeInfo SAttentionHUDUIElement::TypeInfo = ZHMTypeInfo("SAttentionHUDUIElement", sizeof(SAttentionHUDUIElement), alignof(SAttentionHUDUIElement), SAttentionHUDUIElement::WriteSimpleJson, SAttentionHUDUIElement::FromSimpleJson, SAttentionHUDUIElement::Serialize, SAttentionHUDUIElement::Equals, SAttentionHUDUIElement::Destroy);

void SAttentionHUDUIElement::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fRadius);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nColor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColor);

	p_Stream << "}";
}

void SAttentionHUDUIElement::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Target);

	s_Object->fAngle = simdjson::from_json_float32(p_Document["fAngle"]);

	s_Object->fAttention = simdjson::from_json_float32(p_Document["fAttention"]);

	s_Object->fAlpha = simdjson::from_json_float32(p_Document["fAlpha"]);

	s_Object->fRadius = simdjson::from_json_float32(p_Document["fRadius"]);

	s_Object->nColor = simdjson::from_json_int32(p_Document["nColor"]);

}

void SAttentionHUDUIElement::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);

}

bool SAttentionHUDUIElement::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAttentionHUDUIElement*>(p_Left);
	auto* s_Right = reinterpret_cast<SAttentionHUDUIElement*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAttentionHUDUIElement::operator==(const SAttentionHUDUIElement& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAttentionHUDUIElement>)
		return false;

	if (fAngle != p_Other.fAngle) return false;
	if (fAttention != p_Other.fAttention) return false;
	if (fAlpha != p_Other.fAlpha) return false;
	if (fRadius != p_Other.fRadius) return false;
	if (nColor != p_Other.nColor) return false;

	return true;
}

void SAttentionHUDUIElement::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);
	s_Object->~SAttentionHUDUIElement();
}

ZHMTypeInfo SAttentionHUDUIElementArray_Dummy::TypeInfo = ZHMTypeInfo("SAttentionHUDUIElementArray_Dummy", sizeof(SAttentionHUDUIElementArray_Dummy), alignof(SAttentionHUDUIElementArray_Dummy), SAttentionHUDUIElementArray_Dummy::WriteSimpleJson, SAttentionHUDUIElementArray_Dummy::FromSimpleJson, SAttentionHUDUIElementArray_Dummy::Serialize, SAttentionHUDUIElementArray_Dummy::Equals, SAttentionHUDUIElementArray_Dummy::Destroy);

void SAttentionHUDUIElementArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SAttentionHUDUIElement::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAttentionHUDUIElementArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object->dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAttentionHUDUIElement::FromSimpleJson(s_Item0, &s_Object->dummy[s_Index0]);
		++s_Index0;
	}
	}

}

void SAttentionHUDUIElementArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);

	TArray<SAttentionHUDUIElement>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SAttentionHUDUIElementArray_Dummy, dummy));
}

bool SAttentionHUDUIElementArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAttentionHUDUIElementArray_Dummy::operator==(const SAttentionHUDUIElementArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAttentionHUDUIElementArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SAttentionHUDUIElementArray_Dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);
	s_Object->~SAttentionHUDUIElementArray_Dummy();
}

ZHMTypeInfo SAudioEmitterEventSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterEventSaveData", sizeof(SAudioEmitterEventSaveData), alignof(SAudioEmitterEventSaveData), SAudioEmitterEventSaveData::WriteSimpleJson, SAudioEmitterEventSaveData::FromSimpleJson, SAudioEmitterEventSaveData::Serialize, SAudioEmitterEventSaveData::Equals, SAudioEmitterEventSaveData::Destroy);

void SAudioEmitterEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEventSender") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEventSender);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSeekPosition);

	p_Stream << "}";
}

void SAudioEmitterEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Target);

	s_Object->m_nEventId = simdjson::from_json_uint32(p_Document["m_nEventId"]);

	s_Object->m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	s_Object->m_nFlags = simdjson::from_json_uint32(p_Document["m_nFlags"]);

	s_Object->m_rEventSender = simdjson::from_json_uint32(p_Document["m_rEventSender"]);

	s_Object->m_nSeekPosition = simdjson::from_json_int32(p_Document["m_nSeekPosition"]);

}

void SAudioEmitterEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);

}

bool SAudioEmitterEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterEventSaveData::operator==(const SAudioEmitterEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterEventSaveData>)
		return false;

	if (m_nEventId != p_Other.m_nEventId) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;
	if (m_nFlags != p_Other.m_nFlags) return false;
	if (m_rEventSender != p_Other.m_rEventSender) return false;
	if (m_nSeekPosition != p_Other.m_nSeekPosition) return false;

	return true;
}

void SAudioEmitterEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);
	s_Object->~SAudioEmitterEventSaveData();
}

ZHMTypeInfo SAudioEmitterRTPCSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterRTPCSaveData", sizeof(SAudioEmitterRTPCSaveData), alignof(SAudioEmitterRTPCSaveData), SAudioEmitterRTPCSaveData::WriteSimpleJson, SAudioEmitterRTPCSaveData::FromSimpleJson, SAudioEmitterRTPCSaveData::Serialize, SAudioEmitterRTPCSaveData::Equals, SAudioEmitterRTPCSaveData::Destroy);

void SAudioEmitterRTPCSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nParamId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nParamId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fValue);

	p_Stream << "}";
}

void SAudioEmitterRTPCSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Target);

	s_Object->m_nParamId = simdjson::from_json_uint32(p_Document["m_nParamId"]);

	s_Object->m_fValue = simdjson::from_json_float32(p_Document["m_fValue"]);

}

void SAudioEmitterRTPCSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);

}

bool SAudioEmitterRTPCSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterRTPCSaveData::operator==(const SAudioEmitterRTPCSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterRTPCSaveData>)
		return false;

	if (m_nParamId != p_Other.m_nParamId) return false;
	if (m_fValue != p_Other.m_fValue) return false;

	return true;
}

void SAudioEmitterRTPCSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);
	s_Object->~SAudioEmitterRTPCSaveData();
}

ZHMTypeInfo SAudioEmitterSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterSaveData", sizeof(SAudioEmitterSaveData), alignof(SAudioEmitterSaveData), SAudioEmitterSaveData::WriteSimpleJson, SAudioEmitterSaveData::FromSimpleJson, SAudioEmitterSaveData::Serialize, SAudioEmitterSaveData::Equals, SAudioEmitterSaveData::Destroy);

void SAudioEmitterSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEmitter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEmitter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfEvents") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfEvents);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfRTPCs") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfRTPCs);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfSwitches") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfSwitches);

	p_Stream << "}";
}

void SAudioEmitterSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Target);

	s_Object->m_rEmitter = simdjson::from_json_uint32(p_Document["m_rEmitter"]);

	s_Object->m_nNumberOfEvents = simdjson::from_json_uint32(p_Document["m_nNumberOfEvents"]);

	s_Object->m_nNumberOfRTPCs = simdjson::from_json_uint32(p_Document["m_nNumberOfRTPCs"]);

	s_Object->m_nNumberOfSwitches = simdjson::from_json_uint32(p_Document["m_nNumberOfSwitches"]);

}

void SAudioEmitterSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);

}

bool SAudioEmitterSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterSaveData::operator==(const SAudioEmitterSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterSaveData>)
		return false;

	if (m_rEmitter != p_Other.m_rEmitter) return false;
	if (m_nNumberOfEvents != p_Other.m_nNumberOfEvents) return false;
	if (m_nNumberOfRTPCs != p_Other.m_nNumberOfRTPCs) return false;
	if (m_nNumberOfSwitches != p_Other.m_nNumberOfSwitches) return false;

	return true;
}

void SAudioEmitterSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);
	s_Object->~SAudioEmitterSaveData();
}

ZHMTypeInfo SAudioEmitterStateSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterStateSaveData", sizeof(SAudioEmitterStateSaveData), alignof(SAudioEmitterStateSaveData), SAudioEmitterStateSaveData::WriteSimpleJson, SAudioEmitterStateSaveData::FromSimpleJson, SAudioEmitterStateSaveData::Serialize, SAudioEmitterStateSaveData::Equals, SAudioEmitterStateSaveData::Destroy);

void SAudioEmitterStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nGroupId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStateId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStateId);

	p_Stream << "}";
}

void SAudioEmitterStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Target);

	s_Object->m_nGroupId = simdjson::from_json_uint32(p_Document["m_nGroupId"]);

	s_Object->m_nStateId = simdjson::from_json_uint32(p_Document["m_nStateId"]);

}

void SAudioEmitterStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);

}

bool SAudioEmitterStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterStateSaveData::operator==(const SAudioEmitterStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterStateSaveData>)
		return false;

	if (m_nGroupId != p_Other.m_nGroupId) return false;
	if (m_nStateId != p_Other.m_nStateId) return false;

	return true;
}

void SAudioEmitterStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);
	s_Object->~SAudioEmitterStateSaveData();
}

ZHMTypeInfo SAudioEmitterSwitchSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterSwitchSaveData", sizeof(SAudioEmitterSwitchSaveData), alignof(SAudioEmitterSwitchSaveData), SAudioEmitterSwitchSaveData::WriteSimpleJson, SAudioEmitterSwitchSaveData::FromSimpleJson, SAudioEmitterSwitchSaveData::Serialize, SAudioEmitterSwitchSaveData::Equals, SAudioEmitterSwitchSaveData::Destroy);

void SAudioEmitterSwitchSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nGroupId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStateId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStateId);

	p_Stream << "}";
}

void SAudioEmitterSwitchSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Target);

	s_Object->m_nGroupId = simdjson::from_json_uint32(p_Document["m_nGroupId"]);

	s_Object->m_nStateId = simdjson::from_json_uint32(p_Document["m_nStateId"]);

}

void SAudioEmitterSwitchSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);

}

bool SAudioEmitterSwitchSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterSwitchSaveData::operator==(const SAudioEmitterSwitchSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterSwitchSaveData>)
		return false;

	if (m_nGroupId != p_Other.m_nGroupId) return false;
	if (m_nStateId != p_Other.m_nStateId) return false;

	return true;
}

void SAudioEmitterSwitchSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);
	s_Object->~SAudioEmitterSwitchSaveData();
}

ZHMTypeInfo SAudioEventData::TypeInfo = ZHMTypeInfo("SAudioEventData", sizeof(SAudioEventData), alignof(SAudioEventData), SAudioEventData::WriteSimpleJson, SAudioEventData::FromSimpleJson, SAudioEventData::Serialize, SAudioEventData::Equals, SAudioEventData::Destroy);

void SAudioEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EmitterID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_EmitterID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_EventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_EventID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PlayingID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_PlayingID);

	p_Stream << "}";
}

void SAudioEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAudioEventData*>(p_Target);

	s_Object->m_EmitterID = simdjson::from_json_uint64(p_Document["m_EmitterID"]);

	s_Object->m_EventID = simdjson::from_json_uint32(p_Document["m_EventID"]);

	s_Object->m_PlayingID = simdjson::from_json_uint32(p_Document["m_PlayingID"]);

}

void SAudioEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEventData*>(p_Object);

}

bool SAudioEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEventData::operator==(const SAudioEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEventData>)
		return false;

	if (m_EmitterID != p_Other.m_EmitterID) return false;
	if (m_EventID != p_Other.m_EventID) return false;
	if (m_PlayingID != p_Other.m_PlayingID) return false;

	return true;
}

void SAudioEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEventData*>(p_Object);
	s_Object->~SAudioEventData();
}

ZHMTypeInfo SAudioSaveData::TypeInfo = ZHMTypeInfo("SAudioSaveData", sizeof(SAudioSaveData), alignof(SAudioSaveData), SAudioSaveData::WriteSimpleJson, SAudioSaveData::FromSimpleJson, SAudioSaveData::Serialize, SAudioSaveData::Equals, SAudioSaveData::Destroy);

void SAudioSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEmitters") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitters.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitters[i];
		SAudioEmitterSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitters.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterEvents[i];
		SAudioEmitterEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterRTPCs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterRTPCs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterRTPCs[i];
		SAudioEmitterRTPCSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterRTPCs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterSwitches") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterSwitches.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterSwitches[i];
		SAudioEmitterSwitchSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterSwitches.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGlobalStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGlobalStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGlobalStates[i];
		SAudioEmitterStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGlobalStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGlobalRTPCs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGlobalRTPCs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGlobalRTPCs[i];
		SAudioEmitterRTPCSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGlobalRTPCs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEventsEnabledAfterInit") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEventsEnabledAfterInit.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEventsEnabledAfterInit[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEventsEnabledAfterInit.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAudioSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAudioSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEmitters"];
	s_Object->m_aEmitters.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterSaveData::FromSimpleJson(s_Item0, &s_Object->m_aEmitters[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEmitterEvents"];
	s_Object->m_aEmitterEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterEventSaveData::FromSimpleJson(s_Item0, &s_Object->m_aEmitterEvents[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEmitterRTPCs"];
	s_Object->m_aEmitterRTPCs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterRTPCSaveData::FromSimpleJson(s_Item0, &s_Object->m_aEmitterRTPCs[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEmitterSwitches"];
	s_Object->m_aEmitterSwitches.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterSwitchSaveData::FromSimpleJson(s_Item0, &s_Object->m_aEmitterSwitches[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGlobalStates"];
	s_Object->m_aGlobalStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterStateSaveData::FromSimpleJson(s_Item0, &s_Object->m_aGlobalStates[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGlobalRTPCs"];
	s_Object->m_aGlobalRTPCs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterRTPCSaveData::FromSimpleJson(s_Item0, &s_Object->m_aGlobalRTPCs[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEventsEnabledAfterInit"];
	s_Object->m_aEventsEnabledAfterInit.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEventsEnabledAfterInit[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SAudioSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);

	TArray<SAudioEmitterSaveData>::Serialize(&s_Object->m_aEmitters, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitters));
	TArray<SAudioEmitterEventSaveData>::Serialize(&s_Object->m_aEmitterEvents, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterEvents));
	TArray<SAudioEmitterRTPCSaveData>::Serialize(&s_Object->m_aEmitterRTPCs, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterRTPCs));
	TArray<SAudioEmitterSwitchSaveData>::Serialize(&s_Object->m_aEmitterSwitches, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterSwitches));
	TArray<SAudioEmitterStateSaveData>::Serialize(&s_Object->m_aGlobalStates, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aGlobalStates));
	TArray<SAudioEmitterRTPCSaveData>::Serialize(&s_Object->m_aGlobalRTPCs, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aGlobalRTPCs));
	TArray<uint32>::Serialize(&s_Object->m_aEventsEnabledAfterInit, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEventsEnabledAfterInit));
}

bool SAudioSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioSaveData::operator==(const SAudioSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioSaveData>)
		return false;

	if (m_aEmitters != p_Other.m_aEmitters) return false;
	if (m_aEmitterEvents != p_Other.m_aEmitterEvents) return false;
	if (m_aEmitterRTPCs != p_Other.m_aEmitterRTPCs) return false;
	if (m_aEmitterSwitches != p_Other.m_aEmitterSwitches) return false;
	if (m_aGlobalStates != p_Other.m_aGlobalStates) return false;
	if (m_aGlobalRTPCs != p_Other.m_aGlobalRTPCs) return false;
	if (m_aEventsEnabledAfterInit != p_Other.m_aEventsEnabledAfterInit) return false;

	return true;
}

void SAudioSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);
	s_Object->~SAudioSaveData();
}

ZHMTypeInfo SFSMSaveData::TypeInfo = ZHMTypeInfo("SFSMSaveData", sizeof(SFSMSaveData), alignof(SFSMSaveData), SFSMSaveData::WriteSimpleJson, SFSMSaveData::FromSimpleJson, SFSMSaveData::Serialize, SFSMSaveData::Equals, SFSMSaveData::Destroy);

void SFSMSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eStateStatus") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EFSMStateStatus", static_cast<int>(s_Object->m_eStateStatus)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_state);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_prevState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_prevState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tCurrentStateEnterTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tCurrentStateEnterTime, p_Stream);

	p_Stream << "}";
}

void SFSMSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFSMSaveData*>(p_Target);

	s_Object->m_eStateStatus = static_cast<EFSMStateStatus>(ZHMEnums::GetEnumValueByName("EFSMStateStatus", std::string_view(p_Document["m_eStateStatus"])));

	s_Object->m_state = simdjson::from_json_int32(p_Document["m_state"]);

	s_Object->m_prevState = simdjson::from_json_int32(p_Document["m_prevState"]);

	ZGameTime::FromSimpleJson(p_Document["m_tCurrentStateEnterTime"], &s_Object->m_tCurrentStateEnterTime);

}

void SFSMSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tCurrentStateEnterTime, p_Serializer, p_OwnOffset + offsetof(SFSMSaveData, m_tCurrentStateEnterTime));
}

bool SFSMSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFSMSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFSMSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFSMSaveData::operator==(const SFSMSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFSMSaveData>)
		return false;

	if (m_eStateStatus != p_Other.m_eStateStatus) return false;
	if (m_state != p_Other.m_state) return false;
	if (m_prevState != p_Other.m_prevState) return false;
	if (m_tCurrentStateEnterTime != p_Other.m_tCurrentStateEnterTime) return false;

	return true;
}

void SFSMSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);
	s_Object->~SFSMSaveData();
}

ZHMTypeInfo SAvoidDangerousAreaGroupSaveData::TypeInfo = ZHMTypeInfo("SAvoidDangerousAreaGroupSaveData", sizeof(SAvoidDangerousAreaGroupSaveData), alignof(SAvoidDangerousAreaGroupSaveData), SAvoidDangerousAreaGroupSaveData::WriteSimpleJson, SAvoidDangerousAreaGroupSaveData::FromSimpleJson, SAvoidDangerousAreaGroupSaveData::Serialize, SAvoidDangerousAreaGroupSaveData::Equals, SAvoidDangerousAreaGroupSaveData::Destroy);

void SAvoidDangerousAreaGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDangerousArea") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDangerousArea);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDestinationPoint") << ":";
	float4::WriteSimpleJson(&s_Object->m_vDestinationPoint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iGridId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iGridId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitUntilDangerEnds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitUntilDangerEnds);

	p_Stream << "}";
}

void SAvoidDangerousAreaGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_rDangerousArea = simdjson::from_json_uint32(p_Document["m_rDangerousArea"]);

	float4::FromSimpleJson(p_Document["m_vDestinationPoint"], &s_Object->m_vDestinationPoint);

	s_Object->m_iGridId = simdjson::from_json_int32(p_Document["m_iGridId"]);

	s_Object->m_bWaitUntilDangerEnds = simdjson::from_json_bool(p_Document["m_bWaitUntilDangerEnds"]);

}

void SAvoidDangerousAreaGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SAvoidDangerousAreaGroupSaveData, m_fsmState));
	float4::Serialize(&s_Object->m_vDestinationPoint, p_Serializer, p_OwnOffset + offsetof(SAvoidDangerousAreaGroupSaveData, m_vDestinationPoint));
}

bool SAvoidDangerousAreaGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAvoidDangerousAreaGroupSaveData::operator==(const SAvoidDangerousAreaGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAvoidDangerousAreaGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rDangerousArea != p_Other.m_rDangerousArea) return false;
	if (m_vDestinationPoint != p_Other.m_vDestinationPoint) return false;
	if (m_iGridId != p_Other.m_iGridId) return false;
	if (m_bWaitUntilDangerEnds != p_Other.m_bWaitUntilDangerEnds) return false;

	return true;
}

void SAvoidDangerousAreaGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);
	s_Object->~SAvoidDangerousAreaGroupSaveData();
}

ZHMTypeInfo SBehaviorTreeEntityReference::TypeInfo = ZHMTypeInfo("SBehaviorTreeEntityReference", sizeof(SBehaviorTreeEntityReference), alignof(SBehaviorTreeEntityReference), SBehaviorTreeEntityReference::WriteSimpleJson, SBehaviorTreeEntityReference::FromSimpleJson, SBehaviorTreeEntityReference::Serialize, SBehaviorTreeEntityReference::Equals, SBehaviorTreeEntityReference::Destroy);

void SBehaviorTreeEntityReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bList") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bList);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);

	p_Stream << "}";
}

void SBehaviorTreeEntityReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Target);

	s_Object->m_bList = simdjson::from_json_bool(p_Document["m_bList"]);

	s_Object->m_sName = std::string_view(p_Document["m_sName"]);

}

void SBehaviorTreeEntityReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEntityReference, m_sName));
}

bool SBehaviorTreeEntityReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEntityReference::operator==(const SBehaviorTreeEntityReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEntityReference>)
		return false;

	if (m_bList != p_Other.m_bList) return false;
	if (m_sName != p_Other.m_sName) return false;

	return true;
}

void SBehaviorTreeEntityReference::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);
	s_Object->~SBehaviorTreeEntityReference();
}

ZHMTypeInfo ZResourceID::TypeInfo = ZHMTypeInfo("ZResourceID", sizeof(ZResourceID), alignof(ZResourceID), ZResourceID::WriteSimpleJson, ZResourceID::FromSimpleJson, ZResourceID::Serialize, ZResourceID::Equals, ZResourceID::Destroy);

void ZResourceID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_uri") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uri);

	p_Stream << "}";
}

void ZResourceID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZResourceID*>(p_Target);

	s_Object->m_uri = std::string_view(p_Document["m_uri"]);

}

void ZResourceID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	ZString::Serialize(&s_Object->m_uri, p_Serializer, p_OwnOffset + offsetof(ZResourceID, m_uri));
}

bool ZResourceID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZResourceID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZResourceID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZResourceID::operator==(const ZResourceID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZResourceID>)
		return false;

	if (m_uri != p_Other.m_uri) return false;

	return true;
}

void ZResourceID::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);
	s_Object->~ZResourceID();
}

ZHMTypeInfo SBehaviorTreeEvaluationLogEntry::TypeInfo = ZHMTypeInfo("SBehaviorTreeEvaluationLogEntry", sizeof(SBehaviorTreeEvaluationLogEntry), alignof(SBehaviorTreeEvaluationLogEntry), SBehaviorTreeEvaluationLogEntry::WriteSimpleJson, SBehaviorTreeEvaluationLogEntry::FromSimpleJson, SBehaviorTreeEvaluationLogEntry::Serialize, SBehaviorTreeEvaluationLogEntry::Equals, SBehaviorTreeEvaluationLogEntry::Destroy);

void SBehaviorTreeEvaluationLogEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nBehaviorTreeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBehaviorTreeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nConditionOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nConditionOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bResult") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bResult);

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLogEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Target);

	s_Object->m_nBehaviorTreeIndex = simdjson::from_json_uint32(p_Document["m_nBehaviorTreeIndex"]);

	s_Object->m_nConditionOffset = simdjson::from_json_uint64(p_Document["m_nConditionOffset"]);

	s_Object->m_bResult = simdjson::from_json_bool(p_Document["m_bResult"]);

}

void SBehaviorTreeEvaluationLogEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

}

bool SBehaviorTreeEvaluationLogEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEvaluationLogEntry::operator==(const SBehaviorTreeEvaluationLogEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEvaluationLogEntry>)
		return false;

	if (m_nBehaviorTreeIndex != p_Other.m_nBehaviorTreeIndex) return false;
	if (m_nConditionOffset != p_Other.m_nConditionOffset) return false;
	if (m_bResult != p_Other.m_bResult) return false;

	return true;
}

void SBehaviorTreeEvaluationLogEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);
	s_Object->~SBehaviorTreeEvaluationLogEntry();
}

ZHMTypeInfo SBehaviorTreeEvaluationLog::TypeInfo = ZHMTypeInfo("SBehaviorTreeEvaluationLog", sizeof(SBehaviorTreeEvaluationLog), alignof(SBehaviorTreeEvaluationLog), SBehaviorTreeEvaluationLog::WriteSimpleJson, SBehaviorTreeEvaluationLog::FromSimpleJson, SBehaviorTreeEvaluationLog::Serialize, SBehaviorTreeEvaluationLog::Equals, SBehaviorTreeEvaluationLog::Destroy);

void SBehaviorTreeEvaluationLog::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_BehaviorTrees") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_BehaviorTrees.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_BehaviorTrees[i];
		ZResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_BehaviorTrees.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Entries") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Entries.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Entries[i];
		SBehaviorTreeEvaluationLogEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_Entries.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLog::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_BehaviorTrees"];
	s_Object->m_BehaviorTrees.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZResourceID::FromSimpleJson(s_Item0, &s_Object->m_BehaviorTrees[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_Entries"];
	s_Object->m_Entries.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeEvaluationLogEntry::FromSimpleJson(s_Item0, &s_Object->m_Entries[s_Index0]);
		++s_Index0;
	}
	}

}

void SBehaviorTreeEvaluationLog::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	TArray<ZResourceID>::Serialize(&s_Object->m_BehaviorTrees, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEvaluationLog, m_BehaviorTrees));
	TArray<SBehaviorTreeEvaluationLogEntry>::Serialize(&s_Object->m_Entries, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEvaluationLog, m_Entries));
}

bool SBehaviorTreeEvaluationLog::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEvaluationLog::operator==(const SBehaviorTreeEvaluationLog& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEvaluationLog>)
		return false;

	if (m_BehaviorTrees != p_Other.m_BehaviorTrees) return false;
	if (m_Entries != p_Other.m_Entries) return false;

	return true;
}

void SBehaviorTreeEvaluationLog::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);
	s_Object->~SBehaviorTreeEvaluationLog();
}

ZHMTypeInfo SBehaviorTreeInputPinCondition::TypeInfo = ZHMTypeInfo("SBehaviorTreeInputPinCondition", sizeof(SBehaviorTreeInputPinCondition), alignof(SBehaviorTreeInputPinCondition), SBehaviorTreeInputPinCondition::WriteSimpleJson, SBehaviorTreeInputPinCondition::FromSimpleJson, SBehaviorTreeInputPinCondition::Serialize, SBehaviorTreeInputPinCondition::Equals, SBehaviorTreeInputPinCondition::Destroy);

void SBehaviorTreeInputPinCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);

	p_Stream << "}";
}

void SBehaviorTreeInputPinCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Target);

	s_Object->m_sName = std::string_view(p_Document["m_sName"]);

}

void SBehaviorTreeInputPinCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInputPinCondition, m_sName));
}

bool SBehaviorTreeInputPinCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeInputPinCondition::operator==(const SBehaviorTreeInputPinCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeInputPinCondition>)
		return false;

	if (m_sName != p_Other.m_sName) return false;

	return true;
}

void SBehaviorTreeInputPinCondition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);
	s_Object->~SBehaviorTreeInputPinCondition();
}

ZHMTypeInfo SBehaviorTreeInfo::TypeInfo = ZHMTypeInfo("SBehaviorTreeInfo", sizeof(SBehaviorTreeInfo), alignof(SBehaviorTreeInfo), SBehaviorTreeInfo::WriteSimpleJson, SBehaviorTreeInfo::FromSimpleJson, SBehaviorTreeInfo::Serialize, SBehaviorTreeInfo::Equals, SBehaviorTreeInfo::Destroy);

void SBehaviorTreeInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_references") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_references.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_references[i];
		SBehaviorTreeEntityReference::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_references.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_inputPinConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_inputPinConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_inputPinConditions[i];
		SBehaviorTreeInputPinCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_inputPinConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBehaviorTreeInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_references"];
	s_Object->m_references.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeEntityReference::FromSimpleJson(s_Item0, &s_Object->m_references[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_inputPinConditions"];
	s_Object->m_inputPinConditions.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeInputPinCondition::FromSimpleJson(s_Item0, &s_Object->m_inputPinConditions[s_Index0]);
		++s_Index0;
	}
	}

}

void SBehaviorTreeInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	TArray<SBehaviorTreeEntityReference>::Serialize(&s_Object->m_references, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInfo, m_references));
	TArray<SBehaviorTreeInputPinCondition>::Serialize(&s_Object->m_inputPinConditions, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInfo, m_inputPinConditions));
}

bool SBehaviorTreeInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeInfo::operator==(const SBehaviorTreeInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeInfo>)
		return false;

	if (m_references != p_Other.m_references) return false;
	if (m_inputPinConditions != p_Other.m_inputPinConditions) return false;

	return true;
}

void SBehaviorTreeInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);
	s_Object->~SBehaviorTreeInfo();
}

ZHMTypeInfo ZBehaviorTreeVariable::TypeInfo = ZHMTypeInfo("ZBehaviorTreeVariable", sizeof(ZBehaviorTreeVariable), alignof(ZBehaviorTreeVariable), ZBehaviorTreeVariable::WriteSimpleJson, ZBehaviorTreeVariable::FromSimpleJson, ZBehaviorTreeVariable::Serialize, ZBehaviorTreeVariable::Equals, ZBehaviorTreeVariable::Destroy);

void ZBehaviorTreeVariable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZBehaviorTreeVariable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Target);

}

void ZBehaviorTreeVariable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

}

bool ZBehaviorTreeVariable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZBehaviorTreeVariable*>(p_Left);
	auto* s_Right = reinterpret_cast<ZBehaviorTreeVariable*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZBehaviorTreeVariable::operator==(const ZBehaviorTreeVariable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZBehaviorTreeVariable>)
		return false;


	return true;
}

void ZBehaviorTreeVariable::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);
	s_Object->~ZBehaviorTreeVariable();
}

ZHMTypeInfo SBlobsConfigResourceEntry::TypeInfo = ZHMTypeInfo("SBlobsConfigResourceEntry", sizeof(SBlobsConfigResourceEntry), alignof(SBlobsConfigResourceEntry), SBlobsConfigResourceEntry::WriteSimpleJson, SBlobsConfigResourceEntry::FromSimpleJson, SBlobsConfigResourceEntry::Serialize, SBlobsConfigResourceEntry::Equals, SBlobsConfigResourceEntry::Destroy);

void SBlobsConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("BlobRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->BlobRid, p_Stream);

	p_Stream << "}";
}

void SBlobsConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Target);

	s_Object->Id = std::string_view(p_Document["Id"]);

	ZRuntimeResourceID::FromSimpleJson(p_Document["BlobRid"], &s_Object->BlobRid);

}

void SBlobsConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Id, p_Serializer, p_OwnOffset + offsetof(SBlobsConfigResourceEntry, Id));
	ZRuntimeResourceID::Serialize(&s_Object->BlobRid, p_Serializer, p_OwnOffset + offsetof(SBlobsConfigResourceEntry, BlobRid));
}

bool SBlobsConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBlobsConfigResourceEntry::operator==(const SBlobsConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBlobsConfigResourceEntry>)
		return false;

	if (Id != p_Other.Id) return false;
	if (BlobRid != p_Other.BlobRid) return false;

	return true;
}

void SBlobsConfigResourceEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);
	s_Object->~SBlobsConfigResourceEntry();
}

ZHMTypeInfo ZRayQueryInput::TypeInfo = ZHMTypeInfo("ZRayQueryInput", sizeof(ZRayQueryInput), alignof(ZRayQueryInput), ZRayQueryInput::WriteSimpleJson, ZRayQueryInput::FromSimpleJson, ZRayQueryInput::Serialize, ZRayQueryInput::Equals, ZRayQueryInput::Destroy);

void ZRayQueryInput::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZRayQueryInput::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZRayQueryInput*>(p_Target);

}

void ZRayQueryInput::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

}

bool ZRayQueryInput::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRayQueryInput*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRayQueryInput*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRayQueryInput::operator==(const ZRayQueryInput& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRayQueryInput>)
		return false;


	return true;
}

void ZRayQueryInput::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);
	s_Object->~ZRayQueryInput();
}

ZHMTypeInfo SBodyContainerSaveData::TypeInfo = ZHMTypeInfo("SBodyContainerSaveData", sizeof(SBodyContainerSaveData), alignof(SBodyContainerSaveData), SBodyContainerSaveData::WriteSimpleJson, SBodyContainerSaveData::FromSimpleJson, SBodyContainerSaveData::Serialize, SBodyContainerSaveData::Equals, SBodyContainerSaveData::Destroy);

void SBodyContainerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eBCState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5BodyContainer.EBCState", static_cast<int>(s_Object->m_eBCState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLidAutoCloseTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLidAutoCloseTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLidOpenFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLidOpenFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrameUpdateActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrameUpdateActive);

	p_Stream << "}";
}

void SBodyContainerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Target);

	s_Object->m_eBCState = static_cast<ZHM5BodyContainer::EBCState>(ZHMEnums::GetEnumValueByName("ZHM5BodyContainer.EBCState", std::string_view(p_Document["m_eBCState"])));

	s_Object->m_fLidAutoCloseTime = simdjson::from_json_float32(p_Document["m_fLidAutoCloseTime"]);

	s_Object->m_fLidOpenFraction = simdjson::from_json_float32(p_Document["m_fLidOpenFraction"]);

	s_Object->m_bFrameUpdateActive = simdjson::from_json_bool(p_Document["m_bFrameUpdateActive"]);

}

void SBodyContainerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);

}

bool SBodyContainerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyContainerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyContainerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyContainerSaveData::operator==(const SBodyContainerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyContainerSaveData>)
		return false;

	if (m_eBCState != p_Other.m_eBCState) return false;
	if (m_fLidAutoCloseTime != p_Other.m_fLidAutoCloseTime) return false;
	if (m_fLidOpenFraction != p_Other.m_fLidOpenFraction) return false;
	if (m_bFrameUpdateActive != p_Other.m_bFrameUpdateActive) return false;

	return true;
}

void SBodyContainerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);
	s_Object->~SBodyContainerSaveData();
}

ZHMTypeInfo SBodyContainersSaveData::TypeInfo = ZHMTypeInfo("SBodyContainersSaveData", sizeof(SBodyContainersSaveData), alignof(SBodyContainersSaveData), SBodyContainersSaveData::WriteSimpleJson, SBodyContainersSaveData::FromSimpleJson, SBodyContainersSaveData::Serialize, SBodyContainersSaveData::Equals, SBodyContainersSaveData::Destroy);

void SBodyContainersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SBodyContainerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBodyContainersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBodyContainerSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SBodyContainersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SBodyContainersSaveData, m_aEntities));
	TArray<SBodyContainerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SBodyContainersSaveData, m_aData));
}

bool SBodyContainersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyContainersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyContainersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyContainersSaveData::operator==(const SBodyContainersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyContainersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SBodyContainersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);
	s_Object->~SBodyContainersSaveData();
}

ZHMTypeInfo SBodyPartDamageMultipliers::TypeInfo = ZHMTypeInfo("SBodyPartDamageMultipliers", sizeof(SBodyPartDamageMultipliers), alignof(SBodyPartDamageMultipliers), SBodyPartDamageMultipliers::WriteSimpleJson, SBodyPartDamageMultipliers::FromSimpleJson, SBodyPartDamageMultipliers::Serialize, SBodyPartDamageMultipliers::Equals, SBodyPartDamageMultipliers::Destroy);

void SBodyPartDamageMultipliers::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fHeadDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeadDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fArmDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fArmDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLArmDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLArmDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRArmDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRArmDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHandDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHandDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLHandDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLHandDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRHandDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRHandDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLegDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLegDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLLegDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLLegDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRLegDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRLegDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTorsoDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTorsoDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bApplyLeftRightScalars") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bApplyLeftRightScalars);

	p_Stream << "}";
}

void SBodyPartDamageMultipliers::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Target);

	s_Object->m_fHeadDamageMultiplier = simdjson::from_json_float32(p_Document["m_fHeadDamageMultiplier"]);

	s_Object->m_fFaceDamageMultiplier = simdjson::from_json_float32(p_Document["m_fFaceDamageMultiplier"]);

	s_Object->m_fArmDamageMultiplier = simdjson::from_json_float32(p_Document["m_fArmDamageMultiplier"]);

	s_Object->m_fLArmDamageScalar = simdjson::from_json_float32(p_Document["m_fLArmDamageScalar"]);

	s_Object->m_fRArmDamageScalar = simdjson::from_json_float32(p_Document["m_fRArmDamageScalar"]);

	s_Object->m_fHandDamageMultiplier = simdjson::from_json_float32(p_Document["m_fHandDamageMultiplier"]);

	s_Object->m_fLHandDamageScalar = simdjson::from_json_float32(p_Document["m_fLHandDamageScalar"]);

	s_Object->m_fRHandDamageScalar = simdjson::from_json_float32(p_Document["m_fRHandDamageScalar"]);

	s_Object->m_fLegDamageMultiplier = simdjson::from_json_float32(p_Document["m_fLegDamageMultiplier"]);

	s_Object->m_fLLegDamageScalar = simdjson::from_json_float32(p_Document["m_fLLegDamageScalar"]);

	s_Object->m_fRLegDamageScalar = simdjson::from_json_float32(p_Document["m_fRLegDamageScalar"]);

	s_Object->m_fTorsoDamageMultiplier = simdjson::from_json_float32(p_Document["m_fTorsoDamageMultiplier"]);

	s_Object->m_bApplyLeftRightScalars = simdjson::from_json_bool(p_Document["m_bApplyLeftRightScalars"]);

}

void SBodyPartDamageMultipliers::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

}

bool SBodyPartDamageMultipliers::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyPartDamageMultipliers::operator==(const SBodyPartDamageMultipliers& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyPartDamageMultipliers>)
		return false;

	if (m_fHeadDamageMultiplier != p_Other.m_fHeadDamageMultiplier) return false;
	if (m_fFaceDamageMultiplier != p_Other.m_fFaceDamageMultiplier) return false;
	if (m_fArmDamageMultiplier != p_Other.m_fArmDamageMultiplier) return false;
	if (m_fLArmDamageScalar != p_Other.m_fLArmDamageScalar) return false;
	if (m_fRArmDamageScalar != p_Other.m_fRArmDamageScalar) return false;
	if (m_fHandDamageMultiplier != p_Other.m_fHandDamageMultiplier) return false;
	if (m_fLHandDamageScalar != p_Other.m_fLHandDamageScalar) return false;
	if (m_fRHandDamageScalar != p_Other.m_fRHandDamageScalar) return false;
	if (m_fLegDamageMultiplier != p_Other.m_fLegDamageMultiplier) return false;
	if (m_fLLegDamageScalar != p_Other.m_fLLegDamageScalar) return false;
	if (m_fRLegDamageScalar != p_Other.m_fRLegDamageScalar) return false;
	if (m_fTorsoDamageMultiplier != p_Other.m_fTorsoDamageMultiplier) return false;
	if (m_bApplyLeftRightScalars != p_Other.m_bApplyLeftRightScalars) return false;

	return true;
}

void SBodyPartDamageMultipliers::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);
	s_Object->~SBodyPartDamageMultipliers();
}

ZHMTypeInfo SBodybagBoneSaveData::TypeInfo = ZHMTypeInfo("SBodybagBoneSaveData", sizeof(SBodybagBoneSaveData), alignof(SBodybagBoneSaveData), SBodybagBoneSaveData::WriteSimpleJson, SBodybagBoneSaveData::FromSimpleJson, SBodybagBoneSaveData::Serialize, SBodybagBoneSaveData::Equals, SBodybagBoneSaveData::Destroy);

void SBodybagBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SBodybagBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Target);

	SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Object->mQuaterion);

	SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Object->mTranslation);

}

void SBodybagBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SBodybagBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SBodybagBoneSaveData, mTranslation));
}

bool SBodybagBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodybagBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodybagBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodybagBoneSaveData::operator==(const SBodybagBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodybagBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

void SBodybagBoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);
	s_Object->~SBodybagBoneSaveData();
}

ZHMTypeInfo SBodybagSaveData::TypeInfo = ZHMTypeInfo("SBodybagSaveData", sizeof(SBodybagSaveData), alignof(SBodybagSaveData), SBodybagSaveData::WriteSimpleJson, SBodybagSaveData::FromSimpleJson, SBodybagSaveData::Serialize, SBodybagSaveData::Equals, SBodybagSaveData::Destroy);

void SBodybagSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vLinkedPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLinkedPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLinkedQuaternionRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vLinkedQuaternionRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SBodybagBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBoneIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDeadActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDeadActor);

	p_Stream << "}";
}

void SBodybagSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBodybagSaveData*>(p_Target);

	SVector3::FromSimpleJson(p_Document["m_vLinkedPosition"], &s_Object->m_vLinkedPosition);

	SVector4::FromSimpleJson(p_Document["m_vLinkedQuaternionRotation"], &s_Object->m_vLinkedQuaternionRotation);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBones"];
	s_Object->m_aBones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBodybagBoneSaveData::FromSimpleJson(s_Item0, &s_Object->m_aBones[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneIndices"];
	s_Object->m_aBoneIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aBoneIndices[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_rDeadActor = simdjson::from_json_uint32(p_Document["m_rDeadActor"]);

}

void SBodybagSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLinkedPosition, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_vLinkedPosition));
	SVector4::Serialize(&s_Object->m_vLinkedQuaternionRotation, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_vLinkedQuaternionRotation));
	TArray<SBodybagBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_aBones));
	TArray<uint32>::Serialize(&s_Object->m_aBoneIndices, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_aBoneIndices));
}

bool SBodybagSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodybagSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodybagSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodybagSaveData::operator==(const SBodybagSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodybagSaveData>)
		return false;

	if (m_vLinkedPosition != p_Other.m_vLinkedPosition) return false;
	if (m_vLinkedQuaternionRotation != p_Other.m_vLinkedQuaternionRotation) return false;
	if (m_aBones != p_Other.m_aBones) return false;
	if (m_aBoneIndices != p_Other.m_aBoneIndices) return false;
	if (m_rDeadActor != p_Other.m_rDeadActor) return false;

	return true;
}

void SBodybagSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);
	s_Object->~SBodybagSaveData();
}

ZHMTypeInfo SBoneAttachSaveData::TypeInfo = ZHMTypeInfo("SBoneAttachSaveData", sizeof(SBoneAttachSaveData), alignof(SBoneAttachSaveData), SBoneAttachSaveData::WriteSimpleJson, SBoneAttachSaveData::FromSimpleJson, SBoneAttachSaveData::Serialize, SBoneAttachSaveData::Equals, SBoneAttachSaveData::Destroy);

void SBoneAttachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAttached);

	p_Stream << "}";
}

void SBoneAttachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Target);

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object->m_bIsAttached = simdjson::from_json_bool(p_Document["m_bIsAttached"]);

}

void SBoneAttachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);

}

bool SBoneAttachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneAttachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneAttachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneAttachSaveData::operator==(const SBoneAttachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneAttachSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsAttached != p_Other.m_bIsAttached) return false;

	return true;
}

void SBoneAttachSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);
	s_Object->~SBoneAttachSaveData();
}

ZHMTypeInfo SBoneScalesList::TypeInfo = ZHMTypeInfo("SBoneScalesList", sizeof(SBoneScalesList), alignof(SBoneScalesList), SBoneScalesList::WriteSimpleJson, SBoneScalesList::FromSimpleJson, SBoneScalesList::Serialize, SBoneScalesList::Equals, SBoneScalesList::Destroy);

void SBoneScalesList::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBoneScales") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneScales.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneScales[i];
		SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBoneScales.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBoneScalesList::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SBoneScalesList*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneScales"];
	s_Object->m_aBoneScales.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVector3::FromSimpleJson(s_Item0, &s_Object->m_aBoneScales[s_Index0]);
		++s_Index0;
	}
	}

}

void SBoneScalesList::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	TArray<SVector3>::Serialize(&s_Object->m_aBoneScales, p_Serializer, p_OwnOffset + offsetof(SBoneScalesList, m_aBoneScales));
}

bool SBoneScalesList::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneScalesList*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneScalesList*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneScalesList::operator==(const SBoneScalesList& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneScalesList>)
		return false;

	if (m_aBoneScales != p_Other.m_aBoneScales) return false;

	return true;
}

void SBoneScalesList::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);
	s_Object->~SBoneScalesList();
}

ZHMTypeInfo SCamBone::TypeInfo = ZHMTypeInfo("SCamBone", sizeof(SCamBone), alignof(SCamBone), SCamBone::WriteSimpleJson, SCamBone::FromSimpleJson, SCamBone::Serialize, SCamBone::Equals, SCamBone::Destroy);

void SCamBone::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eBoneId") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("BoneId.Enum", static_cast<int>(s_Object->m_eBoneId)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWeight);

	p_Stream << "}";
}

void SCamBone::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCamBone*>(p_Target);

	s_Object->m_eBoneId = static_cast<BoneId::Enum>(ZHMEnums::GetEnumValueByName("BoneId.Enum", std::string_view(p_Document["m_eBoneId"])));

	s_Object->m_fWeight = simdjson::from_json_float32(p_Document["m_fWeight"]);

}

void SCamBone::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);

}

bool SCamBone::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCamBone*>(p_Left);
	auto* s_Right = reinterpret_cast<SCamBone*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCamBone::operator==(const SCamBone& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCamBone>)
		return false;

	if (m_eBoneId != p_Other.m_eBoneId) return false;
	if (m_fWeight != p_Other.m_fWeight) return false;

	return true;
}

void SCamBone::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);
	s_Object->~SCamBone();
}

ZHMTypeInfo ZSituationGroup::TypeInfo = ZHMTypeInfo("ZSituationGroup", sizeof(ZSituationGroup), alignof(ZSituationGroup), ZSituationGroup::WriteSimpleJson, ZSituationGroup::FromSimpleJson, ZSituationGroup::Serialize, ZSituationGroup::Equals, ZSituationGroup::Destroy);

void ZSituationGroup::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSituationGroup::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSituationGroup*>(p_Target);

}

void ZSituationGroup::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);

}

bool ZSituationGroup::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSituationGroup*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSituationGroup*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSituationGroup::operator==(const ZSituationGroup& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSituationGroup>)
		return false;


	return true;
}

void ZSituationGroup::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);
	s_Object->~ZSituationGroup();
}

ZHMTypeInfo SCautiousBackupGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousBackupGroupSaveData", sizeof(SCautiousBackupGroupSaveData), alignof(SCautiousBackupGroupSaveData), SCautiousBackupGroupSaveData::WriteSimpleJson, SCautiousBackupGroupSaveData::FromSimpleJson, SCautiousBackupGroupSaveData::Serialize, SCautiousBackupGroupSaveData::Equals, SCautiousBackupGroupSaveData::Destroy);

void SCautiousBackupGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eGroupState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousBackupGroup.EGroupState", static_cast<int>(s_Object->m_eGroupState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aReservedApproachNodeIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aReservedApproachNodeIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aReservedApproachNodeIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aReservedApproachNodeIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);

	p_Stream << "}";
}

void SCautiousBackupGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Target);

	s_Object->m_eGroupState = static_cast<ZCautiousBackupGroup::EGroupState>(ZHMEnums::GetEnumValueByName("ZCautiousBackupGroup.EGroupState", std::string_view(p_Document["m_eGroupState"])));

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object->m_nTargetNodeIndex = simdjson::from_json_uint16(p_Document["m_nTargetNodeIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCandidates"];
	s_Object->m_aCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aCandidates[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_pCandidate = simdjson::from_json_uint32(p_Document["m_pCandidate"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aReservedApproachNodeIndices"];
	s_Object->m_aReservedApproachNodeIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aReservedApproachNodeIndices[s_Index0] = simdjson::from_json_uint16(s_Item0);
		++s_Index0;
	}
	}

	ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Object->m_tStart);

}

void SCautiousBackupGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_aCandidates));
	TArray<uint16>::Serialize(&s_Object->m_aReservedApproachNodeIndices, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_aReservedApproachNodeIndices));
	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_tStart));
}

bool SCautiousBackupGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousBackupGroupSaveData::operator==(const SCautiousBackupGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousBackupGroupSaveData>)
		return false;

	if (m_eGroupState != p_Other.m_eGroupState) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_nTargetNodeIndex != p_Other.m_nTargetNodeIndex) return false;
	if (m_aCandidates != p_Other.m_aCandidates) return false;
	if (m_pCandidate != p_Other.m_pCandidate) return false;
	if (m_aReservedApproachNodeIndices != p_Other.m_aReservedApproachNodeIndices) return false;
	if (m_tStart != p_Other.m_tStart) return false;

	return true;
}

void SCautiousBackupGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);
	s_Object->~SCautiousBackupGroupSaveData();
}

ZHMTypeInfo SCautiousHuntSaveData::TypeInfo = ZHMTypeInfo("SCautiousHuntSaveData", sizeof(SCautiousHuntSaveData), alignof(SCautiousHuntSaveData), SCautiousHuntSaveData::WriteSimpleJson, SCautiousHuntSaveData::FromSimpleJson, SCautiousHuntSaveData::Serialize, SCautiousHuntSaveData::Equals, SCautiousHuntSaveData::Destroy);

void SCautiousHuntSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAnnounceHuntCoolDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAnnounceHuntCoolDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAnnouncedHunt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAnnouncedHunt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tShareHuntTargetCoolDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tShareHuntTargetCoolDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnounceHunt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnounceHunt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnouncedHunt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnouncedHunt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayAnnouncementDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayAnnouncementDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHuntTargetKnownKiller") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHuntTargetKnownKiller);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSharedHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSharedHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetBlamed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetBlamed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRuleActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRuleActive);

	p_Stream << "}";
}

void SCautiousHuntSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	ZGameTime::FromSimpleJson(p_Document["m_tAnnounceHuntCoolDown"], &s_Object->m_tAnnounceHuntCoolDown);

	ZGameTime::FromSimpleJson(p_Document["m_tAnnouncedHunt"], &s_Object->m_tAnnouncedHunt);

	ZGameTime::FromSimpleJson(p_Document["m_tShareHuntTargetCoolDown"], &s_Object->m_tShareHuntTargetCoolDown);

	s_Object->m_bAnnounceHunt = simdjson::from_json_bool(p_Document["m_bAnnounceHunt"]);

	s_Object->m_bAnnouncedHunt = simdjson::from_json_bool(p_Document["m_bAnnouncedHunt"]);

	s_Object->m_bPlayAnnouncementDialog = simdjson::from_json_bool(p_Document["m_bPlayAnnouncementDialog"]);

	s_Object->m_bHuntTargetKnownKiller = simdjson::from_json_bool(p_Document["m_bHuntTargetKnownKiller"]);

	s_Object->m_bSharedHuntTarget = simdjson::from_json_bool(p_Document["m_bSharedHuntTarget"]);

	s_Object->m_bTargetBlamed = simdjson::from_json_bool(p_Document["m_bTargetBlamed"]);

	s_Object->m_bRuleActive = simdjson::from_json_bool(p_Document["m_bRuleActive"]);

}

void SCautiousHuntSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tAnnounceHuntCoolDown, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tAnnounceHuntCoolDown));
	ZGameTime::Serialize(&s_Object->m_tAnnouncedHunt, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tAnnouncedHunt));
	ZGameTime::Serialize(&s_Object->m_tShareHuntTargetCoolDown, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tShareHuntTargetCoolDown));
}

bool SCautiousHuntSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousHuntSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousHuntSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousHuntSaveData::operator==(const SCautiousHuntSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousHuntSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tAnnounceHuntCoolDown != p_Other.m_tAnnounceHuntCoolDown) return false;
	if (m_tAnnouncedHunt != p_Other.m_tAnnouncedHunt) return false;
	if (m_tShareHuntTargetCoolDown != p_Other.m_tShareHuntTargetCoolDown) return false;
	if (m_bAnnounceHunt != p_Other.m_bAnnounceHunt) return false;
	if (m_bAnnouncedHunt != p_Other.m_bAnnouncedHunt) return false;
	if (m_bPlayAnnouncementDialog != p_Other.m_bPlayAnnouncementDialog) return false;
	if (m_bHuntTargetKnownKiller != p_Other.m_bHuntTargetKnownKiller) return false;
	if (m_bSharedHuntTarget != p_Other.m_bSharedHuntTarget) return false;
	if (m_bTargetBlamed != p_Other.m_bTargetBlamed) return false;
	if (m_bRuleActive != p_Other.m_bRuleActive) return false;

	return true;
}

void SCautiousHuntSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);
	s_Object->~SCautiousHuntSaveData();
}

ZHMTypeInfo SExactCompressedGridFloatField::TypeInfo = ZHMTypeInfo("SExactCompressedGridFloatField", sizeof(SExactCompressedGridFloatField), alignof(SExactCompressedGridFloatField), SExactCompressedGridFloatField::WriteSimpleJson, SExactCompressedGridFloatField::FromSimpleJson, SExactCompressedGridFloatField::Serialize, SExactCompressedGridFloatField::Equals, SExactCompressedGridFloatField::Destroy);

void SExactCompressedGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFieldSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFieldSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCRC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCRC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SExactCompressedGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Target);

	s_Object->m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	s_Object->m_nFieldSize = simdjson::from_json_uint32(p_Document["m_nFieldSize"]);

	s_Object->m_nGridCRC = simdjson::from_json_uint32(p_Document["m_nGridCRC"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIndices"];
	s_Object->m_aIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aIndices[s_Index0] = simdjson::from_json_uint16(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aValues"];
	s_Object->m_aValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aValues[s_Index0] = simdjson::from_json_float32(s_Item0);
		++s_Index0;
	}
	}

}

void SExactCompressedGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_aIndices, p_Serializer, p_OwnOffset + offsetof(SExactCompressedGridFloatField, m_aIndices));
	TArray<float32>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SExactCompressedGridFloatField, m_aValues));
}

bool SExactCompressedGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExactCompressedGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<SExactCompressedGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExactCompressedGridFloatField::operator==(const SExactCompressedGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExactCompressedGridFloatField>)
		return false;

	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_nFieldSize != p_Other.m_nFieldSize) return false;
	if (m_nGridCRC != p_Other.m_nGridCRC) return false;
	if (m_aIndices != p_Other.m_aIndices) return false;
	if (m_aValues != p_Other.m_aValues) return false;

	return true;
}

void SExactCompressedGridFloatField::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);
	s_Object->~SExactCompressedGridFloatField();
}

ZHMTypeInfo SCautiousInvestigateGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousInvestigateGroupSaveData", sizeof(SCautiousInvestigateGroupSaveData), alignof(SCautiousInvestigateGroupSaveData), SCautiousInvestigateGroupSaveData::WriteSimpleJson, SCautiousInvestigateGroupSaveData::FromSimpleJson, SCautiousInvestigateGroupSaveData::Serialize, SCautiousInvestigateGroupSaveData::Equals, SCautiousInvestigateGroupSaveData::Destroy);

void SCautiousInvestigateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tGroupStarted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGroupStarted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLeaderApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLeaderApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAssistantApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAssistantApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eApproachOrderState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousInvestigateGroup.EApproachOrderState", static_cast<int>(s_Object->m_eApproachOrderState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmAssistantState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmAssistantState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUsingRecurringDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUsingRecurringDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStartedInvestigateDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedInvestigateDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDelayInvestigateDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDelayInvestigateDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReservedOccupancy") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReservedOccupancy);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSilentInvestigation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSilentInvestigation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInvestigateDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInvestigateDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMultipleBodies") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMultipleBodies);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCheckSuspects") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCheckSuspects);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_investigateArea") << ":";
	float4::WriteSimpleJson(&s_Object->m_investigateArea, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetDistanceField") << ":";
	SExactCompressedGridFloatField::WriteSimpleJson(&s_Object->m_targetDistanceField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetLOSField") << ":";
	SExactCompressedGridFloatField::WriteSimpleJson(&s_Object->m_targetLOSField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidTargetDistanceField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidTargetDistanceField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidTargetLOSField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidTargetLOSField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceAcknowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceAcknowledge);

	p_Stream << "}";
}

void SCautiousInvestigateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_tGroupStarted"], &s_Object->m_tGroupStarted);

	s_Object->m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object->m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object->m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object->m_nLeaderApproachNode = simdjson::from_json_int32(p_Document["m_nLeaderApproachNode"]);

	s_Object->m_nAssistantApproachNode = simdjson::from_json_int32(p_Document["m_nAssistantApproachNode"]);

	s_Object->m_eApproachOrderState = static_cast<ZCautiousInvestigateGroup::EApproachOrderState>(ZHMEnums::GetEnumValueByName("ZCautiousInvestigateGroup.EApproachOrderState", std::string_view(p_Document["m_eApproachOrderState"])));

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmAssistantState"], &s_Object->m_fsmAssistantState);

	s_Object->m_bUsingRecurringDialog = simdjson::from_json_bool(p_Document["m_bUsingRecurringDialog"]);

	s_Object->m_bStartedInvestigateDialog = simdjson::from_json_bool(p_Document["m_bStartedInvestigateDialog"]);

	s_Object->m_bDelayInvestigateDialog = simdjson::from_json_bool(p_Document["m_bDelayInvestigateDialog"]);

	s_Object->m_bReservedOccupancy = simdjson::from_json_bool(p_Document["m_bReservedOccupancy"]);

	s_Object->m_bSilentInvestigation = simdjson::from_json_bool(p_Document["m_bSilentInvestigation"]);

	s_Object->m_bInvestigateDeadBody = simdjson::from_json_bool(p_Document["m_bInvestigateDeadBody"]);

	s_Object->m_bMultipleBodies = simdjson::from_json_bool(p_Document["m_bMultipleBodies"]);

	s_Object->m_bCheckSuspects = simdjson::from_json_bool(p_Document["m_bCheckSuspects"]);

	float4::FromSimpleJson(p_Document["m_investigateArea"], &s_Object->m_investigateArea);

	SExactCompressedGridFloatField::FromSimpleJson(p_Document["m_targetDistanceField"], &s_Object->m_targetDistanceField);

	SExactCompressedGridFloatField::FromSimpleJson(p_Document["m_targetLOSField"], &s_Object->m_targetLOSField);

	s_Object->m_bValidTargetDistanceField = simdjson::from_json_bool(p_Document["m_bValidTargetDistanceField"]);

	s_Object->m_bValidTargetLOSField = simdjson::from_json_bool(p_Document["m_bValidTargetLOSField"]);

	s_Object->m_bForceAcknowledge = simdjson::from_json_bool(p_Document["m_bForceAcknowledge"]);

}

void SCautiousInvestigateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGroupStarted, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_tGroupStarted));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_fsmState));
	SFSMSaveData::Serialize(&s_Object->m_fsmAssistantState, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_fsmAssistantState));
	float4::Serialize(&s_Object->m_investigateArea, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_investigateArea));
	SExactCompressedGridFloatField::Serialize(&s_Object->m_targetDistanceField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_targetDistanceField));
	SExactCompressedGridFloatField::Serialize(&s_Object->m_targetLOSField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_targetLOSField));
}

bool SCautiousInvestigateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousInvestigateGroupSaveData::operator==(const SCautiousInvestigateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousInvestigateGroupSaveData>)
		return false;

	if (m_tGroupStarted != p_Other.m_tGroupStarted) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_nLeaderApproachNode != p_Other.m_nLeaderApproachNode) return false;
	if (m_nAssistantApproachNode != p_Other.m_nAssistantApproachNode) return false;
	if (m_eApproachOrderState != p_Other.m_eApproachOrderState) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_fsmAssistantState != p_Other.m_fsmAssistantState) return false;
	if (m_bUsingRecurringDialog != p_Other.m_bUsingRecurringDialog) return false;
	if (m_bStartedInvestigateDialog != p_Other.m_bStartedInvestigateDialog) return false;
	if (m_bDelayInvestigateDialog != p_Other.m_bDelayInvestigateDialog) return false;
	if (m_bReservedOccupancy != p_Other.m_bReservedOccupancy) return false;
	if (m_bSilentInvestigation != p_Other.m_bSilentInvestigation) return false;
	if (m_bInvestigateDeadBody != p_Other.m_bInvestigateDeadBody) return false;
	if (m_bMultipleBodies != p_Other.m_bMultipleBodies) return false;
	if (m_bCheckSuspects != p_Other.m_bCheckSuspects) return false;
	if (m_investigateArea != p_Other.m_investigateArea) return false;
	if (m_targetDistanceField != p_Other.m_targetDistanceField) return false;
	if (m_targetLOSField != p_Other.m_targetLOSField) return false;
	if (m_bValidTargetDistanceField != p_Other.m_bValidTargetDistanceField) return false;
	if (m_bValidTargetLOSField != p_Other.m_bValidTargetLOSField) return false;
	if (m_bForceAcknowledge != p_Other.m_bForceAcknowledge) return false;

	return true;
}

void SCautiousInvestigateGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);
	s_Object->~SCautiousInvestigateGroupSaveData();
}

ZHMTypeInfo SCompressedGridFloatField::TypeInfo = ZHMTypeInfo("SCompressedGridFloatField", sizeof(SCompressedGridFloatField), alignof(SCompressedGridFloatField), SCompressedGridFloatField::WriteSimpleJson, SCompressedGridFloatField::FromSimpleJson, SCompressedGridFloatField::Serialize, SCompressedGridFloatField::Equals, SCompressedGridFloatField::Destroy);

void SCompressedGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsSparse") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSparse);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFieldSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFieldSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCRC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCRC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCompressedGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Target);

	s_Object->m_bIsSparse = simdjson::from_json_bool(p_Document["m_bIsSparse"]);

	s_Object->m_nFieldSize = simdjson::from_json_uint32(p_Document["m_nFieldSize"]);

	s_Object->m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	s_Object->m_nGridCRC = simdjson::from_json_uint32(p_Document["m_nGridCRC"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIndices"];
	s_Object->m_aIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aIndices[s_Index0] = simdjson::from_json_uint16(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aValues"];
	s_Object->m_aValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aValues[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

}

void SCompressedGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_aIndices, p_Serializer, p_OwnOffset + offsetof(SCompressedGridFloatField, m_aIndices));
	TArray<uint8>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SCompressedGridFloatField, m_aValues));
}

bool SCompressedGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCompressedGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<SCompressedGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCompressedGridFloatField::operator==(const SCompressedGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCompressedGridFloatField>)
		return false;

	if (m_bIsSparse != p_Other.m_bIsSparse) return false;
	if (m_nFieldSize != p_Other.m_nFieldSize) return false;
	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_nGridCRC != p_Other.m_nGridCRC) return false;
	if (m_aIndices != p_Other.m_aIndices) return false;
	if (m_aValues != p_Other.m_aValues) return false;

	return true;
}

void SCompressedGridFloatField::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);
	s_Object->~SCompressedGridFloatField();
}

ZHMTypeInfo ZInvestigateCautiousSituation::SStateData::TypeInfo = ZHMTypeInfo("ZInvestigateCautiousSituation.SStateData", sizeof(ZInvestigateCautiousSituation::SStateData), alignof(ZInvestigateCautiousSituation::SStateData), ZInvestigateCautiousSituation::SStateData::WriteSimpleJson, ZInvestigateCautiousSituation::SStateData::FromSimpleJson, ZInvestigateCautiousSituation::SStateData::Serialize, ZInvestigateCautiousSituation::SStateData::Equals, ZInvestigateCautiousSituation::SStateData::Destroy);

void ZInvestigateCautiousSituation::SStateData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation::SStateData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateCautiousSituation.ESituationState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eBystanderState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateCautiousSituation.EBystanderState", static_cast<int>(s_Object->m_eBystanderState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInvestigationEnded") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInvestigationEnded, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastApproachOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastApproachOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastBackupGroupEnded") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastBackupGroupEnded, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastHunt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastHunt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHuntTargetLastUpdate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tHuntTargetLastUpdate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNewHuntTargetTimer") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNewHuntTargetTimer, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCombatAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCombatAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownZoneDisturbanceAdded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownZoneDisturbanceAdded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownFalseAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownFalseAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownGracePeriod") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownGracePeriod);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHMInGuardDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHMInGuardDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrisked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrisked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnouncedFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnouncedFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReasonToFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReasonToFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneHasBeenInCombat") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneHasBeenInCombat);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInvestigationGroupActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInvestigationGroupActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandDownGuards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandDownGuards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStandDownDelay") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStandDownDelay, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMostSevereDisturbance") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eMostSevereDisturbance)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDiscoveredDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDiscoveredDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDiscoveredPacifiedBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDiscoveredPacifiedBody);

	p_Stream << "}";
}

void ZInvestigateCautiousSituation::SStateData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInvestigateCautiousSituation::SStateData*>(p_Target);

	s_Object->m_state = static_cast<ZInvestigateCautiousSituation::ESituationState>(ZHMEnums::GetEnumValueByName("ZInvestigateCautiousSituation.ESituationState", std::string_view(p_Document["m_state"])));

	s_Object->m_eBystanderState = static_cast<ZInvestigateCautiousSituation::EBystanderState>(ZHMEnums::GetEnumValueByName("ZInvestigateCautiousSituation.EBystanderState", std::string_view(p_Document["m_eBystanderState"])));

	ZGameTime::FromSimpleJson(p_Document["m_tLastInvestigationEnded"], &s_Object->m_tLastInvestigationEnded);

	ZGameTime::FromSimpleJson(p_Document["m_tLastApproachOrder"], &s_Object->m_tLastApproachOrder);

	ZGameTime::FromSimpleJson(p_Document["m_tLastBackupGroupEnded"], &s_Object->m_tLastBackupGroupEnded);

	ZGameTime::FromSimpleJson(p_Document["m_tLastHunt"], &s_Object->m_tLastHunt);

	ZGameTime::FromSimpleJson(p_Document["m_tHuntTargetLastUpdate"], &s_Object->m_tHuntTargetLastUpdate);

	ZGameTime::FromSimpleJson(p_Document["m_tNewHuntTargetTimer"], &s_Object->m_tNewHuntTargetTimer);

	s_Object->m_fCombatAge = simdjson::from_json_float32(p_Document["m_fCombatAge"]);

	s_Object->m_bLockdownZoneDisturbanceAdded = simdjson::from_json_bool(p_Document["m_bLockdownZoneDisturbanceAdded"]);

	s_Object->m_bLockdownSituation = simdjson::from_json_bool(p_Document["m_bLockdownSituation"]);

	s_Object->m_bLockdownFalseAlarm = simdjson::from_json_bool(p_Document["m_bLockdownFalseAlarm"]);

	s_Object->m_bLockdownGracePeriod = simdjson::from_json_bool(p_Document["m_bLockdownGracePeriod"]);

	s_Object->m_bHMInGuardDisguise = simdjson::from_json_bool(p_Document["m_bHMInGuardDisguise"]);

	s_Object->m_bFrisked = simdjson::from_json_bool(p_Document["m_bFrisked"]);

	s_Object->m_bAnnouncedFrisk = simdjson::from_json_bool(p_Document["m_bAnnouncedFrisk"]);

	s_Object->m_bReasonToFrisk = simdjson::from_json_bool(p_Document["m_bReasonToFrisk"]);

	s_Object->m_bSomeoneHasBeenInCombat = simdjson::from_json_bool(p_Document["m_bSomeoneHasBeenInCombat"]);

	s_Object->m_bInvestigationGroupActive = simdjson::from_json_bool(p_Document["m_bInvestigationGroupActive"]);

	s_Object->m_bStandDownGuards = simdjson::from_json_bool(p_Document["m_bStandDownGuards"]);

	ZGameTime::FromSimpleJson(p_Document["m_tStandDownDelay"], &s_Object->m_tStandDownDelay);

	s_Object->m_eMostSevereDisturbance = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eMostSevereDisturbance"])));

	s_Object->m_bDiscoveredDeadBody = simdjson::from_json_bool(p_Document["m_bDiscoveredDeadBody"]);

	s_Object->m_bDiscoveredPacifiedBody = simdjson::from_json_bool(p_Document["m_bDiscoveredPacifiedBody"]);

}

void ZInvestigateCautiousSituation::SStateData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation::SStateData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastInvestigationEnded, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation::SStateData, m_tLastInvestigationEnded));
	ZGameTime::Serialize(&s_Object->m_tLastApproachOrder, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation::SStateData, m_tLastApproachOrder));
	ZGameTime::Serialize(&s_Object->m_tLastBackupGroupEnded, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation::SStateData, m_tLastBackupGroupEnded));
	ZGameTime::Serialize(&s_Object->m_tLastHunt, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation::SStateData, m_tLastHunt));
	ZGameTime::Serialize(&s_Object->m_tHuntTargetLastUpdate, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation::SStateData, m_tHuntTargetLastUpdate));
	ZGameTime::Serialize(&s_Object->m_tNewHuntTargetTimer, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation::SStateData, m_tNewHuntTargetTimer));
	ZGameTime::Serialize(&s_Object->m_tStandDownDelay, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation::SStateData, m_tStandDownDelay));
}

bool ZInvestigateCautiousSituation::SStateData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateCautiousSituation::SStateData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateCautiousSituation::SStateData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateCautiousSituation::SStateData::operator==(const ZInvestigateCautiousSituation::SStateData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateCautiousSituation::SStateData>)
		return false;

	if (m_state != p_Other.m_state) return false;
	if (m_eBystanderState != p_Other.m_eBystanderState) return false;
	if (m_tLastInvestigationEnded != p_Other.m_tLastInvestigationEnded) return false;
	if (m_tLastApproachOrder != p_Other.m_tLastApproachOrder) return false;
	if (m_tLastBackupGroupEnded != p_Other.m_tLastBackupGroupEnded) return false;
	if (m_tLastHunt != p_Other.m_tLastHunt) return false;
	if (m_tHuntTargetLastUpdate != p_Other.m_tHuntTargetLastUpdate) return false;
	if (m_tNewHuntTargetTimer != p_Other.m_tNewHuntTargetTimer) return false;
	if (m_fCombatAge != p_Other.m_fCombatAge) return false;
	if (m_bLockdownZoneDisturbanceAdded != p_Other.m_bLockdownZoneDisturbanceAdded) return false;
	if (m_bLockdownSituation != p_Other.m_bLockdownSituation) return false;
	if (m_bLockdownFalseAlarm != p_Other.m_bLockdownFalseAlarm) return false;
	if (m_bLockdownGracePeriod != p_Other.m_bLockdownGracePeriod) return false;
	if (m_bHMInGuardDisguise != p_Other.m_bHMInGuardDisguise) return false;
	if (m_bFrisked != p_Other.m_bFrisked) return false;
	if (m_bAnnouncedFrisk != p_Other.m_bAnnouncedFrisk) return false;
	if (m_bReasonToFrisk != p_Other.m_bReasonToFrisk) return false;
	if (m_bSomeoneHasBeenInCombat != p_Other.m_bSomeoneHasBeenInCombat) return false;
	if (m_bInvestigationGroupActive != p_Other.m_bInvestigationGroupActive) return false;
	if (m_bStandDownGuards != p_Other.m_bStandDownGuards) return false;
	if (m_tStandDownDelay != p_Other.m_tStandDownDelay) return false;
	if (m_eMostSevereDisturbance != p_Other.m_eMostSevereDisturbance) return false;
	if (m_bDiscoveredDeadBody != p_Other.m_bDiscoveredDeadBody) return false;
	if (m_bDiscoveredPacifiedBody != p_Other.m_bDiscoveredPacifiedBody) return false;

	return true;
}

void ZInvestigateCautiousSituation::SStateData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation::SStateData*>(p_Object);
	s_Object->~SStateData();
}

ZHMTypeInfo SDisturbanceSaveData::TypeInfo = ZHMTypeInfo("SDisturbanceSaveData", sizeof(SDisturbanceSaveData), alignof(SDisturbanceSaveData), SDisturbanceSaveData::WriteSimpleJson, SDisturbanceSaveData::FromSimpleJson, SDisturbanceSaveData::Serialize, SDisturbanceSaveData::Equals, SDisturbanceSaveData::Destroy);

void SDisturbanceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_object") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_object);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECautiousDisturbanceState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_started") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_started, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockOnHitmanPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockOnHitmanPosition);

	p_Stream << "}";
}

void SDisturbanceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Target);

	s_Object->m_object = simdjson::from_json_int32(p_Document["m_object"]);

	s_Object->m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object->m_state = static_cast<ECautiousDisturbanceState>(ZHMEnums::GetEnumValueByName("ECautiousDisturbanceState", std::string_view(p_Document["m_state"])));

	ZGameTime::FromSimpleJson(p_Document["m_started"], &s_Object->m_started);

	s_Object->m_pInvestigateGroup = simdjson::from_json_int32(p_Document["m_pInvestigateGroup"]);

	s_Object->m_bLockOnHitmanPosition = simdjson::from_json_bool(p_Document["m_bLockOnHitmanPosition"]);

}

void SDisturbanceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_started, p_Serializer, p_OwnOffset + offsetof(SDisturbanceSaveData, m_started));
}

bool SDisturbanceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDisturbanceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDisturbanceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDisturbanceSaveData::operator==(const SDisturbanceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDisturbanceSaveData>)
		return false;

	if (m_object != p_Other.m_object) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_state != p_Other.m_state) return false;
	if (m_started != p_Other.m_started) return false;
	if (m_pInvestigateGroup != p_Other.m_pInvestigateGroup) return false;
	if (m_bLockOnHitmanPosition != p_Other.m_bLockOnHitmanPosition) return false;

	return true;
}

void SDisturbanceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);
	s_Object->~SDisturbanceSaveData();
}

ZHMTypeInfo SCautiousInvestigateSituationSaveData::TypeInfo = ZHMTypeInfo("SCautiousInvestigateSituationSaveData", sizeof(SCautiousInvestigateSituationSaveData), alignof(SCautiousInvestigateSituationSaveData), SCautiousInvestigateSituationSaveData::WriteSimpleJson, SCautiousInvestigateSituationSaveData::FromSimpleJson, SCautiousInvestigateSituationSaveData::Serialize, SCautiousInvestigateSituationSaveData::Equals, SCautiousInvestigateSituationSaveData::Destroy);

void SCautiousInvestigateSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_StateData") << ":";
	ZInvestigateCautiousSituation::SStateData::WriteSimpleJson(&s_Object->m_StateData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pBackupGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pBackupGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rTriggerAlarmGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTriggerAlarmGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_cautiousVIPGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cautiousVIPGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cautiousVIPGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_cautiousVIPGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_friskGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_friskGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_friskGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_friskGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tFriskCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tFriskCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tFriskGroupEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tFriskGroupEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tRecoverUnconsciousGroupEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tRecoverUnconsciousGroupEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGuardMembers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGuardMembers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGuardMembers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aGuardMembers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_disturbances") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_disturbances.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_disturbances[i];
		SDisturbanceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_disturbances.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidDisturbanceField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidDisturbanceField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_disturbanceField") << ":";
	SCompressedGridFloatField::WriteSimpleJson(&s_Object->m_disturbanceField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_recoverUnconsciousGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_recoverUnconsciousGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspendSearchOnInitialGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspendSearchOnInitialGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastStaticArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastStaticArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastStaticCombatReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastStaticCombatReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnyGunshotDisturbance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnyGunshotDisturbance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadBodyMassiveReported") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadBodyMassiveReported);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadBodiesDiscovered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadBodiesDiscovered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadCrowdBodiesDiscovered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadCrowdBodiesDiscovered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicEnforceEventsForSearchers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicEnforceEventsForSearchers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicEnforceEventsForSearchers[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aDynamicEnforceEventsForSearchers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastIdleStanddown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastIdleStanddown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_cautiousHuntData") << ":";
	SCautiousHuntSaveData::WriteSimpleJson(&s_Object->m_cautiousHuntData, p_Stream);

	p_Stream << "}";
}

void SCautiousInvestigateSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Target);

	ZInvestigateCautiousSituation::SStateData::FromSimpleJson(p_Document["m_StateData"], &s_Object->m_StateData);

	s_Object->m_pGetHelpGroup = simdjson::from_json_int32(p_Document["m_pGetHelpGroup"]);

	s_Object->m_pBackupGroup = simdjson::from_json_int32(p_Document["m_pBackupGroup"]);

	s_Object->m_rTriggerAlarmGroup = simdjson::from_json_int32(p_Document["m_rTriggerAlarmGroup"]);

	s_Object->m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_cautiousVIPGroups"];
	s_Object->m_cautiousVIPGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_cautiousVIPGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_friskGroups"];
	s_Object->m_friskGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_friskGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	ZGameTime::FromSimpleJson(p_Document["m_tFriskCooldown"], &s_Object->m_tFriskCooldown);

	ZGameTime::FromSimpleJson(p_Document["m_tFriskGroupEnd"], &s_Object->m_tFriskGroupEnd);

	ZGameTime::FromSimpleJson(p_Document["m_tRecoverUnconsciousGroupEnd"], &s_Object->m_tRecoverUnconsciousGroupEnd);

	s_Object->m_nHuntTarget = simdjson::from_json_int32(p_Document["m_nHuntTarget"]);

	s_Object->m_rZone = simdjson::from_json_uint32(p_Document["m_rZone"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGuardMembers"];
	s_Object->m_aGuardMembers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aGuardMembers[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_disturbances"];
	s_Object->m_disturbances.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDisturbanceSaveData::FromSimpleJson(s_Item0, &s_Object->m_disturbances[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_bValidDisturbanceField = simdjson::from_json_bool(p_Document["m_bValidDisturbanceField"]);

	SCompressedGridFloatField::FromSimpleJson(p_Document["m_disturbanceField"], &s_Object->m_disturbanceField);

	s_Object->m_recoverUnconsciousGroup = simdjson::from_json_int32(p_Document["m_recoverUnconsciousGroup"]);

	s_Object->m_bSuspendSearchOnInitialGetHelpGroup = simdjson::from_json_bool(p_Document["m_bSuspendSearchOnInitialGetHelpGroup"]);

	s_Object->m_lastArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastArrestReason"])));

	s_Object->m_lastStaticArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastStaticArrestReason"])));

	s_Object->m_lastStaticCombatReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastStaticCombatReason"])));

	s_Object->m_bAnyGunshotDisturbance = simdjson::from_json_bool(p_Document["m_bAnyGunshotDisturbance"]);

	s_Object->m_deadBodyMassiveReported = simdjson::from_json_bool(p_Document["m_deadBodyMassiveReported"]);

	s_Object->m_deadBodiesDiscovered = simdjson::from_json_int32(p_Document["m_deadBodiesDiscovered"]);

	s_Object->m_deadCrowdBodiesDiscovered = simdjson::from_json_int32(p_Document["m_deadCrowdBodiesDiscovered"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDynamicEnforceEventsForSearchers"];
	s_Object->m_aDynamicEnforceEventsForSearchers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aDynamicEnforceEventsForSearchers[s_Index0] = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(s_Item0)));
		++s_Index0;
	}
	}

	ZGameTime::FromSimpleJson(p_Document["m_tLastIdleStanddown"], &s_Object->m_tLastIdleStanddown);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAvoidDangerGroups"];
	s_Object->m_aAvoidDangerGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aAvoidDangerGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	SCautiousHuntSaveData::FromSimpleJson(p_Document["m_cautiousHuntData"], &s_Object->m_cautiousHuntData);

}

void SCautiousInvestigateSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);

	ZInvestigateCautiousSituation::SStateData::Serialize(&s_Object->m_StateData, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_StateData));
	TArray<int32>::Serialize(&s_Object->m_cautiousVIPGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_cautiousVIPGroups));
	TArray<int32>::Serialize(&s_Object->m_friskGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_friskGroups));
	ZGameTime::Serialize(&s_Object->m_tFriskCooldown, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tFriskCooldown));
	ZGameTime::Serialize(&s_Object->m_tFriskGroupEnd, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tFriskGroupEnd));
	ZGameTime::Serialize(&s_Object->m_tRecoverUnconsciousGroupEnd, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tRecoverUnconsciousGroupEnd));
	TArray<uint32>::Serialize(&s_Object->m_aGuardMembers, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aGuardMembers));
	TArray<SDisturbanceSaveData>::Serialize(&s_Object->m_disturbances, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_disturbances));
	SCompressedGridFloatField::Serialize(&s_Object->m_disturbanceField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_disturbanceField));
	TArray<EAISharedEventType>::Serialize(&s_Object->m_aDynamicEnforceEventsForSearchers, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aDynamicEnforceEventsForSearchers));
	ZGameTime::Serialize(&s_Object->m_tLastIdleStanddown, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tLastIdleStanddown));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aAvoidDangerGroups));
	SCautiousHuntSaveData::Serialize(&s_Object->m_cautiousHuntData, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_cautiousHuntData));
}

bool SCautiousInvestigateSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousInvestigateSituationSaveData::operator==(const SCautiousInvestigateSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousInvestigateSituationSaveData>)
		return false;

	if (m_StateData != p_Other.m_StateData) return false;
	if (m_pGetHelpGroup != p_Other.m_pGetHelpGroup) return false;
	if (m_pBackupGroup != p_Other.m_pBackupGroup) return false;
	if (m_rTriggerAlarmGroup != p_Other.m_rTriggerAlarmGroup) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_cautiousVIPGroups != p_Other.m_cautiousVIPGroups) return false;
	if (m_friskGroups != p_Other.m_friskGroups) return false;
	if (m_tFriskCooldown != p_Other.m_tFriskCooldown) return false;
	if (m_tFriskGroupEnd != p_Other.m_tFriskGroupEnd) return false;
	if (m_tRecoverUnconsciousGroupEnd != p_Other.m_tRecoverUnconsciousGroupEnd) return false;
	if (m_nHuntTarget != p_Other.m_nHuntTarget) return false;
	if (m_rZone != p_Other.m_rZone) return false;
	if (m_aGuardMembers != p_Other.m_aGuardMembers) return false;
	if (m_disturbances != p_Other.m_disturbances) return false;
	if (m_bValidDisturbanceField != p_Other.m_bValidDisturbanceField) return false;
	if (m_disturbanceField != p_Other.m_disturbanceField) return false;
	if (m_recoverUnconsciousGroup != p_Other.m_recoverUnconsciousGroup) return false;
	if (m_bSuspendSearchOnInitialGetHelpGroup != p_Other.m_bSuspendSearchOnInitialGetHelpGroup) return false;
	if (m_lastArrestReason != p_Other.m_lastArrestReason) return false;
	if (m_lastStaticArrestReason != p_Other.m_lastStaticArrestReason) return false;
	if (m_lastStaticCombatReason != p_Other.m_lastStaticCombatReason) return false;
	if (m_bAnyGunshotDisturbance != p_Other.m_bAnyGunshotDisturbance) return false;
	if (m_deadBodyMassiveReported != p_Other.m_deadBodyMassiveReported) return false;
	if (m_deadBodiesDiscovered != p_Other.m_deadBodiesDiscovered) return false;
	if (m_deadCrowdBodiesDiscovered != p_Other.m_deadCrowdBodiesDiscovered) return false;
	if (m_aDynamicEnforceEventsForSearchers != p_Other.m_aDynamicEnforceEventsForSearchers) return false;
	if (m_tLastIdleStanddown != p_Other.m_tLastIdleStanddown) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;
	if (m_cautiousHuntData != p_Other.m_cautiousHuntData) return false;

	return true;
}

void SCautiousInvestigateSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);
	s_Object->~SCautiousInvestigateSituationSaveData();
}

ZHMTypeInfo SCautiousSearchGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousSearchGroupSaveData", sizeof(SCautiousSearchGroupSaveData), alignof(SCautiousSearchGroupSaveData), SCautiousSearchGroupSaveData::WriteSimpleJson, SCautiousSearchGroupSaveData::FromSimpleJson, SCautiousSearchGroupSaveData::Serialize, SCautiousSearchGroupSaveData::Equals, SCautiousSearchGroupSaveData::Destroy);

void SCautiousSearchGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_searchNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_searchNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assistantApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_assistantApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGroupState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousSearchGroup.ESearchGroupState", static_cast<int>(s_Object->m_eGroupState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAssistantState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousSearchGroup.EAssistantState", static_cast<int>(s_Object->m_eAssistantState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);

	p_Stream << "}";
}

void SCautiousSearchGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Target);

	s_Object->m_searchNode = simdjson::from_json_uint16(p_Document["m_searchNode"]);

	s_Object->m_assistantApproachNode = simdjson::from_json_uint16(p_Document["m_assistantApproachNode"]);

	s_Object->m_eGroupState = static_cast<ZCautiousSearchGroup::ESearchGroupState>(ZHMEnums::GetEnumValueByName("ZCautiousSearchGroup.ESearchGroupState", std::string_view(p_Document["m_eGroupState"])));

	s_Object->m_eAssistantState = static_cast<ZCautiousSearchGroup::EAssistantState>(ZHMEnums::GetEnumValueByName("ZCautiousSearchGroup.EAssistantState", std::string_view(p_Document["m_eAssistantState"])));

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object->m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

}

void SCautiousSearchGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);

}

bool SCautiousSearchGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousSearchGroupSaveData::operator==(const SCautiousSearchGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousSearchGroupSaveData>)
		return false;

	if (m_searchNode != p_Other.m_searchNode) return false;
	if (m_assistantApproachNode != p_Other.m_assistantApproachNode) return false;
	if (m_eGroupState != p_Other.m_eGroupState) return false;
	if (m_eAssistantState != p_Other.m_eAssistantState) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;

	return true;
}

void SCautiousSearchGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);
	s_Object->~SCautiousSearchGroupSaveData();
}

ZHMTypeInfo SCautiousSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SCautiousSituationMemberSaveData", sizeof(SCautiousSituationMemberSaveData), alignof(SCautiousSituationMemberSaveData), SCautiousSituationMemberSaveData::WriteSimpleJson, SCautiousSituationMemberSaveData::FromSimpleJson, SCautiousSituationMemberSaveData::Serialize, SCautiousSituationMemberSaveData::Equals, SCautiousSituationMemberSaveData::Destroy);

void SCautiousSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tLastDisturbance") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastDisturbance, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSearchCalc") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSearchCalc, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInfluenceCalc") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInfluenceCalc, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSearchCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSearchCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInvestigationCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInvestigationCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTimeIdling") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tTimeIdling, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGuardDutyPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuardDutyPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBulletImpactsHeard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletImpactsHeard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointSubIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointSubIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBanterCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBanterCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCivOccupant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCivOccupant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRecievingNewHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRecievingNewHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownEnforcer);

	p_Stream << "}";
}

void SCautiousSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_tLastDisturbance"], &s_Object->m_tLastDisturbance);

	ZGameTime::FromSimpleJson(p_Document["m_tLastSearchCalc"], &s_Object->m_tLastSearchCalc);

	ZGameTime::FromSimpleJson(p_Document["m_tLastInfluenceCalc"], &s_Object->m_tLastInfluenceCalc);

	ZGameTime::FromSimpleJson(p_Document["m_tLastSearchCompleted"], &s_Object->m_tLastSearchCompleted);

	ZGameTime::FromSimpleJson(p_Document["m_tLastInvestigationCompleted"], &s_Object->m_tLastInvestigationCompleted);

	ZGameTime::FromSimpleJson(p_Document["m_tTimeIdling"], &s_Object->m_tTimeIdling);

	s_Object->m_pGuardDutyPoint = simdjson::from_json_uint32(p_Document["m_pGuardDutyPoint"]);

	s_Object->m_nBulletImpactsHeard = simdjson::from_json_int32(p_Document["m_nBulletImpactsHeard"]);

	s_Object->m_nPatrolWaypointIndex = simdjson::from_json_int32(p_Document["m_nPatrolWaypointIndex"]);

	s_Object->m_nPatrolWaypointSubIndex = simdjson::from_json_uint32(p_Document["m_nPatrolWaypointSubIndex"]);

	s_Object->m_bBanterCandidate = simdjson::from_json_bool(p_Document["m_bBanterCandidate"]);

	s_Object->m_bCivOccupant = simdjson::from_json_bool(p_Document["m_bCivOccupant"]);

	s_Object->m_bRecievingNewHuntTarget = simdjson::from_json_bool(p_Document["m_bRecievingNewHuntTarget"]);

	s_Object->m_bLockdownEnforcer = simdjson::from_json_bool(p_Document["m_bLockdownEnforcer"]);

}

void SCautiousSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastDisturbance, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastDisturbance));
	ZGameTime::Serialize(&s_Object->m_tLastSearchCalc, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastSearchCalc));
	ZGameTime::Serialize(&s_Object->m_tLastInfluenceCalc, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastInfluenceCalc));
	ZGameTime::Serialize(&s_Object->m_tLastSearchCompleted, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastSearchCompleted));
	ZGameTime::Serialize(&s_Object->m_tLastInvestigationCompleted, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastInvestigationCompleted));
	ZGameTime::Serialize(&s_Object->m_tTimeIdling, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tTimeIdling));
}

bool SCautiousSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousSituationMemberSaveData::operator==(const SCautiousSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousSituationMemberSaveData>)
		return false;

	if (m_tLastDisturbance != p_Other.m_tLastDisturbance) return false;
	if (m_tLastSearchCalc != p_Other.m_tLastSearchCalc) return false;
	if (m_tLastInfluenceCalc != p_Other.m_tLastInfluenceCalc) return false;
	if (m_tLastSearchCompleted != p_Other.m_tLastSearchCompleted) return false;
	if (m_tLastInvestigationCompleted != p_Other.m_tLastInvestigationCompleted) return false;
	if (m_tTimeIdling != p_Other.m_tTimeIdling) return false;
	if (m_pGuardDutyPoint != p_Other.m_pGuardDutyPoint) return false;
	if (m_nBulletImpactsHeard != p_Other.m_nBulletImpactsHeard) return false;
	if (m_nPatrolWaypointIndex != p_Other.m_nPatrolWaypointIndex) return false;
	if (m_nPatrolWaypointSubIndex != p_Other.m_nPatrolWaypointSubIndex) return false;
	if (m_bBanterCandidate != p_Other.m_bBanterCandidate) return false;
	if (m_bCivOccupant != p_Other.m_bCivOccupant) return false;
	if (m_bRecievingNewHuntTarget != p_Other.m_bRecievingNewHuntTarget) return false;
	if (m_bLockdownEnforcer != p_Other.m_bLockdownEnforcer) return false;

	return true;
}

void SCautiousSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);
	s_Object->~SCautiousSituationMemberSaveData();
}

ZHMTypeInfo SCautiousVIPGroupState::TypeInfo = ZHMTypeInfo("SCautiousVIPGroupState", sizeof(SCautiousVIPGroupState), alignof(SCautiousVIPGroupState), SCautiousVIPGroupState::WriteSimpleJson, SCautiousVIPGroupState::FromSimpleJson, SCautiousVIPGroupState::Serialize, SCautiousVIPGroupState::Equals, SCautiousVIPGroupState::Destroy);

void SCautiousVIPGroupState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tMove") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tMove, p_Stream);

	p_Stream << "}";
}

void SCautiousVIPGroupState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_tMove"], &s_Object->m_tMove);

}

void SCautiousVIPGroupState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tMove, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupState, m_tMove));
}

bool SCautiousVIPGroupState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousVIPGroupState*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousVIPGroupState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousVIPGroupState::operator==(const SCautiousVIPGroupState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousVIPGroupState>)
		return false;

	if (m_tMove != p_Other.m_tMove) return false;

	return true;
}

void SCautiousVIPGroupState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);
	s_Object->~SCautiousVIPGroupState();
}

ZHMTypeInfo SCautiousVIPGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousVIPGroupSaveData", sizeof(SCautiousVIPGroupSaveData), alignof(SCautiousVIPGroupSaveData), SCautiousVIPGroupSaveData::WriteSimpleJson, SCautiousVIPGroupSaveData::FromSimpleJson, SCautiousVIPGroupSaveData::Serialize, SCautiousVIPGroupSaveData::Equals, SCautiousVIPGroupSaveData::Destroy);

void SCautiousVIPGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_vip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_stateData") << ":";
	SCautiousVIPGroupState::WriteSimpleJson(&s_Object->m_stateData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vipTargetNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_vipTargetNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_occupancyNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_occupancyNode);

	p_Stream << "}";
}

void SCautiousVIPGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Target);

	s_Object->m_vip = simdjson::from_json_uint32(p_Document["m_vip"]);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	SCautiousVIPGroupState::FromSimpleJson(p_Document["m_stateData"], &s_Object->m_stateData);

	s_Object->m_vipTargetNode = simdjson::from_json_int32(p_Document["m_vipTargetNode"]);

	s_Object->m_occupancyNode = simdjson::from_json_int32(p_Document["m_occupancyNode"]);

}

void SCautiousVIPGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupSaveData, m_fsmState));
	SCautiousVIPGroupState::Serialize(&s_Object->m_stateData, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupSaveData, m_stateData));
}

bool SCautiousVIPGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousVIPGroupSaveData::operator==(const SCautiousVIPGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousVIPGroupSaveData>)
		return false;

	if (m_vip != p_Other.m_vip) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_stateData != p_Other.m_stateData) return false;
	if (m_vipTargetNode != p_Other.m_vipTargetNode) return false;
	if (m_occupancyNode != p_Other.m_occupancyNode) return false;

	return true;
}

void SCautiousVIPGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);
	s_Object->~SCautiousVIPGroupSaveData();
}

ZHMTypeInfo SChairSaveData::TypeInfo = ZHMTypeInfo("SChairSaveData", sizeof(SChairSaveData), alignof(SChairSaveData), SChairSaveData::WriteSimpleJson, SChairSaveData::FromSimpleJson, SChairSaveData::Serialize, SChairSaveData::Equals, SChairSaveData::Destroy);

void SChairSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttached);

	p_Stream << "}";
}

void SChairSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SChairSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object->m_bAttached = simdjson::from_json_bool(p_Document["m_bAttached"]);

}

void SChairSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);

}

bool SChairSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChairSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChairSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChairSaveData::operator==(const SChairSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChairSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_bAttached != p_Other.m_bAttached) return false;

	return true;
}

void SChairSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);
	s_Object->~SChairSaveData();
}

ZHMTypeInfo ZDynamicObject::TypeInfo = ZHMTypeInfo("ZDynamicObject", sizeof(ZDynamicObject), alignof(ZDynamicObject), ZDynamicObject::WriteSimpleJson, ZDynamicObject::FromSimpleJson, ZDynamicObject::Serialize, ZDynamicObject::Equals, ZDynamicObject::Destroy);

void ZDynamicObject::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_value, p_Stream);

	p_Stream << "}";
}

void ZDynamicObject::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZDynamicObject*>(p_Target);

	ZVariant::FromSimpleJson(p_Document["m_value"], &s_Object->m_value);

}

void ZDynamicObject::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);

	ZVariant::Serialize(&s_Object->m_value, p_Serializer, p_OwnOffset + offsetof(ZDynamicObject, m_value));
}

bool ZDynamicObject::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDynamicObject*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDynamicObject*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDynamicObject::operator==(const ZDynamicObject& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDynamicObject>)
		return false;

	if (m_value != p_Other.m_value) return false;

	return true;
}

void ZDynamicObject::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);
	s_Object->~ZDynamicObject();
}

ZHMTypeInfo SChallengeSaveData::TypeInfo = ZHMTypeInfo("SChallengeSaveData", sizeof(SChallengeSaveData), alignof(SChallengeSaveData), SChallengeSaveData::WriteSimpleJson, SChallengeSaveData::FromSimpleJson, SChallengeSaveData::Serialize, SChallengeSaveData::Equals, SChallengeSaveData::Destroy);

void SChallengeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_State, p_Stream);

	p_Stream << "}";
}

void SChallengeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SChallengeSaveData*>(p_Target);

	s_Object->m_sId = std::string_view(p_Document["m_sId"]);

	ZDynamicObject::FromSimpleJson(p_Document["m_State"], &s_Object->m_State);

}

void SChallengeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sId, p_Serializer, p_OwnOffset + offsetof(SChallengeSaveData, m_sId));
	ZDynamicObject::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(SChallengeSaveData, m_State));
}

bool SChallengeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChallengeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChallengeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChallengeSaveData::operator==(const SChallengeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChallengeSaveData>)
		return false;

	if (m_sId != p_Other.m_sId) return false;
	if (m_State != p_Other.m_State) return false;

	return true;
}

void SChallengeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);
	s_Object->~SChallengeSaveData();
}

ZHMTypeInfo SChallengesSaveData::TypeInfo = ZHMTypeInfo("SChallengesSaveData", sizeof(SChallengesSaveData), alignof(SChallengesSaveData), SChallengesSaveData::WriteSimpleJson, SChallengesSaveData::FromSimpleJson, SChallengesSaveData::Serialize, SChallengesSaveData::Equals, SChallengesSaveData::Destroy);

void SChallengesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_mChallengeStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_mChallengeStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_mChallengeStates[i];
		SChallengeSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_mChallengeStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SChallengesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SChallengesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_mChallengeStates"];
	s_Object->m_mChallengeStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SChallengeSaveData::FromSimpleJson(s_Item0, &s_Object->m_mChallengeStates[s_Index0]);
		++s_Index0;
	}
	}

}

void SChallengesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);

	TArray<SChallengeSaveData>::Serialize(&s_Object->m_mChallengeStates, p_Serializer, p_OwnOffset + offsetof(SChallengesSaveData, m_mChallengeStates));
}

bool SChallengesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChallengesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChallengesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChallengesSaveData::operator==(const SChallengesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChallengesSaveData>)
		return false;

	if (m_mChallengeStates != p_Other.m_mChallengeStates) return false;

	return true;
}

void SChallengesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);
	s_Object->~SChallengesSaveData();
}

ZHMTypeInfo SCharacterSpeakEntitySaveData::TypeInfo = ZHMTypeInfo("SCharacterSpeakEntitySaveData", sizeof(SCharacterSpeakEntitySaveData), alignof(SCharacterSpeakEntitySaveData), SCharacterSpeakEntitySaveData::WriteSimpleJson, SCharacterSpeakEntitySaveData::FromSimpleJson, SCharacterSpeakEntitySaveData::Serialize, SCharacterSpeakEntitySaveData::Equals, SCharacterSpeakEntitySaveData::Destroy);

void SCharacterSpeakEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSeekPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWereSubtitlesSeen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWereSubtitlesSeen);

	p_Stream << "}";
}

void SCharacterSpeakEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Target);

	s_Object->m_fSeekPosition = simdjson::from_json_float32(p_Document["m_fSeekPosition"]);

	s_Object->m_bWereSubtitlesSeen = simdjson::from_json_bool(p_Document["m_bWereSubtitlesSeen"]);

}

void SCharacterSpeakEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);

}

bool SCharacterSpeakEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCharacterSpeakEntitySaveData::operator==(const SCharacterSpeakEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCharacterSpeakEntitySaveData>)
		return false;

	if (m_fSeekPosition != p_Other.m_fSeekPosition) return false;
	if (m_bWereSubtitlesSeen != p_Other.m_bWereSubtitlesSeen) return false;

	return true;
}

void SCharacterSpeakEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);
	s_Object->~SCharacterSpeakEntitySaveData();
}

ZHMTypeInfo SCheckLastPositionGroupSaveData::TypeInfo = ZHMTypeInfo("SCheckLastPositionGroupSaveData", sizeof(SCheckLastPositionGroupSaveData), alignof(SCheckLastPositionGroupSaveData), SCheckLastPositionGroupSaveData::WriteSimpleJson, SCheckLastPositionGroupSaveData::FromSimpleJson, SCheckLastPositionGroupSaveData::Serialize, SCheckLastPositionGroupSaveData::Equals, SCheckLastPositionGroupSaveData::Destroy);

void SCheckLastPositionGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLeaderTargetNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLeaderTargetNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAssistantOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAssistantOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSearchCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchCompleted);

	p_Stream << "}";
}

void SCheckLastPositionGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Target);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object->m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object->m_nLeaderTargetNodeIndex = simdjson::from_json_uint16(p_Document["m_nLeaderTargetNodeIndex"]);

	s_Object->m_bLeaderOrderAssigned = simdjson::from_json_bool(p_Document["m_bLeaderOrderAssigned"]);

	s_Object->m_bAssistantOrderAssigned = simdjson::from_json_bool(p_Document["m_bAssistantOrderAssigned"]);

	s_Object->m_bSearchCompleted = simdjson::from_json_bool(p_Document["m_bSearchCompleted"]);

}

void SCheckLastPositionGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);

}

bool SCheckLastPositionGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCheckLastPositionGroupSaveData::operator==(const SCheckLastPositionGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCheckLastPositionGroupSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_nLeaderTargetNodeIndex != p_Other.m_nLeaderTargetNodeIndex) return false;
	if (m_bLeaderOrderAssigned != p_Other.m_bLeaderOrderAssigned) return false;
	if (m_bAssistantOrderAssigned != p_Other.m_bAssistantOrderAssigned) return false;
	if (m_bSearchCompleted != p_Other.m_bSearchCompleted) return false;

	return true;
}

void SCheckLastPositionGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);
	s_Object->~SCheckLastPositionGroupSaveData();
}

ZHMTypeInfo SClothBundleSpawnSaveData::TypeInfo = ZHMTypeInfo("SClothBundleSpawnSaveData", sizeof(SClothBundleSpawnSaveData), alignof(SClothBundleSpawnSaveData), SClothBundleSpawnSaveData::WriteSimpleJson, SClothBundleSpawnSaveData::FromSimpleJson, SClothBundleSpawnSaveData::Serialize, SClothBundleSpawnSaveData::Equals, SClothBundleSpawnSaveData::Destroy);

void SClothBundleSpawnSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rClothbundle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rClothbundle);

	p_Stream << "}";
}

void SClothBundleSpawnSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Target);

	s_Object->m_rClothbundle = simdjson::from_json_uint32(p_Document["m_rClothbundle"]);

}

void SClothBundleSpawnSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);

}

bool SClothBundleSpawnSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothBundleSpawnSaveData::operator==(const SClothBundleSpawnSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothBundleSpawnSaveData>)
		return false;

	if (m_rClothbundle != p_Other.m_rClothbundle) return false;

	return true;
}

void SClothBundleSpawnSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);
	s_Object->~SClothBundleSpawnSaveData();
}

ZHMTypeInfo SClothVertex::TypeInfo = ZHMTypeInfo("SClothVertex", sizeof(SClothVertex), alignof(SClothVertex), SClothVertex::WriteSimpleJson, SClothVertex::FromSimpleJson, SClothVertex::Serialize, SClothVertex::Equals, SClothVertex::Destroy);

void SClothVertex::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nColumn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColumn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRow);

	p_Stream << "}";
}

void SClothVertex::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SClothVertex*>(p_Target);

	s_Object->m_nColumn = simdjson::from_json_uint16(p_Document["m_nColumn"]);

	s_Object->m_nRow = simdjson::from_json_uint16(p_Document["m_nRow"]);

}

void SClothVertex::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);

}

bool SClothVertex::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothVertex*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothVertex*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothVertex::operator==(const SClothVertex& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothVertex>)
		return false;

	if (m_nColumn != p_Other.m_nColumn) return false;
	if (m_nRow != p_Other.m_nRow) return false;

	return true;
}

void SClothVertex::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);
	s_Object->~SClothVertex();
}

ZHMTypeInfo SClothWireEntitySaveData::TypeInfo = ZHMTypeInfo("SClothWireEntitySaveData", sizeof(SClothWireEntitySaveData), alignof(SClothWireEntitySaveData), SClothWireEntitySaveData::WriteSimpleJson, SClothWireEntitySaveData::FromSimpleJson, SClothWireEntitySaveData::Serialize, SClothWireEntitySaveData::Equals, SClothWireEntitySaveData::Destroy);

void SClothWireEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fWireLength") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWireLength);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttachToAnchorTransform") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttachToAnchorTransform);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSimulationEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSimulationEnabled);

	p_Stream << "}";
}

void SClothWireEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Target);

	s_Object->m_fWireLength = simdjson::from_json_float32(p_Document["m_fWireLength"]);

	s_Object->m_bAttachToAnchorTransform = simdjson::from_json_bool(p_Document["m_bAttachToAnchorTransform"]);

	s_Object->m_bSimulationEnabled = simdjson::from_json_bool(p_Document["m_bSimulationEnabled"]);

}

void SClothWireEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);

}

bool SClothWireEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothWireEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothWireEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothWireEntitySaveData::operator==(const SClothWireEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothWireEntitySaveData>)
		return false;

	if (m_fWireLength != p_Other.m_fWireLength) return false;
	if (m_bAttachToAnchorTransform != p_Other.m_bAttachToAnchorTransform) return false;
	if (m_bSimulationEnabled != p_Other.m_bSimulationEnabled) return false;

	return true;
}

void SClothWireEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);
	s_Object->~SClothWireEntitySaveData();
}

ZHMTypeInfo SCollidingParticle::TypeInfo = ZHMTypeInfo("SCollidingParticle", sizeof(SCollidingParticle), alignof(SCollidingParticle), SCollidingParticle::WriteSimpleJson, SCollidingParticle::FromSimpleJson, SCollidingParticle::Serialize, SCollidingParticle::Equals, SCollidingParticle::Destroy);

void SCollidingParticle::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vNewVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_vNewVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nColor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSize);

	p_Stream << "}";
}

void SCollidingParticle::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCollidingParticle*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	float4::FromSimpleJson(p_Document["m_vVelocity"], &s_Object->m_vVelocity);

	float4::FromSimpleJson(p_Document["m_vNewVelocity"], &s_Object->m_vNewVelocity);

	s_Object->m_nColor = simdjson::from_json_uint32(p_Document["m_nColor"]);

	s_Object->m_fSize = simdjson::from_json_float32(p_Document["m_fSize"]);

}

void SCollidingParticle::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vPosition));
	float4::Serialize(&s_Object->m_vVelocity, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vVelocity));
	float4::Serialize(&s_Object->m_vNewVelocity, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vNewVelocity));
}

bool SCollidingParticle::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollidingParticle*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollidingParticle*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollidingParticle::operator==(const SCollidingParticle& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollidingParticle>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vVelocity != p_Other.m_vVelocity) return false;
	if (m_vNewVelocity != p_Other.m_vNewVelocity) return false;
	if (m_nColor != p_Other.m_nColor) return false;
	if (m_fSize != p_Other.m_fSize) return false;

	return true;
}

void SCollidingParticle::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);
	s_Object->~SCollidingParticle();
}

ZHMTypeInfo SCollisionControllerAspectSaveData::TypeInfo = ZHMTypeInfo("SCollisionControllerAspectSaveData", sizeof(SCollisionControllerAspectSaveData), alignof(SCollisionControllerAspectSaveData), SCollisionControllerAspectSaveData::WriteSimpleJson, SCollisionControllerAspectSaveData::FromSimpleJson, SCollisionControllerAspectSaveData::Serialize, SCollisionControllerAspectSaveData::Equals, SCollisionControllerAspectSaveData::Destroy);

void SCollisionControllerAspectSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bCollideHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollideHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCollideCamera") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollideCamera);

	p_Stream << "}";
}

void SCollisionControllerAspectSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Target);

	s_Object->m_bCollideHitman = simdjson::from_json_bool(p_Document["m_bCollideHitman"]);

	s_Object->m_bCollideCamera = simdjson::from_json_bool(p_Document["m_bCollideCamera"]);

}

void SCollisionControllerAspectSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);

}

bool SCollisionControllerAspectSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollisionControllerAspectSaveData::operator==(const SCollisionControllerAspectSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollisionControllerAspectSaveData>)
		return false;

	if (m_bCollideHitman != p_Other.m_bCollideHitman) return false;
	if (m_bCollideCamera != p_Other.m_bCollideCamera) return false;

	return true;
}

void SCollisionControllerAspectSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);
	s_Object->~SCollisionControllerAspectSaveData();
}

ZHMTypeInfo SCollisionControllerAspectsSaveData::TypeInfo = ZHMTypeInfo("SCollisionControllerAspectsSaveData", sizeof(SCollisionControllerAspectsSaveData), alignof(SCollisionControllerAspectsSaveData), SCollisionControllerAspectsSaveData::WriteSimpleJson, SCollisionControllerAspectsSaveData::FromSimpleJson, SCollisionControllerAspectsSaveData::Serialize, SCollisionControllerAspectsSaveData::Equals, SCollisionControllerAspectsSaveData::Destroy);

void SCollisionControllerAspectsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SCollisionControllerAspectSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCollisionControllerAspectsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCollisionControllerAspectSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SCollisionControllerAspectsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SCollisionControllerAspectsSaveData, m_aEntities));
	TArray<SCollisionControllerAspectSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SCollisionControllerAspectsSaveData, m_aData));
}

bool SCollisionControllerAspectsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollisionControllerAspectsSaveData::operator==(const SCollisionControllerAspectsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollisionControllerAspectsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SCollisionControllerAspectsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);
	s_Object->~SCollisionControllerAspectsSaveData();
}

ZHMTypeInfo SColorRGBA::TypeInfo = ZHMTypeInfo("SColorRGBA", sizeof(SColorRGBA), alignof(SColorRGBA), SColorRGBA::WriteSimpleJson, SColorRGBA::FromSimpleJson, SColorRGBA::Serialize, SColorRGBA::Equals, SColorRGBA::Destroy);

void SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->b);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("a") << ":";
	p_Stream << simdjson::as_json_string(s_Object->a);

	p_Stream << "}";
}

void SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SColorRGBA*>(p_Target);

	s_Object->r = simdjson::from_json_float32(p_Document["r"]);

	s_Object->g = simdjson::from_json_float32(p_Document["g"]);

	s_Object->b = simdjson::from_json_float32(p_Document["b"]);

	s_Object->a = simdjson::from_json_float32(p_Document["a"]);

}

void SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

}

bool SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGBA::operator==(const SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGBA>)
		return false;

	if (r != p_Other.r) return false;
	if (g != p_Other.g) return false;
	if (b != p_Other.b) return false;
	if (a != p_Other.a) return false;

	return true;
}

void SColorRGBA::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);
	s_Object->~SColorRGBA();
}

ZHMTypeInfo SColorRGBSaveData::TypeInfo = ZHMTypeInfo("SColorRGBSaveData", sizeof(SColorRGBSaveData), alignof(SColorRGBSaveData), SColorRGBSaveData::WriteSimpleJson, SColorRGBSaveData::FromSimpleJson, SColorRGBSaveData::Serialize, SColorRGBSaveData::Equals, SColorRGBSaveData::Destroy);

void SColorRGBSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SColorRGB::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SColorRGBSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SColorRGB::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SColorRGBSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SColorRGBSaveData, m_aEntities));
	TArray<SColorRGB>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SColorRGBSaveData, m_aData));
}

bool SColorRGBSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGBSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGBSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGBSaveData::operator==(const SColorRGBSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGBSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SColorRGBSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);
	s_Object->~SColorRGBSaveData();
}

ZHMTypeInfo SCombatOrderSaveData::TypeInfo = ZHMTypeInfo("SCombatOrderSaveData", sizeof(SCombatOrderSaveData), alignof(SCombatOrderSaveData), SCombatOrderSaveData::WriteSimpleJson, SCombatOrderSaveData::FromSimpleJson, SCombatOrderSaveData::Serialize, SCombatOrderSaveData::Equals, SCombatOrderSaveData::Destroy);

void SCombatOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPos") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPos, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_coverPlane") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_coverPlane);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInteraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInteraction);

	p_Stream << "}";
}

void SCombatOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vPos"], &s_Object->m_vPos);

	s_Object->m_coverPlane = simdjson::from_json_uint32(p_Document["m_coverPlane"]);

	s_Object->m_rInteraction = simdjson::from_json_uint32(p_Document["m_rInteraction"]);

}

void SCombatOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPos, p_Serializer, p_OwnOffset + offsetof(SCombatOrderSaveData, m_vPos));
}

bool SCombatOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatOrderSaveData::operator==(const SCombatOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatOrderSaveData>)
		return false;

	if (m_vPos != p_Other.m_vPos) return false;
	if (m_coverPlane != p_Other.m_coverPlane) return false;
	if (m_rInteraction != p_Other.m_rInteraction) return false;

	return true;
}

void SCombatOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);
	s_Object->~SCombatOrderSaveData();
}

ZHMTypeInfo SCombatSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SCombatSituationMemberSaveData", sizeof(SCombatSituationMemberSaveData), alignof(SCombatSituationMemberSaveData), SCombatSituationMemberSaveData::WriteSimpleJson, SCombatSituationMemberSaveData::FromSimpleJson, SCombatSituationMemberSaveData::Serialize, SCombatSituationMemberSaveData::Equals, SCombatSituationMemberSaveData::Destroy);

void SCombatSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tAggressiveModeTimer") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAggressiveModeTimer, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceTargetMoved") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceTargetMoved);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceFieldValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceFieldValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_civilianJoinReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_civilianJoinReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPreferredToFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPreferredToFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsReinforcing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsReinforcing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDialogPreventShooting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDialogPreventShooting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanFlee") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanFlee);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCantFleeNoPath") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCantFleeNoPath);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReportedToGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReportedToGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandAndShoot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandAndShoot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAggressiveMode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAggressiveMode);

	p_Stream << "}";
}

void SCombatSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_tAggressiveModeTimer"], &s_Object->m_tAggressiveModeTimer);

	s_Object->m_fDistanceTargetMoved = simdjson::from_json_float32(p_Document["m_fDistanceTargetMoved"]);

	s_Object->m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object->m_fDistanceFieldValue = simdjson::from_json_float32(p_Document["m_fDistanceFieldValue"]);

	s_Object->m_civilianJoinReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_civilianJoinReason"])));

	s_Object->m_bIsPreferredToFire = simdjson::from_json_bool(p_Document["m_bIsPreferredToFire"]);

	s_Object->m_bIsReinforcing = simdjson::from_json_bool(p_Document["m_bIsReinforcing"]);

	s_Object->m_bDialogPreventShooting = simdjson::from_json_bool(p_Document["m_bDialogPreventShooting"]);

	s_Object->m_bCanFlee = simdjson::from_json_bool(p_Document["m_bCanFlee"]);

	s_Object->m_bCantFleeNoPath = simdjson::from_json_bool(p_Document["m_bCantFleeNoPath"]);

	s_Object->m_bReportedToGuard = simdjson::from_json_bool(p_Document["m_bReportedToGuard"]);

	s_Object->m_bStandAndShoot = simdjson::from_json_bool(p_Document["m_bStandAndShoot"]);

	s_Object->m_bAggressiveMode = simdjson::from_json_bool(p_Document["m_bAggressiveMode"]);

}

void SCombatSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tAggressiveModeTimer, p_Serializer, p_OwnOffset + offsetof(SCombatSituationMemberSaveData, m_tAggressiveModeTimer));
}

bool SCombatSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatSituationMemberSaveData::operator==(const SCombatSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatSituationMemberSaveData>)
		return false;

	if (m_tAggressiveModeTimer != p_Other.m_tAggressiveModeTimer) return false;
	if (m_fDistanceTargetMoved != p_Other.m_fDistanceTargetMoved) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_fDistanceFieldValue != p_Other.m_fDistanceFieldValue) return false;
	if (m_civilianJoinReason != p_Other.m_civilianJoinReason) return false;
	if (m_bIsPreferredToFire != p_Other.m_bIsPreferredToFire) return false;
	if (m_bIsReinforcing != p_Other.m_bIsReinforcing) return false;
	if (m_bDialogPreventShooting != p_Other.m_bDialogPreventShooting) return false;
	if (m_bCanFlee != p_Other.m_bCanFlee) return false;
	if (m_bCantFleeNoPath != p_Other.m_bCantFleeNoPath) return false;
	if (m_bReportedToGuard != p_Other.m_bReportedToGuard) return false;
	if (m_bStandAndShoot != p_Other.m_bStandAndShoot) return false;
	if (m_bAggressiveMode != p_Other.m_bAggressiveMode) return false;

	return true;
}

void SCombatSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);
	s_Object->~SCombatSituationMemberSaveData();
}

ZHMTypeInfo SCombatZoneEntitySaveData::TypeInfo = ZHMTypeInfo("SCombatZoneEntitySaveData", sizeof(SCombatZoneEntitySaveData), alignof(SCombatZoneEntitySaveData), SCombatZoneEntitySaveData::WriteSimpleJson, SCombatZoneEntitySaveData::FromSimpleJson, SCombatZoneEntitySaveData::Serialize, SCombatZoneEntitySaveData::Equals, SCombatZoneEntitySaveData::Destroy);

void SCombatZoneEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInLockdown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInLockdown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFalseAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFalseAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECombatZoneState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLockdownTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLockdownTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTriggerTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tTriggerTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEngageTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEngageTime, p_Stream);

	p_Stream << "}";
}

void SCombatZoneEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Target);

	s_Object->m_bIsInLockdown = simdjson::from_json_bool(p_Document["m_bIsInLockdown"]);

	s_Object->m_bIsFalseAlarm = simdjson::from_json_bool(p_Document["m_bIsFalseAlarm"]);

	s_Object->m_nState = static_cast<ECombatZoneState>(ZHMEnums::GetEnumValueByName("ECombatZoneState", std::string_view(p_Document["m_nState"])));

	ZGameTime::FromSimpleJson(p_Document["m_tLockdownTime"], &s_Object->m_tLockdownTime);

	ZGameTime::FromSimpleJson(p_Document["m_tTriggerTime"], &s_Object->m_tTriggerTime);

	ZGameTime::FromSimpleJson(p_Document["m_tEngageTime"], &s_Object->m_tEngageTime);

}

void SCombatZoneEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLockdownTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tLockdownTime));
	ZGameTime::Serialize(&s_Object->m_tTriggerTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tTriggerTime));
	ZGameTime::Serialize(&s_Object->m_tEngageTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tEngageTime));
}

bool SCombatZoneEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatZoneEntitySaveData::operator==(const SCombatZoneEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatZoneEntitySaveData>)
		return false;

	if (m_bIsInLockdown != p_Other.m_bIsInLockdown) return false;
	if (m_bIsFalseAlarm != p_Other.m_bIsFalseAlarm) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_tLockdownTime != p_Other.m_tLockdownTime) return false;
	if (m_tTriggerTime != p_Other.m_tTriggerTime) return false;
	if (m_tEngageTime != p_Other.m_tEngageTime) return false;

	return true;
}

void SCombatZoneEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);
	s_Object->~SCombatZoneEntitySaveData();
}

ZHMTypeInfo SConditionBase::TypeInfo = ZHMTypeInfo("SConditionBase", sizeof(SConditionBase), alignof(SConditionBase), SConditionBase::WriteSimpleJson, SConditionBase::FromSimpleJson, SConditionBase::Serialize, SConditionBase::Equals, SConditionBase::Destroy);

void SConditionBase::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("eConditionType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECompiledConditionType", static_cast<int>(s_Object->eConditionType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nConditionModifiers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nConditionModifiers);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("assignTo") << ":";
	ZBehaviorTreeVariable::WriteSimpleJson(&s_Object->assignTo, p_Stream);

	p_Stream << "}";
}

void SConditionBase::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SConditionBase*>(p_Target);

	s_Object->eConditionType = static_cast<ECompiledConditionType>(ZHMEnums::GetEnumValueByName("ECompiledConditionType", std::string_view(p_Document["eConditionType"])));

	s_Object->nConditionModifiers = simdjson::from_json_uint32(p_Document["nConditionModifiers"]);

	ZBehaviorTreeVariable::FromSimpleJson(p_Document["assignTo"], &s_Object->assignTo);

}

void SConditionBase::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	ZBehaviorTreeVariable::Serialize(&s_Object->assignTo, p_Serializer, p_OwnOffset + offsetof(SConditionBase, assignTo));
}

bool SConditionBase::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConditionBase*>(p_Left);
	auto* s_Right = reinterpret_cast<SConditionBase*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConditionBase::operator==(const SConditionBase& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConditionBase>)
		return false;

	if (eConditionType != p_Other.eConditionType) return false;
	if (nConditionModifiers != p_Other.nConditionModifiers) return false;
	if (assignTo != p_Other.assignTo) return false;

	return true;
}

void SConditionBase::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);
	s_Object->~SConditionBase();
}

ZHMTypeInfo SConditionalTimerEntitySaveData::TypeInfo = ZHMTypeInfo("SConditionalTimerEntitySaveData", sizeof(SConditionalTimerEntitySaveData), alignof(SConditionalTimerEntitySaveData), SConditionalTimerEntitySaveData::WriteSimpleJson, SConditionalTimerEntitySaveData::FromSimpleJson, SConditionalTimerEntitySaveData::Serialize, SConditionalTimerEntitySaveData::Equals, SConditionalTimerEntitySaveData::Destroy);

void SConditionalTimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValue);

	p_Stream << "}";
}

void SConditionalTimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Target);

	s_Object->m_nInterval = simdjson::from_json_int32(p_Document["m_nInterval"]);

	s_Object->m_nRemaining = simdjson::from_json_int32(p_Document["m_nRemaining"]);

	s_Object->m_bValue = simdjson::from_json_bool(p_Document["m_bValue"]);

}

void SConditionalTimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);

}

bool SConditionalTimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConditionalTimerEntitySaveData::operator==(const SConditionalTimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConditionalTimerEntitySaveData>)
		return false;

	if (m_nInterval != p_Other.m_nInterval) return false;
	if (m_nRemaining != p_Other.m_nRemaining) return false;
	if (m_bValue != p_Other.m_bValue) return false;

	return true;
}

void SConditionalTimerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);
	s_Object->~SConditionalTimerEntitySaveData();
}

ZHMTypeInfo SContextActionSaveData::TypeInfo = ZHMTypeInfo("SContextActionSaveData", sizeof(SContextActionSaveData), alignof(SContextActionSaveData), SContextActionSaveData::WriteSimpleJson, SContextActionSaveData::FromSimpleJson, SContextActionSaveData::Serialize, SContextActionSaveData::Equals, SContextActionSaveData::Destroy);

void SContextActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldShow);

	p_Stream << "}";
}

void SContextActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SContextActionSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_bTriggered = simdjson::from_json_bool(p_Document["m_bTriggered"]);

	s_Object->m_bShouldShow = simdjson::from_json_bool(p_Document["m_bShouldShow"]);

}

void SContextActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);

}

bool SContextActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContextActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContextActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContextActionSaveData::operator==(const SContextActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContextActionSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bTriggered != p_Other.m_bTriggered) return false;
	if (m_bShouldShow != p_Other.m_bShouldShow) return false;

	return true;
}

void SContextActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);
	s_Object->~SContextActionSaveData();
}

ZHMTypeInfo SContractConfigResourceEntry::TypeInfo = ZHMTypeInfo("SContractConfigResourceEntry", sizeof(SContractConfigResourceEntry), alignof(SContractConfigResourceEntry), SContractConfigResourceEntry::WriteSimpleJson, SContractConfigResourceEntry::FromSimpleJson, SContractConfigResourceEntry::Serialize, SContractConfigResourceEntry::Equals, SContractConfigResourceEntry::Destroy);

void SContractConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ContractRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->ContractRid, p_Stream);

	p_Stream << "}";
}

void SContractConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Target);

	s_Object->Id = std::string_view(p_Document["Id"]);

	ZRuntimeResourceID::FromSimpleJson(p_Document["ContractRid"], &s_Object->ContractRid);

}

void SContractConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Id, p_Serializer, p_OwnOffset + offsetof(SContractConfigResourceEntry, Id));
	ZRuntimeResourceID::Serialize(&s_Object->ContractRid, p_Serializer, p_OwnOffset + offsetof(SContractConfigResourceEntry, ContractRid));
}

bool SContractConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractConfigResourceEntry::operator==(const SContractConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractConfigResourceEntry>)
		return false;

	if (Id != p_Other.Id) return false;
	if (ContractRid != p_Other.ContractRid) return false;

	return true;
}

void SContractConfigResourceEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);
	s_Object->~SContractConfigResourceEntry();
}

ZHMTypeInfo SContractObjectiveHudHintEntitySaveData::TypeInfo = ZHMTypeInfo("SContractObjectiveHudHintEntitySaveData", sizeof(SContractObjectiveHudHintEntitySaveData), alignof(SContractObjectiveHudHintEntitySaveData), SContractObjectiveHudHintEntitySaveData::WriteSimpleJson, SContractObjectiveHudHintEntitySaveData::FromSimpleJson, SContractObjectiveHudHintEntitySaveData::Serialize, SContractObjectiveHudHintEntitySaveData::Equals, SContractObjectiveHudHintEntitySaveData::Destroy);

void SContractObjectiveHudHintEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SContractObjectiveHudHintEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Target);

	s_Object->m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

}

void SContractObjectiveHudHintEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);

}

bool SContractObjectiveHudHintEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractObjectiveHudHintEntitySaveData::operator==(const SContractObjectiveHudHintEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractObjectiveHudHintEntitySaveData>)
		return false;

	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

void SContractObjectiveHudHintEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);
	s_Object->~SContractObjectiveHudHintEntitySaveData();
}

ZHMTypeInfo SContractObjectiveSaveData::TypeInfo = ZHMTypeInfo("SContractObjectiveSaveData", sizeof(SContractObjectiveSaveData), alignof(SContractObjectiveSaveData), SContractObjectiveSaveData::WriteSimpleJson, SContractObjectiveSaveData::FromSimpleJson, SContractObjectiveSaveData::Serialize, SContractObjectiveSaveData::Equals, SContractObjectiveSaveData::Destroy);

void SContractObjectiveSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Id") << ":";
	ZGuid::WriteSimpleJson(&s_Object->m_Id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCategory") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Category", static_cast<int>(s_Object->m_eCategory)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sSuccessEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sSuccessEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SuccessEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_SuccessEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sFailedEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sFailedEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_FailedEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_FailedEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sResetEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sResetEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ResetEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_ResetEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLongBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sLongBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sHUDText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sHUDText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iRepeatSuccess") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iRepeatSuccess);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iRepeatFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iRepeatFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iCurrentSuccess") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCurrentSuccess);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iCurrentFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCurrentFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationCondition") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_ActivationCondition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_ActivationValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateActivationOnCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateActivationOnCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisplayAsKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisplayAsKill);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreIfInactive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreIfInactive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCombinedDisplayInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCombinedDisplayInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnInactive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnInactive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnActive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnActive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExits") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_aExits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectiveType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectiveType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBriefingName);

	p_Stream << "}";
}

void SContractObjectiveSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Target);

	ZGuid::FromSimpleJson(p_Document["m_Id"], &s_Object->m_Id);

	s_Object->m_sText = std::string_view(p_Document["m_sText"]);

	s_Object->m_eCategory = static_cast<IContractObjective::Category>(ZHMEnums::GetEnumValueByName("IContractObjective.Category", std::string_view(p_Document["m_eCategory"])));

	s_Object->m_bCompleted = simdjson::from_json_bool(p_Document["m_bCompleted"]);

	s_Object->m_bFailed = simdjson::from_json_bool(p_Document["m_bFailed"]);

	s_Object->m_bIsHidden = simdjson::from_json_bool(p_Document["m_bIsHidden"]);

	s_Object->m_sSuccessEventName = std::string_view(p_Document["m_sSuccessEventName"]);

	ZDynamicObject::FromSimpleJson(p_Document["m_SuccessEventValues"], &s_Object->m_SuccessEventValues);

	s_Object->m_sFailedEventName = std::string_view(p_Document["m_sFailedEventName"]);

	ZDynamicObject::FromSimpleJson(p_Document["m_FailedEventValues"], &s_Object->m_FailedEventValues);

	s_Object->m_sResetEventName = std::string_view(p_Document["m_sResetEventName"]);

	ZDynamicObject::FromSimpleJson(p_Document["m_ResetEventValues"], &s_Object->m_ResetEventValues);

	ZDynamicObject::FromSimpleJson(p_Document["m_sBriefingText"], &s_Object->m_sBriefingText);

	ZDynamicObject::FromSimpleJson(p_Document["m_sLongBriefingText"], &s_Object->m_sLongBriefingText);

	ZDynamicObject::FromSimpleJson(p_Document["m_sHUDText"], &s_Object->m_sHUDText);

	s_Object->m_iRepeatSuccess = simdjson::from_json_int32(p_Document["m_iRepeatSuccess"]);

	s_Object->m_iRepeatFailed = simdjson::from_json_int32(p_Document["m_iRepeatFailed"]);

	s_Object->m_iCurrentSuccess = simdjson::from_json_int32(p_Document["m_iCurrentSuccess"]);

	s_Object->m_iCurrentFailed = simdjson::from_json_int32(p_Document["m_iCurrentFailed"]);

	ZDynamicObject::FromSimpleJson(p_Document["m_ActivationCondition"], &s_Object->m_ActivationCondition);

	s_Object->m_ActivationValue = simdjson::from_json_bool(p_Document["m_ActivationValue"]);

	s_Object->m_bUpdateActivationOnCompleted = simdjson::from_json_bool(p_Document["m_bUpdateActivationOnCompleted"]);

	s_Object->m_bDisplayAsKill = simdjson::from_json_bool(p_Document["m_bDisplayAsKill"]);

	s_Object->m_bIgnoreIfInactive = simdjson::from_json_bool(p_Document["m_bIgnoreIfInactive"]);

	s_Object->m_bShowInHud = simdjson::from_json_bool(p_Document["m_bShowInHud"]);

	s_Object->m_bCombinedDisplayInHud = simdjson::from_json_bool(p_Document["m_bCombinedDisplayInHud"]);

	ZDynamicObject::FromSimpleJson(p_Document["m_OnInactive"], &s_Object->m_OnInactive);

	ZDynamicObject::FromSimpleJson(p_Document["m_OnActive"], &s_Object->m_OnActive);

	ZDynamicObject::FromSimpleJson(p_Document["m_aExits"], &s_Object->m_aExits);

	s_Object->m_sImage = std::string_view(p_Document["m_sImage"]);

	s_Object->m_sObjectiveType = std::string_view(p_Document["m_sObjectiveType"]);

	s_Object->m_sBriefingName = std::string_view(p_Document["m_sBriefingName"]);

}

void SContractObjectiveSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);

	ZGuid::Serialize(&s_Object->m_Id, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_Id));
	ZString::Serialize(&s_Object->m_sText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sText));
	ZString::Serialize(&s_Object->m_sSuccessEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sSuccessEventName));
	ZDynamicObject::Serialize(&s_Object->m_SuccessEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_SuccessEventValues));
	ZString::Serialize(&s_Object->m_sFailedEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sFailedEventName));
	ZDynamicObject::Serialize(&s_Object->m_FailedEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_FailedEventValues));
	ZString::Serialize(&s_Object->m_sResetEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sResetEventName));
	ZDynamicObject::Serialize(&s_Object->m_ResetEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_ResetEventValues));
	ZDynamicObject::Serialize(&s_Object->m_sBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_sLongBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sLongBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_sHUDText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sHUDText));
	ZDynamicObject::Serialize(&s_Object->m_ActivationCondition, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_ActivationCondition));
	ZDynamicObject::Serialize(&s_Object->m_OnInactive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_OnInactive));
	ZDynamicObject::Serialize(&s_Object->m_OnActive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_OnActive));
	ZDynamicObject::Serialize(&s_Object->m_aExits, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_aExits));
	ZString::Serialize(&s_Object->m_sImage, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sImage));
	ZString::Serialize(&s_Object->m_sObjectiveType, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sObjectiveType));
	ZString::Serialize(&s_Object->m_sBriefingName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sBriefingName));
}

bool SContractObjectiveSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractObjectiveSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractObjectiveSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractObjectiveSaveData::operator==(const SContractObjectiveSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractObjectiveSaveData>)
		return false;

	if (m_Id != p_Other.m_Id) return false;
	if (m_sText != p_Other.m_sText) return false;
	if (m_eCategory != p_Other.m_eCategory) return false;
	if (m_bCompleted != p_Other.m_bCompleted) return false;
	if (m_bFailed != p_Other.m_bFailed) return false;
	if (m_bIsHidden != p_Other.m_bIsHidden) return false;
	if (m_sSuccessEventName != p_Other.m_sSuccessEventName) return false;
	if (m_SuccessEventValues != p_Other.m_SuccessEventValues) return false;
	if (m_sFailedEventName != p_Other.m_sFailedEventName) return false;
	if (m_FailedEventValues != p_Other.m_FailedEventValues) return false;
	if (m_sResetEventName != p_Other.m_sResetEventName) return false;
	if (m_ResetEventValues != p_Other.m_ResetEventValues) return false;
	if (m_sBriefingText != p_Other.m_sBriefingText) return false;
	if (m_sLongBriefingText != p_Other.m_sLongBriefingText) return false;
	if (m_sHUDText != p_Other.m_sHUDText) return false;
	if (m_iRepeatSuccess != p_Other.m_iRepeatSuccess) return false;
	if (m_iRepeatFailed != p_Other.m_iRepeatFailed) return false;
	if (m_iCurrentSuccess != p_Other.m_iCurrentSuccess) return false;
	if (m_iCurrentFailed != p_Other.m_iCurrentFailed) return false;
	if (m_ActivationCondition != p_Other.m_ActivationCondition) return false;
	if (m_ActivationValue != p_Other.m_ActivationValue) return false;
	if (m_bUpdateActivationOnCompleted != p_Other.m_bUpdateActivationOnCompleted) return false;
	if (m_bDisplayAsKill != p_Other.m_bDisplayAsKill) return false;
	if (m_bIgnoreIfInactive != p_Other.m_bIgnoreIfInactive) return false;
	if (m_bShowInHud != p_Other.m_bShowInHud) return false;
	if (m_bCombinedDisplayInHud != p_Other.m_bCombinedDisplayInHud) return false;
	if (m_OnInactive != p_Other.m_OnInactive) return false;
	if (m_OnActive != p_Other.m_OnActive) return false;
	if (m_aExits != p_Other.m_aExits) return false;
	if (m_sImage != p_Other.m_sImage) return false;
	if (m_sObjectiveType != p_Other.m_sObjectiveType) return false;
	if (m_sBriefingName != p_Other.m_sBriefingName) return false;

	return true;
}

void SContractObjectiveSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);
	s_Object->~SContractObjectiveSaveData();
}

ZHMTypeInfo SEntityTemplateProperty::TypeInfo = ZHMTypeInfo("SEntityTemplateProperty", sizeof(SEntityTemplateProperty), alignof(SEntityTemplateProperty), SEntityTemplateProperty::WriteSimpleJson, SEntityTemplateProperty::FromSimpleJson, SEntityTemplateProperty::Serialize, SEntityTemplateProperty::Equals, SEntityTemplateProperty::Destroy);

void SEntityTemplateProperty::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nPropertyID") << ":";
	{
		auto s_PropertyName = ZHMProperties::PropertyToString(s_Object->nPropertyID);

		if (s_PropertyName.size() == 0)
			p_Stream << simdjson::as_json_string(s_Object->nPropertyID);
		else
			p_Stream << simdjson::as_json_string(s_PropertyName);
	}
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->value, p_Stream);

	p_Stream << "}";
}

void SEntityTemplateProperty::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Target);

	if (p_Document["nPropertyID"].type() == simdjson::ondemand::json_type::string)
		s_Object->nPropertyID = Hash::Crc32(std::string_view(p_Document["nPropertyID"]));
	else
		s_Object->nPropertyID = simdjson::from_json_uint32(p_Document["nPropertyID"]);

	ZVariant::FromSimpleJson(p_Document["value"], &s_Object->value);

}

void SEntityTemplateProperty::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	ZVariant::Serialize(&s_Object->value, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateProperty, value));
}

bool SEntityTemplateProperty::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateProperty*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateProperty*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateProperty::operator==(const SEntityTemplateProperty& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateProperty>)
		return false;

	if (nPropertyID != p_Other.nPropertyID) return false;
	if (value != p_Other.value) return false;

	return true;
}

void SEntityTemplateProperty::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);
	s_Object->~SEntityTemplateProperty();
}

ZHMTypeInfo SCppEntity::TypeInfo = ZHMTypeInfo("SCppEntity", sizeof(SCppEntity), alignof(SCppEntity), SCppEntity::WriteSimpleJson, SCppEntity::FromSimpleJson, SCppEntity::Serialize, SCppEntity::Equals, SCppEntity::Destroy);

void SCppEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCppEntity*>(p_Target);

	s_Object->blueprintIndexInResourceHeader = simdjson::from_json_int32(p_Document["blueprintIndexInResourceHeader"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyValues"];
	s_Object->propertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_Object->propertyValues[s_Index0]);
		++s_Index0;
	}
	}

}

void SCppEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(SCppEntity, propertyValues));
}

bool SCppEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntity::operator==(const SCppEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntity>)
		return false;

	if (blueprintIndexInResourceHeader != p_Other.blueprintIndexInResourceHeader) return false;
	if (propertyValues != p_Other.propertyValues) return false;

	return true;
}

void SCppEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);
	s_Object->~SCppEntity();
}

ZHMTypeInfo SCppEntitySubsetInfo::TypeInfo = ZHMTypeInfo("SCppEntitySubsetInfo", sizeof(SCppEntitySubsetInfo), alignof(SCppEntitySubsetInfo), SCppEntitySubsetInfo::WriteSimpleJson, SCppEntitySubsetInfo::FromSimpleJson, SCppEntitySubsetInfo::Serialize, SCppEntitySubsetInfo::Equals, SCppEntitySubsetInfo::Destroy);

void SCppEntitySubsetInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("name") << ":";
	p_Stream << simdjson::as_json_string(s_Object->name);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("flags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->flags);

	p_Stream << "}";
}

void SCppEntitySubsetInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Target);

	s_Object->name = std::string_view(p_Document["name"]);

	s_Object->flags = simdjson::from_json_uint32(p_Document["flags"]);

}

void SCppEntitySubsetInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	ZString::Serialize(&s_Object->name, p_Serializer, p_OwnOffset + offsetof(SCppEntitySubsetInfo, name));
}

bool SCppEntitySubsetInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntitySubsetInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntitySubsetInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntitySubsetInfo::operator==(const SCppEntitySubsetInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntitySubsetInfo>)
		return false;

	if (name != p_Other.name) return false;
	if (flags != p_Other.flags) return false;

	return true;
}

void SCppEntitySubsetInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);
	s_Object->~SCppEntitySubsetInfo();
}

ZHMTypeInfo SCppEntityBlueprint::TypeInfo = ZHMTypeInfo("SCppEntityBlueprint", sizeof(SCppEntityBlueprint), alignof(SCppEntityBlueprint), SCppEntityBlueprint::WriteSimpleJson, SCppEntityBlueprint::FromSimpleJson, SCppEntityBlueprint::Serialize, SCppEntityBlueprint::Equals, SCppEntityBlueprint::Destroy);

void SCppEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("typeName") << ":";
	TypeID::WriteSimpleJson(&s_Object->typeName, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->subsets[i];
		SCppEntitySubsetInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->subsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Target);

	TypeID::FromSimpleJson(p_Document["typeName"], &s_Object->typeName);

	{
	simdjson::ondemand::array s_Array0 = p_Document["subsets"];
	s_Object->subsets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCppEntitySubsetInfo::FromSimpleJson(s_Item0, &s_Object->subsets[s_Index0]);
		++s_Index0;
	}
	}

}

void SCppEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	TypeID::Serialize(&s_Object->typeName, p_Serializer, p_OwnOffset + offsetof(SCppEntityBlueprint, typeName));
	TArray<SCppEntitySubsetInfo>::Serialize(&s_Object->subsets, p_Serializer, p_OwnOffset + offsetof(SCppEntityBlueprint, subsets));
}

bool SCppEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntityBlueprint::operator==(const SCppEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntityBlueprint>)
		return false;

	if (typeName != p_Other.typeName) return false;
	if (subsets != p_Other.subsets) return false;

	return true;
}

void SCppEntityBlueprint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);
	s_Object->~SCppEntityBlueprint();
}

ZHMTypeInfo SCrimeSceneSaveData::TypeInfo = ZHMTypeInfo("SCrimeSceneSaveData", sizeof(SCrimeSceneSaveData), alignof(SCrimeSceneSaveData), SCrimeSceneSaveData::WriteSimpleJson, SCrimeSceneSaveData::FromSimpleJson, SCrimeSceneSaveData::Serialize, SCrimeSceneSaveData::Equals, SCrimeSceneSaveData::Destroy);

void SCrimeSceneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPos") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPos, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSharedKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSharedKnowledge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMaxSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMaxSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspicionZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspicionZone);

	p_Stream << "}";
}

void SCrimeSceneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrimeSceneSaveData*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vPos"], &s_Object->m_vPos);

	ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Object->m_tStart);

	s_Object->m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object->m_rSharedKnowledge = simdjson::from_json_int32(p_Document["m_rSharedKnowledge"]);

	s_Object->m_fMaxSize = simdjson::from_json_float32(p_Document["m_fMaxSize"]);

	s_Object->m_bSuspicionZone = simdjson::from_json_bool(p_Document["m_bSuspicionZone"]);

}

void SCrimeSceneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPos, p_Serializer, p_OwnOffset + offsetof(SCrimeSceneSaveData, m_vPos));
	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SCrimeSceneSaveData, m_tStart));
}

bool SCrimeSceneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrimeSceneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrimeSceneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrimeSceneSaveData::operator==(const SCrimeSceneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrimeSceneSaveData>)
		return false;

	if (m_vPos != p_Other.m_vPos) return false;
	if (m_tStart != p_Other.m_tStart) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_rSharedKnowledge != p_Other.m_rSharedKnowledge) return false;
	if (m_fMaxSize != p_Other.m_fMaxSize) return false;
	if (m_bSuspicionZone != p_Other.m_bSuspicionZone) return false;

	return true;
}

void SCrimeSceneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneSaveData*>(p_Object);
	s_Object->~SCrimeSceneSaveData();
}

ZHMTypeInfo SCrimeSceneServiceSaveData::TypeInfo = ZHMTypeInfo("SCrimeSceneServiceSaveData", sizeof(SCrimeSceneServiceSaveData), alignof(SCrimeSceneServiceSaveData), SCrimeSceneServiceSaveData::WriteSimpleJson, SCrimeSceneServiceSaveData::FromSimpleJson, SCrimeSceneServiceSaveData::Serialize, SCrimeSceneServiceSaveData::Equals, SCrimeSceneServiceSaveData::Destroy);

void SCrimeSceneServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCrimeScenes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrimeScenes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrimeScenes[i];
		SCrimeSceneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCrimeScenes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrimeSceneServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCrimeScenes"];
	s_Object->m_aCrimeScenes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrimeSceneSaveData::FromSimpleJson(s_Item0, &s_Object->m_aCrimeScenes[s_Index0]);
		++s_Index0;
	}
	}

}

void SCrimeSceneServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Object);

	TArray<SCrimeSceneSaveData>::Serialize(&s_Object->m_aCrimeScenes, p_Serializer, p_OwnOffset + offsetof(SCrimeSceneServiceSaveData, m_aCrimeScenes));
}

bool SCrimeSceneServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrimeSceneServiceSaveData::operator==(const SCrimeSceneServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrimeSceneServiceSaveData>)
		return false;

	if (m_aCrimeScenes != p_Other.m_aCrimeScenes) return false;

	return true;
}

void SCrimeSceneServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrimeSceneServiceSaveData*>(p_Object);
	s_Object->~SCrimeSceneServiceSaveData();
}

ZHMTypeInfo SCrowdActivitySaveData::TypeInfo = ZHMTypeInfo("SCrowdActivitySaveData", sizeof(SCrowdActivitySaveData), alignof(SCrowdActivitySaveData), SCrowdActivitySaveData::WriteSimpleJson, SCrowdActivitySaveData::FromSimpleJson, SCrowdActivitySaveData::Serialize, SCrowdActivitySaveData::Equals, SCrowdActivitySaveData::Destroy);

void SCrowdActivitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGait") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_eGait)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxEnterDelaySec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxEnterDelaySec);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxLeaveDelaySec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxLeaveDelaySec);

	p_Stream << "}";
}

void SCrowdActivitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_eGait = static_cast<EGait>(ZHMEnums::GetEnumValueByName("EGait", std::string_view(p_Document["m_eGait"])));

	s_Object->m_nMaxEnterDelaySec = simdjson::from_json_float32(p_Document["m_nMaxEnterDelaySec"]);

	s_Object->m_nMaxLeaveDelaySec = simdjson::from_json_float32(p_Document["m_nMaxLeaveDelaySec"]);

}

void SCrowdActivitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);

}

bool SCrowdActivitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdActivitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdActivitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdActivitySaveData::operator==(const SCrowdActivitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdActivitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_eGait != p_Other.m_eGait) return false;
	if (m_nMaxEnterDelaySec != p_Other.m_nMaxEnterDelaySec) return false;
	if (m_nMaxLeaveDelaySec != p_Other.m_nMaxLeaveDelaySec) return false;

	return true;
}

void SCrowdActivitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);
	s_Object->~SCrowdActivitySaveData();
}

ZHMTypeInfo SCrowdActorSaveData::TypeInfo = ZHMTypeInfo("SCrowdActorSaveData", sizeof(SCrowdActorSaveData), alignof(SCrowdActorSaveData), SCrowdActorSaveData::WriteSimpleJson, SCrowdActorSaveData::FromSimpleJson, SCrowdActorSaveData::Serialize, SCrowdActorSaveData::Equals, SCrowdActorSaveData::Destroy);

void SCrowdActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eWantedSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESpeed", static_cast<int>(s_Object->m_eWantedSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eWantedGait") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_eWantedGait)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAnimSourceID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAnimSourceID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAnimSourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAnimSourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vForward") << ":";
	float4::WriteSimpleJson(&s_Object->m_vForward, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMood") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("CrowdUtil.ECrowdActorMood", static_cast<int>(s_Object->m_eMood)));

	p_Stream << "}";
}

void SCrowdActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_eWantedSpeed = static_cast<ESpeed>(ZHMEnums::GetEnumValueByName("ESpeed", std::string_view(p_Document["m_eWantedSpeed"])));

	s_Object->m_eWantedGait = static_cast<EGait>(ZHMEnums::GetEnumValueByName("EGait", std::string_view(p_Document["m_eWantedGait"])));

	s_Object->m_nAnimSourceID = simdjson::from_json_uint32(p_Document["m_nAnimSourceID"]);

	s_Object->m_nAnimSourceIndex = simdjson::from_json_uint32(p_Document["m_nAnimSourceIndex"]);

	float4::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	float4::FromSimpleJson(p_Document["m_vForward"], &s_Object->m_vForward);

	s_Object->m_fSpeed = simdjson::from_json_float32(p_Document["m_fSpeed"]);

	s_Object->m_eMood = static_cast<CrowdUtil::ECrowdActorMood>(ZHMEnums::GetEnumValueByName("CrowdUtil.ECrowdActorMood", std::string_view(p_Document["m_eMood"])));

}

void SCrowdActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SCrowdActorSaveData, m_vPosition));
	float4::Serialize(&s_Object->m_vForward, p_Serializer, p_OwnOffset + offsetof(SCrowdActorSaveData, m_vForward));
}

bool SCrowdActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdActorSaveData::operator==(const SCrowdActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdActorSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_eWantedSpeed != p_Other.m_eWantedSpeed) return false;
	if (m_eWantedGait != p_Other.m_eWantedGait) return false;
	if (m_nAnimSourceID != p_Other.m_nAnimSourceID) return false;
	if (m_nAnimSourceIndex != p_Other.m_nAnimSourceIndex) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vForward != p_Other.m_vForward) return false;
	if (m_fSpeed != p_Other.m_fSpeed) return false;
	if (m_eMood != p_Other.m_eMood) return false;

	return true;
}

void SCrowdActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);
	s_Object->~SCrowdActorSaveData();
}

ZHMTypeInfo SCrowdBodySaveData::TypeInfo = ZHMTypeInfo("SCrowdBodySaveData", sizeof(SCrowdBodySaveData), alignof(SCrowdBodySaveData), SCrowdBodySaveData::WriteSimpleJson, SCrowdBodySaveData::FromSimpleJson, SCrowdBodySaveData::Serialize, SCrowdBodySaveData::Equals, SCrowdBodySaveData::Destroy);

void SCrowdBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pCorpseBodybagEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCorpseBodybagEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCrowdEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCrowdEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iActorIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPerceptibleEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPerceptibleEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKnownBy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKnownBy.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKnownBy[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKnownBy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bManaged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bManaged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBagSharedKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBagSharedKnowledge);

	p_Stream << "}";
}

void SCrowdBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Target);

	s_Object->m_pCorpseBodybagEntity = simdjson::from_json_uint32(p_Document["m_pCorpseBodybagEntity"]);

	s_Object->m_rCrowdEntity = simdjson::from_json_uint32(p_Document["m_rCrowdEntity"]);

	s_Object->m_iActorIndex = simdjson::from_json_uint16(p_Document["m_iActorIndex"]);

	s_Object->m_rPerceptibleEntity = simdjson::from_json_uint32(p_Document["m_rPerceptibleEntity"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKnownBy"];
	s_Object->m_aKnownBy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aKnownBy[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Object->m_tStart);

	s_Object->m_bManaged = simdjson::from_json_bool(p_Document["m_bManaged"]);

	s_Object->m_rBagSharedKnowledge = simdjson::from_json_int32(p_Document["m_rBagSharedKnowledge"]);

}

void SCrowdBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aKnownBy, p_Serializer, p_OwnOffset + offsetof(SCrowdBodySaveData, m_aKnownBy));
	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SCrowdBodySaveData, m_tStart));
}

bool SCrowdBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdBodySaveData::operator==(const SCrowdBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdBodySaveData>)
		return false;

	if (m_pCorpseBodybagEntity != p_Other.m_pCorpseBodybagEntity) return false;
	if (m_rCrowdEntity != p_Other.m_rCrowdEntity) return false;
	if (m_iActorIndex != p_Other.m_iActorIndex) return false;
	if (m_rPerceptibleEntity != p_Other.m_rPerceptibleEntity) return false;
	if (m_aKnownBy != p_Other.m_aKnownBy) return false;
	if (m_tStart != p_Other.m_tStart) return false;
	if (m_bManaged != p_Other.m_bManaged) return false;
	if (m_rBagSharedKnowledge != p_Other.m_rBagSharedKnowledge) return false;

	return true;
}

void SCrowdBodySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);
	s_Object->~SCrowdBodySaveData();
}

ZHMTypeInfo SCrowdCells::TypeInfo = ZHMTypeInfo("SCrowdCells", sizeof(SCrowdCells), alignof(SCrowdCells), SCrowdCells::WriteSimpleJson, SCrowdCells::FromSimpleJson, SCrowdCells::Serialize, SCrowdCells::Equals, SCrowdCells::Destroy);

void SCrowdCells::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_cells") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cells.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cells[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_cells.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdCells::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdCells*>(p_Target);

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_cells"])
	{
		s_Object->m_cells[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

}

void SCrowdCells::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	TFixedArray<uint8, 128>::Serialize(&s_Object->m_cells, p_Serializer, p_OwnOffset + offsetof(SCrowdCells, m_cells));
}

bool SCrowdCells::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdCells*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdCells*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdCells::operator==(const SCrowdCells& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdCells>)
		return false;

	if (m_cells != p_Other.m_cells) return false;

	return true;
}

void SCrowdCells::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);
	s_Object->~SCrowdCells();
}

ZHMTypeInfo SCrowdPoseBoneSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseBoneSaveData", sizeof(SCrowdPoseBoneSaveData), alignof(SCrowdPoseBoneSaveData), SCrowdPoseBoneSaveData::WriteSimpleJson, SCrowdPoseBoneSaveData::FromSimpleJson, SCrowdPoseBoneSaveData::Serialize, SCrowdPoseBoneSaveData::Equals, SCrowdPoseBoneSaveData::Destroy);

void SCrowdPoseBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SCrowdPoseBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Target);

	SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Object->mQuaterion);

	SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Object->mTranslation);

}

void SCrowdPoseBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseBoneSaveData, mTranslation));
}

bool SCrowdPoseBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseBoneSaveData::operator==(const SCrowdPoseBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

void SCrowdPoseBoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);
	s_Object->~SCrowdPoseBoneSaveData();
}

ZHMTypeInfo SCrowdPoseSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseSaveData", sizeof(SCrowdPoseSaveData), alignof(SCrowdPoseSaveData), SCrowdPoseSaveData::WriteSimpleJson, SCrowdPoseSaveData::FromSimpleJson, SCrowdPoseSaveData::Serialize, SCrowdPoseSaveData::Equals, SCrowdPoseSaveData::Destroy);

void SCrowdPoseSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SCrowdPoseBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdPoseSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBones"];
	s_Object->m_aBones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdPoseBoneSaveData::FromSimpleJson(s_Item0, &s_Object->m_aBones[s_Index0]);
		++s_Index0;
	}
	}

}

void SCrowdPoseSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);

	TArray<SCrowdPoseBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseSaveData, m_aBones));
}

bool SCrowdPoseSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseSaveData::operator==(const SCrowdPoseSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseSaveData>)
		return false;

	if (m_aBones != p_Other.m_aBones) return false;

	return true;
}

void SCrowdPoseSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);
	s_Object->~SCrowdPoseSaveData();
}

ZHMTypeInfo SCrowdPoseCollectionSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseCollectionSaveData", sizeof(SCrowdPoseCollectionSaveData), alignof(SCrowdPoseCollectionSaveData), SCrowdPoseCollectionSaveData::WriteSimpleJson, SCrowdPoseCollectionSaveData::FromSimpleJson, SCrowdPoseCollectionSaveData::Serialize, SCrowdPoseCollectionSaveData::Equals, SCrowdPoseCollectionSaveData::Destroy);

void SCrowdPoseCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPoses") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPoses.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPoses[i];
		SCrowdPoseSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPoses.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdPoseCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Target);

	s_Object->m_id = simdjson::from_json_uint64(p_Document["m_id"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPoses"];
	s_Object->m_aPoses.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdPoseSaveData::FromSimpleJson(s_Item0, &s_Object->m_aPoses[s_Index0]);
		++s_Index0;
	}
	}

}

void SCrowdPoseCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);

	TArray<SCrowdPoseSaveData>::Serialize(&s_Object->m_aPoses, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseCollectionSaveData, m_aPoses));
}

bool SCrowdPoseCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseCollectionSaveData::operator==(const SCrowdPoseCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseCollectionSaveData>)
		return false;

	if (m_id != p_Other.m_id) return false;
	if (m_aPoses != p_Other.m_aPoses) return false;

	return true;
}

void SCrowdPoseCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);
	s_Object->~SCrowdPoseCollectionSaveData();
}

ZHMTypeInfo SCrowdDeadPoseRepositorySaveData::TypeInfo = ZHMTypeInfo("SCrowdDeadPoseRepositorySaveData", sizeof(SCrowdDeadPoseRepositorySaveData), alignof(SCrowdDeadPoseRepositorySaveData), SCrowdDeadPoseRepositorySaveData::WriteSimpleJson, SCrowdDeadPoseRepositorySaveData::FromSimpleJson, SCrowdDeadPoseRepositorySaveData::Serialize, SCrowdDeadPoseRepositorySaveData::Equals, SCrowdDeadPoseRepositorySaveData::Destroy);

void SCrowdDeadPoseRepositorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aPoseCollections") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPoseCollections.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPoseCollections[i];
		SCrowdPoseCollectionSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPoseCollections.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdDeadPoseRepositorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPoseCollections"];
	s_Object->m_aPoseCollections.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdPoseCollectionSaveData::FromSimpleJson(s_Item0, &s_Object->m_aPoseCollections[s_Index0]);
		++s_Index0;
	}
	}

}

void SCrowdDeadPoseRepositorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);

	TArray<SCrowdPoseCollectionSaveData>::Serialize(&s_Object->m_aPoseCollections, p_Serializer, p_OwnOffset + offsetof(SCrowdDeadPoseRepositorySaveData, m_aPoseCollections));
}

bool SCrowdDeadPoseRepositorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdDeadPoseRepositorySaveData::operator==(const SCrowdDeadPoseRepositorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdDeadPoseRepositorySaveData>)
		return false;

	if (m_aPoseCollections != p_Other.m_aPoseCollections) return false;

	return true;
}

void SCrowdDeadPoseRepositorySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);
	s_Object->~SCrowdDeadPoseRepositorySaveData();
}

ZHMTypeInfo SRegionSaveData::TypeInfo = ZHMTypeInfo("SRegionSaveData", sizeof(SRegionSaveData), alignof(SRegionSaveData), SRegionSaveData::WriteSimpleJson, SRegionSaveData::FromSimpleJson, SRegionSaveData::Serialize, SRegionSaveData::Equals, SRegionSaveData::Destroy);

void SRegionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("CrowdRegionType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCenter") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDirection") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDirection);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRadius);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLifetime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLifetime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleActorIndex);

	p_Stream << "}";
}

void SRegionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRegionSaveData*>(p_Target);

	s_Object->m_nIndex = simdjson::from_json_uint32(p_Document["m_nIndex"]);

	s_Object->m_eType = static_cast<CrowdRegionType>(ZHMEnums::GetEnumValueByName("CrowdRegionType", std::string_view(p_Document["m_eType"])));

	float4::FromSimpleJson(p_Document["m_vCenter"], &s_Object->m_vCenter);

	s_Object->m_nDirection = simdjson::from_json_float32(p_Document["m_nDirection"]);

	s_Object->m_nRadius = simdjson::from_json_float32(p_Document["m_nRadius"]);

	s_Object->m_nAngle = simdjson::from_json_uint32(p_Document["m_nAngle"]);

	s_Object->m_nLifetime = simdjson::from_json_float32(p_Document["m_nLifetime"]);

	s_Object->m_nAge = simdjson::from_json_float32(p_Document["m_nAge"]);

	s_Object->m_nGroupID = simdjson::from_json_uint8(p_Document["m_nGroupID"]);

	s_Object->m_nObstacleActorIndex = simdjson::from_json_int16(p_Document["m_nObstacleActorIndex"]);

}

void SRegionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vCenter, p_Serializer, p_OwnOffset + offsetof(SRegionSaveData, m_vCenter));
}

bool SRegionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRegionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRegionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRegionSaveData::operator==(const SRegionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRegionSaveData>)
		return false;

	if (m_nIndex != p_Other.m_nIndex) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_vCenter != p_Other.m_vCenter) return false;
	if (m_nDirection != p_Other.m_nDirection) return false;
	if (m_nRadius != p_Other.m_nRadius) return false;
	if (m_nAngle != p_Other.m_nAngle) return false;
	if (m_nLifetime != p_Other.m_nLifetime) return false;
	if (m_nAge != p_Other.m_nAge) return false;
	if (m_nGroupID != p_Other.m_nGroupID) return false;
	if (m_nObstacleActorIndex != p_Other.m_nObstacleActorIndex) return false;

	return true;
}

void SRegionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);
	s_Object->~SRegionSaveData();
}

ZHMTypeInfo SCrowdEntitySaveData::TypeInfo = ZHMTypeInfo("SCrowdEntitySaveData", sizeof(SCrowdEntitySaveData), alignof(SCrowdEntitySaveData), SCrowdEntitySaveData::WriteSimpleJson, SCrowdEntitySaveData::FromSimpleJson, SCrowdEntitySaveData::Serialize, SCrowdEntitySaveData::Equals, SCrowdEntitySaveData::Destroy);

void SCrowdEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CrowdActorData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CrowdActorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CrowdActorData[i];
		SCrowdActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CrowdActorData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RegionData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_RegionData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_RegionData[i];
		SRegionSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_RegionData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCrowdAmbient") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCrowdAmbient);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DeadPoseRepository") << ":";
	SCrowdDeadPoseRepositorySaveData::WriteSimpleJson(&s_Object->m_DeadPoseRepository, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCrowdAiPoolActorsMale") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrowdAiPoolActorsMale.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrowdAiPoolActorsMale[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCrowdAiPoolActorsMale.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCrowdAiPoolActorsFemale") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrowdAiPoolActorsFemale.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrowdAiPoolActorsFemale[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCrowdAiPoolActorsFemale.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CrowdActorData"];
	s_Object->m_CrowdActorData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdActorSaveData::FromSimpleJson(s_Item0, &s_Object->m_CrowdActorData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_RegionData"];
	s_Object->m_RegionData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SRegionSaveData::FromSimpleJson(s_Item0, &s_Object->m_RegionData[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_bIsCrowdAmbient = simdjson::from_json_bool(p_Document["m_bIsCrowdAmbient"]);

	SCrowdDeadPoseRepositorySaveData::FromSimpleJson(p_Document["m_DeadPoseRepository"], &s_Object->m_DeadPoseRepository);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCrowdAiPoolActorsMale"];
	s_Object->m_aCrowdAiPoolActorsMale.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aCrowdAiPoolActorsMale[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCrowdAiPoolActorsFemale"];
	s_Object->m_aCrowdAiPoolActorsFemale.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aCrowdAiPoolActorsFemale[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SCrowdEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);

	TArray<SCrowdActorSaveData>::Serialize(&s_Object->m_CrowdActorData, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_CrowdActorData));
	TArray<SRegionSaveData>::Serialize(&s_Object->m_RegionData, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_RegionData));
	SCrowdDeadPoseRepositorySaveData::Serialize(&s_Object->m_DeadPoseRepository, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_DeadPoseRepository));
	TArray<uint32>::Serialize(&s_Object->m_aCrowdAiPoolActorsMale, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_aCrowdAiPoolActorsMale));
	TArray<uint32>::Serialize(&s_Object->m_aCrowdAiPoolActorsFemale, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_aCrowdAiPoolActorsFemale));
}

bool SCrowdEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdEntitySaveData::operator==(const SCrowdEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdEntitySaveData>)
		return false;

	if (m_CrowdActorData != p_Other.m_CrowdActorData) return false;
	if (m_RegionData != p_Other.m_RegionData) return false;
	if (m_bIsCrowdAmbient != p_Other.m_bIsCrowdAmbient) return false;
	if (m_DeadPoseRepository != p_Other.m_DeadPoseRepository) return false;
	if (m_aCrowdAiPoolActorsMale != p_Other.m_aCrowdAiPoolActorsMale) return false;
	if (m_aCrowdAiPoolActorsFemale != p_Other.m_aCrowdAiPoolActorsFemale) return false;

	return true;
}

void SCrowdEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);
	s_Object->~SCrowdEntitySaveData();
}

ZHMTypeInfo SCrowdFlowChannel::TypeInfo = ZHMTypeInfo("SCrowdFlowChannel", sizeof(SCrowdFlowChannel), alignof(SCrowdFlowChannel), SCrowdFlowChannel::WriteSimpleJson, SCrowdFlowChannel::FromSimpleJson, SCrowdFlowChannel::Serialize, SCrowdFlowChannel::Equals, SCrowdFlowChannel::Destroy);

void SCrowdFlowChannel::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aFlowVectorIndex") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowVectorIndex.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowVectorIndex[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFlowVectorIndex.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowCost") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowCost.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowCost[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFlowCost.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdFlowChannel::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowVectorIndex"];
	s_Object->m_aFlowVectorIndex.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aFlowVectorIndex[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowCost"];
	s_Object->m_aFlowCost.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aFlowCost[s_Index0] = simdjson::from_json_uint16(s_Item0);
		++s_Index0;
	}
	}

}

void SCrowdFlowChannel::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aFlowVectorIndex, p_Serializer, p_OwnOffset + offsetof(SCrowdFlowChannel, m_aFlowVectorIndex));
	TArray<uint16>::Serialize(&s_Object->m_aFlowCost, p_Serializer, p_OwnOffset + offsetof(SCrowdFlowChannel, m_aFlowCost));
}

bool SCrowdFlowChannel::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdFlowChannel*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdFlowChannel*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdFlowChannel::operator==(const SCrowdFlowChannel& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdFlowChannel>)
		return false;

	if (m_aFlowVectorIndex != p_Other.m_aFlowVectorIndex) return false;
	if (m_aFlowCost != p_Other.m_aFlowCost) return false;

	return true;
}

void SCrowdFlowChannel::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);
	s_Object->~SCrowdFlowChannel();
}

ZHMTypeInfo ZCrowdGridPoint::TypeInfo = ZHMTypeInfo("ZCrowdGridPoint", sizeof(ZCrowdGridPoint), alignof(ZCrowdGridPoint), ZCrowdGridPoint::WriteSimpleJson, ZCrowdGridPoint::FromSimpleJson, ZCrowdGridPoint::Serialize, ZCrowdGridPoint::Equals, ZCrowdGridPoint::Destroy);

void ZCrowdGridPoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nHeightOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHeightOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOnNavGrid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOnNavGrid);

	p_Stream << "}";
}

void ZCrowdGridPoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Target);

	s_Object->m_nHeightOffset = simdjson::from_json_int16(p_Document["m_nHeightOffset"]);

	s_Object->m_nOnNavGrid = simdjson::from_json_uint8(p_Document["m_nOnNavGrid"]);

}

void ZCrowdGridPoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

}

bool ZCrowdGridPoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCrowdGridPoint*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCrowdGridPoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCrowdGridPoint::operator==(const ZCrowdGridPoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCrowdGridPoint>)
		return false;

	if (m_nHeightOffset != p_Other.m_nHeightOffset) return false;
	if (m_nOnNavGrid != p_Other.m_nOnNavGrid) return false;

	return true;
}

void ZCrowdGridPoint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);
	s_Object->~ZCrowdGridPoint();
}

ZHMTypeInfo SCrowdMapData::TypeInfo = ZHMTypeInfo("SCrowdMapData", sizeof(SCrowdMapData), alignof(SCrowdMapData), SCrowdMapData::WriteSimpleJson, SCrowdMapData::FromSimpleJson, SCrowdMapData::Serialize, SCrowdMapData::Equals, SCrowdMapData::Destroy);

void SCrowdMapData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCellConsts") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vCellConsts, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GridMap") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_GridMap.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_GridMap[i];
		ZCrowdGridPoint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_GridMap.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsBias") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsBias);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellFlags") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellFlags.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellFlags[i];
		SCrowdCells::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CellFlags.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellGroups[i];
		SCrowdCells::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CellGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupFlowStartChannel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupFlowStartChannel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowChannels") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowChannels.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowChannels[i];
		SCrowdFlowChannel::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aFlowChannels.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCellSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCellSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mObjectToWorld") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mObjectToWorld, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vGlobalSize") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vGlobalSize, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridGeneratorOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridGeneratorOffset);

	p_Stream << "}";
}

void SCrowdMapData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdMapData*>(p_Target);

	s_Object->m_nVersion = simdjson::from_json_uint32(p_Document["m_nVersion"]);

	SVector4::FromSimpleJson(p_Document["m_vCellConsts"], &s_Object->m_vCellConsts);

	s_Object->m_nGridSizeX = simdjson::from_json_uint32(p_Document["m_nGridSizeX"]);

	s_Object->m_nGridSizeY = simdjson::from_json_uint32(p_Document["m_nGridSizeY"]);

	s_Object->m_nCellSizeX = simdjson::from_json_uint32(p_Document["m_nCellSizeX"]);

	s_Object->m_nCellSizeY = simdjson::from_json_uint32(p_Document["m_nCellSizeY"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_GridMap"];
	s_Object->m_GridMap.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZCrowdGridPoint::FromSimpleJson(s_Item0, &s_Object->m_GridMap[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_fGridMapHeightOffsetsScale = simdjson::from_json_float32(p_Document["m_fGridMapHeightOffsetsScale"]);

	s_Object->m_fGridMapHeightOffsetsBias = simdjson::from_json_float32(p_Document["m_fGridMapHeightOffsetsBias"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CellFlags"];
	s_Object->m_CellFlags.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdCells::FromSimpleJson(s_Item0, &s_Object->m_CellFlags[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CellGroups"];
	s_Object->m_CellGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdCells::FromSimpleJson(s_Item0, &s_Object->m_CellGroups[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_nGroupFlowStartChannel = simdjson::from_json_int32(p_Document["m_nGroupFlowStartChannel"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowChannels"];
	s_Object->m_aFlowChannels.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdFlowChannel::FromSimpleJson(s_Item0, &s_Object->m_aFlowChannels[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_nGridCellSize = simdjson::from_json_float32(p_Document["m_nGridCellSize"]);

	SMatrix::FromSimpleJson(p_Document["m_mObjectToWorld"], &s_Object->m_mObjectToWorld);

	SVector3::FromSimpleJson(p_Document["m_vGlobalSize"], &s_Object->m_vGlobalSize);

	s_Object->m_nGridGeneratorOffset = simdjson::from_json_float32(p_Document["m_nGridGeneratorOffset"]);

}

void SCrowdMapData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vCellConsts, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_vCellConsts));
	TArray<ZCrowdGridPoint>::Serialize(&s_Object->m_GridMap, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_GridMap));
	TArray<SCrowdCells>::Serialize(&s_Object->m_CellFlags, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_CellFlags));
	TArray<SCrowdCells>::Serialize(&s_Object->m_CellGroups, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_CellGroups));
	TArray<SCrowdFlowChannel>::Serialize(&s_Object->m_aFlowChannels, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_aFlowChannels));
	SMatrix::Serialize(&s_Object->m_mObjectToWorld, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_mObjectToWorld));
	SVector3::Serialize(&s_Object->m_vGlobalSize, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_vGlobalSize));
}

bool SCrowdMapData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdMapData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdMapData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdMapData::operator==(const SCrowdMapData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdMapData>)
		return false;

	if (m_nVersion != p_Other.m_nVersion) return false;
	if (m_vCellConsts != p_Other.m_vCellConsts) return false;
	if (m_nGridSizeX != p_Other.m_nGridSizeX) return false;
	if (m_nGridSizeY != p_Other.m_nGridSizeY) return false;
	if (m_nCellSizeX != p_Other.m_nCellSizeX) return false;
	if (m_nCellSizeY != p_Other.m_nCellSizeY) return false;
	if (m_GridMap != p_Other.m_GridMap) return false;
	if (m_fGridMapHeightOffsetsScale != p_Other.m_fGridMapHeightOffsetsScale) return false;
	if (m_fGridMapHeightOffsetsBias != p_Other.m_fGridMapHeightOffsetsBias) return false;
	if (m_CellFlags != p_Other.m_CellFlags) return false;
	if (m_CellGroups != p_Other.m_CellGroups) return false;
	if (m_nGroupFlowStartChannel != p_Other.m_nGroupFlowStartChannel) return false;
	if (m_aFlowChannels != p_Other.m_aFlowChannels) return false;
	if (m_nGridCellSize != p_Other.m_nGridCellSize) return false;
	if (m_mObjectToWorld != p_Other.m_mObjectToWorld) return false;
	if (m_vGlobalSize != p_Other.m_vGlobalSize) return false;
	if (m_nGridGeneratorOffset != p_Other.m_nGridGeneratorOffset) return false;

	return true;
}

void SCrowdMapData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);
	s_Object->~SCrowdMapData();
}

ZHMTypeInfo SCrowdReactionSaveData::TypeInfo = ZHMTypeInfo("SCrowdReactionSaveData", sizeof(SCrowdReactionSaveData), alignof(SCrowdReactionSaveData), SCrowdReactionSaveData::WriteSimpleJson, SCrowdReactionSaveData::FromSimpleJson, SCrowdReactionSaveData::Serialize, SCrowdReactionSaveData::Equals, SCrowdReactionSaveData::Destroy);

void SCrowdReactionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nNumPacify") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumPacify);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumShotsFired") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumShotsFired);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumDeaths") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumDeaths);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumScared") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumScared);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarzoneSpawned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarzoneSpawned);

	p_Stream << "}";
}

void SCrowdReactionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Target);

	s_Object->m_nNumPacify = simdjson::from_json_uint32(p_Document["m_nNumPacify"]);

	s_Object->m_nNumShotsFired = simdjson::from_json_uint32(p_Document["m_nNumShotsFired"]);

	s_Object->m_nNumDeaths = simdjson::from_json_uint32(p_Document["m_nNumDeaths"]);

	s_Object->m_nNumScared = simdjson::from_json_uint32(p_Document["m_nNumScared"]);

	s_Object->m_bWarzoneSpawned = simdjson::from_json_bool(p_Document["m_bWarzoneSpawned"]);

}

void SCrowdReactionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);

}

bool SCrowdReactionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdReactionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdReactionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdReactionSaveData::operator==(const SCrowdReactionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdReactionSaveData>)
		return false;

	if (m_nNumPacify != p_Other.m_nNumPacify) return false;
	if (m_nNumShotsFired != p_Other.m_nNumShotsFired) return false;
	if (m_nNumDeaths != p_Other.m_nNumDeaths) return false;
	if (m_nNumScared != p_Other.m_nNumScared) return false;
	if (m_bWarzoneSpawned != p_Other.m_bWarzoneSpawned) return false;

	return true;
}

void SCrowdReactionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);
	s_Object->~SCrowdReactionSaveData();
}

ZHMTypeInfo SCrowdServiceSaveData::TypeInfo = ZHMTypeInfo("SCrowdServiceSaveData", sizeof(SCrowdServiceSaveData), alignof(SCrowdServiceSaveData), SCrowdServiceSaveData::WriteSimpleJson, SCrowdServiceSaveData::FromSimpleJson, SCrowdServiceSaveData::Serialize, SCrowdServiceSaveData::Equals, SCrowdServiceSaveData::Destroy);

void SCrowdServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aDeadBodies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDeadBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDeadBodies[i];
		SCrowdBodySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aDeadBodies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDeadBodies"];
	s_Object->m_aDeadBodies.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdBodySaveData::FromSimpleJson(s_Item0, &s_Object->m_aDeadBodies[s_Index0]);
		++s_Index0;
	}
	}

}

void SCrowdServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);

	TArray<SCrowdBodySaveData>::Serialize(&s_Object->m_aDeadBodies, p_Serializer, p_OwnOffset + offsetof(SCrowdServiceSaveData, m_aDeadBodies));
}

bool SCrowdServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdServiceSaveData::operator==(const SCrowdServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdServiceSaveData>)
		return false;

	if (m_aDeadBodies != p_Other.m_aDeadBodies) return false;

	return true;
}

void SCrowdServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);
	s_Object->~SCrowdServiceSaveData();
}

ZHMTypeInfo SCuriousEventSaveData::TypeInfo = ZHMTypeInfo("SCuriousEventSaveData", sizeof(SCuriousEventSaveData), alignof(SCuriousEventSaveData), SCuriousEventSaveData::WriteSimpleJson, SCuriousEventSaveData::FromSimpleJson, SCuriousEventSaveData::Serialize, SCuriousEventSaveData::Equals, SCuriousEventSaveData::Destroy);

void SCuriousEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tExpiresAt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiresAt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nKnowledgeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nKnowledgeIndex);

	p_Stream << "}";
}

void SCuriousEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_tExpiresAt"], &s_Object->m_tExpiresAt);

	s_Object->m_nKnowledgeIndex = simdjson::from_json_int32(p_Document["m_nKnowledgeIndex"]);

}

void SCuriousEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tExpiresAt, p_Serializer, p_OwnOffset + offsetof(SCuriousEventSaveData, m_tExpiresAt));
}

bool SCuriousEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousEventSaveData::operator==(const SCuriousEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousEventSaveData>)
		return false;

	if (m_tExpiresAt != p_Other.m_tExpiresAt) return false;
	if (m_nKnowledgeIndex != p_Other.m_nKnowledgeIndex) return false;

	return true;
}

void SCuriousEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);
	s_Object->~SCuriousEventSaveData();
}

ZHMTypeInfo SCuriousEventServiceSaveData::TypeInfo = ZHMTypeInfo("SCuriousEventServiceSaveData", sizeof(SCuriousEventServiceSaveData), alignof(SCuriousEventServiceSaveData), SCuriousEventServiceSaveData::WriteSimpleJson, SCuriousEventServiceSaveData::FromSimpleJson, SCuriousEventServiceSaveData::Serialize, SCuriousEventServiceSaveData::Equals, SCuriousEventServiceSaveData::Destroy);

void SCuriousEventServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCuriousEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCuriousEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCuriousEvents[i];
		SCuriousEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCuriousEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCuriousEventServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCuriousEvents"];
	s_Object->m_aCuriousEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCuriousEventSaveData::FromSimpleJson(s_Item0, &s_Object->m_aCuriousEvents[s_Index0]);
		++s_Index0;
	}
	}

}

void SCuriousEventServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);

	TArray<SCuriousEventSaveData>::Serialize(&s_Object->m_aCuriousEvents, p_Serializer, p_OwnOffset + offsetof(SCuriousEventServiceSaveData, m_aCuriousEvents));
}

bool SCuriousEventServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousEventServiceSaveData::operator==(const SCuriousEventServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousEventServiceSaveData>)
		return false;

	if (m_aCuriousEvents != p_Other.m_aCuriousEvents) return false;

	return true;
}

void SCuriousEventServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);
	s_Object->~SCuriousEventServiceSaveData();
}

ZHMTypeInfo SCuriousInvestigateGroupSaveData::TypeInfo = ZHMTypeInfo("SCuriousInvestigateGroupSaveData", sizeof(SCuriousInvestigateGroupSaveData), alignof(SCuriousInvestigateGroupSaveData), SCuriousInvestigateGroupSaveData::WriteSimpleJson, SCuriousInvestigateGroupSaveData::FromSimpleJson, SCuriousInvestigateGroupSaveData::Serialize, SCuriousInvestigateGroupSaveData::Equals, SCuriousInvestigateGroupSaveData::Destroy);

void SCuriousInvestigateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInvestigationId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInvestigationId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInvestigationType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pTempLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pTempLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pSecondary") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pSecondary);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInvestigationState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tResolveStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tResolveStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStandDownType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EStandDownType", static_cast<int>(s_Object->m_eStandDownType)));

	p_Stream << "}";
}

void SCuriousInvestigateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Target);

	s_Object->m_nInvestigationId = simdjson::from_json_int32(p_Document["m_nInvestigationId"]);

	s_Object->m_type = static_cast<EInvestigationType>(ZHMEnums::GetEnumValueByName("EInvestigationType", std::string_view(p_Document["m_type"])));

	s_Object->m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object->m_pTempLeader = simdjson::from_json_uint32(p_Document["m_pTempLeader"]);

	s_Object->m_pSecondary = simdjson::from_json_uint32(p_Document["m_pSecondary"]);

	s_Object->m_state = static_cast<EInvestigationState>(ZHMEnums::GetEnumValueByName("EInvestigationState", std::string_view(p_Document["m_state"])));

	ZGameTime::FromSimpleJson(p_Document["m_tStartTime"], &s_Object->m_tStartTime);

	ZGameTime::FromSimpleJson(p_Document["m_tResolveStartTime"], &s_Object->m_tResolveStartTime);

	s_Object->m_bWarned = simdjson::from_json_bool(p_Document["m_bWarned"]);

	s_Object->m_eStandDownType = static_cast<EStandDownType>(ZHMEnums::GetEnumValueByName("EStandDownType", std::string_view(p_Document["m_eStandDownType"])));

}

void SCuriousInvestigateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tStartTime, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateGroupSaveData, m_tStartTime));
	ZGameTime::Serialize(&s_Object->m_tResolveStartTime, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateGroupSaveData, m_tResolveStartTime));
}

bool SCuriousInvestigateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousInvestigateGroupSaveData::operator==(const SCuriousInvestigateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousInvestigateGroupSaveData>)
		return false;

	if (m_nInvestigationId != p_Other.m_nInvestigationId) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pTempLeader != p_Other.m_pTempLeader) return false;
	if (m_pSecondary != p_Other.m_pSecondary) return false;
	if (m_state != p_Other.m_state) return false;
	if (m_tStartTime != p_Other.m_tStartTime) return false;
	if (m_tResolveStartTime != p_Other.m_tResolveStartTime) return false;
	if (m_bWarned != p_Other.m_bWarned) return false;
	if (m_eStandDownType != p_Other.m_eStandDownType) return false;

	return true;
}

void SCuriousInvestigateGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateGroupSaveData*>(p_Object);
	s_Object->~SCuriousInvestigateGroupSaveData();
}

ZHMTypeInfo SCuriousInvestigateSituationSaveData::TypeInfo = ZHMTypeInfo("SCuriousInvestigateSituationSaveData", sizeof(SCuriousInvestigateSituationSaveData), alignof(SCuriousInvestigateSituationSaveData), SCuriousInvestigateSituationSaveData::WriteSimpleJson, SCuriousInvestigateSituationSaveData::FromSimpleJson, SCuriousInvestigateSituationSaveData::Serialize, SCuriousInvestigateSituationSaveData::Equals, SCuriousInvestigateSituationSaveData::Destroy);

void SCuriousInvestigateSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aInvestigationGroupIDs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aInvestigationGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aInvestigationGroupIDs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aInvestigationGroupIDs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aVIPInvestigationGroupIDs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aVIPInvestigationGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aVIPInvestigationGroupIDs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aVIPInvestigationGroupIDs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nInvestigationCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInvestigationCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDownOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastStandDownOrder, p_Stream);

	p_Stream << "}";
}

void SCuriousInvestigateSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aInvestigationGroupIDs"];
	s_Object->m_aInvestigationGroupIDs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aInvestigationGroupIDs[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aVIPInvestigationGroupIDs"];
	s_Object->m_aVIPInvestigationGroupIDs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aVIPInvestigationGroupIDs[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_nInvestigationCount = simdjson::from_json_int32(p_Document["m_nInvestigationCount"]);

	ZGameTime::FromSimpleJson(p_Document["m_tLastStandDownOrder"], &s_Object->m_tLastStandDownOrder);

}

void SCuriousInvestigateSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aInvestigationGroupIDs, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateSituationSaveData, m_aInvestigationGroupIDs));
	TArray<int32>::Serialize(&s_Object->m_aVIPInvestigationGroupIDs, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateSituationSaveData, m_aVIPInvestigationGroupIDs));
	ZGameTime::Serialize(&s_Object->m_tLastStandDownOrder, p_Serializer, p_OwnOffset + offsetof(SCuriousInvestigateSituationSaveData, m_tLastStandDownOrder));
}

bool SCuriousInvestigateSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousInvestigateSituationSaveData::operator==(const SCuriousInvestigateSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousInvestigateSituationSaveData>)
		return false;

	if (m_aInvestigationGroupIDs != p_Other.m_aInvestigationGroupIDs) return false;
	if (m_aVIPInvestigationGroupIDs != p_Other.m_aVIPInvestigationGroupIDs) return false;
	if (m_nInvestigationCount != p_Other.m_nInvestigationCount) return false;
	if (m_tLastStandDownOrder != p_Other.m_tLastStandDownOrder) return false;

	return true;
}

void SCuriousInvestigateSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCuriousInvestigateSituationSaveData*>(p_Object);
	s_Object->~SCuriousInvestigateSituationSaveData();
}

ZHMTypeInfo SCuriousSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SCuriousSituationMemberSaveData", sizeof(SCuriousSituationMemberSaveData), alignof(SCuriousSituationMemberSaveData), SCuriousSituationMemberSaveData::WriteSimpleJson, SCuriousSituationMemberSaveData::FromSimpleJson, SCuriousSituationMemberSaveData::Serialize, SCuriousSituationMemberSaveData::Equals, SCuriousSituationMemberSaveData::Destroy);

void SCuriousSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tLastDisturbance") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastDisturbance, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_escalateTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_escalateTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarned);

	p_Stream << "}";
}

void SCuriousSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_tLastDisturbance"], &s_Object->m_tLastDisturbance);

	s_Object->m_escalateTarget = simdjson::from_json_uint32(p_Document["m_escalateTarget"]);

	s_Object->m_bWarned = simdjson::from_json_bool(p_Document["m_bWarned"]);

}

void SCuriousSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastDisturbance, p_Serializer, p_OwnOffset + offsetof(SCuriousSituationMemberSaveData, m_tLastDisturbance));
}

bool SCuriousSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousSituationMemberSaveData::operator==(const SCuriousSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousSituationMemberSaveData>)
		return false;

	if (m_tLastDisturbance != p_Other.m_tLastDisturbance) return false;
	if (m_escalateTarget != p_Other.m_escalateTarget) return false;
	if (m_bWarned != p_Other.m_bWarned) return false;

	return true;
}

void SCuriousSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCuriousSituationMemberSaveData*>(p_Object);
	s_Object->~SCuriousSituationMemberSaveData();
}

ZHMTypeInfo SCutSequenceData::TypeInfo = ZHMTypeInfo("SCutSequenceData", sizeof(SCutSequenceData), alignof(SCutSequenceData), SCutSequenceData::WriteSimpleJson, SCutSequenceData::FromSimpleJson, SCutSequenceData::Serialize, SCutSequenceData::Equals, SCutSequenceData::Destroy);

void SCutSequenceData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCutSequenceData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_animResource") << ":";
	TResourcePtr::WriteSimpleJson(&s_Object->m_animResource, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimationTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimationTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCachedFrameWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCachedFrameWeight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnableAnimationScaling") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnableAnimationScaling);

	p_Stream << "}";
}

void SCutSequenceData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SCutSequenceData*>(p_Target);

	TResourcePtr::FromSimpleJson(p_Document["m_animResource"], &s_Object->m_animResource);

	s_Object->m_fAnimationTime = simdjson::from_json_float32(p_Document["m_fAnimationTime"]);

	s_Object->m_fCachedFrameWeight = simdjson::from_json_float32(p_Document["m_fCachedFrameWeight"]);

	s_Object->m_bEnableAnimationScaling = simdjson::from_json_bool(p_Document["m_bEnableAnimationScaling"]);

}

void SCutSequenceData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCutSequenceData*>(p_Object);

	TResourcePtr::Serialize(&s_Object->m_animResource, p_Serializer, p_OwnOffset + offsetof(SCutSequenceData, m_animResource));
}

bool SCutSequenceData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCutSequenceData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCutSequenceData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCutSequenceData::operator==(const SCutSequenceData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCutSequenceData>)
		return false;

	if (m_animResource != p_Other.m_animResource) return false;
	if (m_fAnimationTime != p_Other.m_fAnimationTime) return false;
	if (m_fCachedFrameWeight != p_Other.m_fCachedFrameWeight) return false;
	if (m_bEnableAnimationScaling != p_Other.m_bEnableAnimationScaling) return false;

	return true;
}

void SCutSequenceData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCutSequenceData*>(p_Object);
	s_Object->~SCutSequenceData();
}

ZHMTypeInfo SDangerousAreaSaveData::TypeInfo = ZHMTypeInfo("SDangerousAreaSaveData", sizeof(SDangerousAreaSaveData), alignof(SDangerousAreaSaveData), SDangerousAreaSaveData::WriteSimpleJson, SDangerousAreaSaveData::FromSimpleJson, SDangerousAreaSaveData::Serialize, SDangerousAreaSaveData::Equals, SDangerousAreaSaveData::Destroy);

void SDangerousAreaSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bDangerous") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDangerous);

	p_Stream << "}";
}

void SDangerousAreaSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Target);

	s_Object->m_bDangerous = simdjson::from_json_bool(p_Document["m_bDangerous"]);

}

void SDangerousAreaSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);

}

bool SDangerousAreaSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDangerousAreaSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDangerousAreaSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDangerousAreaSaveData::operator==(const SDangerousAreaSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDangerousAreaSaveData>)
		return false;

	if (m_bDangerous != p_Other.m_bDangerous) return false;

	return true;
}

void SDangerousAreaSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);
	s_Object->~SDangerousAreaSaveData();
}

ZHMTypeInfo SDeadBodyInfoSaveData::TypeInfo = ZHMTypeInfo("SDeadBodyInfoSaveData", sizeof(SDeadBodyInfoSaveData), alignof(SDeadBodyInfoSaveData), SDeadBodyInfoSaveData::WriteSimpleJson, SDeadBodyInfoSaveData::FromSimpleJson, SDeadBodyInfoSaveData::Serialize, SDeadBodyInfoSaveData::Equals, SDeadBodyInfoSaveData::Destroy);

void SDeadBodyInfoSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_knownByActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_knownByActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_knownByActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_knownByActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tKnownSince") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tKnownSince, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tInvestigatedSince") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tInvestigatedSince, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPoolKnownOnly") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPoolKnownOnly);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPoolInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPoolInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGuarded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGuarded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBodyInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBodyInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByAccident") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByAccident);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByUnnoticed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByUnnoticed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanSuspectedInCurrentOutfit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanSuspectedInCurrentOutfit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByExplosion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByExplosion);

	p_Stream << "}";
}

void SDeadBodyInfoSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object->m_rGuard = simdjson::from_json_uint32(p_Document["m_rGuard"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_knownByActors"];
	s_Object->m_knownByActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_knownByActors[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	ZGameTime::FromSimpleJson(p_Document["m_tKnownSince"], &s_Object->m_tKnownSince);

	ZGameTime::FromSimpleJson(p_Document["m_tInvestigatedSince"], &s_Object->m_tInvestigatedSince);

	s_Object->m_bPoolKnownOnly = simdjson::from_json_bool(p_Document["m_bPoolKnownOnly"]);

	s_Object->m_bPoolInvestigated = simdjson::from_json_bool(p_Document["m_bPoolInvestigated"]);

	s_Object->m_bGuarded = simdjson::from_json_bool(p_Document["m_bGuarded"]);

	s_Object->m_bBodyInvestigated = simdjson::from_json_bool(p_Document["m_bBodyInvestigated"]);

	s_Object->m_bHidden = simdjson::from_json_bool(p_Document["m_bHidden"]);

	s_Object->m_bDeadByAccident = simdjson::from_json_bool(p_Document["m_bDeadByAccident"]);

	s_Object->m_bDeadByUnnoticed = simdjson::from_json_bool(p_Document["m_bDeadByUnnoticed"]);

	s_Object->m_bHitmanSuspectedInCurrentOutfit = simdjson::from_json_bool(p_Document["m_bHitmanSuspectedInCurrentOutfit"]);

	s_Object->m_bDeadByExplosion = simdjson::from_json_bool(p_Document["m_bDeadByExplosion"]);

}

void SDeadBodyInfoSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_knownByActors, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_knownByActors));
	ZGameTime::Serialize(&s_Object->m_tKnownSince, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_tKnownSince));
	ZGameTime::Serialize(&s_Object->m_tInvestigatedSince, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_tInvestigatedSince));
}

bool SDeadBodyInfoSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDeadBodyInfoSaveData::operator==(const SDeadBodyInfoSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDeadBodyInfoSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rGuard != p_Other.m_rGuard) return false;
	if (m_knownByActors != p_Other.m_knownByActors) return false;
	if (m_tKnownSince != p_Other.m_tKnownSince) return false;
	if (m_tInvestigatedSince != p_Other.m_tInvestigatedSince) return false;
	if (m_bPoolKnownOnly != p_Other.m_bPoolKnownOnly) return false;
	if (m_bPoolInvestigated != p_Other.m_bPoolInvestigated) return false;
	if (m_bGuarded != p_Other.m_bGuarded) return false;
	if (m_bBodyInvestigated != p_Other.m_bBodyInvestigated) return false;
	if (m_bHidden != p_Other.m_bHidden) return false;
	if (m_bDeadByAccident != p_Other.m_bDeadByAccident) return false;
	if (m_bDeadByUnnoticed != p_Other.m_bDeadByUnnoticed) return false;
	if (m_bHitmanSuspectedInCurrentOutfit != p_Other.m_bHitmanSuspectedInCurrentOutfit) return false;
	if (m_bDeadByExplosion != p_Other.m_bDeadByExplosion) return false;

	return true;
}

void SDeadBodyInfoSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);
	s_Object->~SDeadBodyInfoSaveData();
}

ZHMTypeInfo SDeadBodySensorSaveData::TypeInfo = ZHMTypeInfo("SDeadBodySensorSaveData", sizeof(SDeadBodySensorSaveData), alignof(SDeadBodySensorSaveData), SDeadBodySensorSaveData::WriteSimpleJson, SDeadBodySensorSaveData::FromSimpleJson, SDeadBodySensorSaveData::Serialize, SDeadBodySensorSaveData::Equals, SDeadBodySensorSaveData::Destroy);

void SDeadBodySensorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBodies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBodies[i];
		SDeadBodyInfoSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBodies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBodyIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBodyIndex);

	p_Stream << "}";
}

void SDeadBodySensorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBodies"];
	s_Object->m_aBodies.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDeadBodyInfoSaveData::FromSimpleJson(s_Item0, &s_Object->m_aBodies[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_nBodyIndex = simdjson::from_json_int32(p_Document["m_nBodyIndex"]);

}

void SDeadBodySensorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);

	TArray<SDeadBodyInfoSaveData>::Serialize(&s_Object->m_aBodies, p_Serializer, p_OwnOffset + offsetof(SDeadBodySensorSaveData, m_aBodies));
}

bool SDeadBodySensorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDeadBodySensorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDeadBodySensorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDeadBodySensorSaveData::operator==(const SDeadBodySensorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDeadBodySensorSaveData>)
		return false;

	if (m_aBodies != p_Other.m_aBodies) return false;
	if (m_nBodyIndex != p_Other.m_nBodyIndex) return false;

	return true;
}

void SDeadBodySensorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);
	s_Object->~SDeadBodySensorSaveData();
}

ZHMTypeInfo SVector2::TypeInfo = ZHMTypeInfo("SVector2", sizeof(SVector2), alignof(SVector2), SVector2::WriteSimpleJson, SVector2::FromSimpleJson, SVector2::Serialize, SVector2::Equals, SVector2::Destroy);

void SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);

	p_Stream << "}";
}

void SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVector2*>(p_Target);

	s_Object->x = simdjson::from_json_float32(p_Document["x"]);

	s_Object->y = simdjson::from_json_float32(p_Document["y"]);

}

void SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

}

bool SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector2::operator==(const SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector2>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;

	return true;
}

void SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);
	s_Object->~SVector2();
}

ZHMTypeInfo SDecalSpawnSaveData::TypeInfo = ZHMTypeInfo("SDecalSpawnSaveData", sizeof(SDecalSpawnSaveData), alignof(SDecalSpawnSaveData), SDecalSpawnSaveData::WriteSimpleJson, SDecalSpawnSaveData::FromSimpleJson, SDecalSpawnSaveData::Serialize, SDecalSpawnSaveData::Equals, SDecalSpawnSaveData::Destroy);

void SDecalSpawnSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bWasSpawned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasSpawned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vNormal") << ":";
	float4::WriteSimpleJson(&s_Object->m_vNormal, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSize") << ":";
	float4::WriteSimpleJson(&s_Object->m_vSize, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Color") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_Color, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vUVOffset") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vUVOffset, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTiling") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vTiling, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBlockingSpatialEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBlockingSpatialEntity);

	p_Stream << "}";
}

void SDecalSpawnSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Target);

	s_Object->m_bWasSpawned = simdjson::from_json_bool(p_Document["m_bWasSpawned"]);

	float4::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	float4::FromSimpleJson(p_Document["m_vNormal"], &s_Object->m_vNormal);

	float4::FromSimpleJson(p_Document["m_vDirection"], &s_Object->m_vDirection);

	float4::FromSimpleJson(p_Document["m_vSize"], &s_Object->m_vSize);

	SColorRGB::FromSimpleJson(p_Document["m_Color"], &s_Object->m_Color);

	s_Object->m_fAlpha = simdjson::from_json_float32(p_Document["m_fAlpha"]);

	s_Object->m_fAngle = simdjson::from_json_float32(p_Document["m_fAngle"]);

	SVector2::FromSimpleJson(p_Document["m_vUVOffset"], &s_Object->m_vUVOffset);

	SVector2::FromSimpleJson(p_Document["m_vTiling"], &s_Object->m_vTiling);

	s_Object->m_rBlockingSpatialEntity = simdjson::from_json_uint32(p_Document["m_rBlockingSpatialEntity"]);

}

void SDecalSpawnSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vPosition));
	float4::Serialize(&s_Object->m_vNormal, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vNormal));
	float4::Serialize(&s_Object->m_vDirection, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vDirection));
	float4::Serialize(&s_Object->m_vSize, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vSize));
	SColorRGB::Serialize(&s_Object->m_Color, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_Color));
	SVector2::Serialize(&s_Object->m_vUVOffset, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vUVOffset));
	SVector2::Serialize(&s_Object->m_vTiling, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vTiling));
}

bool SDecalSpawnSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDecalSpawnSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDecalSpawnSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDecalSpawnSaveData::operator==(const SDecalSpawnSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDecalSpawnSaveData>)
		return false;

	if (m_bWasSpawned != p_Other.m_bWasSpawned) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vNormal != p_Other.m_vNormal) return false;
	if (m_vDirection != p_Other.m_vDirection) return false;
	if (m_vSize != p_Other.m_vSize) return false;
	if (m_Color != p_Other.m_Color) return false;
	if (m_fAlpha != p_Other.m_fAlpha) return false;
	if (m_fAngle != p_Other.m_fAngle) return false;
	if (m_vUVOffset != p_Other.m_vUVOffset) return false;
	if (m_vTiling != p_Other.m_vTiling) return false;
	if (m_rBlockingSpatialEntity != p_Other.m_rBlockingSpatialEntity) return false;

	return true;
}

void SDecalSpawnSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);
	s_Object->~SDecalSpawnSaveData();
}

ZHMTypeInfo SDetectedInPrivateGroupSaveData::TypeInfo = ZHMTypeInfo("SDetectedInPrivateGroupSaveData", sizeof(SDetectedInPrivateGroupSaveData), alignof(SDetectedInPrivateGroupSaveData), SDetectedInPrivateGroupSaveData::WriteSimpleJson, SDetectedInPrivateGroupSaveData::FromSimpleJson, SDetectedInPrivateGroupSaveData::Serialize, SDetectedInPrivateGroupSaveData::Equals, SDetectedInPrivateGroupSaveData::Destroy);

void SDetectedInPrivateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeWaiting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeWaiting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rLead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisbanded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisbanded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirstWait") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirstWait);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);

	p_Stream << "}";
}

void SDetectedInPrivateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_fTimeWaiting = simdjson::from_json_float32(p_Document["m_fTimeWaiting"]);

	s_Object->m_rLead = simdjson::from_json_uint32(p_Document["m_rLead"]);

	s_Object->m_bDisbanded = simdjson::from_json_bool(p_Document["m_bDisbanded"]);

	s_Object->m_bFirstWait = simdjson::from_json_bool(p_Document["m_bFirstWait"]);

	s_Object->m_target = simdjson::from_json_int32(p_Document["m_target"]);

}

void SDetectedInPrivateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SDetectedInPrivateGroupSaveData, m_fsmState));
}

bool SDetectedInPrivateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDetectedInPrivateGroupSaveData::operator==(const SDetectedInPrivateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDetectedInPrivateGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_fTimeWaiting != p_Other.m_fTimeWaiting) return false;
	if (m_rLead != p_Other.m_rLead) return false;
	if (m_bDisbanded != p_Other.m_bDisbanded) return false;
	if (m_bFirstWait != p_Other.m_bFirstWait) return false;
	if (m_target != p_Other.m_target) return false;

	return true;
}

void SDetectedInPrivateGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);
	s_Object->~SDetectedInPrivateGroupSaveData();
}

ZHMTypeInfo SDisguiseZoneSaveData::TypeInfo = ZHMTypeInfo("SDisguiseZoneSaveData", sizeof(SDisguiseZoneSaveData), alignof(SDisguiseZoneSaveData), SDisguiseZoneSaveData::WriteSimpleJson, SDisguiseZoneSaveData::FromSimpleJson, SDisguiseZoneSaveData::Serialize, SDisguiseZoneSaveData::Equals, SDisguiseZoneSaveData::Destroy);

void SDisguiseZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SDisguiseZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

}

void SDisguiseZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);

}

bool SDisguiseZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDisguiseZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDisguiseZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDisguiseZoneSaveData::operator==(const SDisguiseZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDisguiseZoneSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SDisguiseZoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);
	s_Object->~SDisguiseZoneSaveData();
}

ZHMTypeInfo SDoorSaveData::TypeInfo = ZHMTypeInfo("SDoorSaveData", sizeof(SDoorSaveData), alignof(SDoorSaveData), SDoorSaveData::WriteSimpleJson, SDoorSaveData::FromSimpleJson, SDoorSaveData::Serialize, SDoorSaveData::Equals, SDoorSaveData::Destroy);

void SDoorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nDoorState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDoorState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimPercent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimPercent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAnimPercent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAnimPercent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tOpenTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tOpenTime, p_Stream);

	p_Stream << "}";
}

void SDoorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDoorSaveData*>(p_Target);

	s_Object->m_nDoorState = simdjson::from_json_int32(p_Document["m_nDoorState"]);

	s_Object->m_fAnimPercent = simdjson::from_json_float32(p_Document["m_fAnimPercent"]);

	s_Object->m_fTargetAnimPercent = simdjson::from_json_float32(p_Document["m_fTargetAnimPercent"]);

	ZGameTime::FromSimpleJson(p_Document["m_tOpenTime"], &s_Object->m_tOpenTime);

}

void SDoorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tOpenTime, p_Serializer, p_OwnOffset + offsetof(SDoorSaveData, m_tOpenTime));
}

bool SDoorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorSaveData::operator==(const SDoorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorSaveData>)
		return false;

	if (m_nDoorState != p_Other.m_nDoorState) return false;
	if (m_fAnimPercent != p_Other.m_fAnimPercent) return false;
	if (m_fTargetAnimPercent != p_Other.m_fTargetAnimPercent) return false;
	if (m_tOpenTime != p_Other.m_tOpenTime) return false;

	return true;
}

void SDoorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);
	s_Object->~SDoorSaveData();
}

ZHMTypeInfo SDoorSoundDefs::TypeInfo = ZHMTypeInfo("SDoorSoundDefs", sizeof(SDoorSoundDefs), alignof(SDoorSoundDefs), SDoorSoundDefs::WriteSimpleJson, SDoorSoundDefs::FromSimpleJson, SDoorSoundDefs::Serialize, SDoorSoundDefs::Equals, SDoorSoundDefs::Destroy);

void SDoorSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SDoorSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Target);

}

void SDoorSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

}

bool SDoorSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorSoundDefs::operator==(const SDoorSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorSoundDefs>)
		return false;


	return true;
}

void SDoorSoundDefs::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);
	s_Object->~SDoorSoundDefs();
}

ZHMTypeInfo SDoorsSaveData::TypeInfo = ZHMTypeInfo("SDoorsSaveData", sizeof(SDoorsSaveData), alignof(SDoorsSaveData), SDoorsSaveData::WriteSimpleJson, SDoorsSaveData::FromSimpleJson, SDoorsSaveData::Serialize, SDoorsSaveData::Equals, SDoorsSaveData::Destroy);

void SDoorsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SDoorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDoorsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDoorsSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDoorSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SDoorsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDoorsSaveData, m_aEntities));
	TArray<SDoorSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SDoorsSaveData, m_aData));
}

bool SDoorsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorsSaveData::operator==(const SDoorsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SDoorsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);
	s_Object->~SDoorsSaveData();
}

ZHMTypeInfo SDramaActorSaveState::TypeInfo = ZHMTypeInfo("SDramaActorSaveState", sizeof(SDramaActorSaveState), alignof(SDramaActorSaveState), SDramaActorSaveState::WriteSimpleJson, SDramaActorSaveState::FromSimpleJson, SDramaActorSaveState::Serialize, SDramaActorSaveState::Equals, SDramaActorSaveState::Destroy);

void SDramaActorSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSequence") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSequence);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sMatchName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sMatchName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tActorSpeakEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tActorSpeakEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSpeaking") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSpeaking);

	p_Stream << "}";
}

void SDramaActorSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object->m_rSequence = simdjson::from_json_uint32(p_Document["m_rSequence"]);

	s_Object->m_rBehavior = simdjson::from_json_uint32(p_Document["m_rBehavior"]);

	s_Object->m_rCurrentSpeakEntity = simdjson::from_json_uint32(p_Document["m_rCurrentSpeakEntity"]);

	s_Object->m_rScreenplay = simdjson::from_json_uint32(p_Document["m_rScreenplay"]);

	s_Object->m_sMatchName = std::string_view(p_Document["m_sMatchName"]);

	ZGameTime::FromSimpleJson(p_Document["m_tActorSpeakEnd"], &s_Object->m_tActorSpeakEnd);

	s_Object->m_bIsDone = simdjson::from_json_bool(p_Document["m_bIsDone"]);

	s_Object->m_bIsPaused = simdjson::from_json_bool(p_Document["m_bIsPaused"]);

	s_Object->m_bIsSpeaking = simdjson::from_json_bool(p_Document["m_bIsSpeaking"]);

}

void SDramaActorSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);

	ZString::Serialize(&s_Object->m_sMatchName, p_Serializer, p_OwnOffset + offsetof(SDramaActorSaveState, m_sMatchName));
	ZGameTime::Serialize(&s_Object->m_tActorSpeakEnd, p_Serializer, p_OwnOffset + offsetof(SDramaActorSaveState, m_tActorSpeakEnd));
}

bool SDramaActorSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaActorSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaActorSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaActorSaveState::operator==(const SDramaActorSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaActorSaveState>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rSequence != p_Other.m_rSequence) return false;
	if (m_rBehavior != p_Other.m_rBehavior) return false;
	if (m_rCurrentSpeakEntity != p_Other.m_rCurrentSpeakEntity) return false;
	if (m_rScreenplay != p_Other.m_rScreenplay) return false;
	if (m_sMatchName != p_Other.m_sMatchName) return false;
	if (m_tActorSpeakEnd != p_Other.m_tActorSpeakEnd) return false;
	if (m_bIsDone != p_Other.m_bIsDone) return false;
	if (m_bIsPaused != p_Other.m_bIsPaused) return false;
	if (m_bIsSpeaking != p_Other.m_bIsSpeaking) return false;

	return true;
}

void SDramaActorSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);
	s_Object->~SDramaActorSaveState();
}

ZHMTypeInfo SDramaActorCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaActorCollectionSaveData", sizeof(SDramaActorCollectionSaveData), alignof(SDramaActorCollectionSaveData), SDramaActorCollectionSaveData::WriteSimpleJson, SDramaActorCollectionSaveData::FromSimpleJson, SDramaActorCollectionSaveData::Serialize, SDramaActorCollectionSaveData::Equals, SDramaActorCollectionSaveData::Destroy);

void SDramaActorCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaActorSaveState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaActorCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object->m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDramaActorSaveState::FromSimpleJson(s_Item0, &s_Object->m_aStates[s_Index0]);
		++s_Index0;
	}
	}

}

void SDramaActorCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaActorCollectionSaveData, m_aEntities));
	TArray<SDramaActorSaveState>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaActorCollectionSaveData, m_aStates));
}

bool SDramaActorCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaActorCollectionSaveData::operator==(const SDramaActorCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaActorCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDramaActorCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);
	s_Object->~SDramaActorCollectionSaveData();
}

ZHMTypeInfo ZUIDataProvider::TypeInfo = ZHMTypeInfo("ZUIDataProvider", sizeof(ZUIDataProvider), alignof(ZUIDataProvider), ZUIDataProvider::WriteSimpleJson, ZUIDataProvider::FromSimpleJson, ZUIDataProvider::Serialize, ZUIDataProvider::Equals, ZUIDataProvider::Destroy);

void ZUIDataProvider::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZUIDataProvider::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZUIDataProvider*>(p_Target);

}

void ZUIDataProvider::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);

}

bool ZUIDataProvider::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIDataProvider*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIDataProvider*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIDataProvider::operator==(const ZUIDataProvider& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIDataProvider>)
		return false;


	return true;
}

void ZUIDataProvider::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);
	s_Object->~ZUIDataProvider();
}

ZHMTypeInfo SDramaSetupSaveData::TypeInfo = ZHMTypeInfo("SDramaSetupSaveData", sizeof(SDramaSetupSaveData), alignof(SDramaSetupSaveData), SDramaSetupSaveData::WriteSimpleJson, SDramaSetupSaveData::FromSimpleJson, SDramaSetupSaveData::Serialize, SDramaSetupSaveData::Equals, SDramaSetupSaveData::Destroy);

void SDramaSetupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bDoneTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneTriggered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZScreenplay.EState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);

	p_Stream << "}";
}

void SDramaSetupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Target);

	s_Object->m_bDoneTriggered = simdjson::from_json_bool(p_Document["m_bDoneTriggered"]);

	s_Object->m_eState = static_cast<ZScreenplay::EState>(ZHMEnums::GetEnumValueByName("ZScreenplay.EState", std::string_view(p_Document["m_eState"])));

	s_Object->m_rSituation = simdjson::from_json_uint32(p_Document["m_rSituation"]);

}

void SDramaSetupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);

}

bool SDramaSetupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSetupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSetupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSetupSaveData::operator==(const SDramaSetupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSetupSaveData>)
		return false;

	if (m_bDoneTriggered != p_Other.m_bDoneTriggered) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_rSituation != p_Other.m_rSituation) return false;

	return true;
}

void SDramaSetupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);
	s_Object->~SDramaSetupSaveData();
}

ZHMTypeInfo SDramaSetupCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaSetupCollectionSaveData", sizeof(SDramaSetupCollectionSaveData), alignof(SDramaSetupCollectionSaveData), SDramaSetupCollectionSaveData::WriteSimpleJson, SDramaSetupCollectionSaveData::FromSimpleJson, SDramaSetupCollectionSaveData::Serialize, SDramaSetupCollectionSaveData::Equals, SDramaSetupCollectionSaveData::Destroy);

void SDramaSetupCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaSetupSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaSetupCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object->m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDramaSetupSaveData::FromSimpleJson(s_Item0, &s_Object->m_aStates[s_Index0]);
		++s_Index0;
	}
	}

}

void SDramaSetupCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaSetupCollectionSaveData, m_aEntities));
	TArray<SDramaSetupSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaSetupCollectionSaveData, m_aStates));
}

bool SDramaSetupCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSetupCollectionSaveData::operator==(const SDramaSetupCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSetupCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDramaSetupCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);
	s_Object->~SDramaSetupCollectionSaveData();
}

ZHMTypeInfo SDramaSituationSaveData::TypeInfo = ZHMTypeInfo("SDramaSituationSaveData", sizeof(SDramaSituationSaveData), alignof(SDramaSituationSaveData), SDramaSituationSaveData::WriteSimpleJson, SDramaSituationSaveData::FromSimpleJson, SDramaSituationSaveData::Serialize, SDramaSituationSaveData::Equals, SDramaSituationSaveData::Destroy);

void SDramaSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSituationRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsTerminated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsTerminated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPriorityModifier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPriorityModifier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentDrama") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentDrama);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bProvidersStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bProvidersStarted);

	p_Stream << "}";
}

void SDramaSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Target);

	s_Object->m_bSituationRunning = simdjson::from_json_bool(p_Document["m_bSituationRunning"]);

	s_Object->m_bIsTerminated = simdjson::from_json_bool(p_Document["m_bIsTerminated"]);

	s_Object->m_nPriorityModifier = simdjson::from_json_float32(p_Document["m_nPriorityModifier"]);

	s_Object->m_nCurrentDrama = simdjson::from_json_int32(p_Document["m_nCurrentDrama"]);

	s_Object->m_bProvidersStarted = simdjson::from_json_bool(p_Document["m_bProvidersStarted"]);

}

void SDramaSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);

}

bool SDramaSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSituationSaveData::operator==(const SDramaSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSituationSaveData>)
		return false;

	if (m_bSituationRunning != p_Other.m_bSituationRunning) return false;
	if (m_bIsTerminated != p_Other.m_bIsTerminated) return false;
	if (m_nPriorityModifier != p_Other.m_nPriorityModifier) return false;
	if (m_nCurrentDrama != p_Other.m_nCurrentDrama) return false;
	if (m_bProvidersStarted != p_Other.m_bProvidersStarted) return false;

	return true;
}

void SDramaSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);
	s_Object->~SDramaSituationSaveData();
}

ZHMTypeInfo SDramaSituationCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaSituationCollectionSaveData", sizeof(SDramaSituationCollectionSaveData), alignof(SDramaSituationCollectionSaveData), SDramaSituationCollectionSaveData::WriteSimpleJson, SDramaSituationCollectionSaveData::FromSimpleJson, SDramaSituationCollectionSaveData::Serialize, SDramaSituationCollectionSaveData::Equals, SDramaSituationCollectionSaveData::Destroy);

void SDramaSituationCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaSituationSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaSituationCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object->m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDramaSituationSaveData::FromSimpleJson(s_Item0, &s_Object->m_aStates[s_Index0]);
		++s_Index0;
	}
	}

}

void SDramaSituationCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaSituationCollectionSaveData, m_aEntities));
	TArray<SDramaSituationSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaSituationCollectionSaveData, m_aStates));
}

bool SDramaSituationCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSituationCollectionSaveData::operator==(const SDramaSituationCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSituationCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDramaSituationCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);
	s_Object->~SDramaSituationCollectionSaveData();
}

ZHMTypeInfo SDynamicEnforcerCandidateSaveData::TypeInfo = ZHMTypeInfo("SDynamicEnforcerCandidateSaveData", sizeof(SDynamicEnforcerCandidateSaveData), alignof(SDynamicEnforcerCandidateSaveData), SDynamicEnforcerCandidateSaveData::WriteSimpleJson, SDynamicEnforcerCandidateSaveData::FromSimpleJson, SDynamicEnforcerCandidateSaveData::Serialize, SDynamicEnforcerCandidateSaveData::Equals, SDynamicEnforcerCandidateSaveData::Destroy);

void SDynamicEnforcerCandidateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadius);

	p_Stream << "}";
}

void SDynamicEnforcerCandidateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	float4::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	s_Object->m_eType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eType"])));

	s_Object->m_fRadius = simdjson::from_json_float32(p_Document["m_fRadius"]);

}

void SDynamicEnforcerCandidateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SDynamicEnforcerCandidateSaveData, m_vPosition));
}

bool SDynamicEnforcerCandidateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicEnforcerCandidateSaveData::operator==(const SDynamicEnforcerCandidateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicEnforcerCandidateSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_fRadius != p_Other.m_fRadius) return false;

	return true;
}

void SDynamicEnforcerCandidateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);
	s_Object->~SDynamicEnforcerCandidateSaveData();
}

ZHMTypeInfo SDynamicEnforcerServiceSaveData::TypeInfo = ZHMTypeInfo("SDynamicEnforcerServiceSaveData", sizeof(SDynamicEnforcerServiceSaveData), alignof(SDynamicEnforcerServiceSaveData), SDynamicEnforcerServiceSaveData::WriteSimpleJson, SDynamicEnforcerServiceSaveData::FromSimpleJson, SDynamicEnforcerServiceSaveData::Serialize, SDynamicEnforcerServiceSaveData::Equals, SDynamicEnforcerServiceSaveData::Destroy);

void SDynamicEnforcerServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		SDynamicEnforcerCandidateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDynamicEnforcerServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCandidates"];
	s_Object->m_aCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDynamicEnforcerCandidateSaveData::FromSimpleJson(s_Item0, &s_Object->m_aCandidates[s_Index0]);
		++s_Index0;
	}
	}

}

void SDynamicEnforcerServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);

	TArray<SDynamicEnforcerCandidateSaveData>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SDynamicEnforcerServiceSaveData, m_aCandidates));
}

bool SDynamicEnforcerServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicEnforcerServiceSaveData::operator==(const SDynamicEnforcerServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicEnforcerServiceSaveData>)
		return false;

	if (m_aCandidates != p_Other.m_aCandidates) return false;

	return true;
}

void SDynamicEnforcerServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);
	s_Object->~SDynamicEnforcerServiceSaveData();
}

ZHMTypeInfo SDynamicObjectKeyValuePair::TypeInfo = ZHMTypeInfo("SDynamicObjectKeyValuePair", sizeof(SDynamicObjectKeyValuePair), alignof(SDynamicObjectKeyValuePair), SDynamicObjectKeyValuePair::WriteSimpleJson, SDynamicObjectKeyValuePair::FromSimpleJson, SDynamicObjectKeyValuePair::Serialize, SDynamicObjectKeyValuePair::Equals, SDynamicObjectKeyValuePair::Destroy);

void SDynamicObjectKeyValuePair::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->value, p_Stream);

	p_Stream << "}";
}

void SDynamicObjectKeyValuePair::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Target);

	s_Object->sKey = std::string_view(p_Document["sKey"]);

	ZDynamicObject::FromSimpleJson(p_Document["value"], &s_Object->value);

}

void SDynamicObjectKeyValuePair::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);

	ZString::Serialize(&s_Object->sKey, p_Serializer, p_OwnOffset + offsetof(SDynamicObjectKeyValuePair, sKey));
	ZDynamicObject::Serialize(&s_Object->value, p_Serializer, p_OwnOffset + offsetof(SDynamicObjectKeyValuePair, value));
}

bool SDynamicObjectKeyValuePair::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicObjectKeyValuePair::operator==(const SDynamicObjectKeyValuePair& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicObjectKeyValuePair>)
		return false;

	if (sKey != p_Other.sKey) return false;
	if (value != p_Other.value) return false;

	return true;
}

void SDynamicObjectKeyValuePair::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);
	s_Object->~SDynamicObjectKeyValuePair();
}

ZHMTypeInfo SDynamicRayCastEntitySaveData::TypeInfo = ZHMTypeInfo("SDynamicRayCastEntitySaveData", sizeof(SDynamicRayCastEntitySaveData), alignof(SDynamicRayCastEntitySaveData), SDynamicRayCastEntitySaveData::WriteSimpleJson, SDynamicRayCastEntitySaveData::FromSimpleJson, SDynamicRayCastEntitySaveData::Serialize, SDynamicRayCastEntitySaveData::Equals, SDynamicRayCastEntitySaveData::Destroy);

void SDynamicRayCastEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SDynamicRayCastEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

}

void SDynamicRayCastEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);

}

bool SDynamicRayCastEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicRayCastEntitySaveData::operator==(const SDynamicRayCastEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicRayCastEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SDynamicRayCastEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);
	s_Object->~SDynamicRayCastEntitySaveData();
}

ZHMTypeInfo SEntityPath::TypeInfo = ZHMTypeInfo("SEntityPath", sizeof(SEntityPath), alignof(SEntityPath), SEntityPath::WriteSimpleJson, SEntityPath::FromSimpleJson, SEntityPath::Serialize, SEntityPath::Equals, SEntityPath::Destroy);

void SEntityPath::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nOwnerID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOwnerID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityPath") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityPath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityPath[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityPath.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityPath::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityPath*>(p_Target);

	s_Object->m_nOwnerID = simdjson::from_json_uint64(p_Document["m_nOwnerID"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityPath"];
	s_Object->m_aEntityPath.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntityPath[s_Index0] = simdjson::from_json_uint64(s_Item0);
		++s_Index0;
	}
	}

}

void SEntityPath::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);

	TArray<uint64>::Serialize(&s_Object->m_aEntityPath, p_Serializer, p_OwnOffset + offsetof(SEntityPath, m_aEntityPath));
}

bool SEntityPath::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityPath*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityPath*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityPath::operator==(const SEntityPath& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityPath>)
		return false;

	if (m_nOwnerID != p_Other.m_nOwnerID) return false;
	if (m_aEntityPath != p_Other.m_aEntityPath) return false;

	return true;
}

void SEntityPath::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);
	s_Object->~SEntityPath();
}

ZHMTypeInfo SEntityPinDescriptor::TypeInfo = ZHMTypeInfo("SEntityPinDescriptor", sizeof(SEntityPinDescriptor), alignof(SEntityPinDescriptor), SEntityPinDescriptor::WriteSimpleJson, SEntityPinDescriptor::FromSimpleJson, SEntityPinDescriptor::Serialize, SEntityPinDescriptor::Equals, SEntityPinDescriptor::Destroy);

void SEntityPinDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->type, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsPlaceholder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsPlaceholder);

	p_Stream << "}";
}

void SEntityPinDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Target);

	s_Object->sName = std::string_view(p_Document["sName"]);

	s_Object->sDisplayName = std::string_view(p_Document["sDisplayName"]);

	ZResourceID::FromSimpleJson(p_Document["type"], &s_Object->type);

	s_Object->sHelpText = std::string_view(p_Document["sHelpText"]);

	s_Object->bIsPlaceholder = simdjson::from_json_bool(p_Document["bIsPlaceholder"]);

}

void SEntityPinDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sDisplayName));
	ZResourceID::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, type));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sHelpText));
}

bool SEntityPinDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityPinDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityPinDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityPinDescriptor::operator==(const SEntityPinDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityPinDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (type != p_Other.type) return false;
	if (sHelpText != p_Other.sHelpText) return false;
	if (bIsPlaceholder != p_Other.bIsPlaceholder) return false;

	return true;
}

void SEntityPinDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);
	s_Object->~SEntityPinDescriptor();
}

ZHMTypeInfo SEntityPropertyDescriptor::TypeInfo = ZHMTypeInfo("SEntityPropertyDescriptor", sizeof(SEntityPropertyDescriptor), alignof(SEntityPropertyDescriptor), SEntityPropertyDescriptor::WriteSimpleJson, SEntityPropertyDescriptor::FromSimpleJson, SEntityPropertyDescriptor::Serialize, SEntityPropertyDescriptor::Equals, SEntityPropertyDescriptor::Destroy);

void SEntityPropertyDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPropertyDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->type, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("attributes") << ":";
	TMap<ZString,ZString>::WriteSimpleJson(&s_Object->attributes, p_Stream);

	p_Stream << "}";
}

void SEntityPropertyDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityPropertyDescriptor*>(p_Target);

	s_Object->sName = std::string_view(p_Document["sName"]);

	ZResourceID::FromSimpleJson(p_Document["type"], &s_Object->type);

	TMap<ZString,ZString>::FromSimpleJson(p_Document["attributes"], &s_Object->attributes);

}

void SEntityPropertyDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityPropertyDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SEntityPropertyDescriptor, sName));
	ZResourceID::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(SEntityPropertyDescriptor, type));
	TMap<ZString,ZString>::Serialize(&s_Object->attributes, p_Serializer, p_OwnOffset + offsetof(SEntityPropertyDescriptor, attributes));
}

bool SEntityPropertyDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityPropertyDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityPropertyDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityPropertyDescriptor::operator==(const SEntityPropertyDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityPropertyDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (type != p_Other.type) return false;
	if (attributes != p_Other.attributes) return false;

	return true;
}

void SEntityPropertyDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityPropertyDescriptor*>(p_Object);
	s_Object->~SEntityPropertyDescriptor();
}

ZHMTypeInfo SEntityTemplateEntitySubset::TypeInfo = ZHMTypeInfo("SEntityTemplateEntitySubset", sizeof(SEntityTemplateEntitySubset), alignof(SEntityTemplateEntitySubset), SEntityTemplateEntitySubset::WriteSimpleJson, SEntityTemplateEntitySubset::FromSimpleJson, SEntityTemplateEntitySubset::Serialize, SEntityTemplateEntitySubset::Equals, SEntityTemplateEntitySubset::Destroy);

void SEntityTemplateEntitySubset::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("entities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entities.size(); ++i)
	{
		auto& s_Item0 = s_Object->entities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->entities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityTemplateEntitySubset::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["entities"];
	s_Object->entities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->entities[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

}

void SEntityTemplateEntitySubset::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	TArray<int32>::Serialize(&s_Object->entities, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateEntitySubset, entities));
}

bool SEntityTemplateEntitySubset::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateEntitySubset::operator==(const SEntityTemplateEntitySubset& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateEntitySubset>)
		return false;

	if (entities != p_Other.entities) return false;

	return true;
}

void SEntityTemplateEntitySubset::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);
	s_Object->~SEntityTemplateEntitySubset();
}

ZHMTypeInfo SEntityTemplatePinConnection::TypeInfo = ZHMTypeInfo("SEntityTemplatePinConnection", sizeof(SEntityTemplatePinConnection), alignof(SEntityTemplatePinConnection), SEntityTemplatePinConnection::WriteSimpleJson, SEntityTemplatePinConnection::FromSimpleJson, SEntityTemplatePinConnection::Serialize, SEntityTemplatePinConnection::Equals, SEntityTemplatePinConnection::Destroy);

void SEntityTemplatePinConnection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fromID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fromPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromPinName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toPinName);

	p_Stream << "}";
}

void SEntityTemplatePinConnection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Target);

	s_Object->fromID = simdjson::from_json_int32(p_Document["fromID"]);

	s_Object->toID = simdjson::from_json_int32(p_Document["toID"]);

	s_Object->fromPinName = std::string_view(p_Document["fromPinName"]);

	s_Object->toPinName = std::string_view(p_Document["toPinName"]);

}

void SEntityTemplatePinConnection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	ZString::Serialize(&s_Object->fromPinName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, fromPinName));
	ZString::Serialize(&s_Object->toPinName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, toPinName));
}

bool SEntityTemplatePinConnection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePinConnection*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePinConnection*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePinConnection::operator==(const SEntityTemplatePinConnection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePinConnection>)
		return false;

	if (fromID != p_Other.fromID) return false;
	if (toID != p_Other.toID) return false;
	if (fromPinName != p_Other.fromPinName) return false;
	if (toPinName != p_Other.toPinName) return false;

	return true;
}

void SEntityTemplatePinConnection::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);
	s_Object->~SEntityTemplatePinConnection();
}

ZHMTypeInfo SEntityTemplatePropertyAlias::TypeInfo = ZHMTypeInfo("SEntityTemplatePropertyAlias", sizeof(SEntityTemplatePropertyAlias), alignof(SEntityTemplatePropertyAlias), SEntityTemplatePropertyAlias::WriteSimpleJson, SEntityTemplatePropertyAlias::FromSimpleJson, SEntityTemplatePropertyAlias::Serialize, SEntityTemplatePropertyAlias::Equals, SEntityTemplatePropertyAlias::Destroy);

void SEntityTemplatePropertyAlias::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sAliasName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sAliasName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sPropertyName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sPropertyName);

	p_Stream << "}";
}

void SEntityTemplatePropertyAlias::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Target);

	s_Object->sAliasName = std::string_view(p_Document["sAliasName"]);

	s_Object->entityID = simdjson::from_json_int32(p_Document["entityID"]);

	s_Object->sPropertyName = std::string_view(p_Document["sPropertyName"]);

}

void SEntityTemplatePropertyAlias::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	ZString::Serialize(&s_Object->sAliasName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyAlias, sAliasName));
	ZString::Serialize(&s_Object->sPropertyName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyAlias, sPropertyName));
}

bool SEntityTemplatePropertyAlias::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePropertyAlias::operator==(const SEntityTemplatePropertyAlias& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePropertyAlias>)
		return false;

	if (sAliasName != p_Other.sAliasName) return false;
	if (entityID != p_Other.entityID) return false;
	if (sPropertyName != p_Other.sPropertyName) return false;

	return true;
}

void SEntityTemplatePropertyAlias::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);
	s_Object->~SEntityTemplatePropertyAlias();
}

ZHMTypeInfo SEntityTemplateReference::TypeInfo = ZHMTypeInfo("SEntityTemplateReference", sizeof(SEntityTemplateReference), alignof(SEntityTemplateReference), SEntityTemplateReference::WriteSimpleJson, SEntityTemplateReference::FromSimpleJson, SEntityTemplateReference::Serialize, SEntityTemplateReference::Equals, SEntityTemplateReference::Destroy);

void SEntityTemplateReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->externalSceneIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->exposedEntity);

	p_Stream << "}";
}

void SEntityTemplateReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Target);

	s_Object->entityID = simdjson::from_json_uint64(p_Document["entityID"]);

	s_Object->externalSceneIndex = simdjson::from_json_int32(p_Document["externalSceneIndex"]);

	s_Object->entityIndex = simdjson::from_json_int32(p_Document["entityIndex"]);

	s_Object->exposedEntity = std::string_view(p_Document["exposedEntity"]);

}

void SEntityTemplateReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	ZString::Serialize(&s_Object->exposedEntity, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateReference, exposedEntity));
}

bool SEntityTemplateReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateReference*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateReference::operator==(const SEntityTemplateReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateReference>)
		return false;

	if (entityID != p_Other.entityID) return false;
	if (externalSceneIndex != p_Other.externalSceneIndex) return false;
	if (entityIndex != p_Other.entityIndex) return false;
	if (exposedEntity != p_Other.exposedEntity) return false;

	return true;
}

void SEntityTemplateReference::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);
	s_Object->~SEntityTemplateReference();
}

ZHMTypeInfo SEntityTemplatePropertyOverride::TypeInfo = ZHMTypeInfo("SEntityTemplatePropertyOverride", sizeof(SEntityTemplatePropertyOverride), alignof(SEntityTemplatePropertyOverride), SEntityTemplatePropertyOverride::WriteSimpleJson, SEntityTemplatePropertyOverride::FromSimpleJson, SEntityTemplatePropertyOverride::Serialize, SEntityTemplatePropertyOverride::Equals, SEntityTemplatePropertyOverride::Destroy);

void SEntityTemplatePropertyOverride::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("propertyOwner") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->propertyOwner, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValue") << ":";
	SEntityTemplateProperty::WriteSimpleJson(&s_Object->propertyValue, p_Stream);

	p_Stream << "}";
}

void SEntityTemplatePropertyOverride::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Target);

	SEntityTemplateReference::FromSimpleJson(p_Document["propertyOwner"], &s_Object->propertyOwner);

	SEntityTemplateProperty::FromSimpleJson(p_Document["propertyValue"], &s_Object->propertyValue);

}

void SEntityTemplatePropertyOverride::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->propertyOwner, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyOverride, propertyOwner));
	SEntityTemplateProperty::Serialize(&s_Object->propertyValue, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyOverride, propertyValue));
}

bool SEntityTemplatePropertyOverride::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePropertyOverride::operator==(const SEntityTemplatePropertyOverride& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePropertyOverride>)
		return false;

	if (propertyOwner != p_Other.propertyOwner) return false;
	if (propertyValue != p_Other.propertyValue) return false;

	return true;
}

void SEntityTemplatePropertyOverride::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);
	s_Object->~SEntityTemplatePropertyOverride();
}

ZHMTypeInfo SExposedEntityDescriptor::TypeInfo = ZHMTypeInfo("SExposedEntityDescriptor", sizeof(SExposedEntityDescriptor), alignof(SExposedEntityDescriptor), SExposedEntityDescriptor::WriteSimpleJson, SExposedEntityDescriptor::FromSimpleJson, SExposedEntityDescriptor::Serialize, SExposedEntityDescriptor::Equals, SExposedEntityDescriptor::Destroy);

void SExposedEntityDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sUpheldContract") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sUpheldContract);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);

	p_Stream << "}";
}

void SExposedEntityDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Target);

	s_Object->sName = std::string_view(p_Document["sName"]);

	s_Object->sDisplayName = std::string_view(p_Document["sDisplayName"]);

	s_Object->sUpheldContract = std::string_view(p_Document["sUpheldContract"]);

	s_Object->sHelpText = std::string_view(p_Document["sHelpText"]);

}

void SExposedEntityDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sDisplayName));
	ZString::Serialize(&s_Object->sUpheldContract, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sUpheldContract));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sHelpText));
}

bool SExposedEntityDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExposedEntityDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SExposedEntityDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExposedEntityDescriptor::operator==(const SExposedEntityDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExposedEntityDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (sUpheldContract != p_Other.sUpheldContract) return false;
	if (sHelpText != p_Other.sHelpText) return false;

	return true;
}

void SExposedEntityDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);
	s_Object->~SExposedEntityDescriptor();
}

ZHMTypeInfo SEntityTypeDescriptor::TypeInfo = ZHMTypeInfo("SEntityTypeDescriptor", sizeof(SEntityTypeDescriptor), alignof(SEntityTypeDescriptor), SEntityTypeDescriptor::WriteSimpleJson, SEntityTypeDescriptor::FromSimpleJson, SEntityTypeDescriptor::Serialize, SEntityTypeDescriptor::Equals, SEntityTypeDescriptor::Destroy);

void SEntityTypeDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTypeDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("typeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->typeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("attributeOverrides") << ":";
	TMultiMap<ZString,ZString>::WriteSimpleJson(&s_Object->attributeOverrides, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("typeSourceTemplate") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->typeSourceTemplate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("runtimeType") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->runtimeType, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("runtimeBlueprint") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->runtimeBlueprint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("supportedTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->supportedTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->supportedTypes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->supportedTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("properties") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->properties.size(); ++i)
	{
		auto& s_Item0 = s_Object->properties[i];
		SEntityPropertyDescriptor::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->properties.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inputPins") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->inputPins.size(); ++i)
	{
		auto& s_Item0 = s_Object->inputPins[i];
		SEntityPinDescriptor::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->inputPins.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("outputPins") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->outputPins.size(); ++i)
	{
		auto& s_Item0 = s_Object->outputPins[i];
		SEntityPinDescriptor::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->outputPins.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedEntities[i];
		SExposedEntityDescriptor::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("referencedEntityTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->referencedEntityTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->referencedEntityTypes[i];
		ZResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->referencedEntityTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityTypeDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEntityTypeDescriptor*>(p_Target);

	s_Object->typeName = std::string_view(p_Document["typeName"]);

	TMultiMap<ZString,ZString>::FromSimpleJson(p_Document["attributeOverrides"], &s_Object->attributeOverrides);

	ZResourceID::FromSimpleJson(p_Document["typeSourceTemplate"], &s_Object->typeSourceTemplate);

	ZResourceID::FromSimpleJson(p_Document["runtimeType"], &s_Object->runtimeType);

	ZResourceID::FromSimpleJson(p_Document["runtimeBlueprint"], &s_Object->runtimeBlueprint);

	{
	simdjson::ondemand::array s_Array0 = p_Document["supportedTypes"];
	s_Object->supportedTypes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->supportedTypes[s_Index0] = std::string_view(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["properties"];
	s_Object->properties.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityPropertyDescriptor::FromSimpleJson(s_Item0, &s_Object->properties[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["inputPins"];
	s_Object->inputPins.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityPinDescriptor::FromSimpleJson(s_Item0, &s_Object->inputPins[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["outputPins"];
	s_Object->outputPins.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityPinDescriptor::FromSimpleJson(s_Item0, &s_Object->outputPins[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["exposedEntities"];
	s_Object->exposedEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SExposedEntityDescriptor::FromSimpleJson(s_Item0, &s_Object->exposedEntities[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["referencedEntityTypes"];
	s_Object->referencedEntityTypes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZResourceID::FromSimpleJson(s_Item0, &s_Object->referencedEntityTypes[s_Index0]);
		++s_Index0;
	}
	}

}

void SEntityTypeDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTypeDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->typeName, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, typeName));
	TMultiMap<ZString,ZString>::Serialize(&s_Object->attributeOverrides, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, attributeOverrides));
	ZResourceID::Serialize(&s_Object->typeSourceTemplate, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, typeSourceTemplate));
	ZResourceID::Serialize(&s_Object->runtimeType, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, runtimeType));
	ZResourceID::Serialize(&s_Object->runtimeBlueprint, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, runtimeBlueprint));
	TArray<ZString>::Serialize(&s_Object->supportedTypes, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, supportedTypes));
	TArray<SEntityPropertyDescriptor>::Serialize(&s_Object->properties, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, properties));
	TArray<SEntityPinDescriptor>::Serialize(&s_Object->inputPins, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, inputPins));
	TArray<SEntityPinDescriptor>::Serialize(&s_Object->outputPins, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, outputPins));
	TArray<SExposedEntityDescriptor>::Serialize(&s_Object->exposedEntities, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, exposedEntities));
	TArray<ZResourceID>::Serialize(&s_Object->referencedEntityTypes, p_Serializer, p_OwnOffset + offsetof(SEntityTypeDescriptor, referencedEntityTypes));
}

bool SEntityTypeDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTypeDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTypeDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTypeDescriptor::operator==(const SEntityTypeDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTypeDescriptor>)
		return false;

	if (typeName != p_Other.typeName) return false;
	if (attributeOverrides != p_Other.attributeOverrides) return false;
	if (typeSourceTemplate != p_Other.typeSourceTemplate) return false;
	if (runtimeType != p_Other.runtimeType) return false;
	if (runtimeBlueprint != p_Other.runtimeBlueprint) return false;
	if (supportedTypes != p_Other.supportedTypes) return false;
	if (properties != p_Other.properties) return false;
	if (inputPins != p_Other.inputPins) return false;
	if (outputPins != p_Other.outputPins) return false;
	if (exposedEntities != p_Other.exposedEntities) return false;
	if (referencedEntityTypes != p_Other.referencedEntityTypes) return false;

	return true;
}

void SEntityTypeDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTypeDescriptor*>(p_Object);
	s_Object->~SEntityTypeDescriptor();
}

ZHMTypeInfo SEnvironmentConfigResourceEntry::TypeInfo = ZHMTypeInfo("SEnvironmentConfigResourceEntry", sizeof(SEnvironmentConfigResourceEntry), alignof(SEnvironmentConfigResourceEntry), SEnvironmentConfigResourceEntry::WriteSimpleJson, SEnvironmentConfigResourceEntry::FromSimpleJson, SEnvironmentConfigResourceEntry::Serialize, SEnvironmentConfigResourceEntry::Equals, SEnvironmentConfigResourceEntry::Destroy);

void SEnvironmentConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Name") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Name);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ContractsDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->ContractsDatastoreRid, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("UnlockablesDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->UnlockablesDatastoreRid, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("BlobsDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->BlobsDatastoreRid, p_Stream);

	p_Stream << "}";
}

void SEnvironmentConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Target);

	s_Object->Name = std::string_view(p_Document["Name"]);

	ZResourceID::FromSimpleJson(p_Document["ContractsDatastoreRid"], &s_Object->ContractsDatastoreRid);

	ZResourceID::FromSimpleJson(p_Document["UnlockablesDatastoreRid"], &s_Object->UnlockablesDatastoreRid);

	ZResourceID::FromSimpleJson(p_Document["BlobsDatastoreRid"], &s_Object->BlobsDatastoreRid);

}

void SEnvironmentConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Name, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, Name));
	ZResourceID::Serialize(&s_Object->ContractsDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, ContractsDatastoreRid));
	ZResourceID::Serialize(&s_Object->UnlockablesDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, UnlockablesDatastoreRid));
	ZResourceID::Serialize(&s_Object->BlobsDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, BlobsDatastoreRid));
}

bool SEnvironmentConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEnvironmentConfigResourceEntry::operator==(const SEnvironmentConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEnvironmentConfigResourceEntry>)
		return false;

	if (Name != p_Other.Name) return false;
	if (ContractsDatastoreRid != p_Other.ContractsDatastoreRid) return false;
	if (UnlockablesDatastoreRid != p_Other.UnlockablesDatastoreRid) return false;
	if (BlobsDatastoreRid != p_Other.BlobsDatastoreRid) return false;

	return true;
}

void SEnvironmentConfigResourceEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);
	s_Object->~SEnvironmentConfigResourceEntry();
}

ZHMTypeInfo SEnvironmentConfigResource::TypeInfo = ZHMTypeInfo("SEnvironmentConfigResource", sizeof(SEnvironmentConfigResource), alignof(SEnvironmentConfigResource), SEnvironmentConfigResource::WriteSimpleJson, SEnvironmentConfigResource::FromSimpleJson, SEnvironmentConfigResource::Serialize, SEnvironmentConfigResource::Equals, SEnvironmentConfigResource::Destroy);

void SEnvironmentConfigResource::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Environments") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Environments.size(); ++i)
	{
		auto& s_Item0 = s_Object->Environments[i];
		SEnvironmentConfigResourceEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->Environments.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEnvironmentConfigResource::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["Environments"];
	s_Object->Environments.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEnvironmentConfigResourceEntry::FromSimpleJson(s_Item0, &s_Object->Environments[s_Index0]);
		++s_Index0;
	}
	}

}

void SEnvironmentConfigResource::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);

	TArray<SEnvironmentConfigResourceEntry>::Serialize(&s_Object->Environments, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResource, Environments));
}

bool SEnvironmentConfigResource::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEnvironmentConfigResource*>(p_Left);
	auto* s_Right = reinterpret_cast<SEnvironmentConfigResource*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEnvironmentConfigResource::operator==(const SEnvironmentConfigResource& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEnvironmentConfigResource>)
		return false;

	if (Environments != p_Other.Environments) return false;

	return true;
}

void SEnvironmentConfigResource::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);
	s_Object->~SEnvironmentConfigResource();
}

ZHMTypeInfo SEscortOutBehaviorSaveData::TypeInfo = ZHMTypeInfo("SEscortOutBehaviorSaveData", sizeof(SEscortOutBehaviorSaveData), alignof(SEscortOutBehaviorSaveData), SEscortOutBehaviorSaveData::WriteSimpleJson, SEscortOutBehaviorSaveData::FromSimpleJson, SEscortOutBehaviorSaveData::Serialize, SEscortOutBehaviorSaveData::Equals, SEscortOutBehaviorSaveData::Destroy);

void SEscortOutBehaviorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bConversationHelperPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bConversationHelperPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsm") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsm, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vExitPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vExitPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWarningTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWarningTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHardWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHardWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEscortStateSilenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEscortStateSilenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitHitmanToComplyWarningTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitHitmanToComplyWarningTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitHitmanToComplyStateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitHitmanToComplyStateTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastLookBack") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastLookBack, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReachedExitPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReachedExitPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowExitWarningEnded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowExitWarningEnded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bJustShowExit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bJustShowExit);

	p_Stream << "}";
}

void SEscortOutBehaviorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Target);

	s_Object->m_nSituation = simdjson::from_json_int32(p_Document["m_nSituation"]);

	s_Object->m_bConversationHelperPaused = simdjson::from_json_bool(p_Document["m_bConversationHelperPaused"]);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsm"], &s_Object->m_fsm);

	float4::FromSimpleJson(p_Document["m_vExitPosition"], &s_Object->m_vExitPosition);

	ZGameTime::FromSimpleJson(p_Document["m_tWarningTime"], &s_Object->m_tWarningTime);

	s_Object->m_bHardWarning = simdjson::from_json_bool(p_Document["m_bHardWarning"]);

	s_Object->m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	ZGameTime::FromSimpleJson(p_Document["m_tEscortStateSilenceTime"], &s_Object->m_tEscortStateSilenceTime);

	ZGameTime::FromSimpleJson(p_Document["m_tWaitHitmanToComplyWarningTime"], &s_Object->m_tWaitHitmanToComplyWarningTime);

	ZGameTime::FromSimpleJson(p_Document["m_tWaitHitmanToComplyStateTime"], &s_Object->m_tWaitHitmanToComplyStateTime);

	ZGameTime::FromSimpleJson(p_Document["m_tLastLookBack"], &s_Object->m_tLastLookBack);

	s_Object->m_bReachedExitPosition = simdjson::from_json_bool(p_Document["m_bReachedExitPosition"]);

	s_Object->m_bShowExitWarningEnded = simdjson::from_json_bool(p_Document["m_bShowExitWarningEnded"]);

	s_Object->m_bJustShowExit = simdjson::from_json_bool(p_Document["m_bJustShowExit"]);

}

void SEscortOutBehaviorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsm, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_fsm));
	float4::Serialize(&s_Object->m_vExitPosition, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_vExitPosition));
	ZGameTime::Serialize(&s_Object->m_tWarningTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWarningTime));
	ZGameTime::Serialize(&s_Object->m_tEscortStateSilenceTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tEscortStateSilenceTime));
	ZGameTime::Serialize(&s_Object->m_tWaitHitmanToComplyWarningTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWaitHitmanToComplyWarningTime));
	ZGameTime::Serialize(&s_Object->m_tWaitHitmanToComplyStateTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWaitHitmanToComplyStateTime));
	ZGameTime::Serialize(&s_Object->m_tLastLookBack, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tLastLookBack));
}

bool SEscortOutBehaviorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortOutBehaviorSaveData::operator==(const SEscortOutBehaviorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortOutBehaviorSaveData>)
		return false;

	if (m_nSituation != p_Other.m_nSituation) return false;
	if (m_bConversationHelperPaused != p_Other.m_bConversationHelperPaused) return false;
	if (m_fsm != p_Other.m_fsm) return false;
	if (m_vExitPosition != p_Other.m_vExitPosition) return false;
	if (m_tWarningTime != p_Other.m_tWarningTime) return false;
	if (m_bHardWarning != p_Other.m_bHardWarning) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_tEscortStateSilenceTime != p_Other.m_tEscortStateSilenceTime) return false;
	if (m_tWaitHitmanToComplyWarningTime != p_Other.m_tWaitHitmanToComplyWarningTime) return false;
	if (m_tWaitHitmanToComplyStateTime != p_Other.m_tWaitHitmanToComplyStateTime) return false;
	if (m_tLastLookBack != p_Other.m_tLastLookBack) return false;
	if (m_bReachedExitPosition != p_Other.m_bReachedExitPosition) return false;
	if (m_bShowExitWarningEnded != p_Other.m_bShowExitWarningEnded) return false;
	if (m_bJustShowExit != p_Other.m_bJustShowExit) return false;

	return true;
}

void SEscortOutBehaviorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);
	s_Object->~SEscortOutBehaviorSaveData();
}

ZHMTypeInfo SEscortOutOrderSaveData::TypeInfo = ZHMTypeInfo("SEscortOutOrderSaveData", sizeof(SEscortOutOrderSaveData), alignof(SEscortOutOrderSaveData), SEscortOutOrderSaveData::WriteSimpleJson, SEscortOutOrderSaveData::FromSimpleJson, SEscortOutOrderSaveData::Serialize, SEscortOutOrderSaveData::Equals, SEscortOutOrderSaveData::Destroy);

void SEscortOutOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aExitPoints") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aExitPoints.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aExitPoints[i];
		float4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aExitPoints.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEscortOutOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aExitPoints"];
	s_Object->m_aExitPoints.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		float4::FromSimpleJson(s_Item0, &s_Object->m_aExitPoints[s_Index0]);
		++s_Index0;
	}
	}

}

void SEscortOutOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);

	TArray<float4>::Serialize(&s_Object->m_aExitPoints, p_Serializer, p_OwnOffset + offsetof(SEscortOutOrderSaveData, m_aExitPoints));
}

bool SEscortOutOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortOutOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortOutOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortOutOrderSaveData::operator==(const SEscortOutOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortOutOrderSaveData>)
		return false;

	if (m_aExitPoints != p_Other.m_aExitPoints) return false;

	return true;
}

void SEscortOutOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);
	s_Object->~SEscortOutOrderSaveData();
}

ZHMTypeInfo SEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SEscortSituationActorStateSaveData", sizeof(SEscortSituationActorStateSaveData), alignof(SEscortSituationActorStateSaveData), SEscortSituationActorStateSaveData::WriteSimpleJson, SEscortSituationActorStateSaveData::FromSimpleJson, SEscortSituationActorStateSaveData::Serialize, SEscortSituationActorStateSaveData::Equals, SEscortSituationActorStateSaveData::Destroy);

void SEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Target);

	s_Object->m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object->m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object->m_eState = static_cast<ZEscortSituationEntity::EEscortState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object->m_eStatePrevious = static_cast<ZEscortSituationEntity::EEscortState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object->m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object->m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object->m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

}

void SEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);

}

bool SEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationActorStateSaveData::operator==(const SEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

void SEscortSituationActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);
	s_Object->~SEscortSituationActorStateSaveData();
}

ZHMTypeInfo SEscortSituationActors::TypeInfo = ZHMTypeInfo("SEscortSituationActors", sizeof(SEscortSituationActors), alignof(SEscortSituationActors), SEscortSituationActors::WriteSimpleJson, SEscortSituationActors::FromSimpleJson, SEscortSituationActors::Serialize, SEscortSituationActors::Equals, SEscortSituationActors::Destroy);

void SEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEscortSituationActors*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);

}

bool SEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationActors::operator==(const SEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SEscortSituationActors::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);
	s_Object->~SEscortSituationActors();
}

ZHMTypeInfo SEscortSituationSaveData::TypeInfo = ZHMTypeInfo("SEscortSituationSaveData", sizeof(SEscortSituationSaveData), alignof(SEscortSituationSaveData), SEscortSituationSaveData::WriteSimpleJson, SEscortSituationSaveData::FromSimpleJson, SEscortSituationSaveData::Serialize, SEscortSituationSaveData::Equals, SEscortSituationSaveData::Destroy);

void SEscortSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceSearch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceSearch);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFoundDeadTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFoundDeadTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetDeadTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetDeadTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SEscortSituationActors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SEscortSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSearchActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSearchActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSearchActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSearchActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEscortSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Target);

	s_Object->m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object->m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object->m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object->m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object->m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	s_Object->m_bForceSearch = simdjson::from_json_bool(p_Document["m_bForceSearch"]);

	SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Object->m_vLastPosition);

	s_Object->m_bFoundDeadTarget = simdjson::from_json_bool(p_Document["m_bFoundDeadTarget"]);

	s_Object->m_nTargetDeadTime = simdjson::from_json_int64(p_Document["m_nTargetDeadTime"]);

	s_Object->m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object->m_eTargetState = static_cast<ZEscortSituationEntity::ETargetState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object->m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object->m_eTargetActState = static_cast<ZActBehaviorEntity::EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object->m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object->m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAddedActors"];
	s_Object->m_aAddedActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEscortSituationActors::FromSimpleJson(s_Item0, &s_Object->m_aAddedActors[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object->m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEscortSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_Object->m_aStates[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEscortActs"];
	s_Object->m_aEscortActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEscortActs[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSearchActs"];
	s_Object->m_aSearchActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aSearchActs[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SEscortSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_vLastPosition));
	TArray<SEscortSituationActors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aAddedActors));
	TArray<SEscortSituationActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aEscortActs));
	TArray<uint32>::Serialize(&s_Object->m_aSearchActs, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aSearchActs));
}

bool SEscortSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationSaveData::operator==(const SEscortSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationSaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_bForceSearch != p_Other.m_bForceSearch) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bFoundDeadTarget != p_Other.m_bFoundDeadTarget) return false;
	if (m_nTargetDeadTime != p_Other.m_nTargetDeadTime) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;
	if (m_aSearchActs != p_Other.m_aSearchActs) return false;

	return true;
}

void SEscortSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);
	s_Object->~SEscortSituationSaveData();
}

ZHMTypeInfo SEvacuateSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SEvacuateSituationMemberSaveData", sizeof(SEvacuateSituationMemberSaveData), alignof(SEvacuateSituationMemberSaveData), SEvacuateSituationMemberSaveData::WriteSimpleJson, SEvacuateSituationMemberSaveData::FromSimpleJson, SEvacuateSituationMemberSaveData::Serialize, SEvacuateSituationMemberSaveData::Equals, SEvacuateSituationMemberSaveData::Destroy);

void SEvacuateSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pGuardDutyPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuardDutyPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointSubIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointSubIndex);

	p_Stream << "}";
}

void SEvacuateSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Target);

	s_Object->m_pGuardDutyPoint = simdjson::from_json_uint32(p_Document["m_pGuardDutyPoint"]);

	s_Object->m_nPatrolWaypointIndex = simdjson::from_json_int32(p_Document["m_nPatrolWaypointIndex"]);

	s_Object->m_nPatrolWaypointSubIndex = simdjson::from_json_uint32(p_Document["m_nPatrolWaypointSubIndex"]);

}

void SEvacuateSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);

}

bool SEvacuateSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateSituationMemberSaveData::operator==(const SEvacuateSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateSituationMemberSaveData>)
		return false;

	if (m_pGuardDutyPoint != p_Other.m_pGuardDutyPoint) return false;
	if (m_nPatrolWaypointIndex != p_Other.m_nPatrolWaypointIndex) return false;
	if (m_nPatrolWaypointSubIndex != p_Other.m_nPatrolWaypointSubIndex) return false;

	return true;
}

void SEvacuateSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);
	s_Object->~SEvacuateSituationMemberSaveData();
}

ZHMTypeInfo SEvacuateSituationSaveData::TypeInfo = ZHMTypeInfo("SEvacuateSituationSaveData", sizeof(SEvacuateSituationSaveData), alignof(SEvacuateSituationSaveData), SEvacuateSituationSaveData::WriteSimpleJson, SEvacuateSituationSaveData::FromSimpleJson, SEvacuateSituationSaveData::Serialize, SEvacuateSituationSaveData::Equals, SEvacuateSituationSaveData::Destroy);

void SEvacuateSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSeriousSituation") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSeriousSituation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastThreat") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastThreat, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tresspassGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_tresspassGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_evacuateGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_evacuateGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_evacuateGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_evacuateGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_activeSafeRooms") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_activeSafeRooms.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_activeSafeRooms[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_activeSafeRooms.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEvacuateSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	ZGameTime::FromSimpleJson(p_Document["m_tLastSeriousSituation"], &s_Object->m_tLastSeriousSituation);

	ZGameTime::FromSimpleJson(p_Document["m_tLastThreat"], &s_Object->m_tLastThreat);

	s_Object->m_tresspassGroup = simdjson::from_json_int32(p_Document["m_tresspassGroup"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_evacuateGroups"];
	s_Object->m_evacuateGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_evacuateGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_activeSafeRooms"];
	s_Object->m_activeSafeRooms.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_activeSafeRooms[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SEvacuateSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tLastSeriousSituation, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_tLastSeriousSituation));
	ZGameTime::Serialize(&s_Object->m_tLastThreat, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_tLastThreat));
	TArray<int32>::Serialize(&s_Object->m_evacuateGroups, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_evacuateGroups));
	TArray<uint32>::Serialize(&s_Object->m_activeSafeRooms, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_activeSafeRooms));
}

bool SEvacuateSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateSituationSaveData::operator==(const SEvacuateSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateSituationSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tLastSeriousSituation != p_Other.m_tLastSeriousSituation) return false;
	if (m_tLastThreat != p_Other.m_tLastThreat) return false;
	if (m_tresspassGroup != p_Other.m_tresspassGroup) return false;
	if (m_evacuateGroups != p_Other.m_evacuateGroups) return false;
	if (m_activeSafeRooms != p_Other.m_activeSafeRooms) return false;

	return true;
}

void SEvacuateSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);
	s_Object->~SEvacuateSituationSaveData();
}

ZHMTypeInfo SEvacuateTrespassGroupSaveData::TypeInfo = ZHMTypeInfo("SEvacuateTrespassGroupSaveData", sizeof(SEvacuateTrespassGroupSaveData), alignof(SEvacuateTrespassGroupSaveData), SEvacuateTrespassGroupSaveData::WriteSimpleJson, SEvacuateTrespassGroupSaveData::FromSimpleJson, SEvacuateTrespassGroupSaveData::Serialize, SEvacuateTrespassGroupSaveData::Equals, SEvacuateTrespassGroupSaveData::Destroy);

void SEvacuateTrespassGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_safeRoomNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_safeRoomNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_leader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_leader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_assistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_escalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_escalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_completed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_completed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_standDown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_standDown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_warningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_warningCount);

	p_Stream << "}";
}

void SEvacuateTrespassGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object->m_safeRoomNode = simdjson::from_json_uint32(p_Document["m_safeRoomNode"]);

	s_Object->m_leader = simdjson::from_json_uint32(p_Document["m_leader"]);

	s_Object->m_assistant = simdjson::from_json_uint32(p_Document["m_assistant"]);

	s_Object->m_escalate = simdjson::from_json_bool(p_Document["m_escalate"]);

	s_Object->m_completed = simdjson::from_json_bool(p_Document["m_completed"]);

	s_Object->m_standDown = simdjson::from_json_bool(p_Document["m_standDown"]);

	s_Object->m_warningCount = simdjson::from_json_int32(p_Document["m_warningCount"]);

}

void SEvacuateTrespassGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateTrespassGroupSaveData, m_fsmState));
}

bool SEvacuateTrespassGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateTrespassGroupSaveData::operator==(const SEvacuateTrespassGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateTrespassGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_safeRoomNode != p_Other.m_safeRoomNode) return false;
	if (m_leader != p_Other.m_leader) return false;
	if (m_assistant != p_Other.m_assistant) return false;
	if (m_escalate != p_Other.m_escalate) return false;
	if (m_completed != p_Other.m_completed) return false;
	if (m_standDown != p_Other.m_standDown) return false;
	if (m_warningCount != p_Other.m_warningCount) return false;

	return true;
}

void SEvacuateTrespassGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);
	s_Object->~SEvacuateTrespassGroupSaveData();
}

ZHMTypeInfo SEvacuateVIPGroupSaveData::TypeInfo = ZHMTypeInfo("SEvacuateVIPGroupSaveData", sizeof(SEvacuateVIPGroupSaveData), alignof(SEvacuateVIPGroupSaveData), SEvacuateVIPGroupSaveData::WriteSimpleJson, SEvacuateVIPGroupSaveData::FromSimpleJson, SEvacuateVIPGroupSaveData::Serialize, SEvacuateVIPGroupSaveData::Equals, SEvacuateVIPGroupSaveData::Destroy);

void SEvacuateVIPGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIP") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIP);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIPActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIPActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEvacuationNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEvacuationNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSafeRoomNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSafeRoomNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCompromisedEvacNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCompromisedEvacNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assignedBodyguards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_assignedBodyguards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_assignedBodyguards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_assignedBodyguards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEvacuationStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEvacuationStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tCornered") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tCornered, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSafeRoom") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tSafeRoom, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSafeRoomStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tSafeRoomStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInitialFlee") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInitialFlee);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_safeRoomVIPSentActingStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_safeRoomVIPSentActingStarted);

	p_Stream << "}";
}

void SEvacuateVIPGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_rVIP = simdjson::from_json_uint32(p_Document["m_rVIP"]);

	s_Object->m_rVIPActor = simdjson::from_json_uint32(p_Document["m_rVIPActor"]);

	s_Object->m_rEvacuationNode = simdjson::from_json_uint32(p_Document["m_rEvacuationNode"]);

	s_Object->m_rSafeRoomNode = simdjson::from_json_uint32(p_Document["m_rSafeRoomNode"]);

	s_Object->m_rCompromisedEvacNode = simdjson::from_json_uint32(p_Document["m_rCompromisedEvacNode"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_assignedBodyguards"];
	s_Object->m_assignedBodyguards.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_assignedBodyguards[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	ZGameTime::FromSimpleJson(p_Document["m_tEvacuationStart"], &s_Object->m_tEvacuationStart);

	ZGameTime::FromSimpleJson(p_Document["m_tCornered"], &s_Object->m_tCornered);

	ZGameTime::FromSimpleJson(p_Document["m_tSafeRoom"], &s_Object->m_tSafeRoom);

	ZGameTime::FromSimpleJson(p_Document["m_tSafeRoomStandDown"], &s_Object->m_tSafeRoomStandDown);

	s_Object->m_bInitialFlee = simdjson::from_json_bool(p_Document["m_bInitialFlee"]);

	s_Object->m_safeRoomVIPSentActingStarted = simdjson::from_json_bool(p_Document["m_safeRoomVIPSentActingStarted"]);

}

void SEvacuateVIPGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_fsmState));
	TArray<uint32>::Serialize(&s_Object->m_assignedBodyguards, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_assignedBodyguards));
	ZGameTime::Serialize(&s_Object->m_tEvacuationStart, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tEvacuationStart));
	ZGameTime::Serialize(&s_Object->m_tCornered, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tCornered));
	ZGameTime::Serialize(&s_Object->m_tSafeRoom, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tSafeRoom));
	ZGameTime::Serialize(&s_Object->m_tSafeRoomStandDown, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tSafeRoomStandDown));
}

bool SEvacuateVIPGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateVIPGroupSaveData::operator==(const SEvacuateVIPGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateVIPGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rVIP != p_Other.m_rVIP) return false;
	if (m_rVIPActor != p_Other.m_rVIPActor) return false;
	if (m_rEvacuationNode != p_Other.m_rEvacuationNode) return false;
	if (m_rSafeRoomNode != p_Other.m_rSafeRoomNode) return false;
	if (m_rCompromisedEvacNode != p_Other.m_rCompromisedEvacNode) return false;
	if (m_assignedBodyguards != p_Other.m_assignedBodyguards) return false;
	if (m_tEvacuationStart != p_Other.m_tEvacuationStart) return false;
	if (m_tCornered != p_Other.m_tCornered) return false;
	if (m_tSafeRoom != p_Other.m_tSafeRoom) return false;
	if (m_tSafeRoomStandDown != p_Other.m_tSafeRoomStandDown) return false;
	if (m_bInitialFlee != p_Other.m_bInitialFlee) return false;
	if (m_safeRoomVIPSentActingStarted != p_Other.m_safeRoomVIPSentActingStarted) return false;

	return true;
}

void SEvacuateVIPGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);
	s_Object->~SEvacuateVIPGroupSaveData();
}

ZHMTypeInfo SEventChannelSaveData::TypeInfo = ZHMTypeInfo("SEventChannelSaveData", sizeof(SEventChannelSaveData), alignof(SEventChannelSaveData), SEventChannelSaveData::WriteSimpleJson, SEventChannelSaveData::FromSimpleJson, SEventChannelSaveData::Serialize, SEventChannelSaveData::Equals, SEventChannelSaveData::Destroy);

void SEventChannelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SEventChannelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

}

void SEventChannelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);

}

bool SEventChannelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventChannelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventChannelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventChannelSaveData::operator==(const SEventChannelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventChannelSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SEventChannelSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);
	s_Object->~SEventChannelSaveData();
}

ZHMTypeInfo SExitSaveData::TypeInfo = ZHMTypeInfo("SExitSaveData", sizeof(SExitSaveData), alignof(SExitSaveData), SExitSaveData::WriteSimpleJson, SExitSaveData::FromSimpleJson, SExitSaveData::Serialize, SExitSaveData::Equals, SExitSaveData::Destroy);

void SExitSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SExitSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SExitSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

}

void SExitSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);

}

bool SExitSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExitSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SExitSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExitSaveData::operator==(const SExitSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExitSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SExitSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);
	s_Object->~SExitSaveData();
}

ZHMTypeInfo SFRange::TypeInfo = ZHMTypeInfo("SFRange", sizeof(SFRange), alignof(SFRange), SFRange::WriteSimpleJson, SFRange::FromSimpleJson, SFRange::Serialize, SFRange::Equals, SFRange::Destroy);

void SFRange::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fMin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMax);

	p_Stream << "}";
}

void SFRange::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFRange*>(p_Target);

	s_Object->m_fMin = simdjson::from_json_float32(p_Document["m_fMin"]);

	s_Object->m_fMax = simdjson::from_json_float32(p_Document["m_fMax"]);

}

void SFRange::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);

}

bool SFRange::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFRange*>(p_Left);
	auto* s_Right = reinterpret_cast<SFRange*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFRange::operator==(const SFRange& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFRange>)
		return false;

	if (m_fMin != p_Other.m_fMin) return false;
	if (m_fMax != p_Other.m_fMax) return false;

	return true;
}

void SFRange::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFRange*>(p_Object);
	s_Object->~SFRange();
}

ZHMTypeInfo SFaceFXAnimationRef::TypeInfo = ZHMTypeInfo("SFaceFXAnimationRef", sizeof(SFaceFXAnimationRef), alignof(SFaceFXAnimationRef), SFaceFXAnimationRef::WriteSimpleJson, SFaceFXAnimationRef::FromSimpleJson, SFaceFXAnimationRef::Serialize, SFaceFXAnimationRef::Equals, SFaceFXAnimationRef::Destroy);

void SFaceFXAnimationRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFaceFXAnimationRef*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_animationSetResourceID") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->m_animationSetResourceID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AnimationSetResource") << ":";
	TResourcePtr::WriteSimpleJson(&s_Object->m_AnimationSetResource, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sAnimationName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAnimationName);

	p_Stream << "}";
}

void SFaceFXAnimationRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFaceFXAnimationRef*>(p_Target);

	ZRuntimeResourceID::FromSimpleJson(p_Document["m_animationSetResourceID"], &s_Object->m_animationSetResourceID);

	TResourcePtr::FromSimpleJson(p_Document["m_AnimationSetResource"], &s_Object->m_AnimationSetResource);

	s_Object->m_sAnimationName = std::string_view(p_Document["m_sAnimationName"]);

}

void SFaceFXAnimationRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFaceFXAnimationRef*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->m_animationSetResourceID, p_Serializer, p_OwnOffset + offsetof(SFaceFXAnimationRef, m_animationSetResourceID));
	TResourcePtr::Serialize(&s_Object->m_AnimationSetResource, p_Serializer, p_OwnOffset + offsetof(SFaceFXAnimationRef, m_AnimationSetResource));
	ZString::Serialize(&s_Object->m_sAnimationName, p_Serializer, p_OwnOffset + offsetof(SFaceFXAnimationRef, m_sAnimationName));
}

bool SFaceFXAnimationRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFaceFXAnimationRef*>(p_Left);
	auto* s_Right = reinterpret_cast<SFaceFXAnimationRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFaceFXAnimationRef::operator==(const SFaceFXAnimationRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFaceFXAnimationRef>)
		return false;

	if (m_animationSetResourceID != p_Other.m_animationSetResourceID) return false;
	if (m_AnimationSetResource != p_Other.m_AnimationSetResource) return false;
	if (m_sAnimationName != p_Other.m_sAnimationName) return false;

	return true;
}

void SFaceFXAnimationRef::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFaceFXAnimationRef*>(p_Object);
	s_Object->~SFaceFXAnimationRef();
}

ZHMTypeInfo SFaceOrderSaveData::TypeInfo = ZHMTypeInfo("SFaceOrderSaveData", sizeof(SFaceOrderSaveData), alignof(SFaceOrderSaveData), SFaceOrderSaveData::WriteSimpleJson, SFaceOrderSaveData::FromSimpleJson, SFaceOrderSaveData::Serialize, SFaceOrderSaveData::Equals, SFaceOrderSaveData::Destroy);

void SFaceOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bLookAt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAimAt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAimAt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateKnownPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateKnownPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDurationVariance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDurationVariance);

	p_Stream << "}";
}

void SFaceOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Target);

	s_Object->m_bLookAt = simdjson::from_json_bool(p_Document["m_bLookAt"]);

	s_Object->m_bAimAt = simdjson::from_json_bool(p_Document["m_bAimAt"]);

	s_Object->m_bUpdateKnownPosition = simdjson::from_json_bool(p_Document["m_bUpdateKnownPosition"]);

	s_Object->m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

	s_Object->m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object->m_fDurationVariance = simdjson::from_json_float32(p_Document["m_fDurationVariance"]);

}

void SFaceOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);

}

bool SFaceOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFaceOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFaceOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFaceOrderSaveData::operator==(const SFaceOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFaceOrderSaveData>)
		return false;

	if (m_bLookAt != p_Other.m_bLookAt) return false;
	if (m_bAimAt != p_Other.m_bAimAt) return false;
	if (m_bUpdateKnownPosition != p_Other.m_bUpdateKnownPosition) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_fDurationVariance != p_Other.m_fDurationVariance) return false;

	return true;
}

void SFaceOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);
	s_Object->~SFaceOrderSaveData();
}

ZHMTypeInfo SFleeOrderSaveData::TypeInfo = ZHMTypeInfo("SFleeOrderSaveData", sizeof(SFleeOrderSaveData), alignof(SFleeOrderSaveData), SFleeOrderSaveData::WriteSimpleJson, SFleeOrderSaveData::FromSimpleJson, SFleeOrderSaveData::Serialize, SFleeOrderSaveData::Equals, SFleeOrderSaveData::Destroy);

void SFleeOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eHelpReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eHelpReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFleeForHelp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFleeForHelp);

	p_Stream << "}";
}

void SFleeOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Target);

	s_Object->m_eHelpReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eHelpReason"])));

	s_Object->m_nGridNodeIndex = simdjson::from_json_uint16(p_Document["m_nGridNodeIndex"]);

	s_Object->m_bFleeForHelp = simdjson::from_json_bool(p_Document["m_bFleeForHelp"]);

}

void SFleeOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);

}

bool SFleeOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFleeOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFleeOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFleeOrderSaveData::operator==(const SFleeOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFleeOrderSaveData>)
		return false;

	if (m_eHelpReason != p_Other.m_eHelpReason) return false;
	if (m_nGridNodeIndex != p_Other.m_nGridNodeIndex) return false;
	if (m_bFleeForHelp != p_Other.m_bFleeForHelp) return false;

	return true;
}

void SFleeOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);
	s_Object->~SFleeOrderSaveData();
}

ZHMTypeInfo SFontDefinition::TypeInfo = ZHMTypeInfo("SFontDefinition", sizeof(SFontDefinition), alignof(SFontDefinition), SFontDefinition::WriteSimpleJson, SFontDefinition::FromSimpleJson, SFontDefinition::Serialize, SFontDefinition::Equals, SFontDefinition::Destroy);

void SFontDefinition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFontId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sFontName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eFontFlags") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EFontFlags", static_cast<int>(s_Object->eFontFlags)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScaleFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fScaleFactor);

	p_Stream << "}";
}

void SFontDefinition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFontDefinition*>(p_Target);

	s_Object->sFontId = std::string_view(p_Document["sFontId"]);

	s_Object->sFontName = std::string_view(p_Document["sFontName"]);

	s_Object->eFontFlags = static_cast<EFontFlags>(ZHMEnums::GetEnumValueByName("EFontFlags", std::string_view(p_Document["eFontFlags"])));

	s_Object->fScaleFactor = simdjson::from_json_float32(p_Document["fScaleFactor"]);

}

void SFontDefinition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);

	ZString::Serialize(&s_Object->sFontId, p_Serializer, p_OwnOffset + offsetof(SFontDefinition, sFontId));
	ZString::Serialize(&s_Object->sFontName, p_Serializer, p_OwnOffset + offsetof(SFontDefinition, sFontName));
}

bool SFontDefinition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFontDefinition*>(p_Left);
	auto* s_Right = reinterpret_cast<SFontDefinition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFontDefinition::operator==(const SFontDefinition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFontDefinition>)
		return false;

	if (sFontId != p_Other.sFontId) return false;
	if (sFontName != p_Other.sFontName) return false;
	if (eFontFlags != p_Other.eFontFlags) return false;
	if (fScaleFactor != p_Other.fScaleFactor) return false;

	return true;
}

void SFontDefinition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);
	s_Object->~SFontDefinition();
}

ZHMTypeInfo SFontLibraryDefinition::TypeInfo = ZHMTypeInfo("SFontLibraryDefinition", sizeof(SFontLibraryDefinition), alignof(SFontLibraryDefinition), SFontLibraryDefinition::WriteSimpleJson, SFontLibraryDefinition::FromSimpleJson, SFontLibraryDefinition::Serialize, SFontLibraryDefinition::Equals, SFontLibraryDefinition::Destroy);

void SFontLibraryDefinition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFontLocaleID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontLocaleID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFontDefinitions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFontDefinitions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFontDefinitions[i];
		SFontDefinition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aFontDefinitions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SFontLibraryDefinition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Target);

	s_Object->sFontLocaleID = std::string_view(p_Document["sFontLocaleID"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFontDefinitions"];
	s_Object->m_aFontDefinitions.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SFontDefinition::FromSimpleJson(s_Item0, &s_Object->m_aFontDefinitions[s_Index0]);
		++s_Index0;
	}
	}

}

void SFontLibraryDefinition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);

	ZString::Serialize(&s_Object->sFontLocaleID, p_Serializer, p_OwnOffset + offsetof(SFontLibraryDefinition, sFontLocaleID));
	TArray<SFontDefinition>::Serialize(&s_Object->m_aFontDefinitions, p_Serializer, p_OwnOffset + offsetof(SFontLibraryDefinition, m_aFontDefinitions));
}

bool SFontLibraryDefinition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFontLibraryDefinition*>(p_Left);
	auto* s_Right = reinterpret_cast<SFontLibraryDefinition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFontLibraryDefinition::operator==(const SFontLibraryDefinition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFontLibraryDefinition>)
		return false;

	if (sFontLocaleID != p_Other.sFontLocaleID) return false;
	if (m_aFontDefinitions != p_Other.m_aFontDefinitions) return false;

	return true;
}

void SFontLibraryDefinition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);
	s_Object->~SFontLibraryDefinition();
}

ZHMTypeInfo SFootIKEventData::TypeInfo = ZHMTypeInfo("SFootIKEventData", sizeof(SFootIKEventData), alignof(SFootIKEventData), SFootIKEventData::WriteSimpleJson, SFootIKEventData::FromSimpleJson, SFootIKEventData::Serialize, SFootIKEventData::Equals, SFootIKEventData::Destroy);

void SFootIKEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Foot") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SFootIKEventData.EFoot", static_cast<int>(s_Object->m_Foot)));

	p_Stream << "}";
}

void SFootIKEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFootIKEventData*>(p_Target);

	s_Object->m_Foot = static_cast<SFootIKEventData::EFoot>(ZHMEnums::GetEnumValueByName("SFootIKEventData.EFoot", std::string_view(p_Document["m_Foot"])));

}

void SFootIKEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);

}

bool SFootIKEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFootIKEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFootIKEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFootIKEventData::operator==(const SFootIKEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFootIKEventData>)
		return false;

	if (m_Foot != p_Other.m_Foot) return false;

	return true;
}

void SFootIKEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);
	s_Object->~SFootIKEventData();
}

ZHMTypeInfo SFriskSuspectGroupSaveData::TypeInfo = ZHMTypeInfo("SFriskSuspectGroupSaveData", sizeof(SFriskSuspectGroupSaveData), alignof(SFriskSuspectGroupSaveData), SFriskSuspectGroupSaveData::WriteSimpleJson, SFriskSuspectGroupSaveData::FromSimpleJson, SFriskSuspectGroupSaveData::Serialize, SFriskSuspectGroupSaveData::Equals, SFriskSuspectGroupSaveData::Destroy);

void SFriskSuspectGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanIsGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanIsGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAssistantState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZFriskSuspectGroup.EAssistantState", static_cast<int>(s_Object->m_eAssistantState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDisturbanceType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eDisturbanceType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eHitmanGreetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZFriskSuspectGroup.EHitmanGreetState", static_cast<int>(s_Object->m_eHitmanGreetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHitmanGreet") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tHitmanGreet, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitToComplyTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitToComplyTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarnOnWeaponFound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarnOnWeaponFound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponFound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponFound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMoveWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMoveWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirskRequestRepeated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirskRequestRepeated);

	p_Stream << "}";
}

void SFriskSuspectGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_bHitmanIsGuard = simdjson::from_json_bool(p_Document["m_bHitmanIsGuard"]);

	s_Object->m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object->m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object->m_eAssistantState = static_cast<ZFriskSuspectGroup::EAssistantState>(ZHMEnums::GetEnumValueByName("ZFriskSuspectGroup.EAssistantState", std::string_view(p_Document["m_eAssistantState"])));

	s_Object->m_eDisturbanceType = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eDisturbanceType"])));

	s_Object->m_eHitmanGreetState = static_cast<ZFriskSuspectGroup::EHitmanGreetState>(ZHMEnums::GetEnumValueByName("ZFriskSuspectGroup.EHitmanGreetState", std::string_view(p_Document["m_eHitmanGreetState"])));

	ZGameTime::FromSimpleJson(p_Document["m_tHitmanGreet"], &s_Object->m_tHitmanGreet);

	s_Object->m_fMovingTime = simdjson::from_json_float32(p_Document["m_fMovingTime"]);

	s_Object->m_fRunningTime = simdjson::from_json_float32(p_Document["m_fRunningTime"]);

	ZGameTime::FromSimpleJson(p_Document["m_tWaitToComplyTime"], &s_Object->m_tWaitToComplyTime);

	s_Object->m_bWarnOnWeaponFound = simdjson::from_json_bool(p_Document["m_bWarnOnWeaponFound"]);

	s_Object->m_bWeaponFound = simdjson::from_json_bool(p_Document["m_bWeaponFound"]);

	s_Object->m_bMoveWarning = simdjson::from_json_bool(p_Document["m_bMoveWarning"]);

	s_Object->m_bFirskRequestRepeated = simdjson::from_json_bool(p_Document["m_bFirskRequestRepeated"]);

}

void SFriskSuspectGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tHitmanGreet, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_tHitmanGreet));
	ZGameTime::Serialize(&s_Object->m_tWaitToComplyTime, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_tWaitToComplyTime));
}

bool SFriskSuspectGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFriskSuspectGroupSaveData::operator==(const SFriskSuspectGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFriskSuspectGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_bHitmanIsGuard != p_Other.m_bHitmanIsGuard) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_eAssistantState != p_Other.m_eAssistantState) return false;
	if (m_eDisturbanceType != p_Other.m_eDisturbanceType) return false;
	if (m_eHitmanGreetState != p_Other.m_eHitmanGreetState) return false;
	if (m_tHitmanGreet != p_Other.m_tHitmanGreet) return false;
	if (m_fMovingTime != p_Other.m_fMovingTime) return false;
	if (m_fRunningTime != p_Other.m_fRunningTime) return false;
	if (m_tWaitToComplyTime != p_Other.m_tWaitToComplyTime) return false;
	if (m_bWarnOnWeaponFound != p_Other.m_bWarnOnWeaponFound) return false;
	if (m_bWeaponFound != p_Other.m_bWeaponFound) return false;
	if (m_bMoveWarning != p_Other.m_bMoveWarning) return false;
	if (m_bFirskRequestRepeated != p_Other.m_bFirskRequestRepeated) return false;

	return true;
}

void SFriskSuspectGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);
	s_Object->~SFriskSuspectGroupSaveData();
}

ZHMTypeInfo SGBufferSample::TypeInfo = ZHMTypeInfo("SGBufferSample", sizeof(SGBufferSample), alignof(SGBufferSample), SGBufferSample::WriteSimpleJson, SGBufferSample::FromSimpleJson, SGBufferSample::Serialize, SGBufferSample::Equals, SGBufferSample::Destroy);

void SGBufferSample::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("normal") << ":";
	SVector3::WriteSimpleJson(&s_Object->normal, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("diffuse") << ":";
	SVector3::WriteSimpleJson(&s_Object->diffuse, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("specular") << ":";
	SVector3::WriteSimpleJson(&s_Object->specular, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("accumulatedLight") << ":";
	SVector3::WriteSimpleJson(&s_Object->accumulatedLight, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("glossiness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->glossiness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("translucency") << ":";
	p_Stream << simdjson::as_json_string(s_Object->translucency);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ao") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ao);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("shadingModel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->shadingModel);

	p_Stream << "}";
}

void SGBufferSample::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGBufferSample*>(p_Target);

	SVector3::FromSimpleJson(p_Document["normal"], &s_Object->normal);

	SVector3::FromSimpleJson(p_Document["diffuse"], &s_Object->diffuse);

	SVector3::FromSimpleJson(p_Document["specular"], &s_Object->specular);

	SVector3::FromSimpleJson(p_Document["accumulatedLight"], &s_Object->accumulatedLight);

	s_Object->glossiness = simdjson::from_json_float32(p_Document["glossiness"]);

	s_Object->translucency = simdjson::from_json_float32(p_Document["translucency"]);

	s_Object->ao = simdjson::from_json_float32(p_Document["ao"]);

	s_Object->shadingModel = simdjson::from_json_uint32(p_Document["shadingModel"]);

}

void SGBufferSample::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);

	SVector3::Serialize(&s_Object->normal, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, normal));
	SVector3::Serialize(&s_Object->diffuse, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, diffuse));
	SVector3::Serialize(&s_Object->specular, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, specular));
	SVector3::Serialize(&s_Object->accumulatedLight, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, accumulatedLight));
}

bool SGBufferSample::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGBufferSample*>(p_Left);
	auto* s_Right = reinterpret_cast<SGBufferSample*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGBufferSample::operator==(const SGBufferSample& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGBufferSample>)
		return false;

	if (normal != p_Other.normal) return false;
	if (diffuse != p_Other.diffuse) return false;
	if (specular != p_Other.specular) return false;
	if (accumulatedLight != p_Other.accumulatedLight) return false;
	if (glossiness != p_Other.glossiness) return false;
	if (translucency != p_Other.translucency) return false;
	if (ao != p_Other.ao) return false;
	if (shadingModel != p_Other.shadingModel) return false;

	return true;
}

void SGBufferSample::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);
	s_Object->~SGBufferSample();
}

ZHMTypeInfo SGProperties::TypeInfo = ZHMTypeInfo("SGProperties", sizeof(SGProperties), alignof(SGProperties), SGProperties::WriteSimpleJson, SGProperties::FromSimpleJson, SGProperties::Serialize, SGProperties::Equals, SGProperties::Destroy);

void SGProperties::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("vMin") << ":";
	float4::WriteSimpleJson(&s_Object->vMin, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vMax") << ":";
	float4::WriteSimpleJson(&s_Object->vMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nGridWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nGridWidth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fGridSpacing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fGridSpacing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVisibilityRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVisibilityRange);

	p_Stream << "}";
}

void SGProperties::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGProperties*>(p_Target);

	float4::FromSimpleJson(p_Document["vMin"], &s_Object->vMin);

	float4::FromSimpleJson(p_Document["vMax"], &s_Object->vMax);

	s_Object->nGridWidth = simdjson::from_json_int32(p_Document["nGridWidth"]);

	s_Object->fGridSpacing = simdjson::from_json_float32(p_Document["fGridSpacing"]);

	s_Object->nVisibilityRange = simdjson::from_json_int32(p_Document["nVisibilityRange"]);

}

void SGProperties::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	float4::Serialize(&s_Object->vMin, p_Serializer, p_OwnOffset + offsetof(SGProperties, vMin));
	float4::Serialize(&s_Object->vMax, p_Serializer, p_OwnOffset + offsetof(SGProperties, vMax));
}

bool SGProperties::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGProperties*>(p_Left);
	auto* s_Right = reinterpret_cast<SGProperties*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGProperties::operator==(const SGProperties& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGProperties>)
		return false;

	if (vMin != p_Other.vMin) return false;
	if (vMax != p_Other.vMax) return false;
	if (nGridWidth != p_Other.nGridWidth) return false;
	if (fGridSpacing != p_Other.fGridSpacing) return false;
	if (nVisibilityRange != p_Other.nVisibilityRange) return false;

	return true;
}

void SGProperties::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);
	s_Object->~SGProperties();
}

ZHMTypeInfo SGWaypoint::TypeInfo = ZHMTypeInfo("SGWaypoint", sizeof(SGWaypoint), alignof(SGWaypoint), SGWaypoint::WriteSimpleJson, SGWaypoint::FromSimpleJson, SGWaypoint::Serialize, SGWaypoint::Equals, SGWaypoint::Destroy);

void SGWaypoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nNeighbor0") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor0);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor1") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor1);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor2") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor2);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor3") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor3);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor4") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor4);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor5") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor5);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor6") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor6);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor7") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor7);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vPos") << ":";
	float4::WriteSimpleJson(&s_Object->vPos, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVisionDataOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVisionDataOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nLayerIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nLayerIndex);

	p_Stream << "}";
}

void SGWaypoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGWaypoint*>(p_Target);

	s_Object->nNeighbor0 = simdjson::from_json_uint16(p_Document["nNeighbor0"]);

	s_Object->nNeighbor1 = simdjson::from_json_uint16(p_Document["nNeighbor1"]);

	s_Object->nNeighbor2 = simdjson::from_json_uint16(p_Document["nNeighbor2"]);

	s_Object->nNeighbor3 = simdjson::from_json_uint16(p_Document["nNeighbor3"]);

	s_Object->nNeighbor4 = simdjson::from_json_uint16(p_Document["nNeighbor4"]);

	s_Object->nNeighbor5 = simdjson::from_json_uint16(p_Document["nNeighbor5"]);

	s_Object->nNeighbor6 = simdjson::from_json_uint16(p_Document["nNeighbor6"]);

	s_Object->nNeighbor7 = simdjson::from_json_uint16(p_Document["nNeighbor7"]);

	float4::FromSimpleJson(p_Document["vPos"], &s_Object->vPos);

	s_Object->nVisionDataOffset = simdjson::from_json_uint32(p_Document["nVisionDataOffset"]);

	s_Object->nLayerIndex = simdjson::from_json_int16(p_Document["nLayerIndex"]);

}

void SGWaypoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	float4::Serialize(&s_Object->vPos, p_Serializer, p_OwnOffset + offsetof(SGWaypoint, vPos));
}

bool SGWaypoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGWaypoint*>(p_Left);
	auto* s_Right = reinterpret_cast<SGWaypoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGWaypoint::operator==(const SGWaypoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGWaypoint>)
		return false;

	if (nNeighbor0 != p_Other.nNeighbor0) return false;
	if (nNeighbor1 != p_Other.nNeighbor1) return false;
	if (nNeighbor2 != p_Other.nNeighbor2) return false;
	if (nNeighbor3 != p_Other.nNeighbor3) return false;
	if (nNeighbor4 != p_Other.nNeighbor4) return false;
	if (nNeighbor5 != p_Other.nNeighbor5) return false;
	if (nNeighbor6 != p_Other.nNeighbor6) return false;
	if (nNeighbor7 != p_Other.nNeighbor7) return false;
	if (vPos != p_Other.vPos) return false;
	if (nVisionDataOffset != p_Other.nVisionDataOffset) return false;
	if (nLayerIndex != p_Other.nLayerIndex) return false;

	return true;
}

void SGWaypoint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);
	s_Object->~SGWaypoint();
}

ZHMTypeInfo SGameCamProfileEntitySaveData::TypeInfo = ZHMTypeInfo("SGameCamProfileEntitySaveData", sizeof(SGameCamProfileEntitySaveData), alignof(SGameCamProfileEntitySaveData), SGameCamProfileEntitySaveData::WriteSimpleJson, SGameCamProfileEntitySaveData::FromSimpleJson, SGameCamProfileEntitySaveData::Serialize, SGameCamProfileEntitySaveData::Equals, SGameCamProfileEntitySaveData::Destroy);

void SGameCamProfileEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);

	p_Stream << "}";
}

void SGameCamProfileEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Target);

	s_Object->m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

}

void SGameCamProfileEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);

}

bool SGameCamProfileEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameCamProfileEntitySaveData::operator==(const SGameCamProfileEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameCamProfileEntitySaveData>)
		return false;

	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;

	return true;
}

void SGameCamProfileEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);
	s_Object->~SGameCamProfileEntitySaveData();
}

ZHMTypeInfo SShatterShardTransformSaveData::TypeInfo = ZHMTypeInfo("SShatterShardTransformSaveData", sizeof(SShatterShardTransformSaveData), alignof(SShatterShardTransformSaveData), SShatterShardTransformSaveData::WriteSimpleJson, SShatterShardTransformSaveData::FromSimpleJson, SShatterShardTransformSaveData::Serialize, SShatterShardTransformSaveData::Equals, SShatterShardTransformSaveData::Destroy);

void SShatterShardTransformSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterShardTransformSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vBoneRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vBoneRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vBonePosition") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vBonePosition, p_Stream);

	p_Stream << "}";
}

void SShatterShardTransformSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SShatterShardTransformSaveData*>(p_Target);

	SVector4::FromSimpleJson(p_Document["m_vBoneRotation"], &s_Object->m_vBoneRotation);

	SVector4::FromSimpleJson(p_Document["m_vBonePosition"], &s_Object->m_vBonePosition);

}

void SShatterShardTransformSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShatterShardTransformSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vBoneRotation, p_Serializer, p_OwnOffset + offsetof(SShatterShardTransformSaveData, m_vBoneRotation));
	SVector4::Serialize(&s_Object->m_vBonePosition, p_Serializer, p_OwnOffset + offsetof(SShatterShardTransformSaveData, m_vBonePosition));
}

bool SShatterShardTransformSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShatterShardTransformSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShatterShardTransformSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShatterShardTransformSaveData::operator==(const SShatterShardTransformSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShatterShardTransformSaveData>)
		return false;

	if (m_vBoneRotation != p_Other.m_vBoneRotation) return false;
	if (m_vBonePosition != p_Other.m_vBonePosition) return false;

	return true;
}

void SShatterShardTransformSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SShatterShardTransformSaveData*>(p_Object);
	s_Object->~SShatterShardTransformSaveData();
}

ZHMTypeInfo SShatterShardSaveData::TypeInfo = ZHMTypeInfo("SShatterShardSaveData", sizeof(SShatterShardSaveData), alignof(SShatterShardSaveData), SShatterShardSaveData::WriteSimpleJson, SShatterShardSaveData::FromSimpleJson, SShatterShardSaveData::Serialize, SShatterShardSaveData::Equals, SShatterShardSaveData::Destroy);

void SShatterShardSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterShardSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nShardIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShardIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasBody);

	p_Stream << "}";
}

void SShatterShardSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SShatterShardSaveData*>(p_Target);

	s_Object->m_nShardIndex = simdjson::from_json_uint32(p_Document["m_nShardIndex"]);

	s_Object->m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	s_Object->m_bHasBody = simdjson::from_json_bool(p_Document["m_bHasBody"]);

}

void SShatterShardSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShatterShardSaveData*>(p_Object);

}

bool SShatterShardSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShatterShardSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShatterShardSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShatterShardSaveData::operator==(const SShatterShardSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShatterShardSaveData>)
		return false;

	if (m_nShardIndex != p_Other.m_nShardIndex) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;
	if (m_bHasBody != p_Other.m_bHasBody) return false;

	return true;
}

void SShatterShardSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SShatterShardSaveData*>(p_Object);
	s_Object->~SShatterShardSaveData();
}

ZHMTypeInfo SShatterSystemSaveData::TypeInfo = ZHMTypeInfo("SShatterSystemSaveData", sizeof(SShatterSystemSaveData), alignof(SShatterSystemSaveData), SShatterSystemSaveData::WriteSimpleJson, SShatterSystemSaveData::FromSimpleJson, SShatterSystemSaveData::Serialize, SShatterSystemSaveData::Equals, SShatterSystemSaveData::Destroy);

void SShatterSystemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterSystemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aShardTransforms") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aShardTransforms.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aShardTransforms[i];
		SShatterShardTransformSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aShardTransforms.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aShardsData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aShardsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aShardsData[i];
		SShatterShardSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aShardsData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nShatterSteps") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nShatterSteps);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCoreIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCoreIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoreHasBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoreHasBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCoreKinematic") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCoreKinematic);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsInitialCoreActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInitialCoreActive);

	p_Stream << "}";
}

void SShatterSystemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SShatterSystemSaveData*>(p_Target);

	SVector4::FromSimpleJson(p_Document["m_vRotation"], &s_Object->m_vRotation);

	SVector4::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aShardTransforms"];
	s_Object->m_aShardTransforms.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SShatterShardTransformSaveData::FromSimpleJson(s_Item0, &s_Object->m_aShardTransforms[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aShardsData"];
	s_Object->m_aShardsData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SShatterShardSaveData::FromSimpleJson(s_Item0, &s_Object->m_aShardsData[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_nShatterSteps = simdjson::from_json_uint32(p_Document["m_nShatterSteps"]);

	s_Object->m_nCoreIndex = simdjson::from_json_uint32(p_Document["m_nCoreIndex"]);

	s_Object->m_bCoreHasBody = simdjson::from_json_bool(p_Document["m_bCoreHasBody"]);

	s_Object->m_bIsCoreKinematic = simdjson::from_json_bool(p_Document["m_bIsCoreKinematic"]);

	s_Object->m_bIsInitialCoreActive = simdjson::from_json_bool(p_Document["m_bIsInitialCoreActive"]);

}

void SShatterSystemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShatterSystemSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SShatterSystemSaveData, m_vRotation));
	SVector4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SShatterSystemSaveData, m_vPosition));
	TArray<SShatterShardTransformSaveData>::Serialize(&s_Object->m_aShardTransforms, p_Serializer, p_OwnOffset + offsetof(SShatterSystemSaveData, m_aShardTransforms));
	TArray<SShatterShardSaveData>::Serialize(&s_Object->m_aShardsData, p_Serializer, p_OwnOffset + offsetof(SShatterSystemSaveData, m_aShardsData));
}

bool SShatterSystemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShatterSystemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShatterSystemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShatterSystemSaveData::operator==(const SShatterSystemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShatterSystemSaveData>)
		return false;

	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_aShardTransforms != p_Other.m_aShardTransforms) return false;
	if (m_aShardsData != p_Other.m_aShardsData) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_nShatterSteps != p_Other.m_nShatterSteps) return false;
	if (m_nCoreIndex != p_Other.m_nCoreIndex) return false;
	if (m_bCoreHasBody != p_Other.m_bCoreHasBody) return false;
	if (m_bIsCoreKinematic != p_Other.m_bIsCoreKinematic) return false;
	if (m_bIsInitialCoreActive != p_Other.m_bIsInitialCoreActive) return false;

	return true;
}

void SShatterSystemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SShatterSystemSaveData*>(p_Object);
	s_Object->~SShatterSystemSaveData();
}

ZHMTypeInfo SShatterSaveData::TypeInfo = ZHMTypeInfo("SShatterSaveData", sizeof(SShatterSaveData), alignof(SShatterSaveData), SShatterSaveData::WriteSimpleJson, SShatterSaveData::FromSimpleJson, SShatterSaveData::Serialize, SShatterSaveData::Equals, SShatterSaveData::Destroy);

void SShatterSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShatterSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SShatterSystemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SShatterSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SShatterSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SShatterSystemSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SShatterSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShatterSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SShatterSaveData, m_aEntities));
	TArray<SShatterSystemSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SShatterSaveData, m_aData));
}

bool SShatterSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShatterSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShatterSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShatterSaveData::operator==(const SShatterSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShatterSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SShatterSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SShatterSaveData*>(p_Object);
	s_Object->~SShatterSaveData();
}

ZHMTypeInfo SVIPEvacuationNodeSaveData::TypeInfo = ZHMTypeInfo("SVIPEvacuationNodeSaveData", sizeof(SVIPEvacuationNodeSaveData), alignof(SVIPEvacuationNodeSaveData), SVIPEvacuationNodeSaveData::WriteSimpleJson, SVIPEvacuationNodeSaveData::FromSimpleJson, SVIPEvacuationNodeSaveData::Serialize, SVIPEvacuationNodeSaveData::Equals, SVIPEvacuationNodeSaveData::Destroy);

void SVIPEvacuationNodeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fPenaltyMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPenaltyMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPenaltyDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPenaltyDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tPenalty") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tPenalty, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_compromisedOnEnter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_compromisedOnEnter);

	p_Stream << "}";
}

void SVIPEvacuationNodeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Target);

	s_Object->m_fPenaltyMultiplier = simdjson::from_json_float32(p_Document["m_fPenaltyMultiplier"]);

	s_Object->m_fPenaltyDuration = simdjson::from_json_float32(p_Document["m_fPenaltyDuration"]);

	ZGameTime::FromSimpleJson(p_Document["m_tPenalty"], &s_Object->m_tPenalty);

	s_Object->m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object->m_compromisedOnEnter = simdjson::from_json_bool(p_Document["m_compromisedOnEnter"]);

}

void SVIPEvacuationNodeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tPenalty, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodeSaveData, m_tPenalty));
}

bool SVIPEvacuationNodeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVIPEvacuationNodeSaveData::operator==(const SVIPEvacuationNodeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVIPEvacuationNodeSaveData>)
		return false;

	if (m_fPenaltyMultiplier != p_Other.m_fPenaltyMultiplier) return false;
	if (m_fPenaltyDuration != p_Other.m_fPenaltyDuration) return false;
	if (m_tPenalty != p_Other.m_tPenalty) return false;
	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_compromisedOnEnter != p_Other.m_compromisedOnEnter) return false;

	return true;
}

void SVIPEvacuationNodeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);
	s_Object->~SVIPEvacuationNodeSaveData();
}

ZHMTypeInfo SVIPEvacuationNodesSaveData::TypeInfo = ZHMTypeInfo("SVIPEvacuationNodesSaveData", sizeof(SVIPEvacuationNodesSaveData), alignof(SVIPEvacuationNodesSaveData), SVIPEvacuationNodesSaveData::WriteSimpleJson, SVIPEvacuationNodesSaveData::FromSimpleJson, SVIPEvacuationNodesSaveData::Serialize, SVIPEvacuationNodesSaveData::Equals, SVIPEvacuationNodesSaveData::Destroy);

void SVIPEvacuationNodesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SVIPEvacuationNodeSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVIPEvacuationNodesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVIPEvacuationNodeSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SVIPEvacuationNodesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodesSaveData, m_aEntities));
	TArray<SVIPEvacuationNodeSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodesSaveData, m_aData));
}

bool SVIPEvacuationNodesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVIPEvacuationNodesSaveData::operator==(const SVIPEvacuationNodesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVIPEvacuationNodesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SVIPEvacuationNodesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);
	s_Object->~SVIPEvacuationNodesSaveData();
}

ZHMTypeInfo SItemSaveData::TypeInfo = ZHMTypeInfo("SItemSaveData", sizeof(SItemSaveData), alignof(SItemSaveData), SItemSaveData::WriteSimpleJson, SItemSaveData::FromSimpleJson, SItemSaveData::Serialize, SItemSaveData::Equals, SItemSaveData::Destroy);

void SItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnablePickup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnablePickup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKinematic") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKinematic);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSleeping") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSleeping);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPerceptible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPerceptible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ContainerSaveData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_ContainerSaveData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rTransformParent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTransformParent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSpawner") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSpawner);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rOwner") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rOwner);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHoldingContainer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHoldingContainer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTurnedOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTurnedOn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEverOwnedByHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEverOwnedByHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasPlacedAndAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasPlacedAndAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bObjectInPhysicsWorld") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bObjectInPhysicsWorld);

	p_Stream << "}";
}

void SItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItemSaveData*>(p_Target);

	SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	SVector4::FromSimpleJson(p_Document["m_vRotation"], &s_Object->m_vRotation);

	s_Object->m_bShowItem = simdjson::from_json_bool(p_Document["m_bShowItem"]);

	s_Object->m_bEnablePickup = simdjson::from_json_bool(p_Document["m_bEnablePickup"]);

	s_Object->m_bKinematic = simdjson::from_json_bool(p_Document["m_bKinematic"]);

	s_Object->m_bSleeping = simdjson::from_json_bool(p_Document["m_bSleeping"]);

	s_Object->m_bIsPerceptible = simdjson::from_json_bool(p_Document["m_bIsPerceptible"]);

	s_Object->m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

	SVector3::FromSimpleJson(p_Document["m_vVelocity"], &s_Object->m_vVelocity);

	ZVariant::FromSimpleJson(p_Document["m_ContainerSaveData"], &s_Object->m_ContainerSaveData);

	s_Object->m_rTransformParent = simdjson::from_json_uint32(p_Document["m_rTransformParent"]);

	s_Object->m_rSpawner = simdjson::from_json_uint32(p_Document["m_rSpawner"]);

	s_Object->m_rOwner = simdjson::from_json_uint32(p_Document["m_rOwner"]);

	s_Object->m_rHoldingContainer = simdjson::from_json_uint32(p_Document["m_rHoldingContainer"]);

	s_Object->m_bTurnedOn = simdjson::from_json_bool(p_Document["m_bTurnedOn"]);

	s_Object->m_bEverOwnedByHitman = simdjson::from_json_bool(p_Document["m_bEverOwnedByHitman"]);

	s_Object->m_bWasPlacedAndAttached = simdjson::from_json_bool(p_Document["m_bWasPlacedAndAttached"]);

	s_Object->m_bObjectInPhysicsWorld = simdjson::from_json_bool(p_Document["m_bObjectInPhysicsWorld"]);

}

void SItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vRotation));
	SVector3::Serialize(&s_Object->m_vVelocity, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vVelocity));
	ZVariant::Serialize(&s_Object->m_ContainerSaveData, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_ContainerSaveData));
}

bool SItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemSaveData::operator==(const SItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemSaveData>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_bShowItem != p_Other.m_bShowItem) return false;
	if (m_bEnablePickup != p_Other.m_bEnablePickup) return false;
	if (m_bKinematic != p_Other.m_bKinematic) return false;
	if (m_bSleeping != p_Other.m_bSleeping) return false;
	if (m_bIsPerceptible != p_Other.m_bIsPerceptible) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;
	if (m_vVelocity != p_Other.m_vVelocity) return false;
	if (m_ContainerSaveData != p_Other.m_ContainerSaveData) return false;
	if (m_rTransformParent != p_Other.m_rTransformParent) return false;
	if (m_rSpawner != p_Other.m_rSpawner) return false;
	if (m_rOwner != p_Other.m_rOwner) return false;
	if (m_rHoldingContainer != p_Other.m_rHoldingContainer) return false;
	if (m_bTurnedOn != p_Other.m_bTurnedOn) return false;
	if (m_bEverOwnedByHitman != p_Other.m_bEverOwnedByHitman) return false;
	if (m_bWasPlacedAndAttached != p_Other.m_bWasPlacedAndAttached) return false;
	if (m_bObjectInPhysicsWorld != p_Other.m_bObjectInPhysicsWorld) return false;

	return true;
}

void SItemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);
	s_Object->~SItemSaveData();
}

ZHMTypeInfo SItemsSaveData::TypeInfo = ZHMTypeInfo("SItemsSaveData", sizeof(SItemsSaveData), alignof(SItemsSaveData), SItemsSaveData::WriteSimpleJson, SItemsSaveData::FromSimpleJson, SItemsSaveData::Serialize, SItemsSaveData::Equals, SItemsSaveData::Destroy);

void SItemsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItemsSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SItemSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SItemsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SItemsSaveData, m_aEntities));
	TArray<SItemSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SItemsSaveData, m_aData));
}

bool SItemsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemsSaveData::operator==(const SItemsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SItemsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);
	s_Object->~SItemsSaveData();
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector4", sizeof(SMathMultiplyDivideSaveData_SVector4), alignof(SMathMultiplyDivideSaveData_SVector4), SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector4::FromSimpleJson, SMathMultiplyDivideSaveData_SVector4::Serialize, SMathMultiplyDivideSaveData_SVector4::Equals, SMathMultiplyDivideSaveData_SVector4::Destroy);

void SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Target);

	SVector4::FromSimpleJson(p_Document["m_fA"], &s_Object->m_fA);

	SVector4::FromSimpleJson(p_Document["m_fB"], &s_Object->m_fB);

	s_Object->m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

}

void SMathMultiplyDivideSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);

	SVector4::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector4, m_fA));
	SVector4::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector4, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector4::operator==(const SMathMultiplyDivideSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector4>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

void SMathMultiplyDivideSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);
	s_Object->~SMathMultiplyDivideSaveData_SVector4();
}

ZHMTypeInfo SMathMultipliesSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector4", sizeof(SMathMultipliesSaveData_SVector4), alignof(SMathMultipliesSaveData_SVector4), SMathMultipliesSaveData_SVector4::WriteSimpleJson, SMathMultipliesSaveData_SVector4::FromSimpleJson, SMathMultipliesSaveData_SVector4::Serialize, SMathMultipliesSaveData_SVector4::Equals, SMathMultipliesSaveData_SVector4::Destroy);

void SMathMultipliesSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathMultiplyDivideSaveData_SVector4::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathMultipliesSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector4, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector4>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector4, m_aData));
}

bool SMathMultipliesSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector4::operator==(const SMathMultipliesSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector4>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathMultipliesSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);
	s_Object->~SMathMultipliesSaveData_SVector4();
}

ZHMTypeInfo SVolumeTriggerListenerSaveData::TypeInfo = ZHMTypeInfo("SVolumeTriggerListenerSaveData", sizeof(SVolumeTriggerListenerSaveData), alignof(SVolumeTriggerListenerSaveData), SVolumeTriggerListenerSaveData::WriteSimpleJson, SVolumeTriggerListenerSaveData::FromSimpleJson, SVolumeTriggerListenerSaveData::Serialize, SVolumeTriggerListenerSaveData::Equals, SVolumeTriggerListenerSaveData::Destroy);

void SVolumeTriggerListenerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bColliding") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bColliding);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInternalEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInternalEnabled);

	p_Stream << "}";
}

void SVolumeTriggerListenerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Target);

	s_Object->m_bColliding = simdjson::from_json_bool(p_Document["m_bColliding"]);

	s_Object->m_bInternalEnabled = simdjson::from_json_bool(p_Document["m_bInternalEnabled"]);

}

void SVolumeTriggerListenerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);

}

bool SVolumeTriggerListenerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVolumeTriggerListenerSaveData::operator==(const SVolumeTriggerListenerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVolumeTriggerListenerSaveData>)
		return false;

	if (m_bColliding != p_Other.m_bColliding) return false;
	if (m_bInternalEnabled != p_Other.m_bInternalEnabled) return false;

	return true;
}

void SVolumeTriggerListenerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);
	s_Object->~SVolumeTriggerListenerSaveData();
}

ZHMTypeInfo SVolumeTriggersSaveData::TypeInfo = ZHMTypeInfo("SVolumeTriggersSaveData", sizeof(SVolumeTriggersSaveData), alignof(SVolumeTriggersSaveData), SVolumeTriggersSaveData::WriteSimpleJson, SVolumeTriggersSaveData::FromSimpleJson, SVolumeTriggersSaveData::Serialize, SVolumeTriggersSaveData::Equals, SVolumeTriggersSaveData::Destroy);

void SVolumeTriggersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SVolumeTriggerListenerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVolumeTriggersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVolumeTriggerListenerSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SVolumeTriggersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SVolumeTriggersSaveData, m_aEntities));
	TArray<SVolumeTriggerListenerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SVolumeTriggersSaveData, m_aData));
}

bool SVolumeTriggersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVolumeTriggersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVolumeTriggersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVolumeTriggersSaveData::operator==(const SVolumeTriggersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVolumeTriggersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SVolumeTriggersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);
	s_Object->~SVolumeTriggersSaveData();
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector3", sizeof(SMathMultiplyDivideSaveData_SVector3), alignof(SMathMultiplyDivideSaveData_SVector3), SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector3::FromSimpleJson, SMathMultiplyDivideSaveData_SVector3::Serialize, SMathMultiplyDivideSaveData_SVector3::Equals, SMathMultiplyDivideSaveData_SVector3::Destroy);

void SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Target);

	SVector3::FromSimpleJson(p_Document["m_fA"], &s_Object->m_fA);

	SVector3::FromSimpleJson(p_Document["m_fB"], &s_Object->m_fB);

	s_Object->m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

}

void SMathMultiplyDivideSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);

	SVector3::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector3, m_fA));
	SVector3::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector3, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector3::operator==(const SMathMultiplyDivideSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector3>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

void SMathMultiplyDivideSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);
	s_Object->~SMathMultiplyDivideSaveData_SVector3();
}

ZHMTypeInfo SMathMultipliesSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector3", sizeof(SMathMultipliesSaveData_SVector3), alignof(SMathMultipliesSaveData_SVector3), SMathMultipliesSaveData_SVector3::WriteSimpleJson, SMathMultipliesSaveData_SVector3::FromSimpleJson, SMathMultipliesSaveData_SVector3::Serialize, SMathMultipliesSaveData_SVector3::Equals, SMathMultipliesSaveData_SVector3::Destroy);

void SMathMultipliesSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathMultiplyDivideSaveData_SVector3::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathMultipliesSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector3, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector3>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector3, m_aData));
}

bool SMathMultipliesSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector3::operator==(const SMathMultipliesSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector3>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathMultipliesSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);
	s_Object->~SMathMultipliesSaveData_SVector3();
}

ZHMTypeInfo SMathMultiplyDivideSaveData_float32::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_float32", sizeof(SMathMultiplyDivideSaveData_float32), alignof(SMathMultiplyDivideSaveData_float32), SMathMultiplyDivideSaveData_float32::WriteSimpleJson, SMathMultiplyDivideSaveData_float32::FromSimpleJson, SMathMultiplyDivideSaveData_float32::Serialize, SMathMultiplyDivideSaveData_float32::Equals, SMathMultiplyDivideSaveData_float32::Destroy);

void SMathMultiplyDivideSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fA);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fB);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Target);

	s_Object->m_fA = simdjson::from_json_float32(p_Document["m_fA"]);

	s_Object->m_fB = simdjson::from_json_float32(p_Document["m_fB"]);

	s_Object->m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

}

void SMathMultiplyDivideSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);

}

bool SMathMultiplyDivideSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_float32::operator==(const SMathMultiplyDivideSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_float32>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

void SMathMultiplyDivideSaveData_float32::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);
	s_Object->~SMathMultiplyDivideSaveData_float32();
}

ZHMTypeInfo SMathMultipliesSaveData_float32::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_float32", sizeof(SMathMultipliesSaveData_float32), alignof(SMathMultipliesSaveData_float32), SMathMultipliesSaveData_float32::WriteSimpleJson, SMathMultipliesSaveData_float32::FromSimpleJson, SMathMultipliesSaveData_float32::Serialize, SMathMultipliesSaveData_float32::Equals, SMathMultipliesSaveData_float32::Destroy);

void SMathMultipliesSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_float32::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathMultiplyDivideSaveData_float32::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathMultipliesSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_float32, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_float32, m_aData));
}

bool SMathMultipliesSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_float32::operator==(const SMathMultipliesSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_float32>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathMultipliesSaveData_float32::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);
	s_Object->~SMathMultipliesSaveData_float32();
}

ZHMTypeInfo SItemKeywordProxySaveData::TypeInfo = ZHMTypeInfo("SItemKeywordProxySaveData", sizeof(SItemKeywordProxySaveData), alignof(SItemKeywordProxySaveData), SItemKeywordProxySaveData::WriteSimpleJson, SItemKeywordProxySaveData::FromSimpleJson, SItemKeywordProxySaveData::Serialize, SItemKeywordProxySaveData::Equals, SItemKeywordProxySaveData::Destroy);

void SItemKeywordProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SItemKeywordProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Target);

	s_Object->m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

}

void SItemKeywordProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);

}

bool SItemKeywordProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemKeywordProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemKeywordProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemKeywordProxySaveData::operator==(const SItemKeywordProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemKeywordProxySaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SItemKeywordProxySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);
	s_Object->~SItemKeywordProxySaveData();
}

ZHMTypeInfo SItemKeywordProxiesSaveData::TypeInfo = ZHMTypeInfo("SItemKeywordProxiesSaveData", sizeof(SItemKeywordProxiesSaveData), alignof(SItemKeywordProxiesSaveData), SItemKeywordProxiesSaveData::WriteSimpleJson, SItemKeywordProxiesSaveData::FromSimpleJson, SItemKeywordProxiesSaveData::Serialize, SItemKeywordProxiesSaveData::Equals, SItemKeywordProxiesSaveData::Destroy);

void SItemKeywordProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItemKeywordProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemKeywordProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SItemKeywordProxySaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SItemKeywordProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SItemKeywordProxiesSaveData, m_aEntities));
	TArray<SItemKeywordProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SItemKeywordProxiesSaveData, m_aData));
}

bool SItemKeywordProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemKeywordProxiesSaveData::operator==(const SItemKeywordProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemKeywordProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SItemKeywordProxiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);
	s_Object->~SItemKeywordProxiesSaveData();
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector2", sizeof(SMathMultiplyDivideSaveData_SVector2), alignof(SMathMultiplyDivideSaveData_SVector2), SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector2::FromSimpleJson, SMathMultiplyDivideSaveData_SVector2::Serialize, SMathMultiplyDivideSaveData_SVector2::Equals, SMathMultiplyDivideSaveData_SVector2::Destroy);

void SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Target);

	SVector2::FromSimpleJson(p_Document["m_fA"], &s_Object->m_fA);

	SVector2::FromSimpleJson(p_Document["m_fB"], &s_Object->m_fB);

	s_Object->m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

}

void SMathMultiplyDivideSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);

	SVector2::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector2, m_fA));
	SVector2::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector2, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector2::operator==(const SMathMultiplyDivideSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector2>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

void SMathMultiplyDivideSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);
	s_Object->~SMathMultiplyDivideSaveData_SVector2();
}

ZHMTypeInfo SMathMultipliesSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector2", sizeof(SMathMultipliesSaveData_SVector2), alignof(SMathMultipliesSaveData_SVector2), SMathMultipliesSaveData_SVector2::WriteSimpleJson, SMathMultipliesSaveData_SVector2::FromSimpleJson, SMathMultipliesSaveData_SVector2::Serialize, SMathMultipliesSaveData_SVector2::Equals, SMathMultipliesSaveData_SVector2::Destroy);

void SMathMultipliesSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathMultiplyDivideSaveData_SVector2::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathMultipliesSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector2, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector2>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector2, m_aData));
}

bool SMathMultipliesSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector2::operator==(const SMathMultipliesSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector2>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathMultipliesSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);
	s_Object->~SMathMultipliesSaveData_SVector2();
}

ZHMTypeInfo SLampCoreSaveState::TypeInfo = ZHMTypeInfo("SLampCoreSaveState", sizeof(SLampCoreSaveState), alignof(SLampCoreSaveState), SLampCoreSaveState::WriteSimpleJson, SLampCoreSaveState::FromSimpleJson, SLampCoreSaveState::Serialize, SLampCoreSaveState::Equals, SLampCoreSaveState::Destroy);

void SLampCoreSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fDiffusePower") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDiffusePower);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSwitchState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSwitchState);

	p_Stream << "}";
}

void SLampCoreSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Target);

	s_Object->m_fDiffusePower = simdjson::from_json_float32(p_Document["m_fDiffusePower"]);

	s_Object->m_bSwitchState = simdjson::from_json_bool(p_Document["m_bSwitchState"]);

}

void SLampCoreSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);

}

bool SLampCoreSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLampCoreSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SLampCoreSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLampCoreSaveState::operator==(const SLampCoreSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLampCoreSaveState>)
		return false;

	if (m_fDiffusePower != p_Other.m_fDiffusePower) return false;
	if (m_bSwitchState != p_Other.m_bSwitchState) return false;

	return true;
}

void SLampCoreSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);
	s_Object->~SLampCoreSaveState();
}

ZHMTypeInfo SLampCoreSaveData::TypeInfo = ZHMTypeInfo("SLampCoreSaveData", sizeof(SLampCoreSaveData), alignof(SLampCoreSaveData), SLampCoreSaveData::WriteSimpleJson, SLampCoreSaveData::FromSimpleJson, SLampCoreSaveData::Serialize, SLampCoreSaveData::Equals, SLampCoreSaveData::Destroy);

void SLampCoreSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SLampCoreSaveState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLampCoreSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLampCoreSaveState::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SLampCoreSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SLampCoreSaveData, m_aEntities));
	TArray<SLampCoreSaveState>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SLampCoreSaveData, m_aData));
}

bool SLampCoreSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLampCoreSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLampCoreSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLampCoreSaveData::operator==(const SLampCoreSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLampCoreSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SLampCoreSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);
	s_Object->~SLampCoreSaveData();
}

ZHMTypeInfo SShotListenerSaveData::TypeInfo = ZHMTypeInfo("SShotListenerSaveData", sizeof(SShotListenerSaveData), alignof(SShotListenerSaveData), SShotListenerSaveData::WriteSimpleJson, SShotListenerSaveData::FromSimpleJson, SShotListenerSaveData::Serialize, SShotListenerSaveData::Equals, SShotListenerSaveData::Destroy);

void SShotListenerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNPCShotProcessed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNPCShotProcessed);

	p_Stream << "}";
}

void SShotListenerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_bNPCShotProcessed = simdjson::from_json_bool(p_Document["m_bNPCShotProcessed"]);

}

void SShotListenerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);

}

bool SShotListenerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShotListenerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShotListenerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShotListenerSaveData::operator==(const SShotListenerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShotListenerSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bNPCShotProcessed != p_Other.m_bNPCShotProcessed) return false;

	return true;
}

void SShotListenerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);
	s_Object->~SShotListenerSaveData();
}

ZHMTypeInfo SShotListenersSaveData::TypeInfo = ZHMTypeInfo("SShotListenersSaveData", sizeof(SShotListenersSaveData), alignof(SShotListenersSaveData), SShotListenersSaveData::WriteSimpleJson, SShotListenersSaveData::FromSimpleJson, SShotListenersSaveData::Serialize, SShotListenersSaveData::Equals, SShotListenersSaveData::Destroy);

void SShotListenersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SShotListenerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SShotListenersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SShotListenerSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SShotListenersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SShotListenersSaveData, m_aEntities));
	TArray<SShotListenerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SShotListenersSaveData, m_aData));
}

bool SShotListenersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShotListenersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShotListenersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShotListenersSaveData::operator==(const SShotListenersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShotListenersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SShotListenersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);
	s_Object->~SShotListenersSaveData();
}

ZHMTypeInfo SItsATrapSaveData::TypeInfo = ZHMTypeInfo("SItsATrapSaveData", sizeof(SItsATrapSaveData), alignof(SItsATrapSaveData), SItsATrapSaveData::WriteSimpleJson, SItsATrapSaveData::FromSimpleJson, SItsATrapSaveData::Serialize, SItsATrapSaveData::Equals, SItsATrapSaveData::Destroy);

void SItsATrapSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimer);

	p_Stream << "}";
}

void SItsATrapSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_fTimer = simdjson::from_json_float32(p_Document["m_fTimer"]);

}

void SItsATrapSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);

}

bool SItsATrapSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItsATrapSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItsATrapSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItsATrapSaveData::operator==(const SItsATrapSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItsATrapSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fTimer != p_Other.m_fTimer) return false;

	return true;
}

void SItsATrapSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);
	s_Object->~SItsATrapSaveData();
}

ZHMTypeInfo STrapsSaveData::TypeInfo = ZHMTypeInfo("STrapsSaveData", sizeof(STrapsSaveData), alignof(STrapsSaveData), STrapsSaveData::WriteSimpleJson, STrapsSaveData::FromSimpleJson, STrapsSaveData::Serialize, STrapsSaveData::Equals, STrapsSaveData::Destroy);

void STrapsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItsATrapSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrapsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STrapsSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SItsATrapSaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void STrapsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(STrapsSaveData, m_aEntities));
	TArray<SItsATrapSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(STrapsSaveData, m_aData));
}

bool STrapsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrapsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrapsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrapsSaveData::operator==(const STrapsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrapsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void STrapsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);
	s_Object->~STrapsSaveData();
}

ZHMTypeInfo SMathLerpSaveData_float32::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_float32", sizeof(SMathLerpSaveData_float32), alignof(SMathLerpSaveData_float32), SMathLerpSaveData_float32::WriteSimpleJson, SMathLerpSaveData_float32::FromSimpleJson, SMathLerpSaveData_float32::Serialize, SMathLerpSaveData_float32::Equals, SMathLerpSaveData_float32::Destroy);

void SMathLerpSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_A);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_B);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Target);

	s_Object->m_A = simdjson::from_json_float32(p_Document["m_A"]);

	s_Object->m_B = simdjson::from_json_float32(p_Document["m_B"]);

	s_Object->m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

}

void SMathLerpSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);

}

bool SMathLerpSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_float32::operator==(const SMathLerpSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_float32>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_float32::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);
	s_Object->~SMathLerpSaveData_float32();
}

ZHMTypeInfo SMathLerpsSaveData_float32::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_float32", sizeof(SMathLerpsSaveData_float32), alignof(SMathLerpsSaveData_float32), SMathLerpsSaveData_float32::WriteSimpleJson, SMathLerpsSaveData_float32::FromSimpleJson, SMathLerpsSaveData_float32::Serialize, SMathLerpsSaveData_float32::Equals, SMathLerpsSaveData_float32::Destroy);

void SMathLerpsSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_float32::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_float32::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathLerpsSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_float32, m_aEntities));
	TArray<SMathLerpSaveData_float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_float32, m_aData));
}

bool SMathLerpsSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_float32::operator==(const SMathLerpsSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_float32>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_float32::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);
	s_Object->~SMathLerpsSaveData_float32();
}

ZHMTypeInfo SMathLerpSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector2", sizeof(SMathLerpSaveData_SVector2), alignof(SMathLerpSaveData_SVector2), SMathLerpSaveData_SVector2::WriteSimpleJson, SMathLerpSaveData_SVector2::FromSimpleJson, SMathLerpSaveData_SVector2::Serialize, SMathLerpSaveData_SVector2::Equals, SMathLerpSaveData_SVector2::Destroy);

void SMathLerpSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Target);

	SVector2::FromSimpleJson(p_Document["m_A"], &s_Object->m_A);

	SVector2::FromSimpleJson(p_Document["m_B"], &s_Object->m_B);

	s_Object->m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

}

void SMathLerpSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);

	SVector2::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector2, m_A));
	SVector2::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector2, m_B));
}

bool SMathLerpSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector2::operator==(const SMathLerpSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector2>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);
	s_Object->~SMathLerpSaveData_SVector2();
}

ZHMTypeInfo SMathLerpsSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector2", sizeof(SMathLerpsSaveData_SVector2), alignof(SMathLerpsSaveData_SVector2), SMathLerpsSaveData_SVector2::WriteSimpleJson, SMathLerpsSaveData_SVector2::FromSimpleJson, SMathLerpsSaveData_SVector2::Serialize, SMathLerpsSaveData_SVector2::Equals, SMathLerpsSaveData_SVector2::Destroy);

void SMathLerpsSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SVector2::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathLerpsSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector2, m_aEntities));
	TArray<SMathLerpSaveData_SVector2>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector2, m_aData));
}

bool SMathLerpsSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector2::operator==(const SMathLerpsSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector2>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);
	s_Object->~SMathLerpsSaveData_SVector2();
}

ZHMTypeInfo SMathLerpSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector3", sizeof(SMathLerpSaveData_SVector3), alignof(SMathLerpSaveData_SVector3), SMathLerpSaveData_SVector3::WriteSimpleJson, SMathLerpSaveData_SVector3::FromSimpleJson, SMathLerpSaveData_SVector3::Serialize, SMathLerpSaveData_SVector3::Equals, SMathLerpSaveData_SVector3::Destroy);

void SMathLerpSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Target);

	SVector3::FromSimpleJson(p_Document["m_A"], &s_Object->m_A);

	SVector3::FromSimpleJson(p_Document["m_B"], &s_Object->m_B);

	s_Object->m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

}

void SMathLerpSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);

	SVector3::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector3, m_A));
	SVector3::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector3, m_B));
}

bool SMathLerpSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector3::operator==(const SMathLerpSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector3>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);
	s_Object->~SMathLerpSaveData_SVector3();
}

ZHMTypeInfo SMathLerpsSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector3", sizeof(SMathLerpsSaveData_SVector3), alignof(SMathLerpsSaveData_SVector3), SMathLerpsSaveData_SVector3::WriteSimpleJson, SMathLerpsSaveData_SVector3::FromSimpleJson, SMathLerpsSaveData_SVector3::Serialize, SMathLerpsSaveData_SVector3::Equals, SMathLerpsSaveData_SVector3::Destroy);

void SMathLerpsSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SVector3::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathLerpsSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector3, m_aEntities));
	TArray<SMathLerpSaveData_SVector3>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector3, m_aData));
}

bool SMathLerpsSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector3::operator==(const SMathLerpsSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector3>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);
	s_Object->~SMathLerpsSaveData_SVector3();
}

ZHMTypeInfo SMathLerpSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector4", sizeof(SMathLerpSaveData_SVector4), alignof(SMathLerpSaveData_SVector4), SMathLerpSaveData_SVector4::WriteSimpleJson, SMathLerpSaveData_SVector4::FromSimpleJson, SMathLerpSaveData_SVector4::Serialize, SMathLerpSaveData_SVector4::Equals, SMathLerpSaveData_SVector4::Destroy);

void SMathLerpSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Target);

	SVector4::FromSimpleJson(p_Document["m_A"], &s_Object->m_A);

	SVector4::FromSimpleJson(p_Document["m_B"], &s_Object->m_B);

	s_Object->m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

}

void SMathLerpSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);

	SVector4::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector4, m_A));
	SVector4::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector4, m_B));
}

bool SMathLerpSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector4::operator==(const SMathLerpSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector4>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);
	s_Object->~SMathLerpSaveData_SVector4();
}

ZHMTypeInfo SMathLerpsSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector4", sizeof(SMathLerpsSaveData_SVector4), alignof(SMathLerpsSaveData_SVector4), SMathLerpsSaveData_SVector4::WriteSimpleJson, SMathLerpsSaveData_SVector4::FromSimpleJson, SMathLerpsSaveData_SVector4::Serialize, SMathLerpsSaveData_SVector4::Equals, SMathLerpsSaveData_SVector4::Destroy);

void SMathLerpsSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SVector4::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathLerpsSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector4, m_aEntities));
	TArray<SMathLerpSaveData_SVector4>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector4, m_aData));
}

bool SMathLerpsSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector4::operator==(const SMathLerpsSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector4>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);
	s_Object->~SMathLerpsSaveData_SVector4();
}

ZHMTypeInfo SMathLerpSaveData_SColorRGB::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SColorRGB", sizeof(SMathLerpSaveData_SColorRGB), alignof(SMathLerpSaveData_SColorRGB), SMathLerpSaveData_SColorRGB::WriteSimpleJson, SMathLerpSaveData_SColorRGB::FromSimpleJson, SMathLerpSaveData_SColorRGB::Serialize, SMathLerpSaveData_SColorRGB::Equals, SMathLerpSaveData_SColorRGB::Destroy);

void SMathLerpSaveData_SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Target);

	SColorRGB::FromSimpleJson(p_Document["m_A"], &s_Object->m_A);

	SColorRGB::FromSimpleJson(p_Document["m_B"], &s_Object->m_B);

	s_Object->m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

}

void SMathLerpSaveData_SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);

	SColorRGB::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGB, m_A));
	SColorRGB::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGB, m_B));
}

bool SMathLerpSaveData_SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SColorRGB::operator==(const SMathLerpSaveData_SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SColorRGB>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SColorRGB::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);
	s_Object->~SMathLerpSaveData_SColorRGB();
}

ZHMTypeInfo SMathLerpsSaveData_SColorRGB::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SColorRGB", sizeof(SMathLerpsSaveData_SColorRGB), alignof(SMathLerpsSaveData_SColorRGB), SMathLerpsSaveData_SColorRGB::WriteSimpleJson, SMathLerpsSaveData_SColorRGB::FromSimpleJson, SMathLerpsSaveData_SColorRGB::Serialize, SMathLerpsSaveData_SColorRGB::Equals, SMathLerpsSaveData_SColorRGB::Destroy);

void SMathLerpsSaveData_SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SColorRGB::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SColorRGB::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathLerpsSaveData_SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGB, m_aEntities));
	TArray<SMathLerpSaveData_SColorRGB>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGB, m_aData));
}

bool SMathLerpsSaveData_SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SColorRGB::operator==(const SMathLerpsSaveData_SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SColorRGB>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SColorRGB::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);
	s_Object->~SMathLerpsSaveData_SColorRGB();
}

ZHMTypeInfo SMathLerpSaveData_SColorRGBA::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SColorRGBA", sizeof(SMathLerpSaveData_SColorRGBA), alignof(SMathLerpSaveData_SColorRGBA), SMathLerpSaveData_SColorRGBA::WriteSimpleJson, SMathLerpSaveData_SColorRGBA::FromSimpleJson, SMathLerpSaveData_SColorRGBA::Serialize, SMathLerpSaveData_SColorRGBA::Equals, SMathLerpSaveData_SColorRGBA::Destroy);

void SMathLerpSaveData_SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SColorRGBA::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SColorRGBA::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Target);

	SColorRGBA::FromSimpleJson(p_Document["m_A"], &s_Object->m_A);

	SColorRGBA::FromSimpleJson(p_Document["m_B"], &s_Object->m_B);

	s_Object->m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

}

void SMathLerpSaveData_SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);

	SColorRGBA::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGBA, m_A));
	SColorRGBA::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGBA, m_B));
}

bool SMathLerpSaveData_SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SColorRGBA::operator==(const SMathLerpSaveData_SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SColorRGBA>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SColorRGBA::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);
	s_Object->~SMathLerpSaveData_SColorRGBA();
}

ZHMTypeInfo SMathLerpsSaveData_SColorRGBA::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SColorRGBA", sizeof(SMathLerpsSaveData_SColorRGBA), alignof(SMathLerpsSaveData_SColorRGBA), SMathLerpsSaveData_SColorRGBA::WriteSimpleJson, SMathLerpsSaveData_SColorRGBA::FromSimpleJson, SMathLerpsSaveData_SColorRGBA::Serialize, SMathLerpsSaveData_SColorRGBA::Equals, SMathLerpsSaveData_SColorRGBA::Destroy);

void SMathLerpsSaveData_SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SColorRGBA::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SColorRGBA::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SMathLerpsSaveData_SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGBA, m_aEntities));
	TArray<SMathLerpSaveData_SColorRGBA>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGBA, m_aData));
}

bool SMathLerpsSaveData_SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SColorRGBA::operator==(const SMathLerpsSaveData_SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SColorRGBA>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SColorRGBA::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);
	s_Object->~SMathLerpsSaveData_SColorRGBA();
}

ZHMTypeInfo SGameEntitySaveData::TypeInfo = ZHMTypeInfo("SGameEntitySaveData", sizeof(SGameEntitySaveData), alignof(SGameEntitySaveData), SGameEntitySaveData::WriteSimpleJson, SGameEntitySaveData::FromSimpleJson, SGameEntitySaveData::Serialize, SGameEntitySaveData::Equals, SGameEntitySaveData::Destroy);

void SGameEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_DoorData") << ":";
	SDoorsSaveData::WriteSimpleJson(&s_Object->m_DoorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ShatterData") << ":";
	SShatterSaveData::WriteSimpleJson(&s_Object->m_ShatterData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemsData") << ":";
	SItemsSaveData::WriteSimpleJson(&s_Object->m_ItemsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_VolumeTriggersData") << ":";
	SVolumeTriggersSaveData::WriteSimpleJson(&s_Object->m_VolumeTriggersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_float32") << ":";
	SMathMultipliesSaveData_float32::WriteSimpleJson(&s_Object->m_MathMultipliesData_float32, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector2") << ":";
	SMathMultipliesSaveData_SVector2::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector2, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector3") << ":";
	SMathMultipliesSaveData_SVector3::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector3, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector4") << ":";
	SMathMultipliesSaveData_SVector4::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector4, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ShotListenersData") << ":";
	SShotListenersSaveData::WriteSimpleJson(&s_Object->m_ShotListenersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TrapsData") << ":";
	STrapsSaveData::WriteSimpleJson(&s_Object->m_TrapsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorProxiesData") << ":";
	SActorProxiesSaveData::WriteSimpleJson(&s_Object->m_ActorProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorStandInEntitiesData") << ":";
	SActorStandInEntitiesSaveData::WriteSimpleJson(&s_Object->m_ActorStandInEntitiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorBoneAttachmentsData") << ":";
	SActorBoneAttachmentsSaveData::WriteSimpleJson(&s_Object->m_ActorBoneAttachmentsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorKeywordProxiesData") << ":";
	SActorKeywordProxiesSaveData::WriteSimpleJson(&s_Object->m_ActorKeywordProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemKeywordProxiesData") << ":";
	SItemKeywordProxiesSaveData::WriteSimpleJson(&s_Object->m_ItemKeywordProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LampCoreData") << ":";
	SLampCoreSaveData::WriteSimpleJson(&s_Object->m_LampCoreData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_VIPEvacuationNodesData") << ":";
	SVIPEvacuationNodesSaveData::WriteSimpleJson(&s_Object->m_VIPEvacuationNodesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CollisionControllerAspectsData") << ":";
	SCollisionControllerAspectsSaveData::WriteSimpleJson(&s_Object->m_CollisionControllerAspectsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BodyContainersData") << ":";
	SBodyContainersSaveData::WriteSimpleJson(&s_Object->m_BodyContainersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_float32") << ":";
	SMathLerpsSaveData_float32::WriteSimpleJson(&s_Object->m_MathLerpsData_float32, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector2") << ":";
	SMathLerpsSaveData_SVector2::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector2, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector3") << ":";
	SMathLerpsSaveData_SVector3::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector3, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector4") << ":";
	SMathLerpsSaveData_SVector4::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector4, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SColorRGB") << ":";
	SMathLerpsSaveData_SColorRGB::WriteSimpleJson(&s_Object->m_MathLerpsData_SColorRGB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SColorRGBA") << ":";
	SMathLerpsSaveData_SColorRGBA::WriteSimpleJson(&s_Object->m_MathLerpsData_SColorRGBA, p_Stream);

	p_Stream << "}";
}

void SGameEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Target);

	SDoorsSaveData::FromSimpleJson(p_Document["m_DoorData"], &s_Object->m_DoorData);

	SShatterSaveData::FromSimpleJson(p_Document["m_ShatterData"], &s_Object->m_ShatterData);

	SItemsSaveData::FromSimpleJson(p_Document["m_ItemsData"], &s_Object->m_ItemsData);

	SVolumeTriggersSaveData::FromSimpleJson(p_Document["m_VolumeTriggersData"], &s_Object->m_VolumeTriggersData);

	SMathMultipliesSaveData_float32::FromSimpleJson(p_Document["m_MathMultipliesData_float32"], &s_Object->m_MathMultipliesData_float32);

	SMathMultipliesSaveData_SVector2::FromSimpleJson(p_Document["m_MathMultipliesData_Vector2"], &s_Object->m_MathMultipliesData_Vector2);

	SMathMultipliesSaveData_SVector3::FromSimpleJson(p_Document["m_MathMultipliesData_Vector3"], &s_Object->m_MathMultipliesData_Vector3);

	SMathMultipliesSaveData_SVector4::FromSimpleJson(p_Document["m_MathMultipliesData_Vector4"], &s_Object->m_MathMultipliesData_Vector4);

	SShotListenersSaveData::FromSimpleJson(p_Document["m_ShotListenersData"], &s_Object->m_ShotListenersData);

	STrapsSaveData::FromSimpleJson(p_Document["m_TrapsData"], &s_Object->m_TrapsData);

	SActorProxiesSaveData::FromSimpleJson(p_Document["m_ActorProxiesData"], &s_Object->m_ActorProxiesData);

	SActorStandInEntitiesSaveData::FromSimpleJson(p_Document["m_ActorStandInEntitiesData"], &s_Object->m_ActorStandInEntitiesData);

	SActorBoneAttachmentsSaveData::FromSimpleJson(p_Document["m_ActorBoneAttachmentsData"], &s_Object->m_ActorBoneAttachmentsData);

	SActorKeywordProxiesSaveData::FromSimpleJson(p_Document["m_ActorKeywordProxiesData"], &s_Object->m_ActorKeywordProxiesData);

	SItemKeywordProxiesSaveData::FromSimpleJson(p_Document["m_ItemKeywordProxiesData"], &s_Object->m_ItemKeywordProxiesData);

	SLampCoreSaveData::FromSimpleJson(p_Document["m_LampCoreData"], &s_Object->m_LampCoreData);

	SVIPEvacuationNodesSaveData::FromSimpleJson(p_Document["m_VIPEvacuationNodesData"], &s_Object->m_VIPEvacuationNodesData);

	SCollisionControllerAspectsSaveData::FromSimpleJson(p_Document["m_CollisionControllerAspectsData"], &s_Object->m_CollisionControllerAspectsData);

	SBodyContainersSaveData::FromSimpleJson(p_Document["m_BodyContainersData"], &s_Object->m_BodyContainersData);

	SMathLerpsSaveData_float32::FromSimpleJson(p_Document["m_MathLerpsData_float32"], &s_Object->m_MathLerpsData_float32);

	SMathLerpsSaveData_SVector2::FromSimpleJson(p_Document["m_MathLerpsData_SVector2"], &s_Object->m_MathLerpsData_SVector2);

	SMathLerpsSaveData_SVector3::FromSimpleJson(p_Document["m_MathLerpsData_SVector3"], &s_Object->m_MathLerpsData_SVector3);

	SMathLerpsSaveData_SVector4::FromSimpleJson(p_Document["m_MathLerpsData_SVector4"], &s_Object->m_MathLerpsData_SVector4);

	SMathLerpsSaveData_SColorRGB::FromSimpleJson(p_Document["m_MathLerpsData_SColorRGB"], &s_Object->m_MathLerpsData_SColorRGB);

	SMathLerpsSaveData_SColorRGBA::FromSimpleJson(p_Document["m_MathLerpsData_SColorRGBA"], &s_Object->m_MathLerpsData_SColorRGBA);

}

void SGameEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);

	SDoorsSaveData::Serialize(&s_Object->m_DoorData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_DoorData));
	SShatterSaveData::Serialize(&s_Object->m_ShatterData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ShatterData));
	SItemsSaveData::Serialize(&s_Object->m_ItemsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ItemsData));
	SVolumeTriggersSaveData::Serialize(&s_Object->m_VolumeTriggersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_VolumeTriggersData));
	SMathMultipliesSaveData_float32::Serialize(&s_Object->m_MathMultipliesData_float32, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_float32));
	SMathMultipliesSaveData_SVector2::Serialize(&s_Object->m_MathMultipliesData_Vector2, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector2));
	SMathMultipliesSaveData_SVector3::Serialize(&s_Object->m_MathMultipliesData_Vector3, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector3));
	SMathMultipliesSaveData_SVector4::Serialize(&s_Object->m_MathMultipliesData_Vector4, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector4));
	SShotListenersSaveData::Serialize(&s_Object->m_ShotListenersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ShotListenersData));
	STrapsSaveData::Serialize(&s_Object->m_TrapsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_TrapsData));
	SActorProxiesSaveData::Serialize(&s_Object->m_ActorProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorProxiesData));
	SActorStandInEntitiesSaveData::Serialize(&s_Object->m_ActorStandInEntitiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorStandInEntitiesData));
	SActorBoneAttachmentsSaveData::Serialize(&s_Object->m_ActorBoneAttachmentsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorBoneAttachmentsData));
	SActorKeywordProxiesSaveData::Serialize(&s_Object->m_ActorKeywordProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorKeywordProxiesData));
	SItemKeywordProxiesSaveData::Serialize(&s_Object->m_ItemKeywordProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ItemKeywordProxiesData));
	SLampCoreSaveData::Serialize(&s_Object->m_LampCoreData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_LampCoreData));
	SVIPEvacuationNodesSaveData::Serialize(&s_Object->m_VIPEvacuationNodesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_VIPEvacuationNodesData));
	SCollisionControllerAspectsSaveData::Serialize(&s_Object->m_CollisionControllerAspectsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_CollisionControllerAspectsData));
	SBodyContainersSaveData::Serialize(&s_Object->m_BodyContainersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_BodyContainersData));
	SMathLerpsSaveData_float32::Serialize(&s_Object->m_MathLerpsData_float32, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_float32));
	SMathLerpsSaveData_SVector2::Serialize(&s_Object->m_MathLerpsData_SVector2, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector2));
	SMathLerpsSaveData_SVector3::Serialize(&s_Object->m_MathLerpsData_SVector3, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector3));
	SMathLerpsSaveData_SVector4::Serialize(&s_Object->m_MathLerpsData_SVector4, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector4));
	SMathLerpsSaveData_SColorRGB::Serialize(&s_Object->m_MathLerpsData_SColorRGB, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SColorRGB));
	SMathLerpsSaveData_SColorRGBA::Serialize(&s_Object->m_MathLerpsData_SColorRGBA, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SColorRGBA));
}

bool SGameEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameEntitySaveData::operator==(const SGameEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameEntitySaveData>)
		return false;

	if (m_DoorData != p_Other.m_DoorData) return false;
	if (m_ShatterData != p_Other.m_ShatterData) return false;
	if (m_ItemsData != p_Other.m_ItemsData) return false;
	if (m_VolumeTriggersData != p_Other.m_VolumeTriggersData) return false;
	if (m_MathMultipliesData_float32 != p_Other.m_MathMultipliesData_float32) return false;
	if (m_MathMultipliesData_Vector2 != p_Other.m_MathMultipliesData_Vector2) return false;
	if (m_MathMultipliesData_Vector3 != p_Other.m_MathMultipliesData_Vector3) return false;
	if (m_MathMultipliesData_Vector4 != p_Other.m_MathMultipliesData_Vector4) return false;
	if (m_ShotListenersData != p_Other.m_ShotListenersData) return false;
	if (m_TrapsData != p_Other.m_TrapsData) return false;
	if (m_ActorProxiesData != p_Other.m_ActorProxiesData) return false;
	if (m_ActorStandInEntitiesData != p_Other.m_ActorStandInEntitiesData) return false;
	if (m_ActorBoneAttachmentsData != p_Other.m_ActorBoneAttachmentsData) return false;
	if (m_ActorKeywordProxiesData != p_Other.m_ActorKeywordProxiesData) return false;
	if (m_ItemKeywordProxiesData != p_Other.m_ItemKeywordProxiesData) return false;
	if (m_LampCoreData != p_Other.m_LampCoreData) return false;
	if (m_VIPEvacuationNodesData != p_Other.m_VIPEvacuationNodesData) return false;
	if (m_CollisionControllerAspectsData != p_Other.m_CollisionControllerAspectsData) return false;
	if (m_BodyContainersData != p_Other.m_BodyContainersData) return false;
	if (m_MathLerpsData_float32 != p_Other.m_MathLerpsData_float32) return false;
	if (m_MathLerpsData_SVector2 != p_Other.m_MathLerpsData_SVector2) return false;
	if (m_MathLerpsData_SVector3 != p_Other.m_MathLerpsData_SVector3) return false;
	if (m_MathLerpsData_SVector4 != p_Other.m_MathLerpsData_SVector4) return false;
	if (m_MathLerpsData_SColorRGB != p_Other.m_MathLerpsData_SColorRGB) return false;
	if (m_MathLerpsData_SColorRGBA != p_Other.m_MathLerpsData_SColorRGBA) return false;

	return true;
}

void SGameEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);
	s_Object->~SGameEntitySaveData();
}

ZHMTypeInfo SKeywordSaveData::TypeInfo = ZHMTypeInfo("SKeywordSaveData", sizeof(SKeywordSaveData), alignof(SKeywordSaveData), SKeywordSaveData::WriteSimpleJson, SKeywordSaveData::FromSimpleJson, SKeywordSaveData::Serialize, SKeywordSaveData::Equals, SKeywordSaveData::Destroy);

void SKeywordSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_HolderSaveableId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_HolderSaveableId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_KeywordID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_KeywordID);

	p_Stream << "}";
}

void SKeywordSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SKeywordSaveData*>(p_Target);

	s_Object->m_HolderSaveableId = simdjson::from_json_uint32(p_Document["m_HolderSaveableId"]);

	s_Object->m_KeywordID = simdjson::from_json_int32(p_Document["m_KeywordID"]);

}

void SKeywordSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);

}

bool SKeywordSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKeywordSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKeywordSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKeywordSaveData::operator==(const SKeywordSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKeywordSaveData>)
		return false;

	if (m_HolderSaveableId != p_Other.m_HolderSaveableId) return false;
	if (m_KeywordID != p_Other.m_KeywordID) return false;

	return true;
}

void SKeywordSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);
	s_Object->~SKeywordSaveData();
}

ZHMTypeInfo SGameKeywordManagerSaveData::TypeInfo = ZHMTypeInfo("SGameKeywordManagerSaveData", sizeof(SGameKeywordManagerSaveData), alignof(SGameKeywordManagerSaveData), SGameKeywordManagerSaveData::WriteSimpleJson, SGameKeywordManagerSaveData::FromSimpleJson, SGameKeywordManagerSaveData::Serialize, SGameKeywordManagerSaveData::Equals, SGameKeywordManagerSaveData::Destroy);

void SGameKeywordManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKeywordsData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeywordsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeywordsData[i];
		SKeywordSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aKeywordsData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKeywordStringData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeywordStringData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeywordStringData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKeywordStringData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameKeywordManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKeywordsData"];
	s_Object->m_aKeywordsData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SKeywordSaveData::FromSimpleJson(s_Item0, &s_Object->m_aKeywordsData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKeywordStringData"];
	s_Object->m_aKeywordStringData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aKeywordStringData[s_Index0] = std::string_view(s_Item0);
		++s_Index0;
	}
	}

}

void SGameKeywordManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);

	TArray<SKeywordSaveData>::Serialize(&s_Object->m_aKeywordsData, p_Serializer, p_OwnOffset + offsetof(SGameKeywordManagerSaveData, m_aKeywordsData));
	TArray<ZString>::Serialize(&s_Object->m_aKeywordStringData, p_Serializer, p_OwnOffset + offsetof(SGameKeywordManagerSaveData, m_aKeywordStringData));
}

bool SGameKeywordManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameKeywordManagerSaveData::operator==(const SGameKeywordManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameKeywordManagerSaveData>)
		return false;

	if (m_aKeywordsData != p_Other.m_aKeywordsData) return false;
	if (m_aKeywordStringData != p_Other.m_aKeywordStringData) return false;

	return true;
}

void SGameKeywordManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);
	s_Object->~SGameKeywordManagerSaveData();
}

ZHMTypeInfo STimerEntityCommandSaveData::TypeInfo = ZHMTypeInfo("STimerEntityCommandSaveData", sizeof(STimerEntityCommandSaveData), alignof(STimerEntityCommandSaveData), STimerEntityCommandSaveData::WriteSimpleJson, STimerEntityCommandSaveData::FromSimpleJson, STimerEntityCommandSaveData::Serialize, STimerEntityCommandSaveData::Equals, STimerEntityCommandSaveData::Destroy);

void STimerEntityCommandSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ETimerEntityCommandType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInterval);

	p_Stream << "}";
}

void STimerEntityCommandSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Target);

	s_Object->m_eType = static_cast<ETimerEntityCommandType>(ZHMEnums::GetEnumValueByName("ETimerEntityCommandType", std::string_view(p_Document["m_eType"])));

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object->m_fInterval = simdjson::from_json_float32(p_Document["m_fInterval"]);

}

void STimerEntityCommandSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);

}

bool STimerEntityCommandSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntityCommandSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntityCommandSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntityCommandSaveData::operator==(const STimerEntityCommandSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntityCommandSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_fInterval != p_Other.m_fInterval) return false;

	return true;
}

void STimerEntityCommandSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);
	s_Object->~STimerEntityCommandSaveData();
}

ZHMTypeInfo STimerEntityStateSaveData::TypeInfo = ZHMTypeInfo("STimerEntityStateSaveData", sizeof(STimerEntityStateSaveData), alignof(STimerEntityStateSaveData), STimerEntityStateSaveData::WriteSimpleJson, STimerEntityStateSaveData::FromSimpleJson, STimerEntityStateSaveData::Serialize, STimerEntityStateSaveData::Equals, STimerEntityStateSaveData::Destroy);

void STimerEntityStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fNextEventTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fNextEventTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPending") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPending);

	p_Stream << "}";
}

void STimerEntityStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Target);

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object->m_fNextEventTime = simdjson::from_json_float32(p_Document["m_fNextEventTime"]);

	s_Object->m_bPending = simdjson::from_json_bool(p_Document["m_bPending"]);

}

void STimerEntityStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);

}

bool STimerEntityStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntityStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntityStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntityStateSaveData::operator==(const STimerEntityStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntityStateSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_fNextEventTime != p_Other.m_fNextEventTime) return false;
	if (m_bPending != p_Other.m_bPending) return false;

	return true;
}

void STimerEntityStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);
	s_Object->~STimerEntityStateSaveData();
}

ZHMTypeInfo SGameTimersSaveData::TypeInfo = ZHMTypeInfo("SGameTimersSaveData", sizeof(SGameTimersSaveData), alignof(SGameTimersSaveData), SGameTimersSaveData::WriteSimpleJson, SGameTimersSaveData::FromSimpleJson, SGameTimersSaveData::Serialize, SGameTimersSaveData::Equals, SGameTimersSaveData::Destroy);

void SGameTimersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTimerEntityCommands") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTimerEntityCommands.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTimerEntityCommands[i];
		STimerEntityCommandSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTimerEntityCommands.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTimerEntityState") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTimerEntityState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTimerEntityState[i];
		STimerEntityStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTimerEntityState.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPendingTimers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPendingTimers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPendingTimers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aPendingTimers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameTimersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTimerEntityCommands"];
	s_Object->m_aTimerEntityCommands.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STimerEntityCommandSaveData::FromSimpleJson(s_Item0, &s_Object->m_aTimerEntityCommands[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTimerEntityState"];
	s_Object->m_aTimerEntityState.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STimerEntityStateSaveData::FromSimpleJson(s_Item0, &s_Object->m_aTimerEntityState[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPendingTimers"];
	s_Object->m_aPendingTimers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aPendingTimers[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SGameTimersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);

	TArray<STimerEntityCommandSaveData>::Serialize(&s_Object->m_aTimerEntityCommands, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aTimerEntityCommands));
	TArray<STimerEntityStateSaveData>::Serialize(&s_Object->m_aTimerEntityState, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aTimerEntityState));
	TArray<uint32>::Serialize(&s_Object->m_aPendingTimers, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aPendingTimers));
}

bool SGameTimersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameTimersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameTimersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameTimersSaveData::operator==(const SGameTimersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameTimersSaveData>)
		return false;

	if (m_aTimerEntityCommands != p_Other.m_aTimerEntityCommands) return false;
	if (m_aTimerEntityState != p_Other.m_aTimerEntityState) return false;
	if (m_aPendingTimers != p_Other.m_aPendingTimers) return false;

	return true;
}

void SGameTimersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);
	s_Object->~SGameTimersSaveData();
}

ZHMTypeInfo SLightSaveData::TypeInfo = ZHMTypeInfo("SLightSaveData", sizeof(SLightSaveData), alignof(SLightSaveData), SLightSaveData::WriteSimpleJson, SLightSaveData::FromSimpleJson, SLightSaveData::Serialize, SLightSaveData::Equals, SLightSaveData::Destroy);

void SLightSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DiffuseColor") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_DiffuseColor, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDiffusePower") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDiffusePower);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAspectXByY_Actual") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAspectXByY_Actual);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SLightSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLightSaveData*>(p_Target);

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	SColorRGB::FromSimpleJson(p_Document["m_DiffuseColor"], &s_Object->m_DiffuseColor);

	s_Object->m_fDiffusePower = simdjson::from_json_float32(p_Document["m_fDiffusePower"]);

	s_Object->m_fAspectXByY_Actual = simdjson::from_json_float32(p_Document["m_fAspectXByY_Actual"]);

	s_Object->m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

}

void SLightSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);

	SColorRGB::Serialize(&s_Object->m_DiffuseColor, p_Serializer, p_OwnOffset + offsetof(SLightSaveData, m_DiffuseColor));
}

bool SLightSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLightSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLightSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLightSaveData::operator==(const SLightSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLightSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_DiffuseColor != p_Other.m_DiffuseColor) return false;
	if (m_fDiffusePower != p_Other.m_fDiffusePower) return false;
	if (m_fAspectXByY_Actual != p_Other.m_fAspectXByY_Actual) return false;
	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

void SLightSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);
	s_Object->~SLightSaveData();
}

ZHMTypeInfo SPostfilterParametersSaveData::TypeInfo = ZHMTypeInfo("SPostfilterParametersSaveData", sizeof(SPostfilterParametersSaveData), alignof(SPostfilterParametersSaveData), SPostfilterParametersSaveData::WriteSimpleJson, SPostfilterParametersSaveData::FromSimpleJson, SPostfilterParametersSaveData::Serialize, SPostfilterParametersSaveData::Equals, SPostfilterParametersSaveData::Destroy);

void SPostfilterParametersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDepthOfFieldEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDepthOfFieldEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDepthOfFieldBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDepthOfFieldBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRadialBlurEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRadialBlurEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadialBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadialBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRadialBlurCenter") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vRadialBlurCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadialBlurStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadialBlurStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpatialBlurEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpatialBlurEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSpatialBlurCenter") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vSpatialBlurCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurFade") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurFade);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDistortionWobbleEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDistortionWobbleEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistortionWobbleScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistortionWobbleScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDistortionWobbleWaveLength") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vDistortionWobbleWaveLength, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDistortionWobbleSpeed") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vDistortionWobbleSpeed, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDistortionWobbleUseRealTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDistortionWobbleUseRealTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHDRActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHDRActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHDREnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHDREnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationSpeed") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationSpeed, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationLuminanceMinMax") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationLuminanceMinMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationMiddleGrayMinMax") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationMiddleGrayMinMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRWhitePoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRWhitePoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRBrightPassThreshold") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRBrightPassThreshold);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRBrightPassMaxPercentage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRBrightPassMaxPercentage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HDRColorTint") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_HDRColorTint, p_Stream);

	p_Stream << "}";
}

void SPostfilterParametersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Target);

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object->m_bDepthOfFieldEnabled = simdjson::from_json_bool(p_Document["m_bDepthOfFieldEnabled"]);

	s_Object->m_fDepthOfFieldBlurriness = simdjson::from_json_float32(p_Document["m_fDepthOfFieldBlurriness"]);

	s_Object->m_bRadialBlurEnabled = simdjson::from_json_bool(p_Document["m_bRadialBlurEnabled"]);

	s_Object->m_fRadialBlurriness = simdjson::from_json_float32(p_Document["m_fRadialBlurriness"]);

	SVector2::FromSimpleJson(p_Document["m_vRadialBlurCenter"], &s_Object->m_vRadialBlurCenter);

	s_Object->m_fRadialBlurStart = simdjson::from_json_float32(p_Document["m_fRadialBlurStart"]);

	s_Object->m_bSpatialBlurEnabled = simdjson::from_json_bool(p_Document["m_bSpatialBlurEnabled"]);

	s_Object->m_fSpatialBlurriness = simdjson::from_json_float32(p_Document["m_fSpatialBlurriness"]);

	SVector3::FromSimpleJson(p_Document["m_vSpatialBlurCenter"], &s_Object->m_vSpatialBlurCenter);

	s_Object->m_fSpatialBlurStart = simdjson::from_json_float32(p_Document["m_fSpatialBlurStart"]);

	s_Object->m_fSpatialBlurFade = simdjson::from_json_float32(p_Document["m_fSpatialBlurFade"]);

	s_Object->m_bDistortionWobbleEnabled = simdjson::from_json_bool(p_Document["m_bDistortionWobbleEnabled"]);

	s_Object->m_fDistortionWobbleScale = simdjson::from_json_float32(p_Document["m_fDistortionWobbleScale"]);

	SVector2::FromSimpleJson(p_Document["m_vDistortionWobbleWaveLength"], &s_Object->m_vDistortionWobbleWaveLength);

	SVector2::FromSimpleJson(p_Document["m_vDistortionWobbleSpeed"], &s_Object->m_vDistortionWobbleSpeed);

	s_Object->m_bDistortionWobbleUseRealTime = simdjson::from_json_bool(p_Document["m_bDistortionWobbleUseRealTime"]);

	s_Object->m_bHDRActive = simdjson::from_json_bool(p_Document["m_bHDRActive"]);

	s_Object->m_bHDREnabled = simdjson::from_json_bool(p_Document["m_bHDREnabled"]);

	SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationSpeed"], &s_Object->m_vHDRAdaptationSpeed);

	SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationLuminanceMinMax"], &s_Object->m_vHDRAdaptationLuminanceMinMax);

	SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationMiddleGrayMinMax"], &s_Object->m_vHDRAdaptationMiddleGrayMinMax);

	s_Object->m_fHDRWhitePoint = simdjson::from_json_float32(p_Document["m_fHDRWhitePoint"]);

	s_Object->m_fHDRBrightPassThreshold = simdjson::from_json_float32(p_Document["m_fHDRBrightPassThreshold"]);

	s_Object->m_fHDRBrightPassMaxPercentage = simdjson::from_json_float32(p_Document["m_fHDRBrightPassMaxPercentage"]);

	SColorRGB::FromSimpleJson(p_Document["m_HDRColorTint"], &s_Object->m_HDRColorTint);

}

void SPostfilterParametersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);

	SVector2::Serialize(&s_Object->m_vRadialBlurCenter, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vRadialBlurCenter));
	SVector3::Serialize(&s_Object->m_vSpatialBlurCenter, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vSpatialBlurCenter));
	SVector2::Serialize(&s_Object->m_vDistortionWobbleWaveLength, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vDistortionWobbleWaveLength));
	SVector2::Serialize(&s_Object->m_vDistortionWobbleSpeed, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vDistortionWobbleSpeed));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationSpeed, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationSpeed));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationLuminanceMinMax, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationLuminanceMinMax));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationMiddleGrayMinMax, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationMiddleGrayMinMax));
	SColorRGB::Serialize(&s_Object->m_HDRColorTint, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_HDRColorTint));
}

bool SPostfilterParametersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPostfilterParametersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPostfilterParametersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPostfilterParametersSaveData::operator==(const SPostfilterParametersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPostfilterParametersSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bDepthOfFieldEnabled != p_Other.m_bDepthOfFieldEnabled) return false;
	if (m_fDepthOfFieldBlurriness != p_Other.m_fDepthOfFieldBlurriness) return false;
	if (m_bRadialBlurEnabled != p_Other.m_bRadialBlurEnabled) return false;
	if (m_fRadialBlurriness != p_Other.m_fRadialBlurriness) return false;
	if (m_vRadialBlurCenter != p_Other.m_vRadialBlurCenter) return false;
	if (m_fRadialBlurStart != p_Other.m_fRadialBlurStart) return false;
	if (m_bSpatialBlurEnabled != p_Other.m_bSpatialBlurEnabled) return false;
	if (m_fSpatialBlurriness != p_Other.m_fSpatialBlurriness) return false;
	if (m_vSpatialBlurCenter != p_Other.m_vSpatialBlurCenter) return false;
	if (m_fSpatialBlurStart != p_Other.m_fSpatialBlurStart) return false;
	if (m_fSpatialBlurFade != p_Other.m_fSpatialBlurFade) return false;
	if (m_bDistortionWobbleEnabled != p_Other.m_bDistortionWobbleEnabled) return false;
	if (m_fDistortionWobbleScale != p_Other.m_fDistortionWobbleScale) return false;
	if (m_vDistortionWobbleWaveLength != p_Other.m_vDistortionWobbleWaveLength) return false;
	if (m_vDistortionWobbleSpeed != p_Other.m_vDistortionWobbleSpeed) return false;
	if (m_bDistortionWobbleUseRealTime != p_Other.m_bDistortionWobbleUseRealTime) return false;
	if (m_bHDRActive != p_Other.m_bHDRActive) return false;
	if (m_bHDREnabled != p_Other.m_bHDREnabled) return false;
	if (m_vHDRAdaptationSpeed != p_Other.m_vHDRAdaptationSpeed) return false;
	if (m_vHDRAdaptationLuminanceMinMax != p_Other.m_vHDRAdaptationLuminanceMinMax) return false;
	if (m_vHDRAdaptationMiddleGrayMinMax != p_Other.m_vHDRAdaptationMiddleGrayMinMax) return false;
	if (m_fHDRWhitePoint != p_Other.m_fHDRWhitePoint) return false;
	if (m_fHDRBrightPassThreshold != p_Other.m_fHDRBrightPassThreshold) return false;
	if (m_fHDRBrightPassMaxPercentage != p_Other.m_fHDRBrightPassMaxPercentage) return false;
	if (m_HDRColorTint != p_Other.m_HDRColorTint) return false;

	return true;
}

void SPostfilterParametersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);
	s_Object->~SPostfilterParametersSaveData();
}

ZHMTypeInfo SRenderMaterialSaveData::TypeInfo = ZHMTypeInfo("SRenderMaterialSaveData", sizeof(SRenderMaterialSaveData), alignof(SRenderMaterialSaveData), SRenderMaterialSaveData::WriteSimpleJson, SRenderMaterialSaveData::FromSimpleJson, SRenderMaterialSaveData::Serialize, SRenderMaterialSaveData::Equals, SRenderMaterialSaveData::Destroy);

void SRenderMaterialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDynamicParametersOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDynamicParametersOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);

	p_Stream << "}";
}

void SRenderMaterialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Target);

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object->m_nDynamicParametersOffset = simdjson::from_json_uint32(p_Document["m_nDynamicParametersOffset"]);

	s_Object->m_bActive = simdjson::from_json_bool(p_Document["m_bActive"]);

}

void SRenderMaterialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);

}

bool SRenderMaterialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRenderMaterialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRenderMaterialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRenderMaterialSaveData::operator==(const SRenderMaterialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRenderMaterialSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_nDynamicParametersOffset != p_Other.m_nDynamicParametersOffset) return false;
	if (m_bActive != p_Other.m_bActive) return false;

	return true;
}

void SRenderMaterialSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);
	s_Object->~SRenderMaterialSaveData();
}

ZHMTypeInfo SParticleEmitterSaveData::TypeInfo = ZHMTypeInfo("SParticleEmitterSaveData", sizeof(SParticleEmitterSaveData), alignof(SParticleEmitterSaveData), SParticleEmitterSaveData::WriteSimpleJson, SParticleEmitterSaveData::FromSimpleJson, SParticleEmitterSaveData::Serialize, SParticleEmitterSaveData::Equals, SParticleEmitterSaveData::Destroy);

void SParticleEmitterSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionTimeLeft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionTimeLeft);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionTimeFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionTimeFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionCntLeft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionCntLeft);

	p_Stream << "}";
}

void SParticleEmitterSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Target);

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object->m_bIsActivated = simdjson::from_json_bool(p_Document["m_bIsActivated"]);

	s_Object->m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	s_Object->m_fEmissionTimeLeft = simdjson::from_json_float32(p_Document["m_fEmissionTimeLeft"]);

	s_Object->m_fEmissionTimeFraction = simdjson::from_json_float32(p_Document["m_fEmissionTimeFraction"]);

	s_Object->m_fEmissionCntLeft = simdjson::from_json_float32(p_Document["m_fEmissionCntLeft"]);

}

void SParticleEmitterSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);

}

bool SParticleEmitterSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SParticleEmitterSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SParticleEmitterSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SParticleEmitterSaveData::operator==(const SParticleEmitterSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SParticleEmitterSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsActivated != p_Other.m_bIsActivated) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;
	if (m_fEmissionTimeLeft != p_Other.m_fEmissionTimeLeft) return false;
	if (m_fEmissionTimeFraction != p_Other.m_fEmissionTimeFraction) return false;
	if (m_fEmissionCntLeft != p_Other.m_fEmissionCntLeft) return false;

	return true;
}

void SParticleEmitterSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);
	s_Object->~SParticleEmitterSaveData();
}

ZHMTypeInfo SGateSaveData::TypeInfo = ZHMTypeInfo("SGateSaveData", sizeof(SGateSaveData), alignof(SGateSaveData), SGateSaveData::WriteSimpleJson, SGateSaveData::FromSimpleJson, SGateSaveData::Serialize, SGateSaveData::Equals, SGateSaveData::Destroy);

void SGateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOpen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOpen);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpenFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpenFraction);

	p_Stream << "}";
}

void SGateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGateSaveData*>(p_Target);

	s_Object->m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object->m_bIsOpen = simdjson::from_json_bool(p_Document["m_bIsOpen"]);

	s_Object->m_fOpenFraction = simdjson::from_json_float32(p_Document["m_fOpenFraction"]);

}

void SGateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);

}

bool SGateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGateSaveData::operator==(const SGateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGateSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsOpen != p_Other.m_bIsOpen) return false;
	if (m_fOpenFraction != p_Other.m_fOpenFraction) return false;

	return true;
}

void SGateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);
	s_Object->~SGateSaveData();
}

ZHMTypeInfo SGameplayRenderablesSaveData::TypeInfo = ZHMTypeInfo("SGameplayRenderablesSaveData", sizeof(SGameplayRenderablesSaveData), alignof(SGameplayRenderablesSaveData), SGameplayRenderablesSaveData::WriteSimpleJson, SGameplayRenderablesSaveData::FromSimpleJson, SGameplayRenderablesSaveData::Serialize, SGameplayRenderablesSaveData::Equals, SGameplayRenderablesSaveData::Destroy);

void SGameplayRenderablesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aLightData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aLightData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aLightData[i];
		SLightSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aLightData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMaterialData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMaterialData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMaterialData[i];
		SRenderMaterialSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aMaterialData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aParticleData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aParticleData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aParticleData[i];
		SParticleEmitterSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aParticleData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneAttachData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneAttachData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneAttachData[i];
		SBoneAttachSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBoneAttachData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPostFilterParametersData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPostFilterParametersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPostFilterParametersData[i];
		SPostfilterParametersSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPostFilterParametersData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGateData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGateData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGateData[i];
		SGateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGateData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicParametersData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicParametersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicParametersData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDynamicParametersData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameplayRenderablesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aLightData"];
	s_Object->m_aLightData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLightSaveData::FromSimpleJson(s_Item0, &s_Object->m_aLightData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aMaterialData"];
	s_Object->m_aMaterialData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SRenderMaterialSaveData::FromSimpleJson(s_Item0, &s_Object->m_aMaterialData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aParticleData"];
	s_Object->m_aParticleData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SParticleEmitterSaveData::FromSimpleJson(s_Item0, &s_Object->m_aParticleData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneAttachData"];
	s_Object->m_aBoneAttachData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBoneAttachSaveData::FromSimpleJson(s_Item0, &s_Object->m_aBoneAttachData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPostFilterParametersData"];
	s_Object->m_aPostFilterParametersData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SPostfilterParametersSaveData::FromSimpleJson(s_Item0, &s_Object->m_aPostFilterParametersData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGateData"];
	s_Object->m_aGateData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SGateSaveData::FromSimpleJson(s_Item0, &s_Object->m_aGateData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDynamicParametersData"];
	s_Object->m_aDynamicParametersData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aDynamicParametersData[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

}

void SGameplayRenderablesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);

	TArray<SLightSaveData>::Serialize(&s_Object->m_aLightData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aLightData));
	TArray<SRenderMaterialSaveData>::Serialize(&s_Object->m_aMaterialData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aMaterialData));
	TArray<SParticleEmitterSaveData>::Serialize(&s_Object->m_aParticleData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aParticleData));
	TArray<SBoneAttachSaveData>::Serialize(&s_Object->m_aBoneAttachData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aBoneAttachData));
	TArray<SPostfilterParametersSaveData>::Serialize(&s_Object->m_aPostFilterParametersData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aPostFilterParametersData));
	TArray<SGateSaveData>::Serialize(&s_Object->m_aGateData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aGateData));
	TArray<uint8>::Serialize(&s_Object->m_aDynamicParametersData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aDynamicParametersData));
}

bool SGameplayRenderablesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameplayRenderablesSaveData::operator==(const SGameplayRenderablesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameplayRenderablesSaveData>)
		return false;

	if (m_aLightData != p_Other.m_aLightData) return false;
	if (m_aMaterialData != p_Other.m_aMaterialData) return false;
	if (m_aParticleData != p_Other.m_aParticleData) return false;
	if (m_aBoneAttachData != p_Other.m_aBoneAttachData) return false;
	if (m_aPostFilterParametersData != p_Other.m_aPostFilterParametersData) return false;
	if (m_aGateData != p_Other.m_aGateData) return false;
	if (m_aDynamicParametersData != p_Other.m_aDynamicParametersData) return false;

	return true;
}

void SGameplayRenderablesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);
	s_Object->~SGameplayRenderablesSaveData();
}

ZHMTypeInfo SGetHelpGroupSaveData::TypeInfo = ZHMTypeInfo("SGetHelpGroupSaveData", sizeof(SGetHelpGroupSaveData), alignof(SGetHelpGroupSaveData), SGetHelpGroupSaveData::WriteSimpleJson, SGetHelpGroupSaveData::FromSimpleJson, SGetHelpGroupSaveData::Serialize, SGetHelpGroupSaveData::Equals, SGetHelpGroupSaveData::Destroy);

void SGetHelpGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vLastKnownTargetPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vLastKnownTargetPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rReturnNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rReturnNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_blocked") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_blocked.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_blocked[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_blocked.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReportingToHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReportingToHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStartedReportDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedReportDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMultipleBodies") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMultipleBodies);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGetHelpOrderCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGetHelpOrderCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDoneReporting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneReporting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGetHelpCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGetHelpCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pReporter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pReporter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_additionalGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_additionalGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_additionalGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_additionalGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGetHelpGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vLastKnownTargetPosition"], &s_Object->m_vLastKnownTargetPosition);

	s_Object->m_rReturnNode = simdjson::from_json_uint16(p_Document["m_rReturnNode"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_blocked"];
	s_Object->m_blocked.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_blocked[s_Index0] = simdjson::from_json_uint16(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_bReportingToHitman = simdjson::from_json_bool(p_Document["m_bReportingToHitman"]);

	s_Object->m_bStartedReportDialog = simdjson::from_json_bool(p_Document["m_bStartedReportDialog"]);

	s_Object->m_bMultipleBodies = simdjson::from_json_bool(p_Document["m_bMultipleBodies"]);

	s_Object->m_bGetHelpOrderCompleted = simdjson::from_json_bool(p_Document["m_bGetHelpOrderCompleted"]);

	s_Object->m_bDoneReporting = simdjson::from_json_bool(p_Document["m_bDoneReporting"]);

	ZGameTime::FromSimpleJson(p_Document["m_tGetHelpCompleted"], &s_Object->m_tGetHelpCompleted);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object->m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	s_Object->m_pReporter = simdjson::from_json_uint32(p_Document["m_pReporter"]);

	s_Object->m_pGuard = simdjson::from_json_uint32(p_Document["m_pGuard"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_additionalGuards"];
	s_Object->m_additionalGuards.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_additionalGuards[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SGetHelpGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vLastKnownTargetPosition, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_vLastKnownTargetPosition));
	TArray<uint16>::Serialize(&s_Object->m_blocked, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_blocked));
	ZGameTime::Serialize(&s_Object->m_tGetHelpCompleted, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_tGetHelpCompleted));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_fsmState));
	TArray<uint32>::Serialize(&s_Object->m_additionalGuards, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_additionalGuards));
}

bool SGetHelpGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpGroupSaveData::operator==(const SGetHelpGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpGroupSaveData>)
		return false;

	if (m_vLastKnownTargetPosition != p_Other.m_vLastKnownTargetPosition) return false;
	if (m_rReturnNode != p_Other.m_rReturnNode) return false;
	if (m_blocked != p_Other.m_blocked) return false;
	if (m_bReportingToHitman != p_Other.m_bReportingToHitman) return false;
	if (m_bStartedReportDialog != p_Other.m_bStartedReportDialog) return false;
	if (m_bMultipleBodies != p_Other.m_bMultipleBodies) return false;
	if (m_bGetHelpOrderCompleted != p_Other.m_bGetHelpOrderCompleted) return false;
	if (m_bDoneReporting != p_Other.m_bDoneReporting) return false;
	if (m_tGetHelpCompleted != p_Other.m_tGetHelpCompleted) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pReporter != p_Other.m_pReporter) return false;
	if (m_pGuard != p_Other.m_pGuard) return false;
	if (m_additionalGuards != p_Other.m_additionalGuards) return false;

	return true;
}

void SGetHelpGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);
	s_Object->~SGetHelpGroupSaveData();
}

ZHMTypeInfo SGetHelpOrderSaveData::TypeInfo = ZHMTypeInfo("SGetHelpOrderSaveData", sizeof(SGetHelpOrderSaveData), alignof(SGetHelpOrderSaveData), SGetHelpOrderSaveData::WriteSimpleJson, SGetHelpOrderSaveData::FromSimpleJson, SGetHelpOrderSaveData::Serialize, SGetHelpOrderSaveData::Equals, SGetHelpOrderSaveData::Destroy);

void SGetHelpOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_helpType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_helpType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInitialGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInitialGuard);

	p_Stream << "}";
}

void SGetHelpOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Target);

	s_Object->m_helpType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_helpType"])));

	s_Object->m_rInitialGuard = simdjson::from_json_uint32(p_Document["m_rInitialGuard"]);

}

void SGetHelpOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);

}

bool SGetHelpOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpOrderSaveData::operator==(const SGetHelpOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpOrderSaveData>)
		return false;

	if (m_helpType != p_Other.m_helpType) return false;
	if (m_rInitialGuard != p_Other.m_rInitialGuard) return false;

	return true;
}

void SGetHelpOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);
	s_Object->~SGetHelpOrderSaveData();
}

ZHMTypeInfo SHelpingActorSaveData::TypeInfo = ZHMTypeInfo("SHelpingActorSaveData", sizeof(SHelpingActorSaveData), alignof(SHelpingActorSaveData), SHelpingActorSaveData::WriteSimpleJson, SHelpingActorSaveData::FromSimpleJson, SHelpingActorSaveData::Serialize, SHelpingActorSaveData::Equals, SHelpingActorSaveData::Destroy);

void SHelpingActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nLocationKnowledgeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLocationKnowledgeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SHelpingActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Target);

	s_Object->m_nLocationKnowledgeIndex = simdjson::from_json_int32(p_Document["m_nLocationKnowledgeIndex"]);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SHelpingActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);

}

bool SHelpingActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHelpingActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHelpingActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHelpingActorSaveData::operator==(const SHelpingActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHelpingActorSaveData>)
		return false;

	if (m_nLocationKnowledgeIndex != p_Other.m_nLocationKnowledgeIndex) return false;
	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SHelpingActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);
	s_Object->~SHelpingActorSaveData();
}

ZHMTypeInfo SHelpingActorRequestSaveData::TypeInfo = ZHMTypeInfo("SHelpingActorRequestSaveData", sizeof(SHelpingActorRequestSaveData), alignof(SHelpingActorRequestSaveData), SHelpingActorRequestSaveData::WriteSimpleJson, SHelpingActorRequestSaveData::FromSimpleJson, SHelpingActorRequestSaveData::Serialize, SHelpingActorRequestSaveData::Equals, SHelpingActorRequestSaveData::Destroy);

void SHelpingActorRequestSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLocation") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLocation, p_Stream);

	p_Stream << "}";
}

void SHelpingActorRequestSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCandidates"];
	s_Object->m_aCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aCandidates[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	SVector3::FromSimpleJson(p_Document["m_vLocation"], &s_Object->m_vLocation);

}

void SHelpingActorRequestSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SHelpingActorRequestSaveData, m_aCandidates));
	SVector3::Serialize(&s_Object->m_vLocation, p_Serializer, p_OwnOffset + offsetof(SHelpingActorRequestSaveData, m_vLocation));
}

bool SHelpingActorRequestSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHelpingActorRequestSaveData::operator==(const SHelpingActorRequestSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHelpingActorRequestSaveData>)
		return false;

	if (m_aCandidates != p_Other.m_aCandidates) return false;
	if (m_vLocation != p_Other.m_vLocation) return false;

	return true;
}

void SHelpingActorRequestSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHelpingActorRequestSaveData*>(p_Object);
	s_Object->~SHelpingActorRequestSaveData();
}

ZHMTypeInfo SGetHelpServiceSaveData::TypeInfo = ZHMTypeInfo("SGetHelpServiceSaveData", sizeof(SGetHelpServiceSaveData), alignof(SGetHelpServiceSaveData), SGetHelpServiceSaveData::WriteSimpleJson, SGetHelpServiceSaveData::FromSimpleJson, SGetHelpServiceSaveData::Serialize, SGetHelpServiceSaveData::Equals, SGetHelpServiceSaveData::Destroy);

void SGetHelpServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aHelpingActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHelpingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHelpingActors[i];
		SHelpingActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aHelpingActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aHelpingActorRequests") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHelpingActorRequests.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHelpingActorRequests[i];
		SHelpingActorRequestSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aHelpingActorRequests.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGetHelpServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aHelpingActors"];
	s_Object->m_aHelpingActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHelpingActorSaveData::FromSimpleJson(s_Item0, &s_Object->m_aHelpingActors[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aHelpingActorRequests"];
	s_Object->m_aHelpingActorRequests.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHelpingActorRequestSaveData::FromSimpleJson(s_Item0, &s_Object->m_aHelpingActorRequests[s_Index0]);
		++s_Index0;
	}
	}

}

void SGetHelpServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);

	TArray<SHelpingActorSaveData>::Serialize(&s_Object->m_aHelpingActors, p_Serializer, p_OwnOffset + offsetof(SGetHelpServiceSaveData, m_aHelpingActors));
	TArray<SHelpingActorRequestSaveData>::Serialize(&s_Object->m_aHelpingActorRequests, p_Serializer, p_OwnOffset + offsetof(SGetHelpServiceSaveData, m_aHelpingActorRequests));
}

bool SGetHelpServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpServiceSaveData::operator==(const SGetHelpServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpServiceSaveData>)
		return false;

	if (m_aHelpingActors != p_Other.m_aHelpingActors) return false;
	if (m_aHelpingActorRequests != p_Other.m_aHelpingActorRequests) return false;

	return true;
}

void SGetHelpServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);
	s_Object->~SGetHelpServiceSaveData();
}

ZHMTypeInfo SGuardBodySituationMemberSaveData::TypeInfo = ZHMTypeInfo("SGuardBodySituationMemberSaveData", sizeof(SGuardBodySituationMemberSaveData), alignof(SGuardBodySituationMemberSaveData), SGuardBodySituationMemberSaveData::WriteSimpleJson, SGuardBodySituationMemberSaveData::FromSimpleJson, SGuardBodySituationMemberSaveData::Serialize, SGuardBodySituationMemberSaveData::Equals, SGuardBodySituationMemberSaveData::Destroy);

void SGuardBodySituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bHasThingsTodo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasThingsTodo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBodybag") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBodybag);

	p_Stream << "}";
}

void SGuardBodySituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Target);

	s_Object->m_bHasThingsTodo = simdjson::from_json_bool(p_Document["m_bHasThingsTodo"]);

	s_Object->m_rDeadBody = simdjson::from_json_uint32(p_Document["m_rDeadBody"]);

	s_Object->m_rBodybag = simdjson::from_json_uint32(p_Document["m_rBodybag"]);

}

void SGuardBodySituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);

}

bool SGuardBodySituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardBodySituationMemberSaveData::operator==(const SGuardBodySituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardBodySituationMemberSaveData>)
		return false;

	if (m_bHasThingsTodo != p_Other.m_bHasThingsTodo) return false;
	if (m_rDeadBody != p_Other.m_rDeadBody) return false;
	if (m_rBodybag != p_Other.m_rBodybag) return false;

	return true;
}

void SGuardBodySituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);
	s_Object->~SGuardBodySituationMemberSaveData();
}

ZHMTypeInfo SGuardBodySituationSaveData::TypeInfo = ZHMTypeInfo("SGuardBodySituationSaveData", sizeof(SGuardBodySituationSaveData), alignof(SGuardBodySituationSaveData), SGuardBodySituationSaveData::WriteSimpleJson, SGuardBodySituationSaveData::FromSimpleJson, SGuardBodySituationSaveData::Serialize, SGuardBodySituationSaveData::Equals, SGuardBodySituationSaveData::Destroy);

void SGuardBodySituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bBystanderFieldsFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBystanderFieldsFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGuardInSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGuardInSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLastGetHelpGroupFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLastGetHelpGroupFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneCanSeeBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneCanSeeBody);

	p_Stream << "}";
}

void SGuardBodySituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Target);

	s_Object->m_bBystanderFieldsFailed = simdjson::from_json_bool(p_Document["m_bBystanderFieldsFailed"]);

	s_Object->m_bGuardInSituation = simdjson::from_json_bool(p_Document["m_bGuardInSituation"]);

	s_Object->m_bLastGetHelpGroupFailed = simdjson::from_json_bool(p_Document["m_bLastGetHelpGroupFailed"]);

	s_Object->m_bSomeoneCanSeeBody = simdjson::from_json_bool(p_Document["m_bSomeoneCanSeeBody"]);

}

void SGuardBodySituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);

}

bool SGuardBodySituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardBodySituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardBodySituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardBodySituationSaveData::operator==(const SGuardBodySituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardBodySituationSaveData>)
		return false;

	if (m_bBystanderFieldsFailed != p_Other.m_bBystanderFieldsFailed) return false;
	if (m_bGuardInSituation != p_Other.m_bGuardInSituation) return false;
	if (m_bLastGetHelpGroupFailed != p_Other.m_bLastGetHelpGroupFailed) return false;
	if (m_bSomeoneCanSeeBody != p_Other.m_bSomeoneCanSeeBody) return false;

	return true;
}

void SGuardBodySituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);
	s_Object->~SGuardBodySituationSaveData();
}

ZHMTypeInfo SGuardPointGroupSaveData::TypeInfo = ZHMTypeInfo("SGuardPointGroupSaveData", sizeof(SGuardPointGroupSaveData), alignof(SGuardPointGroupSaveData), SGuardPointGroupSaveData::WriteSimpleJson, SGuardPointGroupSaveData::FromSimpleJson, SGuardPointGroupSaveData::Serialize, SGuardPointGroupSaveData::Equals, SGuardPointGroupSaveData::Destroy);

void SGuardPointGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardPointGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bGroupEngaged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGroupEngaged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_combatZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_combatZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_guardPointEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_guardPointEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGroupTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGroupTime, p_Stream);

	p_Stream << "}";
}

void SGuardPointGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGuardPointGroupSaveData*>(p_Target);

	s_Object->m_bGroupEngaged = simdjson::from_json_bool(p_Document["m_bGroupEngaged"]);

	s_Object->m_combatZone = simdjson::from_json_uint32(p_Document["m_combatZone"]);

	s_Object->m_guardPointEntity = simdjson::from_json_uint32(p_Document["m_guardPointEntity"]);

	ZGameTime::FromSimpleJson(p_Document["m_tGroupTime"], &s_Object->m_tGroupTime);

}

void SGuardPointGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardPointGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGroupTime, p_Serializer, p_OwnOffset + offsetof(SGuardPointGroupSaveData, m_tGroupTime));
}

bool SGuardPointGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardPointGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardPointGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardPointGroupSaveData::operator==(const SGuardPointGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardPointGroupSaveData>)
		return false;

	if (m_bGroupEngaged != p_Other.m_bGroupEngaged) return false;
	if (m_combatZone != p_Other.m_combatZone) return false;
	if (m_guardPointEntity != p_Other.m_guardPointEntity) return false;
	if (m_tGroupTime != p_Other.m_tGroupTime) return false;

	return true;
}

void SGuardPointGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGuardPointGroupSaveData*>(p_Object);
	s_Object->~SGuardPointGroupSaveData();
}

ZHMTypeInfo SGuardPointOrderSaveData::TypeInfo = ZHMTypeInfo("SGuardPointOrderSaveData", sizeof(SGuardPointOrderSaveData), alignof(SGuardPointOrderSaveData), SGuardPointOrderSaveData::WriteSimpleJson, SGuardPointOrderSaveData::FromSimpleJson, SGuardPointOrderSaveData::Serialize, SGuardPointOrderSaveData::Equals, SGuardPointOrderSaveData::Destroy);

void SGuardPointOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_guardPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_guardPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_walkOnly") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_walkOnly);

	p_Stream << "}";
}

void SGuardPointOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Target);

	s_Object->m_guardPoint = simdjson::from_json_uint32(p_Document["m_guardPoint"]);

	s_Object->m_walkOnly = simdjson::from_json_bool(p_Document["m_walkOnly"]);

}

void SGuardPointOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);

}

bool SGuardPointOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardPointOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardPointOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardPointOrderSaveData::operator==(const SGuardPointOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardPointOrderSaveData>)
		return false;

	if (m_guardPoint != p_Other.m_guardPoint) return false;
	if (m_walkOnly != p_Other.m_walkOnly) return false;

	return true;
}

void SGuardPointOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);
	s_Object->~SGuardPointOrderSaveData();
}

ZHMTypeInfo SHM5CrippleBoxSaveData::TypeInfo = ZHMTypeInfo("SHM5CrippleBoxSaveData", sizeof(SHM5CrippleBoxSaveData), alignof(SHM5CrippleBoxSaveData), SHM5CrippleBoxSaveData::WriteSimpleJson, SHM5CrippleBoxSaveData::FromSimpleJson, SHM5CrippleBoxSaveData::Serialize, SHM5CrippleBoxSaveData::Equals, SHM5CrippleBoxSaveData::Destroy);

void SHM5CrippleBoxSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bInSequence") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInSequence);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllowBaseMovements") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllowBaseMovements);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSequenceAllowCamera") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSequenceAllowCamera);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLedges") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLedges);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShootingBallet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShootingBallet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCover") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCover);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTakeClothes") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTakeClothes);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLadder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLadder);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPullVictimFromWindow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPullVictimFromWindow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFiberWireKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFiberWireKill);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bClimbWindow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bClimbWindow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bThrowBodyOverRail") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bThrowBodyOverRail);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDumpBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDumpBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOperateCPDoor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOperateCPDoor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHideInCloset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHideInCloset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombat") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombat);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVentilatorShaft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVentilatorShaft);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGrabVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGrabVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPushVictimThroughWindowAndRail") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPushVictimThroughWindowAndRail);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKickVictimOverLedge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKickVictimOverLedge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPickupItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPickupItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDragBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDragBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bThrowItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bThrowItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlaceItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlaceItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTurn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTurn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSneak") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSneak);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoSnapSneak") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoSnapSneak);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandUp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandUp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFastWalk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFastWalk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMovementAllowed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMovementAllowed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIdleAnimationsAllowed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIdleAnimationsAllowed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanHolsterItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanHolsterItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverTakedown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverTakedown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverToCover") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverToCover);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatSnapNeck") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatSnapNeck);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatChoke") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatChoke);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatPistolFinish") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatPistolFinish);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatProps") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatProps);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatStandart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatStandart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatFakeSwing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatFakeSwing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGameCameraAutoAlign") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGameCameraAutoAlign);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInstinct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInstinct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanCancelShootingBallet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanCancelShootingBallet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlindFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlindFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHairTrigger") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHairTrigger);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOpenLogbook") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOpenLogbook);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOpenPauseMenu") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOpenPauseMenu);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivatedByPinSignal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivatedByPinSignal);

	p_Stream << "}";
}

void SHM5CrippleBoxSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Target);

	s_Object->m_bInSequence = simdjson::from_json_bool(p_Document["m_bInSequence"]);

	s_Object->m_bAllowBaseMovements = simdjson::from_json_bool(p_Document["m_bAllowBaseMovements"]);

	s_Object->m_bSequenceAllowCamera = simdjson::from_json_bool(p_Document["m_bSequenceAllowCamera"]);

	s_Object->m_bLedges = simdjson::from_json_bool(p_Document["m_bLedges"]);

	s_Object->m_bShootingBallet = simdjson::from_json_bool(p_Document["m_bShootingBallet"]);

	s_Object->m_bCover = simdjson::from_json_bool(p_Document["m_bCover"]);

	s_Object->m_bTakeClothes = simdjson::from_json_bool(p_Document["m_bTakeClothes"]);

	s_Object->m_bLadder = simdjson::from_json_bool(p_Document["m_bLadder"]);

	s_Object->m_bPullVictimFromWindow = simdjson::from_json_bool(p_Document["m_bPullVictimFromWindow"]);

	s_Object->m_bFiberWireKill = simdjson::from_json_bool(p_Document["m_bFiberWireKill"]);

	s_Object->m_bClimbWindow = simdjson::from_json_bool(p_Document["m_bClimbWindow"]);

	s_Object->m_bThrowBodyOverRail = simdjson::from_json_bool(p_Document["m_bThrowBodyOverRail"]);

	s_Object->m_bDumpBody = simdjson::from_json_bool(p_Document["m_bDumpBody"]);

	s_Object->m_bOperateCPDoor = simdjson::from_json_bool(p_Document["m_bOperateCPDoor"]);

	s_Object->m_bHideInCloset = simdjson::from_json_bool(p_Document["m_bHideInCloset"]);

	s_Object->m_bCloseCombat = simdjson::from_json_bool(p_Document["m_bCloseCombat"]);

	s_Object->m_bVentilatorShaft = simdjson::from_json_bool(p_Document["m_bVentilatorShaft"]);

	s_Object->m_bGrabVictim = simdjson::from_json_bool(p_Document["m_bGrabVictim"]);

	s_Object->m_bPushVictimThroughWindowAndRail = simdjson::from_json_bool(p_Document["m_bPushVictimThroughWindowAndRail"]);

	s_Object->m_bKickVictimOverLedge = simdjson::from_json_bool(p_Document["m_bKickVictimOverLedge"]);

	s_Object->m_bPickupItem = simdjson::from_json_bool(p_Document["m_bPickupItem"]);

	s_Object->m_bDropItem = simdjson::from_json_bool(p_Document["m_bDropItem"]);

	s_Object->m_bDragBody = simdjson::from_json_bool(p_Document["m_bDragBody"]);

	s_Object->m_bThrowItem = simdjson::from_json_bool(p_Document["m_bThrowItem"]);

	s_Object->m_bPlaceItem = simdjson::from_json_bool(p_Document["m_bPlaceItem"]);

	s_Object->m_bRun = simdjson::from_json_bool(p_Document["m_bRun"]);

	s_Object->m_bTurn = simdjson::from_json_bool(p_Document["m_bTurn"]);

	s_Object->m_bSneak = simdjson::from_json_bool(p_Document["m_bSneak"]);

	s_Object->m_bNoSnapSneak = simdjson::from_json_bool(p_Document["m_bNoSnapSneak"]);

	s_Object->m_bStandUp = simdjson::from_json_bool(p_Document["m_bStandUp"]);

	s_Object->m_bFastWalk = simdjson::from_json_bool(p_Document["m_bFastWalk"]);

	s_Object->m_bMovementAllowed = simdjson::from_json_bool(p_Document["m_bMovementAllowed"]);

	s_Object->m_bIdleAnimationsAllowed = simdjson::from_json_bool(p_Document["m_bIdleAnimationsAllowed"]);

	s_Object->m_bItems = simdjson::from_json_bool(p_Document["m_bItems"]);

	s_Object->m_bCanHolsterItems = simdjson::from_json_bool(p_Document["m_bCanHolsterItems"]);

	s_Object->m_bCoverTakedown = simdjson::from_json_bool(p_Document["m_bCoverTakedown"]);

	s_Object->m_bCoverScale = simdjson::from_json_bool(p_Document["m_bCoverScale"]);

	s_Object->m_bCoverToCover = simdjson::from_json_bool(p_Document["m_bCoverToCover"]);

	s_Object->m_bCloseCombatSnapNeck = simdjson::from_json_bool(p_Document["m_bCloseCombatSnapNeck"]);

	s_Object->m_bCloseCombatChoke = simdjson::from_json_bool(p_Document["m_bCloseCombatChoke"]);

	s_Object->m_bCloseCombatPistolFinish = simdjson::from_json_bool(p_Document["m_bCloseCombatPistolFinish"]);

	s_Object->m_bCloseCombatProps = simdjson::from_json_bool(p_Document["m_bCloseCombatProps"]);

	s_Object->m_bCloseCombatStandart = simdjson::from_json_bool(p_Document["m_bCloseCombatStandart"]);

	s_Object->m_bCloseCombatFakeSwing = simdjson::from_json_bool(p_Document["m_bCloseCombatFakeSwing"]);

	s_Object->m_bGameCameraAutoAlign = simdjson::from_json_bool(p_Document["m_bGameCameraAutoAlign"]);

	s_Object->m_bInstinct = simdjson::from_json_bool(p_Document["m_bInstinct"]);

	s_Object->m_bCanCancelShootingBallet = simdjson::from_json_bool(p_Document["m_bCanCancelShootingBallet"]);

	s_Object->m_bBlindFire = simdjson::from_json_bool(p_Document["m_bBlindFire"]);

	s_Object->m_bAim = simdjson::from_json_bool(p_Document["m_bAim"]);

	s_Object->m_bHairTrigger = simdjson::from_json_bool(p_Document["m_bHairTrigger"]);

	s_Object->m_bFire = simdjson::from_json_bool(p_Document["m_bFire"]);

	s_Object->m_bOpenLogbook = simdjson::from_json_bool(p_Document["m_bOpenLogbook"]);

	s_Object->m_bOpenPauseMenu = simdjson::from_json_bool(p_Document["m_bOpenPauseMenu"]);

	s_Object->m_bActivatedByPinSignal = simdjson::from_json_bool(p_Document["m_bActivatedByPinSignal"]);

}

void SHM5CrippleBoxSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);

}

bool SHM5CrippleBoxSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHM5CrippleBoxSaveData::operator==(const SHM5CrippleBoxSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHM5CrippleBoxSaveData>)
		return false;

	if (m_bInSequence != p_Other.m_bInSequence) return false;
	if (m_bAllowBaseMovements != p_Other.m_bAllowBaseMovements) return false;
	if (m_bSequenceAllowCamera != p_Other.m_bSequenceAllowCamera) return false;
	if (m_bLedges != p_Other.m_bLedges) return false;
	if (m_bShootingBallet != p_Other.m_bShootingBallet) return false;
	if (m_bCover != p_Other.m_bCover) return false;
	if (m_bTakeClothes != p_Other.m_bTakeClothes) return false;
	if (m_bLadder != p_Other.m_bLadder) return false;
	if (m_bPullVictimFromWindow != p_Other.m_bPullVictimFromWindow) return false;
	if (m_bFiberWireKill != p_Other.m_bFiberWireKill) return false;
	if (m_bClimbWindow != p_Other.m_bClimbWindow) return false;
	if (m_bThrowBodyOverRail != p_Other.m_bThrowBodyOverRail) return false;
	if (m_bDumpBody != p_Other.m_bDumpBody) return false;
	if (m_bOperateCPDoor != p_Other.m_bOperateCPDoor) return false;
	if (m_bHideInCloset != p_Other.m_bHideInCloset) return false;
	if (m_bCloseCombat != p_Other.m_bCloseCombat) return false;
	if (m_bVentilatorShaft != p_Other.m_bVentilatorShaft) return false;
	if (m_bGrabVictim != p_Other.m_bGrabVictim) return false;
	if (m_bPushVictimThroughWindowAndRail != p_Other.m_bPushVictimThroughWindowAndRail) return false;
	if (m_bKickVictimOverLedge != p_Other.m_bKickVictimOverLedge) return false;
	if (m_bPickupItem != p_Other.m_bPickupItem) return false;
	if (m_bDropItem != p_Other.m_bDropItem) return false;
	if (m_bDragBody != p_Other.m_bDragBody) return false;
	if (m_bThrowItem != p_Other.m_bThrowItem) return false;
	if (m_bPlaceItem != p_Other.m_bPlaceItem) return false;
	if (m_bRun != p_Other.m_bRun) return false;
	if (m_bTurn != p_Other.m_bTurn) return false;
	if (m_bSneak != p_Other.m_bSneak) return false;
	if (m_bNoSnapSneak != p_Other.m_bNoSnapSneak) return false;
	if (m_bStandUp != p_Other.m_bStandUp) return false;
	if (m_bFastWalk != p_Other.m_bFastWalk) return false;
	if (m_bMovementAllowed != p_Other.m_bMovementAllowed) return false;
	if (m_bIdleAnimationsAllowed != p_Other.m_bIdleAnimationsAllowed) return false;
	if (m_bItems != p_Other.m_bItems) return false;
	if (m_bCanHolsterItems != p_Other.m_bCanHolsterItems) return false;
	if (m_bCoverTakedown != p_Other.m_bCoverTakedown) return false;
	if (m_bCoverScale != p_Other.m_bCoverScale) return false;
	if (m_bCoverToCover != p_Other.m_bCoverToCover) return false;
	if (m_bCloseCombatSnapNeck != p_Other.m_bCloseCombatSnapNeck) return false;
	if (m_bCloseCombatChoke != p_Other.m_bCloseCombatChoke) return false;
	if (m_bCloseCombatPistolFinish != p_Other.m_bCloseCombatPistolFinish) return false;
	if (m_bCloseCombatProps != p_Other.m_bCloseCombatProps) return false;
	if (m_bCloseCombatStandart != p_Other.m_bCloseCombatStandart) return false;
	if (m_bCloseCombatFakeSwing != p_Other.m_bCloseCombatFakeSwing) return false;
	if (m_bGameCameraAutoAlign != p_Other.m_bGameCameraAutoAlign) return false;
	if (m_bInstinct != p_Other.m_bInstinct) return false;
	if (m_bCanCancelShootingBallet != p_Other.m_bCanCancelShootingBallet) return false;
	if (m_bBlindFire != p_Other.m_bBlindFire) return false;
	if (m_bAim != p_Other.m_bAim) return false;
	if (m_bHairTrigger != p_Other.m_bHairTrigger) return false;
	if (m_bFire != p_Other.m_bFire) return false;
	if (m_bOpenLogbook != p_Other.m_bOpenLogbook) return false;
	if (m_bOpenPauseMenu != p_Other.m_bOpenPauseMenu) return false;
	if (m_bActivatedByPinSignal != p_Other.m_bActivatedByPinSignal) return false;

	return true;
}

void SHM5CrippleBoxSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);
	s_Object->~SHM5CrippleBoxSaveData();
}

ZHMTypeInfo SHUDPromptDisplayInfo::TypeInfo = ZHMTypeInfo("SHUDPromptDisplayInfo", sizeof(SHUDPromptDisplayInfo), alignof(SHUDPromptDisplayInfo), SHUDPromptDisplayInfo::WriteSimpleJson, SHUDPromptDisplayInfo::FromSimpleJson, SHUDPromptDisplayInfo::Serialize, SHUDPromptDisplayInfo::Equals, SHUDPromptDisplayInfo::Destroy);

void SHUDPromptDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActionPromptState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIconId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIconId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTypeId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTypeId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoActionAvailable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoActionAvailable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sGlyph") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sGlyph);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpacity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpacity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegalItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegalItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspiciousItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspiciousItem);

	p_Stream << "}";
}

void SHUDPromptDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Target);

	s_Object->m_bActive = simdjson::from_json_bool(p_Document["m_bActive"]);

	s_Object->m_eState = static_cast<EActionPromptState>(ZHMEnums::GetEnumValueByName("EActionPromptState", std::string_view(p_Document["m_eState"])));

	s_Object->m_nIconId = simdjson::from_json_int32(p_Document["m_nIconId"]);

	s_Object->m_eTypeId = simdjson::from_json_int32(p_Document["m_eTypeId"]);

	s_Object->m_fProgress = simdjson::from_json_float32(p_Document["m_fProgress"]);

	s_Object->m_fDistance = simdjson::from_json_float32(p_Document["m_fDistance"]);

	s_Object->m_bShowWarning = simdjson::from_json_bool(p_Document["m_bShowWarning"]);

	s_Object->m_bNoActionAvailable = simdjson::from_json_bool(p_Document["m_bNoActionAvailable"]);

	s_Object->m_sLabel = std::string_view(p_Document["m_sLabel"]);

	s_Object->m_sDescription = std::string_view(p_Document["m_sDescription"]);

	s_Object->m_sGlyph = std::string_view(p_Document["m_sGlyph"]);

	s_Object->m_fOpacity = simdjson::from_json_float32(p_Document["m_fOpacity"]);

	s_Object->m_bIllegalItem = simdjson::from_json_bool(p_Document["m_bIllegalItem"]);

	s_Object->m_bSuspiciousItem = simdjson::from_json_bool(p_Document["m_bSuspiciousItem"]);

}

void SHUDPromptDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->m_sLabel, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sLabel));
	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sDescription));
	ZString::Serialize(&s_Object->m_sGlyph, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sGlyph));
}

bool SHUDPromptDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDPromptDisplayInfo::operator==(const SHUDPromptDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDPromptDisplayInfo>)
		return false;

	if (m_bActive != p_Other.m_bActive) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_nIconId != p_Other.m_nIconId) return false;
	if (m_eTypeId != p_Other.m_eTypeId) return false;
	if (m_fProgress != p_Other.m_fProgress) return false;
	if (m_fDistance != p_Other.m_fDistance) return false;
	if (m_bShowWarning != p_Other.m_bShowWarning) return false;
	if (m_bNoActionAvailable != p_Other.m_bNoActionAvailable) return false;
	if (m_sLabel != p_Other.m_sLabel) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_sGlyph != p_Other.m_sGlyph) return false;
	if (m_fOpacity != p_Other.m_fOpacity) return false;
	if (m_bIllegalItem != p_Other.m_bIllegalItem) return false;
	if (m_bSuspiciousItem != p_Other.m_bSuspiciousItem) return false;

	return true;
}

void SHUDPromptDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);
	s_Object->~SHUDPromptDisplayInfo();
}

ZHMTypeInfo SHUDPromptDisplayInfoArray_Dummy::TypeInfo = ZHMTypeInfo("SHUDPromptDisplayInfoArray_Dummy", sizeof(SHUDPromptDisplayInfoArray_Dummy), alignof(SHUDPromptDisplayInfoArray_Dummy), SHUDPromptDisplayInfoArray_Dummy::WriteSimpleJson, SHUDPromptDisplayInfoArray_Dummy::FromSimpleJson, SHUDPromptDisplayInfoArray_Dummy::Serialize, SHUDPromptDisplayInfoArray_Dummy::Equals, SHUDPromptDisplayInfoArray_Dummy::Destroy);

void SHUDPromptDisplayInfoArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SHUDPromptDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SHUDPromptDisplayInfoArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object->dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHUDPromptDisplayInfo::FromSimpleJson(s_Item0, &s_Object->dummy[s_Index0]);
		++s_Index0;
	}
	}

}

void SHUDPromptDisplayInfoArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);

	TArray<SHUDPromptDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfoArray_Dummy, dummy));
}

bool SHUDPromptDisplayInfoArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDPromptDisplayInfoArray_Dummy::operator==(const SHUDPromptDisplayInfoArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDPromptDisplayInfoArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SHUDPromptDisplayInfoArray_Dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);
	s_Object->~SHUDPromptDisplayInfoArray_Dummy();
}

ZHMTypeInfo SHUDTimerControllerSaveData::TypeInfo = ZHMTypeInfo("SHUDTimerControllerSaveData", sizeof(SHUDTimerControllerSaveData), alignof(SHUDTimerControllerSaveData), SHUDTimerControllerSaveData::WriteSimpleJson, SHUDTimerControllerSaveData::FromSimpleJson, SHUDTimerControllerSaveData::Serialize, SHUDTimerControllerSaveData::Equals, SHUDTimerControllerSaveData::Destroy);

void SHUDTimerControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pCurrentInstance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCurrentInstance);

	p_Stream << "}";
}

void SHUDTimerControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Target);

	s_Object->m_pCurrentInstance = simdjson::from_json_uint32(p_Document["m_pCurrentInstance"]);

}

void SHUDTimerControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);

}

bool SHUDTimerControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDTimerControllerSaveData::operator==(const SHUDTimerControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDTimerControllerSaveData>)
		return false;

	if (m_pCurrentInstance != p_Other.m_pCurrentInstance) return false;

	return true;
}

void SHUDTimerControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);
	s_Object->~SHUDTimerControllerSaveData();
}

ZHMTypeInfo SHUDVisibilityController2SaveData::TypeInfo = ZHMTypeInfo("SHUDVisibilityController2SaveData", sizeof(SHUDVisibilityController2SaveData), alignof(SHUDVisibilityController2SaveData), SHUDVisibilityController2SaveData::WriteSimpleJson, SHUDVisibilityController2SaveData::FromSimpleJson, SHUDVisibilityController2SaveData::Serialize, SHUDVisibilityController2SaveData::Equals, SHUDVisibilityController2SaveData::Destroy);

void SHUDVisibilityController2SaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eCurrentRequest") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHUDUIRoot.EHUDVisibility", static_cast<int>(s_Object->m_eCurrentRequest)));

	p_Stream << "}";
}

void SHUDVisibilityController2SaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Target);

	s_Object->m_eCurrentRequest = static_cast<ZHUDUIRoot::EHUDVisibility>(ZHMEnums::GetEnumValueByName("ZHUDUIRoot.EHUDVisibility", std::string_view(p_Document["m_eCurrentRequest"])));

}

void SHUDVisibilityController2SaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);

}

bool SHUDVisibilityController2SaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDVisibilityController2SaveData::operator==(const SHUDVisibilityController2SaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDVisibilityController2SaveData>)
		return false;

	if (m_eCurrentRequest != p_Other.m_eCurrentRequest) return false;

	return true;
}

void SHUDVisibilityController2SaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);
	s_Object->~SHUDVisibilityController2SaveData();
}

ZHMTypeInfo SHandleClosetGroupSaveData::TypeInfo = ZHMTypeInfo("SHandleClosetGroupSaveData", sizeof(SHandleClosetGroupSaveData), alignof(SHandleClosetGroupSaveData), SHandleClosetGroupSaveData::WriteSimpleJson, SHandleClosetGroupSaveData::FromSimpleJson, SHandleClosetGroupSaveData::Serialize, SHandleClosetGroupSaveData::Equals, SHandleClosetGroupSaveData::Destroy);

void SHandleClosetGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pProcessingMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pProcessingMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_startTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_startTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SpeechState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHandleClosetSpeechState", static_cast<int>(s_Object->m_SpeechState)));

	p_Stream << "}";
}

void SHandleClosetGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Target);

	s_Object->m_pProcessingMember = simdjson::from_json_uint32(p_Document["m_pProcessingMember"]);

	ZGameTime::FromSimpleJson(p_Document["m_startTime"], &s_Object->m_startTime);

	s_Object->m_SpeechState = static_cast<EHandleClosetSpeechState>(ZHMEnums::GetEnumValueByName("EHandleClosetSpeechState", std::string_view(p_Document["m_SpeechState"])));

}

void SHandleClosetGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_startTime, p_Serializer, p_OwnOffset + offsetof(SHandleClosetGroupSaveData, m_startTime));
}

bool SHandleClosetGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHandleClosetGroupSaveData::operator==(const SHandleClosetGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHandleClosetGroupSaveData>)
		return false;

	if (m_pProcessingMember != p_Other.m_pProcessingMember) return false;
	if (m_startTime != p_Other.m_startTime) return false;
	if (m_SpeechState != p_Other.m_SpeechState) return false;

	return true;
}

void SHandleClosetGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHandleClosetGroupSaveData*>(p_Object);
	s_Object->~SHandleClosetGroupSaveData();
}

ZHMTypeInfo SHeroEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SHeroEscortSituationActorStateSaveData", sizeof(SHeroEscortSituationActorStateSaveData), alignof(SHeroEscortSituationActorStateSaveData), SHeroEscortSituationActorStateSaveData::WriteSimpleJson, SHeroEscortSituationActorStateSaveData::FromSimpleJson, SHeroEscortSituationActorStateSaveData::Serialize, SHeroEscortSituationActorStateSaveData::Equals, SHeroEscortSituationActorStateSaveData::Destroy);

void SHeroEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SHeroEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Target);

	s_Object->m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object->m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object->m_eState = static_cast<ZHeroEscortSituationEntity::EEscortState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object->m_eStatePrevious = static_cast<ZHeroEscortSituationEntity::EEscortState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object->m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object->m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object->m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

}

void SHeroEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);

}

bool SHeroEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituationActorStateSaveData::operator==(const SHeroEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

void SHeroEscortSituationActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);
	s_Object->~SHeroEscortSituationActorStateSaveData();
}

ZHMTypeInfo SHeroEscortSituationActors::TypeInfo = ZHMTypeInfo("SHeroEscortSituationActors", sizeof(SHeroEscortSituationActors), alignof(SHeroEscortSituationActors), SHeroEscortSituationActors::WriteSimpleJson, SHeroEscortSituationActors::FromSimpleJson, SHeroEscortSituationActors::Serialize, SHeroEscortSituationActors::Equals, SHeroEscortSituationActors::Destroy);

void SHeroEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SHeroEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SHeroEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);

}

bool SHeroEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituationActors::operator==(const SHeroEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SHeroEscortSituationActors::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);
	s_Object->~SHeroEscortSituationActors();
}

ZHMTypeInfo SHeroItemActionSaveData::TypeInfo = ZHMTypeInfo("SHeroItemActionSaveData", sizeof(SHeroItemActionSaveData), alignof(SHeroItemActionSaveData), SHeroItemActionSaveData::WriteSimpleJson, SHeroItemActionSaveData::FromSimpleJson, SHeroItemActionSaveData::Serialize, SHeroItemActionSaveData::Equals, SHeroItemActionSaveData::Destroy);

void SHeroItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SHeroItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Target);

	s_Object->m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

}

void SHeroItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);

}

bool SHeroItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroItemActionSaveData::operator==(const SHeroItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroItemActionSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SHeroItemActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);
	s_Object->~SHeroItemActionSaveData();
}

ZHMTypeInfo SHeroItemAttachmentSaveData::TypeInfo = ZHMTypeInfo("SHeroItemAttachmentSaveData", sizeof(SHeroItemAttachmentSaveData), alignof(SHeroItemAttachmentSaveData), SHeroItemAttachmentSaveData::WriteSimpleJson, SHeroItemAttachmentSaveData::FromSimpleJson, SHeroItemAttachmentSaveData::Serialize, SHeroItemAttachmentSaveData::Equals, SHeroItemAttachmentSaveData::Destroy);

void SHeroItemAttachmentSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SHeroItemAttachmentSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Target);

	s_Object->m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

}

void SHeroItemAttachmentSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);

}

bool SHeroItemAttachmentSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroItemAttachmentSaveData::operator==(const SHeroItemAttachmentSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroItemAttachmentSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SHeroItemAttachmentSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);
	s_Object->~SHeroItemAttachmentSaveData();
}

ZHMTypeInfo SHeroStandInSaveState::TypeInfo = ZHMTypeInfo("SHeroStandInSaveState", sizeof(SHeroStandInSaveState), alignof(SHeroStandInSaveState), SHeroStandInSaveState::WriteSimpleJson, SHeroStandInSaveState::FromSimpleJson, SHeroStandInSaveState::Serialize, SHeroStandInSaveState::Equals, SHeroStandInSaveState::Destroy);

void SHeroStandInSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);

	p_Stream << "}";
}

void SHeroStandInSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Target);

	s_Object->m_rCurrentSpeakEntity = simdjson::from_json_uint32(p_Document["m_rCurrentSpeakEntity"]);

	s_Object->m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

}

void SHeroStandInSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);

}

bool SHeroStandInSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroStandInSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroStandInSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroStandInSaveState::operator==(const SHeroStandInSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroStandInSaveState>)
		return false;

	if (m_rCurrentSpeakEntity != p_Other.m_rCurrentSpeakEntity) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;

	return true;
}

void SHeroStandInSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);
	s_Object->~SHeroStandInSaveState();
}

ZHMTypeInfo SHintEntrySaveData::TypeInfo = ZHMTypeInfo("SHintEntrySaveData", sizeof(SHintEntrySaveData), alignof(SHintEntrySaveData), SHintEntrySaveData::WriteSimpleJson, SHintEntrySaveData::FromSimpleJson, SHintEntrySaveData::Serialize, SHintEntrySaveData::Equals, SHintEntrySaveData::Destroy);

void SHintEntrySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsValid);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_hint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_hint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_context") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_context);

	p_Stream << "}";
}

void SHintEntrySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Target);

	s_Object->m_bIsValid = simdjson::from_json_bool(p_Document["m_bIsValid"]);

	s_Object->m_hint = simdjson::from_json_uint32(p_Document["m_hint"]);

	s_Object->m_context = simdjson::from_json_uint32(p_Document["m_context"]);

}

void SHintEntrySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);

}

bool SHintEntrySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHintEntrySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHintEntrySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHintEntrySaveData::operator==(const SHintEntrySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHintEntrySaveData>)
		return false;

	if (m_bIsValid != p_Other.m_bIsValid) return false;
	if (m_hint != p_Other.m_hint) return false;
	if (m_context != p_Other.m_context) return false;

	return true;
}

void SHintEntrySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);
	s_Object->~SHintEntrySaveData();
}

ZHMTypeInfo SHintManagerSaveData::TypeInfo = ZHMTypeInfo("SHintManagerSaveData", sizeof(SHintManagerSaveData), alignof(SHintManagerSaveData), SHintManagerSaveData::WriteSimpleJson, SHintManagerSaveData::FromSimpleJson, SHintManagerSaveData::Serialize, SHintManagerSaveData::Equals, SHintManagerSaveData::Destroy);

void SHintManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_activeHint") << ":";
	SHintEntrySaveData::WriteSimpleJson(&s_Object->m_activeHint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aQueue") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aQueue.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aQueue[i];
		SHintEntrySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aQueue.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRunning);

	p_Stream << "}";
}

void SHintManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Target);

	SHintEntrySaveData::FromSimpleJson(p_Document["m_activeHint"], &s_Object->m_activeHint);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aQueue"];
	s_Object->m_aQueue.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHintEntrySaveData::FromSimpleJson(s_Item0, &s_Object->m_aQueue[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_bIsRunning = simdjson::from_json_bool(p_Document["m_bIsRunning"]);

}

void SHintManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);

	SHintEntrySaveData::Serialize(&s_Object->m_activeHint, p_Serializer, p_OwnOffset + offsetof(SHintManagerSaveData, m_activeHint));
	TArray<SHintEntrySaveData>::Serialize(&s_Object->m_aQueue, p_Serializer, p_OwnOffset + offsetof(SHintManagerSaveData, m_aQueue));
}

bool SHintManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHintManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHintManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHintManagerSaveData::operator==(const SHintManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHintManagerSaveData>)
		return false;

	if (m_activeHint != p_Other.m_activeHint) return false;
	if (m_aQueue != p_Other.m_aQueue) return false;
	if (m_bIsRunning != p_Other.m_bIsRunning) return false;

	return true;
}

void SHintManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);
	s_Object->~SHintManagerSaveData();
}

ZHMTypeInfo SHudMissionTimerControllerData::TypeInfo = ZHMTypeInfo("SHudMissionTimerControllerData", sizeof(SHudMissionTimerControllerData), alignof(SHudMissionTimerControllerData), SHudMissionTimerControllerData::WriteSimpleJson, SHudMissionTimerControllerData::FromSimpleJson, SHudMissionTimerControllerData::Serialize, SHudMissionTimerControllerData::Equals, SHudMissionTimerControllerData::Destroy);

void SHudMissionTimerControllerData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fScoreGameTimeStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_fScoreGameTimeStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasIntroCutFired") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasIntroCutFired);

	p_Stream << "}";
}

void SHudMissionTimerControllerData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_fScoreGameTimeStart"], &s_Object->m_fScoreGameTimeStart);

	s_Object->m_bWasIntroCutFired = simdjson::from_json_bool(p_Document["m_bWasIntroCutFired"]);

}

void SHudMissionTimerControllerData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_fScoreGameTimeStart, p_Serializer, p_OwnOffset + offsetof(SHudMissionTimerControllerData, m_fScoreGameTimeStart));
}

bool SHudMissionTimerControllerData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHudMissionTimerControllerData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHudMissionTimerControllerData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHudMissionTimerControllerData::operator==(const SHudMissionTimerControllerData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHudMissionTimerControllerData>)
		return false;

	if (m_fScoreGameTimeStart != p_Other.m_fScoreGameTimeStart) return false;
	if (m_bWasIntroCutFired != p_Other.m_bWasIntroCutFired) return false;

	return true;
}

void SHudMissionTimerControllerData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);
	s_Object->~SHudMissionTimerControllerData();
}

ZHMTypeInfo SHumanShieldGroupSaveData::TypeInfo = ZHMTypeInfo("SHumanShieldGroupSaveData", sizeof(SHumanShieldGroupSaveData), alignof(SHumanShieldGroupSaveData), SHumanShieldGroupSaveData::WriteSimpleJson, SHumanShieldGroupSaveData::FromSimpleJson, SHumanShieldGroupSaveData::Serialize, SHumanShieldGroupSaveData::Equals, SHumanShieldGroupSaveData::Destroy);

void SHumanShieldGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGroupTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGroupTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pRelationship") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pRelationship);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SpeechState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHumanShieldSpeechState", static_cast<int>(s_Object->m_SpeechState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPositionMemberIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPositionMemberIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_positionRequestMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_positionRequestMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastPositionRequest") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastPositionRequest, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWeaponFiredTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastWeaponFiredTime, p_Stream);

	p_Stream << "}";
}

void SHumanShieldGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Target);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	ZGameTime::FromSimpleJson(p_Document["m_tGroupTime"], &s_Object->m_tGroupTime);

	s_Object->m_pVictim = simdjson::from_json_uint32(p_Document["m_pVictim"]);

	s_Object->m_pRelationship = simdjson::from_json_uint32(p_Document["m_pRelationship"]);

	s_Object->m_SpeechState = static_cast<EHumanShieldSpeechState>(ZHMEnums::GetEnumValueByName("EHumanShieldSpeechState", std::string_view(p_Document["m_SpeechState"])));

	s_Object->m_nPositionMemberIndex = simdjson::from_json_int32(p_Document["m_nPositionMemberIndex"]);

	s_Object->m_positionRequestMember = simdjson::from_json_uint32(p_Document["m_positionRequestMember"]);

	ZGameTime::FromSimpleJson(p_Document["m_tLastPositionRequest"], &s_Object->m_tLastPositionRequest);

	ZGameTime::FromSimpleJson(p_Document["m_tLastWeaponFiredTime"], &s_Object->m_tLastWeaponFiredTime);

}

void SHumanShieldGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGroupTime, p_Serializer, p_OwnOffset + offsetof(SHumanShieldGroupSaveData, m_tGroupTime));
	ZGameTime::Serialize(&s_Object->m_tLastPositionRequest, p_Serializer, p_OwnOffset + offsetof(SHumanShieldGroupSaveData, m_tLastPositionRequest));
	ZGameTime::Serialize(&s_Object->m_tLastWeaponFiredTime, p_Serializer, p_OwnOffset + offsetof(SHumanShieldGroupSaveData, m_tLastWeaponFiredTime));
}

bool SHumanShieldGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHumanShieldGroupSaveData::operator==(const SHumanShieldGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHumanShieldGroupSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_tGroupTime != p_Other.m_tGroupTime) return false;
	if (m_pVictim != p_Other.m_pVictim) return false;
	if (m_pRelationship != p_Other.m_pRelationship) return false;
	if (m_SpeechState != p_Other.m_SpeechState) return false;
	if (m_nPositionMemberIndex != p_Other.m_nPositionMemberIndex) return false;
	if (m_positionRequestMember != p_Other.m_positionRequestMember) return false;
	if (m_tLastPositionRequest != p_Other.m_tLastPositionRequest) return false;
	if (m_tLastWeaponFiredTime != p_Other.m_tLastWeaponFiredTime) return false;

	return true;
}

void SHumanShieldGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHumanShieldGroupSaveData*>(p_Object);
	s_Object->~SHumanShieldGroupSaveData();
}

ZHMTypeInfo SIntelData::TypeInfo = ZHMTypeInfo("SIntelData", sizeof(SIntelData), alignof(SIntelData), SIntelData::WriteSimpleJson, SIntelData::FromSimpleJson, SIntelData::Serialize, SIntelData::Equals, SIntelData::Destroy);

void SIntelData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sHeadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sHeadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyHeadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyHeadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodytext") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodytext);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);

	p_Stream << "}";
}

void SIntelData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SIntelData*>(p_Target);

	s_Object->m_sHeadline = std::string_view(p_Document["m_sHeadline"]);

	s_Object->m_sBodyHeadline = std::string_view(p_Document["m_sBodyHeadline"]);

	s_Object->m_sBodytext = std::string_view(p_Document["m_sBodytext"]);

	s_Object->m_sImage = std::string_view(p_Document["m_sImage"]);

}

void SIntelData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);

	ZString::Serialize(&s_Object->m_sHeadline, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sHeadline));
	ZString::Serialize(&s_Object->m_sBodyHeadline, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sBodyHeadline));
	ZString::Serialize(&s_Object->m_sBodytext, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sBodytext));
	ZString::Serialize(&s_Object->m_sImage, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sImage));
}

bool SIntelData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelData*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelData::operator==(const SIntelData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelData>)
		return false;

	if (m_sHeadline != p_Other.m_sHeadline) return false;
	if (m_sBodyHeadline != p_Other.m_sBodyHeadline) return false;
	if (m_sBodytext != p_Other.m_sBodytext) return false;
	if (m_sImage != p_Other.m_sImage) return false;

	return true;
}

void SIntelData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);
	s_Object->~SIntelData();
}

ZHMTypeInfo SIntelDataArray_dummy::TypeInfo = ZHMTypeInfo("SIntelDataArray_dummy", sizeof(SIntelDataArray_dummy), alignof(SIntelDataArray_dummy), SIntelDataArray_dummy::WriteSimpleJson, SIntelDataArray_dummy::FromSimpleJson, SIntelDataArray_dummy::Serialize, SIntelDataArray_dummy::Equals, SIntelDataArray_dummy::Destroy);

void SIntelDataArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelDataArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object->dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SIntelData::FromSimpleJson(s_Item0, &s_Object->dummy[s_Index0]);
		++s_Index0;
	}
	}

}

void SIntelDataArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);

	TArray<SIntelData>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelDataArray_dummy, dummy));
}

bool SIntelDataArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDataArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDataArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDataArray_dummy::operator==(const SIntelDataArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDataArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SIntelDataArray_dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);
	s_Object->~SIntelDataArray_dummy();
}

ZHMTypeInfo SIntelDisplayInfo::TypeInfo = ZHMTypeInfo("SIntelDisplayInfo", sizeof(SIntelDisplayInfo), alignof(SIntelDisplayInfo), SIntelDisplayInfo::WriteSimpleJson, SIntelDisplayInfo::FromSimpleJson, SIntelDisplayInfo::Serialize, SIntelDisplayInfo::Equals, SIntelDisplayInfo::Destroy);

void SIntelDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("index") << ":";
	p_Stream << simdjson::as_json_string(s_Object->index);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->selected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("headline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->headline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bodyheadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bodyheadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("text") << ":";
	p_Stream << simdjson::as_json_string(s_Object->text);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("img") << ":";
	p_Stream << simdjson::as_json_string(s_Object->img);

	p_Stream << "}";
}

void SIntelDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Target);

	s_Object->index = simdjson::from_json_int32(p_Document["index"]);

	s_Object->selected = simdjson::from_json_bool(p_Document["selected"]);

	s_Object->active = simdjson::from_json_bool(p_Document["active"]);

	s_Object->headline = std::string_view(p_Document["headline"]);

	s_Object->bodyheadline = std::string_view(p_Document["bodyheadline"]);

	s_Object->text = std::string_view(p_Document["text"]);

	s_Object->img = std::string_view(p_Document["img"]);

}

void SIntelDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->headline, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, headline));
	ZString::Serialize(&s_Object->bodyheadline, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, bodyheadline));
	ZString::Serialize(&s_Object->text, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, text));
	ZString::Serialize(&s_Object->img, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, img));
}

bool SIntelDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDisplayInfo::operator==(const SIntelDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDisplayInfo>)
		return false;

	if (index != p_Other.index) return false;
	if (selected != p_Other.selected) return false;
	if (active != p_Other.active) return false;
	if (headline != p_Other.headline) return false;
	if (bodyheadline != p_Other.bodyheadline) return false;
	if (text != p_Other.text) return false;
	if (img != p_Other.img) return false;

	return true;
}

void SIntelDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);
	s_Object->~SIntelDisplayInfo();
}

ZHMTypeInfo SIntelDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SIntelDisplayInfoArray_dummy", sizeof(SIntelDisplayInfoArray_dummy), alignof(SIntelDisplayInfoArray_dummy), SIntelDisplayInfoArray_dummy::WriteSimpleJson, SIntelDisplayInfoArray_dummy::FromSimpleJson, SIntelDisplayInfoArray_dummy::Serialize, SIntelDisplayInfoArray_dummy::Equals, SIntelDisplayInfoArray_dummy::Destroy);

void SIntelDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object->dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SIntelDisplayInfo::FromSimpleJson(s_Item0, &s_Object->dummy[s_Index0]);
		++s_Index0;
	}
	}

}

void SIntelDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);

	TArray<SIntelDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfoArray_dummy, dummy));
}

bool SIntelDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDisplayInfoArray_dummy::operator==(const SIntelDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SIntelDisplayInfoArray_dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);
	s_Object->~SIntelDisplayInfoArray_dummy();
}

ZHMTypeInfo SIntelListDisplayInfo::TypeInfo = ZHMTypeInfo("SIntelListDisplayInfo", sizeof(SIntelListDisplayInfo), alignof(SIntelListDisplayInfo), SIntelListDisplayInfo::WriteSimpleJson, SIntelListDisplayInfo::FromSimpleJson, SIntelListDisplayInfo::Serialize, SIntelListDisplayInfo::Equals, SIntelListDisplayInfo::Destroy);

void SIntelListDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("index") << ":";
	p_Stream << simdjson::as_json_string(s_Object->index);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("newInfo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->newInfo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);

	p_Stream << "}";
}

void SIntelListDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Target);

	s_Object->index = simdjson::from_json_int32(p_Document["index"]);

	s_Object->active = simdjson::from_json_bool(p_Document["active"]);

	s_Object->newInfo = simdjson::from_json_bool(p_Document["newInfo"]);

	s_Object->label = std::string_view(p_Document["label"]);

}

void SIntelListDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SIntelListDisplayInfo, label));
}

bool SIntelListDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelListDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelListDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelListDisplayInfo::operator==(const SIntelListDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelListDisplayInfo>)
		return false;

	if (index != p_Other.index) return false;
	if (active != p_Other.active) return false;
	if (newInfo != p_Other.newInfo) return false;
	if (label != p_Other.label) return false;

	return true;
}

void SIntelListDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);
	s_Object->~SIntelListDisplayInfo();
}

ZHMTypeInfo SIntelListDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SIntelListDisplayInfoArray_dummy", sizeof(SIntelListDisplayInfoArray_dummy), alignof(SIntelListDisplayInfoArray_dummy), SIntelListDisplayInfoArray_dummy::WriteSimpleJson, SIntelListDisplayInfoArray_dummy::FromSimpleJson, SIntelListDisplayInfoArray_dummy::Serialize, SIntelListDisplayInfoArray_dummy::Equals, SIntelListDisplayInfoArray_dummy::Destroy);

void SIntelListDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelListDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelListDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object->dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SIntelListDisplayInfo::FromSimpleJson(s_Item0, &s_Object->dummy[s_Index0]);
		++s_Index0;
	}
	}

}

void SIntelListDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);

	TArray<SIntelListDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelListDisplayInfoArray_dummy, dummy));
}

bool SIntelListDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelListDisplayInfoArray_dummy::operator==(const SIntelListDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelListDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SIntelListDisplayInfoArray_dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);
	s_Object->~SIntelListDisplayInfoArray_dummy();
}

ZHMTypeInfo SIntelSaveData::TypeInfo = ZHMTypeInfo("SIntelSaveData", sizeof(SIntelSaveData), alignof(SIntelSaveData), SIntelSaveData::WriteSimpleJson, SIntelSaveData::FromSimpleJson, SIntelSaveData::Serialize, SIntelSaveData::Equals, SIntelSaveData::Destroy);

void SIntelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentStage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentStage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTracked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTracked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUnlocked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUnlocked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegistered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsLastTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsLastTriggered);

	p_Stream << "}";
}

void SIntelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SIntelSaveData*>(p_Target);

	s_Object->m_rCurrentStage = simdjson::from_json_uint32(p_Document["m_rCurrentStage"]);

	s_Object->m_bTracked = simdjson::from_json_bool(p_Document["m_bTracked"]);

	s_Object->m_bUnlocked = simdjson::from_json_bool(p_Document["m_bUnlocked"]);

	s_Object->m_bRegistered = simdjson::from_json_bool(p_Document["m_bRegistered"]);

	s_Object->m_bIsLastTriggered = simdjson::from_json_bool(p_Document["m_bIsLastTriggered"]);

}

void SIntelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);

}

bool SIntelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelSaveData::operator==(const SIntelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelSaveData>)
		return false;

	if (m_rCurrentStage != p_Other.m_rCurrentStage) return false;
	if (m_bTracked != p_Other.m_bTracked) return false;
	if (m_bUnlocked != p_Other.m_bUnlocked) return false;
	if (m_bRegistered != p_Other.m_bRegistered) return false;
	if (m_bIsLastTriggered != p_Other.m_bIsLastTriggered) return false;

	return true;
}

void SIntelSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);
	s_Object->~SIntelSaveData();
}

ZHMTypeInfo SInteractionIndicatorInstanceData::TypeInfo = ZHMTypeInfo("SInteractionIndicatorInstanceData", sizeof(SInteractionIndicatorInstanceData), alignof(SInteractionIndicatorInstanceData), SInteractionIndicatorInstanceData::WriteSimpleJson, SInteractionIndicatorInstanceData::FromSimpleJson, SInteractionIndicatorInstanceData::Serialize, SInteractionIndicatorInstanceData::Equals, SInteractionIndicatorInstanceData::Destroy);

void SInteractionIndicatorInstanceData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIconId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIconId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTypeId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTypeId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sGlyph") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sGlyph);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoActionAvailable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoActionAvailable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegalItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegalItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspiciousItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspiciousItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRotateIndicator") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRotateIndicator);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedDataUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedDataUpdate);

	p_Stream << "}";
}

void SInteractionIndicatorInstanceData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Target);

	s_Object->m_eState = simdjson::from_json_int32(p_Document["m_eState"]);

	s_Object->m_nIconId = simdjson::from_json_int32(p_Document["m_nIconId"]);

	s_Object->m_eTypeId = simdjson::from_json_int32(p_Document["m_eTypeId"]);

	s_Object->m_fProgress = simdjson::from_json_float32(p_Document["m_fProgress"]);

	s_Object->m_sLabel = std::string_view(p_Document["m_sLabel"]);

	s_Object->m_sDescription = std::string_view(p_Document["m_sDescription"]);

	s_Object->m_sGlyph = std::string_view(p_Document["m_sGlyph"]);

	s_Object->m_fAnimation = simdjson::from_json_float32(p_Document["m_fAnimation"]);

	s_Object->m_bIllegal = simdjson::from_json_bool(p_Document["m_bIllegal"]);

	s_Object->m_bNoActionAvailable = simdjson::from_json_bool(p_Document["m_bNoActionAvailable"]);

	s_Object->m_bInRange = simdjson::from_json_bool(p_Document["m_bInRange"]);

	s_Object->m_bIllegalItem = simdjson::from_json_bool(p_Document["m_bIllegalItem"]);

	s_Object->m_bSuspiciousItem = simdjson::from_json_bool(p_Document["m_bSuspiciousItem"]);

	s_Object->m_bRotateIndicator = simdjson::from_json_bool(p_Document["m_bRotateIndicator"]);

	SVector2::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	SVector3::FromSimpleJson(p_Document["m_vRotation"], &s_Object->m_vRotation);

	s_Object->m_bNeedDataUpdate = simdjson::from_json_bool(p_Document["m_bNeedDataUpdate"]);

}

void SInteractionIndicatorInstanceData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);

	ZString::Serialize(&s_Object->m_sLabel, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_sLabel));
	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_sDescription));
	ZString::Serialize(&s_Object->m_sGlyph, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_sGlyph));
	SVector2::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_vPosition));
	SVector3::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_vRotation));
}

bool SInteractionIndicatorInstanceData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInteractionIndicatorInstanceData::operator==(const SInteractionIndicatorInstanceData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInteractionIndicatorInstanceData>)
		return false;

	if (m_eState != p_Other.m_eState) return false;
	if (m_nIconId != p_Other.m_nIconId) return false;
	if (m_eTypeId != p_Other.m_eTypeId) return false;
	if (m_fProgress != p_Other.m_fProgress) return false;
	if (m_sLabel != p_Other.m_sLabel) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_sGlyph != p_Other.m_sGlyph) return false;
	if (m_fAnimation != p_Other.m_fAnimation) return false;
	if (m_bIllegal != p_Other.m_bIllegal) return false;
	if (m_bNoActionAvailable != p_Other.m_bNoActionAvailable) return false;
	if (m_bInRange != p_Other.m_bInRange) return false;
	if (m_bIllegalItem != p_Other.m_bIllegalItem) return false;
	if (m_bSuspiciousItem != p_Other.m_bSuspiciousItem) return false;
	if (m_bRotateIndicator != p_Other.m_bRotateIndicator) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_bNeedDataUpdate != p_Other.m_bNeedDataUpdate) return false;

	return true;
}

void SInteractionIndicatorInstanceData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);
	s_Object->~SInteractionIndicatorInstanceData();
}

ZHMTypeInfo SInteractionIndicatorInstanceDataArray_Dummy::TypeInfo = ZHMTypeInfo("SInteractionIndicatorInstanceDataArray_Dummy", sizeof(SInteractionIndicatorInstanceDataArray_Dummy), alignof(SInteractionIndicatorInstanceDataArray_Dummy), SInteractionIndicatorInstanceDataArray_Dummy::WriteSimpleJson, SInteractionIndicatorInstanceDataArray_Dummy::FromSimpleJson, SInteractionIndicatorInstanceDataArray_Dummy::Serialize, SInteractionIndicatorInstanceDataArray_Dummy::Equals, SInteractionIndicatorInstanceDataArray_Dummy::Destroy);

void SInteractionIndicatorInstanceDataArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SInteractionIndicatorInstanceData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInteractionIndicatorInstanceDataArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object->dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInteractionIndicatorInstanceData::FromSimpleJson(s_Item0, &s_Object->dummy[s_Index0]);
		++s_Index0;
	}
	}

}

void SInteractionIndicatorInstanceDataArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);

	TArray<SInteractionIndicatorInstanceData>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceDataArray_Dummy, dummy));
}

bool SInteractionIndicatorInstanceDataArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInteractionIndicatorInstanceDataArray_Dummy::operator==(const SInteractionIndicatorInstanceDataArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInteractionIndicatorInstanceDataArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SInteractionIndicatorInstanceDataArray_Dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);
	s_Object->~SInteractionIndicatorInstanceDataArray_Dummy();
}

ZHMTypeInfo SInventoryControllerItemSaveData::TypeInfo = ZHMTypeInfo("SInventoryControllerItemSaveData", sizeof(SInventoryControllerItemSaveData), alignof(SInventoryControllerItemSaveData), SInventoryControllerItemSaveData::WriteSimpleJson, SInventoryControllerItemSaveData::FromSimpleJson, SInventoryControllerItemSaveData::Serialize, SInventoryControllerItemSaveData::Equals, SInventoryControllerItemSaveData::Destroy);

void SInventoryControllerItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItemEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItemEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fShootingBalletCooldown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fShootingBalletCooldown);

	p_Stream << "}";
}

void SInventoryControllerItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Target);

	s_Object->m_rItemEntity = simdjson::from_json_uint32(p_Document["m_rItemEntity"]);

	s_Object->m_nAmmo = simdjson::from_json_uint32(p_Document["m_nAmmo"]);

	s_Object->m_fShootingBalletCooldown = simdjson::from_json_float32(p_Document["m_fShootingBalletCooldown"]);

}

void SInventoryControllerItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);

}

bool SInventoryControllerItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryControllerItemSaveData::operator==(const SInventoryControllerItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryControllerItemSaveData>)
		return false;

	if (m_rItemEntity != p_Other.m_rItemEntity) return false;
	if (m_nAmmo != p_Other.m_nAmmo) return false;
	if (m_fShootingBalletCooldown != p_Other.m_fShootingBalletCooldown) return false;

	return true;
}

void SInventoryControllerItemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);
	s_Object->~SInventoryControllerItemSaveData();
}

ZHMTypeInfo SStoredSlotSaveData::TypeInfo = ZHMTypeInfo("SStoredSlotSaveData", sizeof(SStoredSlotSaveData), alignof(SStoredSlotSaveData), SStoredSlotSaveData::WriteSimpleJson, SStoredSlotSaveData::FromSimpleJson, SStoredSlotSaveData::Serialize, SStoredSlotSaveData::Equals, SStoredSlotSaveData::Destroy);

void SStoredSlotSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iStoredInventorySlotIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iStoredInventorySlotIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iStoreReason") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iStoreReason);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItemsStored") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemsStored);

	p_Stream << "}";
}

void SStoredSlotSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Target);

	s_Object->m_iStoredInventorySlotIndex = simdjson::from_json_uint32(p_Document["m_iStoredInventorySlotIndex"]);

	s_Object->m_iStoreReason = simdjson::from_json_uint8(p_Document["m_iStoreReason"]);

	s_Object->m_bItemsStored = simdjson::from_json_bool(p_Document["m_bItemsStored"]);

}

void SStoredSlotSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);

}

bool SStoredSlotSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStoredSlotSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStoredSlotSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStoredSlotSaveData::operator==(const SStoredSlotSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStoredSlotSaveData>)
		return false;

	if (m_iStoredInventorySlotIndex != p_Other.m_iStoredInventorySlotIndex) return false;
	if (m_iStoreReason != p_Other.m_iStoreReason) return false;
	if (m_bItemsStored != p_Other.m_bItemsStored) return false;

	return true;
}

void SStoredSlotSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);
	s_Object->~SStoredSlotSaveData();
}

ZHMTypeInfo SInventoryControllerSaveData::TypeInfo = ZHMTypeInfo("SInventoryControllerSaveData", sizeof(SInventoryControllerSaveData), alignof(SInventoryControllerSaveData), SInventoryControllerSaveData::WriteSimpleJson, SInventoryControllerSaveData::FromSimpleJson, SInventoryControllerSaveData::Serialize, SInventoryControllerSaveData::Equals, SInventoryControllerSaveData::Destroy);

void SInventoryControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		SInventoryControllerItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEquippedItemIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEquippedItemIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMostRecentItemIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMostRecentItemIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StoredSlot") << ":";
	SStoredSlotSaveData::WriteSimpleJson(&s_Object->m_StoredSlot, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountGun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountGun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRevolver") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRevolver);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountSMG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountSMG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRifle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRifle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountShotgun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountShotgun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountSniper") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountSniper);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountMG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountMG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRPG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRPG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountFake") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountFake);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountLightPistol") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountLightPistol);

	p_Stream << "}";
}

void SInventoryControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aItems"];
	s_Object->m_aItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInventoryControllerItemSaveData::FromSimpleJson(s_Item0, &s_Object->m_aItems[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_nEquippedItemIndex = simdjson::from_json_uint32(p_Document["m_nEquippedItemIndex"]);

	s_Object->m_nMostRecentItemIndex = simdjson::from_json_uint32(p_Document["m_nMostRecentItemIndex"]);

	SStoredSlotSaveData::FromSimpleJson(p_Document["m_StoredSlot"], &s_Object->m_StoredSlot);

	s_Object->m_nAmmoCountGun = simdjson::from_json_uint32(p_Document["m_nAmmoCountGun"]);

	s_Object->m_nAmmoCountRevolver = simdjson::from_json_uint32(p_Document["m_nAmmoCountRevolver"]);

	s_Object->m_nAmmoCountSMG = simdjson::from_json_uint32(p_Document["m_nAmmoCountSMG"]);

	s_Object->m_nAmmoCountRifle = simdjson::from_json_uint32(p_Document["m_nAmmoCountRifle"]);

	s_Object->m_nAmmoCountShotgun = simdjson::from_json_uint32(p_Document["m_nAmmoCountShotgun"]);

	s_Object->m_nAmmoCountSniper = simdjson::from_json_uint32(p_Document["m_nAmmoCountSniper"]);

	s_Object->m_nAmmoCountMG = simdjson::from_json_uint32(p_Document["m_nAmmoCountMG"]);

	s_Object->m_nAmmoCountRPG = simdjson::from_json_uint32(p_Document["m_nAmmoCountRPG"]);

	s_Object->m_nAmmoCountFake = simdjson::from_json_uint32(p_Document["m_nAmmoCountFake"]);

	s_Object->m_nAmmoCountLightPistol = simdjson::from_json_uint32(p_Document["m_nAmmoCountLightPistol"]);

}

void SInventoryControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);

	TArray<SInventoryControllerItemSaveData>::Serialize(&s_Object->m_aItems, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_aItems));
	SStoredSlotSaveData::Serialize(&s_Object->m_StoredSlot, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_StoredSlot));
}

bool SInventoryControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryControllerSaveData::operator==(const SInventoryControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryControllerSaveData>)
		return false;

	if (m_aItems != p_Other.m_aItems) return false;
	if (m_nEquippedItemIndex != p_Other.m_nEquippedItemIndex) return false;
	if (m_nMostRecentItemIndex != p_Other.m_nMostRecentItemIndex) return false;
	if (m_StoredSlot != p_Other.m_StoredSlot) return false;
	if (m_nAmmoCountGun != p_Other.m_nAmmoCountGun) return false;
	if (m_nAmmoCountRevolver != p_Other.m_nAmmoCountRevolver) return false;
	if (m_nAmmoCountSMG != p_Other.m_nAmmoCountSMG) return false;
	if (m_nAmmoCountRifle != p_Other.m_nAmmoCountRifle) return false;
	if (m_nAmmoCountShotgun != p_Other.m_nAmmoCountShotgun) return false;
	if (m_nAmmoCountSniper != p_Other.m_nAmmoCountSniper) return false;
	if (m_nAmmoCountMG != p_Other.m_nAmmoCountMG) return false;
	if (m_nAmmoCountRPG != p_Other.m_nAmmoCountRPG) return false;
	if (m_nAmmoCountFake != p_Other.m_nAmmoCountFake) return false;
	if (m_nAmmoCountLightPistol != p_Other.m_nAmmoCountLightPistol) return false;

	return true;
}

void SInventoryControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);
	s_Object->~SInventoryControllerSaveData();
}

ZHMTypeInfo ZInvestigateDisguiseGroup::SDialogLines::TypeInfo = ZHMTypeInfo("ZInvestigateDisguiseGroup.SDialogLines", sizeof(ZInvestigateDisguiseGroup::SDialogLines), alignof(ZInvestigateDisguiseGroup::SDialogLines), ZInvestigateDisguiseGroup::SDialogLines::WriteSimpleJson, ZInvestigateDisguiseGroup::SDialogLines::FromSimpleJson, ZInvestigateDisguiseGroup::SDialogLines::Serialize, ZInvestigateDisguiseGroup::SDialogLines::Equals, ZInvestigateDisguiseGroup::SDialogLines::Destroy);

void ZInvestigateDisguiseGroup::SDialogLines::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup::SDialogLines*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFirstWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eFirstWarning)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSecondWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eSecondWarning)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eThirdWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_eThirdWarning)));

	p_Stream << "}";
}

void ZInvestigateDisguiseGroup::SDialogLines::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInvestigateDisguiseGroup::SDialogLines*>(p_Target);

	s_Object->m_eFirstWarning = static_cast<SActorSoundDefs::EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_eFirstWarning"])));

	s_Object->m_eSecondWarning = static_cast<SActorSoundDefs::EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_eSecondWarning"])));

	s_Object->m_eThirdWarning = static_cast<SActorSoundDefs::EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_eThirdWarning"])));

}

void ZInvestigateDisguiseGroup::SDialogLines::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup::SDialogLines*>(p_Object);

}

bool ZInvestigateDisguiseGroup::SDialogLines::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateDisguiseGroup::SDialogLines*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateDisguiseGroup::SDialogLines*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateDisguiseGroup::SDialogLines::operator==(const ZInvestigateDisguiseGroup::SDialogLines& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateDisguiseGroup::SDialogLines>)
		return false;

	if (m_eFirstWarning != p_Other.m_eFirstWarning) return false;
	if (m_eSecondWarning != p_Other.m_eSecondWarning) return false;
	if (m_eThirdWarning != p_Other.m_eThirdWarning) return false;

	return true;
}

void ZInvestigateDisguiseGroup::SDialogLines::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup::SDialogLines*>(p_Object);
	s_Object->~SDialogLines();
}

ZHMTypeInfo ZSituationOrder::TypeInfo = ZHMTypeInfo("ZSituationOrder", sizeof(ZSituationOrder), alignof(ZSituationOrder), ZSituationOrder::WriteSimpleJson, ZSituationOrder::FromSimpleJson, ZSituationOrder::Serialize, ZSituationOrder::Equals, ZSituationOrder::Destroy);

void ZSituationOrder::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSituationOrder::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSituationOrder*>(p_Target);

}

void ZSituationOrder::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);

}

bool ZSituationOrder::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSituationOrder*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSituationOrder*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSituationOrder::operator==(const ZSituationOrder& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSituationOrder>)
		return false;


	return true;
}

void ZSituationOrder::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);
	s_Object->~ZSituationOrder();
}

ZHMTypeInfo ZMoveToOrder::SMoveToOrderSaveData::TypeInfo = ZHMTypeInfo("ZMoveToOrder.SMoveToOrderSaveData", sizeof(ZMoveToOrder::SMoveToOrderSaveData), alignof(ZMoveToOrder::SMoveToOrderSaveData), ZMoveToOrder::SMoveToOrderSaveData::WriteSimpleJson, ZMoveToOrder::SMoveToOrderSaveData::FromSimpleJson, ZMoveToOrder::SMoveToOrderSaveData::Serialize, ZMoveToOrder::SMoveToOrderSaveData::Equals, ZMoveToOrder::SMoveToOrderSaveData::Destroy);

void ZMoveToOrder::SMoveToOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder::SMoveToOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStopDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStopDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fWalkDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWalkDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleBlockageFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleBlockageFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZMoveToOrder.EMoveSpeed", static_cast<int>(s_Object->m_eMoveSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreEndCollision") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreEndCollision);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPrecisePositioning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPrecisePositioning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceStand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceStand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLookAtTargetMustBeInSight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAtTargetMustBeInSight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseKnownPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseKnownPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStrafe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStrafe);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEndStanding") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEndStanding);

	p_Stream << "}";
}

void ZMoveToOrder::SMoveToOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZMoveToOrder::SMoveToOrderSaveData*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Object->m_vStopDirection);

	s_Object->m_fStopDistance = simdjson::from_json_float32(p_Document["m_fStopDistance"]);

	s_Object->m_fWalkDistance = simdjson::from_json_float32(p_Document["m_fWalkDistance"]);

	s_Object->m_nObstacleBlockageFlags = simdjson::from_json_uint32(p_Document["m_nObstacleBlockageFlags"]);

	s_Object->m_eMoveSpeed = static_cast<ZMoveToOrder::EMoveSpeed>(ZHMEnums::GetEnumValueByName("ZMoveToOrder.EMoveSpeed", std::string_view(p_Document["m_eMoveSpeed"])));

	s_Object->m_bIgnoreEndCollision = simdjson::from_json_bool(p_Document["m_bIgnoreEndCollision"]);

	s_Object->m_bPrecisePositioning = simdjson::from_json_bool(p_Document["m_bPrecisePositioning"]);

	s_Object->m_bForceStand = simdjson::from_json_bool(p_Document["m_bForceStand"]);

	s_Object->m_bLookAtTargetMustBeInSight = simdjson::from_json_bool(p_Document["m_bLookAtTargetMustBeInSight"]);

	s_Object->m_bUseKnownPosition = simdjson::from_json_bool(p_Document["m_bUseKnownPosition"]);

	s_Object->m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

	s_Object->m_bStrafe = simdjson::from_json_bool(p_Document["m_bStrafe"]);

	s_Object->m_bEndStanding = simdjson::from_json_bool(p_Document["m_bEndStanding"]);

}

void ZMoveToOrder::SMoveToOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder::SMoveToOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZMoveToOrder::SMoveToOrderSaveData, m_vStopDirection));
}

bool ZMoveToOrder::SMoveToOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZMoveToOrder::SMoveToOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZMoveToOrder::SMoveToOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZMoveToOrder::SMoveToOrderSaveData::operator==(const ZMoveToOrder::SMoveToOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZMoveToOrder::SMoveToOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_fStopDistance != p_Other.m_fStopDistance) return false;
	if (m_fWalkDistance != p_Other.m_fWalkDistance) return false;
	if (m_nObstacleBlockageFlags != p_Other.m_nObstacleBlockageFlags) return false;
	if (m_eMoveSpeed != p_Other.m_eMoveSpeed) return false;
	if (m_bIgnoreEndCollision != p_Other.m_bIgnoreEndCollision) return false;
	if (m_bPrecisePositioning != p_Other.m_bPrecisePositioning) return false;
	if (m_bForceStand != p_Other.m_bForceStand) return false;
	if (m_bLookAtTargetMustBeInSight != p_Other.m_bLookAtTargetMustBeInSight) return false;
	if (m_bUseKnownPosition != p_Other.m_bUseKnownPosition) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;
	if (m_bStrafe != p_Other.m_bStrafe) return false;
	if (m_bEndStanding != p_Other.m_bEndStanding) return false;

	return true;
}

void ZMoveToOrder::SMoveToOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder::SMoveToOrderSaveData*>(p_Object);
	s_Object->~SMoveToOrderSaveData();
}

ZHMTypeInfo SInvestigateDisguiseGroupSaveData::TypeInfo = ZHMTypeInfo("SInvestigateDisguiseGroupSaveData", sizeof(SInvestigateDisguiseGroupSaveData), alignof(SInvestigateDisguiseGroupSaveData), SInvestigateDisguiseGroupSaveData::WriteSimpleJson, SInvestigateDisguiseGroupSaveData::FromSimpleJson, SInvestigateDisguiseGroupSaveData::Serialize, SInvestigateDisguiseGroupSaveData::Equals, SInvestigateDisguiseGroupSaveData::Destroy);

void SInvestigateDisguiseGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateDisguiseGroup.EState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pPendingLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pPendingLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_groupAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_groupAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDisguiseFollowTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDisguiseFollowTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWarning") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastWarning, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eLeaderMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZMoveToOrder.EMoveSpeed", static_cast<int>(s_Object->m_eLeaderMoveSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDownOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastStandDownOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartFollow") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartFollow, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginalPositionLeader") << ":";
	float4::WriteSimpleJson(&s_Object->m_vOriginalPositionLeader, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_dialogLines") << ":";
	ZInvestigateDisguiseGroup::SDialogLines::WriteSimpleJson(&s_Object->m_dialogLines, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSearchCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderMovingBack") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderMovingBack);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitingForDistanceStanddown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitingForDistanceStanddown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFollow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFollow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMembersFollow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMembersFollow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunningWarningIssued") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunningWarningIssued);

	p_Stream << "}";
}

void SInvestigateDisguiseGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Target);

	s_Object->m_state = static_cast<ZInvestigateDisguiseGroup::EState>(ZHMEnums::GetEnumValueByName("ZInvestigateDisguiseGroup.EState", std::string_view(p_Document["m_state"])));

	s_Object->m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object->m_pPendingLeader = simdjson::from_json_uint32(p_Document["m_pPendingLeader"]);

	ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Object->m_tStart);

	s_Object->m_groupAge = simdjson::from_json_float32(p_Document["m_groupAge"]);

	s_Object->m_fDisguiseFollowTime = simdjson::from_json_float32(p_Document["m_fDisguiseFollowTime"]);

	s_Object->m_fTargetRunningTime = simdjson::from_json_float32(p_Document["m_fTargetRunningTime"]);

	ZGameTime::FromSimpleJson(p_Document["m_tLastWarning"], &s_Object->m_tLastWarning);

	s_Object->m_iWarningCount = simdjson::from_json_int32(p_Document["m_iWarningCount"]);

	s_Object->m_eLeaderMoveSpeed = static_cast<ZMoveToOrder::EMoveSpeed>(ZHMEnums::GetEnumValueByName("ZMoveToOrder.EMoveSpeed", std::string_view(p_Document["m_eLeaderMoveSpeed"])));

	ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Object->m_tLastEscalateOrder);

	ZGameTime::FromSimpleJson(p_Document["m_tLastStandDownOrder"], &s_Object->m_tLastStandDownOrder);

	ZGameTime::FromSimpleJson(p_Document["m_tStartFollow"], &s_Object->m_tStartFollow);

	float4::FromSimpleJson(p_Document["m_vOriginalPositionLeader"], &s_Object->m_vOriginalPositionLeader);

	ZInvestigateDisguiseGroup::SDialogLines::FromSimpleJson(p_Document["m_dialogLines"], &s_Object->m_dialogLines);

	s_Object->m_bLeaderOrderAssigned = simdjson::from_json_bool(p_Document["m_bLeaderOrderAssigned"]);

	s_Object->m_bSearchCompleted = simdjson::from_json_bool(p_Document["m_bSearchCompleted"]);

	s_Object->m_bLeaderMovingBack = simdjson::from_json_bool(p_Document["m_bLeaderMovingBack"]);

	s_Object->m_bWaitingForDistanceStanddown = simdjson::from_json_bool(p_Document["m_bWaitingForDistanceStanddown"]);

	s_Object->m_bFollow = simdjson::from_json_bool(p_Document["m_bFollow"]);

	s_Object->m_bMembersFollow = simdjson::from_json_bool(p_Document["m_bMembersFollow"]);

	s_Object->m_bRunningWarningIssued = simdjson::from_json_bool(p_Document["m_bRunningWarningIssued"]);

}

void SInvestigateDisguiseGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tStart));
	ZGameTime::Serialize(&s_Object->m_tLastWarning, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastWarning));
	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastEscalateOrder));
	ZGameTime::Serialize(&s_Object->m_tLastStandDownOrder, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastStandDownOrder));
	ZGameTime::Serialize(&s_Object->m_tStartFollow, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tStartFollow));
	float4::Serialize(&s_Object->m_vOriginalPositionLeader, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_vOriginalPositionLeader));
	ZInvestigateDisguiseGroup::SDialogLines::Serialize(&s_Object->m_dialogLines, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_dialogLines));
}

bool SInvestigateDisguiseGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInvestigateDisguiseGroupSaveData::operator==(const SInvestigateDisguiseGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInvestigateDisguiseGroupSaveData>)
		return false;

	if (m_state != p_Other.m_state) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pPendingLeader != p_Other.m_pPendingLeader) return false;
	if (m_tStart != p_Other.m_tStart) return false;
	if (m_groupAge != p_Other.m_groupAge) return false;
	if (m_fDisguiseFollowTime != p_Other.m_fDisguiseFollowTime) return false;
	if (m_fTargetRunningTime != p_Other.m_fTargetRunningTime) return false;
	if (m_tLastWarning != p_Other.m_tLastWarning) return false;
	if (m_iWarningCount != p_Other.m_iWarningCount) return false;
	if (m_eLeaderMoveSpeed != p_Other.m_eLeaderMoveSpeed) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_tLastStandDownOrder != p_Other.m_tLastStandDownOrder) return false;
	if (m_tStartFollow != p_Other.m_tStartFollow) return false;
	if (m_vOriginalPositionLeader != p_Other.m_vOriginalPositionLeader) return false;
	if (m_dialogLines != p_Other.m_dialogLines) return false;
	if (m_bLeaderOrderAssigned != p_Other.m_bLeaderOrderAssigned) return false;
	if (m_bSearchCompleted != p_Other.m_bSearchCompleted) return false;
	if (m_bLeaderMovingBack != p_Other.m_bLeaderMovingBack) return false;
	if (m_bWaitingForDistanceStanddown != p_Other.m_bWaitingForDistanceStanddown) return false;
	if (m_bFollow != p_Other.m_bFollow) return false;
	if (m_bMembersFollow != p_Other.m_bMembersFollow) return false;
	if (m_bRunningWarningIssued != p_Other.m_bRunningWarningIssued) return false;

	return true;
}

void SInvestigateDisguiseGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);
	s_Object->~SInvestigateDisguiseGroupSaveData();
}

ZHMTypeInfo SInvestigateWeaponGroupSaveData::TypeInfo = ZHMTypeInfo("SInvestigateWeaponGroupSaveData", sizeof(SInvestigateWeaponGroupSaveData), alignof(SInvestigateWeaponGroupSaveData), SInvestigateWeaponGroupSaveData::WriteSimpleJson, SInvestigateWeaponGroupSaveData::FromSimpleJson, SInvestigateWeaponGroupSaveData::Serialize, SInvestigateWeaponGroupSaveData::Equals, SInvestigateWeaponGroupSaveData::Destroy);

void SInvestigateWeaponGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rReporter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rReporter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInvestigator") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInvestigator);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastGuardSearch") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastGuardSearch, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aUnconsciousGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aUnconsciousGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aUnconsciousGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aUnconsciousGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInvestigateWeaponGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Target);

	s_Object->m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object->m_rReporter = simdjson::from_json_uint32(p_Document["m_rReporter"]);

	s_Object->m_rInvestigator = simdjson::from_json_uint32(p_Document["m_rInvestigator"]);

	s_Object->m_rGuard = simdjson::from_json_uint32(p_Document["m_rGuard"]);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	ZGameTime::FromSimpleJson(p_Document["m_tLastGuardSearch"], &s_Object->m_tLastGuardSearch);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aUnconsciousGuards"];
	s_Object->m_aUnconsciousGuards.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aUnconsciousGuards[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SInvestigateWeaponGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tLastGuardSearch, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_tLastGuardSearch));
	TArray<uint32>::Serialize(&s_Object->m_aUnconsciousGuards, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_aUnconsciousGuards));
}

bool SInvestigateWeaponGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInvestigateWeaponGroupSaveData::operator==(const SInvestigateWeaponGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInvestigateWeaponGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_rReporter != p_Other.m_rReporter) return false;
	if (m_rInvestigator != p_Other.m_rInvestigator) return false;
	if (m_rGuard != p_Other.m_rGuard) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tLastGuardSearch != p_Other.m_tLastGuardSearch) return false;
	if (m_aUnconsciousGuards != p_Other.m_aUnconsciousGuards) return false;

	return true;
}

void SInvestigateWeaponGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);
	s_Object->~SInvestigateWeaponGroupSaveData();
}

ZHMTypeInfo SItemOnBackUIData::TypeInfo = ZHMTypeInfo("SItemOnBackUIData", sizeof(SItemOnBackUIData), alignof(SItemOnBackUIData), SItemOnBackUIData::WriteSimpleJson, SItemOnBackUIData::FromSimpleJson, SItemOnBackUIData::Serialize, SItemOnBackUIData::Equals, SItemOnBackUIData::Destroy);

void SItemOnBackUIData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHasItemToShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHasItemToShow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIllegal);

	p_Stream << "}";
}

void SItemOnBackUIData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Target);

	ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Object->icon);

	s_Object->bHasItemToShow = simdjson::from_json_bool(p_Document["bHasItemToShow"]);

	s_Object->bSuspicious = simdjson::from_json_bool(p_Document["bSuspicious"]);

	s_Object->bIllegal = simdjson::from_json_bool(p_Document["bIllegal"]);

}

void SItemOnBackUIData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SItemOnBackUIData, icon));
}

bool SItemOnBackUIData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemOnBackUIData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemOnBackUIData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemOnBackUIData::operator==(const SItemOnBackUIData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemOnBackUIData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (bHasItemToShow != p_Other.bHasItemToShow) return false;
	if (bSuspicious != p_Other.bSuspicious) return false;
	if (bIllegal != p_Other.bIllegal) return false;

	return true;
}

void SItemOnBackUIData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);
	s_Object->~SItemOnBackUIData();
}

ZHMTypeInfo SItemSpawnerSaveData::TypeInfo = ZHMTypeInfo("SItemSpawnerSaveData", sizeof(SItemSpawnerSaveData), alignof(SItemSpawnerSaveData), SItemSpawnerSaveData::WriteSimpleJson, SItemSpawnerSaveData::FromSimpleJson, SItemSpawnerSaveData::Serialize, SItemSpawnerSaveData::Equals, SItemSpawnerSaveData::Destroy);

void SItemSpawnerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bItemUpdateTransformChange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemUpdateTransformChange);

	p_Stream << "}";
}

void SItemSpawnerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Target);

	s_Object->m_bItemUpdateTransformChange = simdjson::from_json_bool(p_Document["m_bItemUpdateTransformChange"]);

}

void SItemSpawnerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);

}

bool SItemSpawnerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemSpawnerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemSpawnerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemSpawnerSaveData::operator==(const SItemSpawnerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemSpawnerSaveData>)
		return false;

	if (m_bItemUpdateTransformChange != p_Other.m_bItemUpdateTransformChange) return false;

	return true;
}

void SItemSpawnerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);
	s_Object->~SItemSpawnerSaveData();
}

ZHMTypeInfo SItemStorageSaveData::TypeInfo = ZHMTypeInfo("SItemStorageSaveData", sizeof(SItemStorageSaveData), alignof(SItemStorageSaveData), SItemStorageSaveData::WriteSimpleJson, SItemStorageSaveData::FromSimpleJson, SItemStorageSaveData::Serialize, SItemStorageSaveData::Equals, SItemStorageSaveData::Destroy);

void SItemStorageSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ContainedItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_ContainedItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Storage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_Storage);

	p_Stream << "}";
}

void SItemStorageSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Target);

	s_Object->m_ContainedItem = simdjson::from_json_uint32(p_Document["m_ContainedItem"]);

	s_Object->m_Storage = simdjson::from_json_uint32(p_Document["m_Storage"]);

}

void SItemStorageSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);

}

bool SItemStorageSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemStorageSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemStorageSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemStorageSaveData::operator==(const SItemStorageSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemStorageSaveData>)
		return false;

	if (m_ContainedItem != p_Other.m_ContainedItem) return false;
	if (m_Storage != p_Other.m_Storage) return false;

	return true;
}

void SItemStorageSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);
	s_Object->~SItemStorageSaveData();
}

ZHMTypeInfo SItemWeaponSaveData::TypeInfo = ZHMTypeInfo("SItemWeaponSaveData", sizeof(SItemWeaponSaveData), alignof(SItemWeaponSaveData), SItemWeaponSaveData::WriteSimpleJson, SItemWeaponSaveData::FromSimpleJson, SItemWeaponSaveData::Serialize, SItemWeaponSaveData::Equals, SItemWeaponSaveData::Destroy);

void SItemWeaponSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nBulletsInMagazine") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletsInMagazine);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nExtraMagazineBullets") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nExtraMagazineBullets);

	p_Stream << "}";
}

void SItemWeaponSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Target);

	s_Object->m_nBulletsInMagazine = simdjson::from_json_uint16(p_Document["m_nBulletsInMagazine"]);

	s_Object->m_nExtraMagazineBullets = simdjson::from_json_uint16(p_Document["m_nExtraMagazineBullets"]);

}

void SItemWeaponSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);

}

bool SItemWeaponSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemWeaponSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemWeaponSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemWeaponSaveData::operator==(const SItemWeaponSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemWeaponSaveData>)
		return false;

	if (m_nBulletsInMagazine != p_Other.m_nBulletsInMagazine) return false;
	if (m_nExtraMagazineBullets != p_Other.m_nExtraMagazineBullets) return false;

	return true;
}

void SItemWeaponSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);
	s_Object->~SItemWeaponSaveData();
}

ZHMTypeInfo SLayerBehaviorConfiguration::TypeInfo = ZHMTypeInfo("SLayerBehaviorConfiguration", sizeof(SLayerBehaviorConfiguration), alignof(SLayerBehaviorConfiguration), SLayerBehaviorConfiguration::WriteSimpleJson, SLayerBehaviorConfiguration::FromSimpleJson, SLayerBehaviorConfiguration::Serialize, SLayerBehaviorConfiguration::Equals, SLayerBehaviorConfiguration::Destroy);

void SLayerBehaviorConfiguration::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bTrigger") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTrigger);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCollector") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollector);

	p_Stream << "}";
}

void SLayerBehaviorConfiguration::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Target);

	s_Object->m_bTrigger = simdjson::from_json_bool(p_Document["m_bTrigger"]);

	s_Object->m_bCollector = simdjson::from_json_bool(p_Document["m_bCollector"]);

}

void SLayerBehaviorConfiguration::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);

}

bool SLayerBehaviorConfiguration::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Left);
	auto* s_Right = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLayerBehaviorConfiguration::operator==(const SLayerBehaviorConfiguration& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLayerBehaviorConfiguration>)
		return false;

	if (m_bTrigger != p_Other.m_bTrigger) return false;
	if (m_bCollector != p_Other.m_bCollector) return false;

	return true;
}

void SLayerBehaviorConfiguration::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);
	s_Object->~SLayerBehaviorConfiguration();
}

ZHMTypeInfo SLeadEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SLeadEscortSituationActorStateSaveData", sizeof(SLeadEscortSituationActorStateSaveData), alignof(SLeadEscortSituationActorStateSaveData), SLeadEscortSituationActorStateSaveData::WriteSimpleJson, SLeadEscortSituationActorStateSaveData::FromSimpleJson, SLeadEscortSituationActorStateSaveData::Serialize, SLeadEscortSituationActorStateSaveData::Equals, SLeadEscortSituationActorStateSaveData::Destroy);

void SLeadEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SLeadEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Target);

	s_Object->m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object->m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object->m_eState = static_cast<ZLeadEscortSituationEntity::EEscortState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object->m_eStatePrevious = static_cast<ZLeadEscortSituationEntity::EEscortState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object->m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object->m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object->m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

}

void SLeadEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);

}

bool SLeadEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationActorStateSaveData::operator==(const SLeadEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

void SLeadEscortSituationActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);
	s_Object->~SLeadEscortSituationActorStateSaveData();
}

ZHMTypeInfo SLeadEscortSituationActors::TypeInfo = ZHMTypeInfo("SLeadEscortSituationActors", sizeof(SLeadEscortSituationActors), alignof(SLeadEscortSituationActors), SLeadEscortSituationActors::WriteSimpleJson, SLeadEscortSituationActors::FromSimpleJson, SLeadEscortSituationActors::Serialize, SLeadEscortSituationActors::Equals, SLeadEscortSituationActors::Destroy);

void SLeadEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SLeadEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

}

void SLeadEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);

}

bool SLeadEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationActors::operator==(const SLeadEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SLeadEscortSituationActors::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);
	s_Object->~SLeadEscortSituationActors();
}

ZHMTypeInfo SLeadEscortSituationSaveData::TypeInfo = ZHMTypeInfo("SLeadEscortSituationSaveData", sizeof(SLeadEscortSituationSaveData), alignof(SLeadEscortSituationSaveData), SLeadEscortSituationSaveData::WriteSimpleJson, SLeadEscortSituationSaveData::FromSimpleJson, SLeadEscortSituationSaveData::Serialize, SLeadEscortSituationSaveData::Equals, SLeadEscortSituationSaveData::Destroy);

void SLeadEscortSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SLeadEscortSituationActors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SLeadEscortSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLeadEscortSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Target);

	s_Object->m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object->m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object->m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object->m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object->m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Object->m_vLastPosition);

	s_Object->m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object->m_eTargetState = static_cast<ZLeadEscortSituationEntity::ETargetState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object->m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object->m_eTargetActState = static_cast<ZActBehaviorEntity::EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object->m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object->m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAddedActors"];
	s_Object->m_aAddedActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLeadEscortSituationActors::FromSimpleJson(s_Item0, &s_Object->m_aAddedActors[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object->m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLeadEscortSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_Object->m_aStates[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEscortActs"];
	s_Object->m_aEscortActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEscortActs[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SLeadEscortSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_vLastPosition));
	TArray<SLeadEscortSituationActors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aAddedActors));
	TArray<SLeadEscortSituationActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aEscortActs));
}

bool SLeadEscortSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationSaveData::operator==(const SLeadEscortSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationSaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;

	return true;
}

void SLeadEscortSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);
	s_Object->~SLeadEscortSituationSaveData();
}

ZHMTypeInfo SLevelReferenceableEntitieSaveData::TypeInfo = ZHMTypeInfo("SLevelReferenceableEntitieSaveData", sizeof(SLevelReferenceableEntitieSaveData), alignof(SLevelReferenceableEntitieSaveData), SLevelReferenceableEntitieSaveData::WriteSimpleJson, SLevelReferenceableEntitieSaveData::FromSimpleJson, SLevelReferenceableEntitieSaveData::Serialize, SLevelReferenceableEntitieSaveData::Equals, SLevelReferenceableEntitieSaveData::Destroy);

void SLevelReferenceableEntitieSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sSceneResource") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sSceneResource);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAdditionalBrickResources") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAdditionalBrickResources.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAdditionalBrickResources[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAdditionalBrickResources.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLevelReferenceableEntitieSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Target);

	s_Object->m_sSceneResource = std::string_view(p_Document["m_sSceneResource"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAdditionalBrickResources"];
	s_Object->m_aAdditionalBrickResources.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aAdditionalBrickResources[s_Index0] = std::string_view(s_Item0);
		++s_Index0;
	}
	}

}

void SLevelReferenceableEntitieSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sSceneResource, p_Serializer, p_OwnOffset + offsetof(SLevelReferenceableEntitieSaveData, m_sSceneResource));
	TArray<ZString>::Serialize(&s_Object->m_aAdditionalBrickResources, p_Serializer, p_OwnOffset + offsetof(SLevelReferenceableEntitieSaveData, m_aAdditionalBrickResources));
}

bool SLevelReferenceableEntitieSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLevelReferenceableEntitieSaveData::operator==(const SLevelReferenceableEntitieSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLevelReferenceableEntitieSaveData>)
		return false;

	if (m_sSceneResource != p_Other.m_sSceneResource) return false;
	if (m_aAdditionalBrickResources != p_Other.m_aAdditionalBrickResources) return false;

	return true;
}

void SLevelReferenceableEntitieSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);
	s_Object->~SLevelReferenceableEntitieSaveData();
}

ZHMTypeInfo SSoundAmbienceSaveData::TypeInfo = ZHMTypeInfo("SSoundAmbienceSaveData", sizeof(SSoundAmbienceSaveData), alignof(SSoundAmbienceSaveData), SSoundAmbienceSaveData::WriteSimpleJson, SSoundAmbienceSaveData::FromSimpleJson, SSoundAmbienceSaveData::Serialize, SSoundAmbienceSaveData::Equals, SSoundAmbienceSaveData::Destroy);

void SSoundAmbienceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentAmbience") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentAmbience);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentGate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentGate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTransitionAmount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTransitionAmount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnteredFromSide0") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnteredFromSide0);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInTransition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInTransition);

	p_Stream << "}";
}

void SSoundAmbienceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Target);

	s_Object->m_rCurrentAmbience = simdjson::from_json_uint32(p_Document["m_rCurrentAmbience"]);

	s_Object->m_rCurrentGate = simdjson::from_json_uint32(p_Document["m_rCurrentGate"]);

	s_Object->m_fTransitionAmount = simdjson::from_json_float32(p_Document["m_fTransitionAmount"]);

	s_Object->m_bEnteredFromSide0 = simdjson::from_json_bool(p_Document["m_bEnteredFromSide0"]);

	s_Object->m_bInTransition = simdjson::from_json_bool(p_Document["m_bInTransition"]);

}

void SSoundAmbienceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);

}

bool SSoundAmbienceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSoundAmbienceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSoundAmbienceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSoundAmbienceSaveData::operator==(const SSoundAmbienceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSoundAmbienceSaveData>)
		return false;

	if (m_rCurrentAmbience != p_Other.m_rCurrentAmbience) return false;
	if (m_rCurrentGate != p_Other.m_rCurrentGate) return false;
	if (m_fTransitionAmount != p_Other.m_fTransitionAmount) return false;
	if (m_bEnteredFromSide0 != p_Other.m_bEnteredFromSide0) return false;
	if (m_bInTransition != p_Other.m_bInTransition) return false;

	return true;
}

void SSoundAmbienceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);
	s_Object->~SSoundAmbienceSaveData();
}

ZHMTypeInfo SObjetiveSaveData::TypeInfo = ZHMTypeInfo("SObjetiveSaveData", sizeof(SObjetiveSaveData), alignof(SObjetiveSaveData), SObjetiveSaveData::WriteSimpleJson, SObjetiveSaveData::FromSimpleJson, SObjetiveSaveData::Serialize, SObjetiveSaveData::Equals, SObjetiveSaveData::Destroy);

void SObjetiveSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Type", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SaveData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_SaveData, p_Stream);

	p_Stream << "}";
}

void SObjetiveSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Target);

	s_Object->m_eType = static_cast<IContractObjective::Type>(ZHMEnums::GetEnumValueByName("IContractObjective.Type", std::string_view(p_Document["m_eType"])));

	ZVariant::FromSimpleJson(p_Document["m_SaveData"], &s_Object->m_SaveData);

}

void SObjetiveSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_SaveData, p_Serializer, p_OwnOffset + offsetof(SObjetiveSaveData, m_SaveData));
}

bool SObjetiveSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SObjetiveSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SObjetiveSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SObjetiveSaveData::operator==(const SObjetiveSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SObjetiveSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_SaveData != p_Other.m_SaveData) return false;

	return true;
}

void SObjetiveSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);
	s_Object->~SObjetiveSaveData();
}

ZHMTypeInfo SLightFlickerEntitySaveData::TypeInfo = ZHMTypeInfo("SLightFlickerEntitySaveData", sizeof(SLightFlickerEntitySaveData), alignof(SLightFlickerEntitySaveData), SLightFlickerEntitySaveData::WriteSimpleJson, SLightFlickerEntitySaveData::FromSimpleJson, SLightFlickerEntitySaveData::Serialize, SLightFlickerEntitySaveData::Equals, SLightFlickerEntitySaveData::Destroy);

void SLightFlickerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bLightOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLightOn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFlickerOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFlickerOn);

	p_Stream << "}";
}

void SLightFlickerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Target);

	s_Object->m_bLightOn = simdjson::from_json_bool(p_Document["m_bLightOn"]);

	s_Object->m_bFlickerOn = simdjson::from_json_bool(p_Document["m_bFlickerOn"]);

}

void SLightFlickerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);

}

bool SLightFlickerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLightFlickerEntitySaveData::operator==(const SLightFlickerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLightFlickerEntitySaveData>)
		return false;

	if (m_bLightOn != p_Other.m_bLightOn) return false;
	if (m_bFlickerOn != p_Other.m_bFlickerOn) return false;

	return true;
}

void SLightFlickerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);
	s_Object->~SLightFlickerEntitySaveData();
}

ZHMTypeInfo SLoadRuntimeResourceResult::TypeInfo = ZHMTypeInfo("SLoadRuntimeResourceResult", sizeof(SLoadRuntimeResourceResult), alignof(SLoadRuntimeResourceResult), SLoadRuntimeResourceResult::WriteSimpleJson, SLoadRuntimeResourceResult::FromSimpleJson, SLoadRuntimeResourceResult::Serialize, SLoadRuntimeResourceResult::Equals, SLoadRuntimeResourceResult::Destroy);

void SLoadRuntimeResourceResult::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFilePath") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFilePath);

	p_Stream << "}";
}

void SLoadRuntimeResourceResult::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Target);

	s_Object->sFilePath = std::string_view(p_Document["sFilePath"]);

}

void SLoadRuntimeResourceResult::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	ZString::Serialize(&s_Object->sFilePath, p_Serializer, p_OwnOffset + offsetof(SLoadRuntimeResourceResult, sFilePath));
}

bool SLoadRuntimeResourceResult::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Left);
	auto* s_Right = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLoadRuntimeResourceResult::operator==(const SLoadRuntimeResourceResult& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLoadRuntimeResourceResult>)
		return false;

	if (sFilePath != p_Other.sFilePath) return false;

	return true;
}

void SLoadRuntimeResourceResult::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);
	s_Object->~SLoadRuntimeResourceResult();
}

ZHMTypeInfo SLocalizedVideoData::TypeInfo = ZHMTypeInfo("SLocalizedVideoData", sizeof(SLocalizedVideoData), alignof(SLocalizedVideoData), SLocalizedVideoData::WriteSimpleJson, SLocalizedVideoData::FromSimpleJson, SLocalizedVideoData::Serialize, SLocalizedVideoData::Equals, SLocalizedVideoData::Destroy);

void SLocalizedVideoData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("AudioLanguages") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->AudioLanguages.size(); ++i)
	{
		auto& s_Item0 = s_Object->AudioLanguages[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->AudioLanguages.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("VideoRidsPerAudioLanguage") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->VideoRidsPerAudioLanguage.size(); ++i)
	{
		auto& s_Item0 = s_Object->VideoRidsPerAudioLanguage[i];
		ZRuntimeResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->VideoRidsPerAudioLanguage.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SubtitleLanguages") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->SubtitleLanguages.size(); ++i)
	{
		auto& s_Item0 = s_Object->SubtitleLanguages[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->SubtitleLanguages.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SubtitleMarkupsPerLanguage") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->SubtitleMarkupsPerLanguage.size(); ++i)
	{
		auto& s_Item0 = s_Object->SubtitleMarkupsPerLanguage[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->SubtitleMarkupsPerLanguage.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLocalizedVideoData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["AudioLanguages"];
	s_Object->AudioLanguages.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->AudioLanguages[s_Index0] = std::string_view(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["VideoRidsPerAudioLanguage"];
	s_Object->VideoRidsPerAudioLanguage.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZRuntimeResourceID::FromSimpleJson(s_Item0, &s_Object->VideoRidsPerAudioLanguage[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["SubtitleLanguages"];
	s_Object->SubtitleLanguages.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->SubtitleLanguages[s_Index0] = std::string_view(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["SubtitleMarkupsPerLanguage"];
	s_Object->SubtitleMarkupsPerLanguage.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->SubtitleMarkupsPerLanguage[s_Index0] = std::string_view(s_Item0);
		++s_Index0;
	}
	}

}

void SLocalizedVideoData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);

	TArray<ZString>::Serialize(&s_Object->AudioLanguages, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, AudioLanguages));
	TArray<ZRuntimeResourceID>::Serialize(&s_Object->VideoRidsPerAudioLanguage, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, VideoRidsPerAudioLanguage));
	TArray<ZString>::Serialize(&s_Object->SubtitleLanguages, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, SubtitleLanguages));
	TArray<ZString>::Serialize(&s_Object->SubtitleMarkupsPerLanguage, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, SubtitleMarkupsPerLanguage));
}

bool SLocalizedVideoData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLocalizedVideoData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLocalizedVideoData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLocalizedVideoData::operator==(const SLocalizedVideoData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLocalizedVideoData>)
		return false;

	if (AudioLanguages != p_Other.AudioLanguages) return false;
	if (VideoRidsPerAudioLanguage != p_Other.VideoRidsPerAudioLanguage) return false;
	if (SubtitleLanguages != p_Other.SubtitleLanguages) return false;
	if (SubtitleMarkupsPerLanguage != p_Other.SubtitleMarkupsPerLanguage) return false;

	return true;
}

void SLocalizedVideoData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);
	s_Object->~SLocalizedVideoData();
}

ZHMTypeInfo SLockdownManagerAIZoneSaveData::TypeInfo = ZHMTypeInfo("SLockdownManagerAIZoneSaveData", sizeof(SLockdownManagerAIZoneSaveData), alignof(SLockdownManagerAIZoneSaveData), SLockdownManagerAIZoneSaveData::WriteSimpleJson, SLockdownManagerAIZoneSaveData::FromSimpleJson, SLockdownManagerAIZoneSaveData::Serialize, SLockdownManagerAIZoneSaveData::Equals, SLockdownManagerAIZoneSaveData::Destroy);

void SLockdownManagerAIZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tExpiry") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiry, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tExpiryHeroOutside") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiryHeroOutside, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rZone);

	p_Stream << "}";
}

void SLockdownManagerAIZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_tExpiry"], &s_Object->m_tExpiry);

	ZGameTime::FromSimpleJson(p_Document["m_tExpiryHeroOutside"], &s_Object->m_tExpiryHeroOutside);

	s_Object->m_rZone = simdjson::from_json_uint32(p_Document["m_rZone"]);

}

void SLockdownManagerAIZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tExpiry, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerAIZoneSaveData, m_tExpiry));
	ZGameTime::Serialize(&s_Object->m_tExpiryHeroOutside, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerAIZoneSaveData, m_tExpiryHeroOutside));
}

bool SLockdownManagerAIZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLockdownManagerAIZoneSaveData::operator==(const SLockdownManagerAIZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLockdownManagerAIZoneSaveData>)
		return false;

	if (m_tExpiry != p_Other.m_tExpiry) return false;
	if (m_tExpiryHeroOutside != p_Other.m_tExpiryHeroOutside) return false;
	if (m_rZone != p_Other.m_rZone) return false;

	return true;
}

void SLockdownManagerAIZoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);
	s_Object->~SLockdownManagerAIZoneSaveData();
}

ZHMTypeInfo SLockdownManagerSaveData::TypeInfo = ZHMTypeInfo("SLockdownManagerSaveData", sizeof(SLockdownManagerSaveData), alignof(SLockdownManagerSaveData), SLockdownManagerSaveData::WriteSimpleJson, SLockdownManagerSaveData::FromSimpleJson, SLockdownManagerSaveData::Serialize, SLockdownManagerSaveData::Equals, SLockdownManagerSaveData::Destroy);

void SLockdownManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAIZones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAIZones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAIZones[i];
		SLockdownManagerAIZoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAIZones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLockdownManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAIZones"];
	s_Object->m_aAIZones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLockdownManagerAIZoneSaveData::FromSimpleJson(s_Item0, &s_Object->m_aAIZones[s_Index0]);
		++s_Index0;
	}
	}

}

void SLockdownManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);

	TArray<SLockdownManagerAIZoneSaveData>::Serialize(&s_Object->m_aAIZones, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerSaveData, m_aAIZones));
}

bool SLockdownManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLockdownManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLockdownManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLockdownManagerSaveData::operator==(const SLockdownManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLockdownManagerSaveData>)
		return false;

	if (m_aAIZones != p_Other.m_aAIZones) return false;

	return true;
}

void SLockdownManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);
	s_Object->~SLockdownManagerSaveData();
}

ZHMTypeInfo SManHuntServiceSaveData::TypeInfo = ZHMTypeInfo("SManHuntServiceSaveData", sizeof(SManHuntServiceSaveData), alignof(SManHuntServiceSaveData), SManHuntServiceSaveData::WriteSimpleJson, SManHuntServiceSaveData::FromSimpleJson, SManHuntServiceSaveData::Serialize, SManHuntServiceSaveData::Equals, SManHuntServiceSaveData::Destroy);

void SManHuntServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rGuardNodes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_rGuardNodes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_rGuardNodes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_rGuardNodes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInitialNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInitialNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGuardSightRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGuardSightRange);

	p_Stream << "}";
}

void SManHuntServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_rGuardNodes"];
	s_Object->m_rGuardNodes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_rGuardNodes[s_Index0] = simdjson::from_json_uint16(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_rInitialNode = simdjson::from_json_uint16(p_Document["m_rInitialNode"]);

	s_Object->m_fGuardSightRange = simdjson::from_json_float32(p_Document["m_fGuardSightRange"]);

}

void SManHuntServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_rGuardNodes, p_Serializer, p_OwnOffset + offsetof(SManHuntServiceSaveData, m_rGuardNodes));
}

bool SManHuntServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SManHuntServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SManHuntServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SManHuntServiceSaveData::operator==(const SManHuntServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SManHuntServiceSaveData>)
		return false;

	if (m_rGuardNodes != p_Other.m_rGuardNodes) return false;
	if (m_rInitialNode != p_Other.m_rInitialNode) return false;
	if (m_fGuardSightRange != p_Other.m_fGuardSightRange) return false;

	return true;
}

void SManHuntServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);
	s_Object->~SManHuntServiceSaveData();
}

ZHMTypeInfo SMapMarkerData::TypeInfo = ZHMTypeInfo("SMapMarkerData", sizeof(SMapMarkerData), alignof(SMapMarkerData), SMapMarkerData::WriteSimpleJson, SMapMarkerData::FromSimpleJson, SMapMarkerData::Serialize, SMapMarkerData::Equals, SMapMarkerData::Destroy);

void SMapMarkerData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("pathPoints") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pathPoints.size(); ++i)
	{
		auto& s_Item0 = s_Object->pathPoints[i];
		SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pathPoints.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMapMarkerData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMapMarkerData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["pathPoints"];
	s_Object->pathPoints.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVector2::FromSimpleJson(s_Item0, &s_Object->pathPoints[s_Index0]);
		++s_Index0;
	}
	}

}

void SMapMarkerData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);

	TArray<SVector2>::Serialize(&s_Object->pathPoints, p_Serializer, p_OwnOffset + offsetof(SMapMarkerData, pathPoints));
}

bool SMapMarkerData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMapMarkerData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMapMarkerData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMapMarkerData::operator==(const SMapMarkerData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMapMarkerData>)
		return false;

	if (pathPoints != p_Other.pathPoints) return false;

	return true;
}

void SMapMarkerData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);
	s_Object->~SMapMarkerData();
}

ZHMTypeInfo SMatrix33::TypeInfo = ZHMTypeInfo("SMatrix33", sizeof(SMatrix33), alignof(SMatrix33), SMatrix33::WriteSimpleJson, SMatrix33::FromSimpleJson, SMatrix33::Serialize, SMatrix33::Equals, SMatrix33::Destroy);

void SMatrix33::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->ZAxis, p_Stream);

	p_Stream << "}";
}

void SMatrix33::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMatrix33*>(p_Target);

	SVector3::FromSimpleJson(p_Document["XAxis"], &s_Object->XAxis);

	SVector3::FromSimpleJson(p_Document["YAxis"], &s_Object->YAxis);

	SVector3::FromSimpleJson(p_Document["ZAxis"], &s_Object->ZAxis);

}

void SMatrix33::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	SVector3::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, XAxis));
	SVector3::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, YAxis));
	SVector3::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, ZAxis));
}

bool SMatrix33::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix33*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix33*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix33::operator==(const SMatrix33& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix33>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;

	return true;
}

void SMatrix33::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);
	s_Object->~SMatrix33();
}

ZHMTypeInfo SMatrix44::TypeInfo = ZHMTypeInfo("SMatrix44", sizeof(SMatrix44), alignof(SMatrix44), SMatrix44::WriteSimpleJson, SMatrix44::FromSimpleJson, SMatrix44::Serialize, SMatrix44::Equals, SMatrix44::Destroy);

void SMatrix44::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m11") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m11);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m12") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m12);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m13") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m13);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m14") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m14);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m21") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m21);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m22") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m22);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m23") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m23);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m24") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m24);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m31") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m31);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m32") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m32);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m33") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m33);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m34") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m34);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m41") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m41);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m42") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m42);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m43") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m43);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m44") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m44);

	p_Stream << "}";
}

void SMatrix44::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMatrix44*>(p_Target);

	s_Object->m11 = simdjson::from_json_float32(p_Document["m11"]);

	s_Object->m12 = simdjson::from_json_float32(p_Document["m12"]);

	s_Object->m13 = simdjson::from_json_float32(p_Document["m13"]);

	s_Object->m14 = simdjson::from_json_float32(p_Document["m14"]);

	s_Object->m21 = simdjson::from_json_float32(p_Document["m21"]);

	s_Object->m22 = simdjson::from_json_float32(p_Document["m22"]);

	s_Object->m23 = simdjson::from_json_float32(p_Document["m23"]);

	s_Object->m24 = simdjson::from_json_float32(p_Document["m24"]);

	s_Object->m31 = simdjson::from_json_float32(p_Document["m31"]);

	s_Object->m32 = simdjson::from_json_float32(p_Document["m32"]);

	s_Object->m33 = simdjson::from_json_float32(p_Document["m33"]);

	s_Object->m34 = simdjson::from_json_float32(p_Document["m34"]);

	s_Object->m41 = simdjson::from_json_float32(p_Document["m41"]);

	s_Object->m42 = simdjson::from_json_float32(p_Document["m42"]);

	s_Object->m43 = simdjson::from_json_float32(p_Document["m43"]);

	s_Object->m44 = simdjson::from_json_float32(p_Document["m44"]);

}

void SMatrix44::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

}

bool SMatrix44::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix44*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix44*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix44::operator==(const SMatrix44& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix44>)
		return false;

	if (m11 != p_Other.m11) return false;
	if (m12 != p_Other.m12) return false;
	if (m13 != p_Other.m13) return false;
	if (m14 != p_Other.m14) return false;
	if (m21 != p_Other.m21) return false;
	if (m22 != p_Other.m22) return false;
	if (m23 != p_Other.m23) return false;
	if (m24 != p_Other.m24) return false;
	if (m31 != p_Other.m31) return false;
	if (m32 != p_Other.m32) return false;
	if (m33 != p_Other.m33) return false;
	if (m34 != p_Other.m34) return false;
	if (m41 != p_Other.m41) return false;
	if (m42 != p_Other.m42) return false;
	if (m43 != p_Other.m43) return false;
	if (m44 != p_Other.m44) return false;

	return true;
}

void SMatrix44::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);
	s_Object->~SMatrix44();
}

ZHMTypeInfo SMovementAgilitySaveData::TypeInfo = ZHMTypeInfo("SMovementAgilitySaveData", sizeof(SMovementAgilitySaveData), alignof(SMovementAgilitySaveData), SMovementAgilitySaveData::WriteSimpleJson, SMovementAgilitySaveData::FromSimpleJson, SMovementAgilitySaveData::Serialize, SMovementAgilitySaveData::Equals, SMovementAgilitySaveData::Destroy);

void SMovementAgilitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rLedgeGuide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLedgeGuide);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceLeftRightTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceLeftRightTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePrevAgilityState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAgilityState", static_cast<int>(s_Object->m_ePrevAgilityState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAgilityState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAgilityState", static_cast<int>(s_Object->m_eAgilityState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nActiveAnimNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nActiveAnimNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCameraOffset") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECameraOffset_old", static_cast<int>(s_Object->m_eCameraOffset)));

	p_Stream << "}";
}

void SMovementAgilitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Target);

	s_Object->m_rLedgeGuide = simdjson::from_json_uint32(p_Document["m_rLedgeGuide"]);

	s_Object->m_fFaceLeftRightTarget = simdjson::from_json_float32(p_Document["m_fFaceLeftRightTarget"]);

	s_Object->m_ePrevAgilityState = static_cast<EAgilityState>(ZHMEnums::GetEnumValueByName("EAgilityState", std::string_view(p_Document["m_ePrevAgilityState"])));

	s_Object->m_eAgilityState = static_cast<EAgilityState>(ZHMEnums::GetEnumValueByName("EAgilityState", std::string_view(p_Document["m_eAgilityState"])));

	s_Object->m_nActiveAnimNode = simdjson::from_json_uint32(p_Document["m_nActiveAnimNode"]);

	s_Object->m_eCameraOffset = static_cast<ECameraOffset_old>(ZHMEnums::GetEnumValueByName("ECameraOffset_old", std::string_view(p_Document["m_eCameraOffset"])));

}

void SMovementAgilitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);

}

bool SMovementAgilitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementAgilitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementAgilitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementAgilitySaveData::operator==(const SMovementAgilitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementAgilitySaveData>)
		return false;

	if (m_rLedgeGuide != p_Other.m_rLedgeGuide) return false;
	if (m_fFaceLeftRightTarget != p_Other.m_fFaceLeftRightTarget) return false;
	if (m_ePrevAgilityState != p_Other.m_ePrevAgilityState) return false;
	if (m_eAgilityState != p_Other.m_eAgilityState) return false;
	if (m_nActiveAnimNode != p_Other.m_nActiveAnimNode) return false;
	if (m_eCameraOffset != p_Other.m_eCameraOffset) return false;

	return true;
}

void SMovementAgilitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);
	s_Object->~SMovementAgilitySaveData();
}

ZHMTypeInfo SMovementCoverSaveData::TypeInfo = ZHMTypeInfo("SMovementCoverSaveData", sizeof(SMovementCoverSaveData), alignof(SMovementCoverSaveData), SMovementCoverSaveData::WriteSimpleJson, SMovementCoverSaveData::FromSimpleJson, SMovementCoverSaveData::Serialize, SMovementCoverSaveData::Equals, SMovementCoverSaveData::Destroy);

void SMovementCoverSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCoverPlane") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCoverPlane);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCoverAnimNodeID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCoverAnimNodeID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeftSideFacing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeftSideFacing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCrouched") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCrouched);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mPositionInCover") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mPositionInCover, p_Stream);

	p_Stream << "}";
}

void SMovementCoverSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Target);

	s_Object->m_rCoverPlane = simdjson::from_json_uint32(p_Document["m_rCoverPlane"]);

	s_Object->m_nCoverAnimNodeID = simdjson::from_json_uint32(p_Document["m_nCoverAnimNodeID"]);

	s_Object->m_bLeftSideFacing = simdjson::from_json_bool(p_Document["m_bLeftSideFacing"]);

	s_Object->m_bCrouched = simdjson::from_json_bool(p_Document["m_bCrouched"]);

	SMatrix::FromSimpleJson(p_Document["m_mPositionInCover"], &s_Object->m_mPositionInCover);

}

void SMovementCoverSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);

	SMatrix::Serialize(&s_Object->m_mPositionInCover, p_Serializer, p_OwnOffset + offsetof(SMovementCoverSaveData, m_mPositionInCover));
}

bool SMovementCoverSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementCoverSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementCoverSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementCoverSaveData::operator==(const SMovementCoverSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementCoverSaveData>)
		return false;

	if (m_rCoverPlane != p_Other.m_rCoverPlane) return false;
	if (m_nCoverAnimNodeID != p_Other.m_nCoverAnimNodeID) return false;
	if (m_bLeftSideFacing != p_Other.m_bLeftSideFacing) return false;
	if (m_bCrouched != p_Other.m_bCrouched) return false;
	if (m_mPositionInCover != p_Other.m_mPositionInCover) return false;

	return true;
}

void SMovementCoverSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);
	s_Object->~SMovementCoverSaveData();
}

ZHMTypeInfo SMovementDisguiseSafeZoneSaveData::TypeInfo = ZHMTypeInfo("SMovementDisguiseSafeZoneSaveData", sizeof(SMovementDisguiseSafeZoneSaveData), alignof(SMovementDisguiseSafeZoneSaveData), SMovementDisguiseSafeZoneSaveData::WriteSimpleJson, SMovementDisguiseSafeZoneSaveData::FromSimpleJson, SMovementDisguiseSafeZoneSaveData::Serialize, SMovementDisguiseSafeZoneSaveData::Equals, SMovementDisguiseSafeZoneSaveData::Destroy);

void SMovementDisguiseSafeZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSafeZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSafeZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSafeZoneAnimNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSafeZoneAnimNode);

	p_Stream << "}";
}

void SMovementDisguiseSafeZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Target);

	s_Object->m_rSafeZone = simdjson::from_json_uint32(p_Document["m_rSafeZone"]);

	s_Object->m_nSafeZoneAnimNode = simdjson::from_json_uint32(p_Document["m_nSafeZoneAnimNode"]);

}

void SMovementDisguiseSafeZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);

}

bool SMovementDisguiseSafeZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDisguiseSafeZoneSaveData::operator==(const SMovementDisguiseSafeZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDisguiseSafeZoneSaveData>)
		return false;

	if (m_rSafeZone != p_Other.m_rSafeZone) return false;
	if (m_nSafeZoneAnimNode != p_Other.m_nSafeZoneAnimNode) return false;

	return true;
}

void SMovementDisguiseSafeZoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);
	s_Object->~SMovementDisguiseSafeZoneSaveData();
}

ZHMTypeInfo SMovementDragBodySaveData::TypeInfo = ZHMTypeInfo("SMovementDragBodySaveData", sizeof(SMovementDragBodySaveData), alignof(SMovementDragBodySaveData), SMovementDragBodySaveData::WriteSimpleJson, SMovementDragBodySaveData::FromSimpleJson, SMovementDragBodySaveData::Serialize, SMovementDragBodySaveData::Equals, SMovementDragBodySaveData::Destroy);

void SMovementDragBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rDraggedActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDraggedActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGrabBoneID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGrabBoneID);

	p_Stream << "}";
}

void SMovementDragBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Target);

	s_Object->m_rDraggedActor = simdjson::from_json_uint32(p_Document["m_rDraggedActor"]);

	s_Object->m_nGrabBoneID = simdjson::from_json_uint32(p_Document["m_nGrabBoneID"]);

}

void SMovementDragBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);

}

bool SMovementDragBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDragBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDragBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDragBodySaveData::operator==(const SMovementDragBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDragBodySaveData>)
		return false;

	if (m_rDraggedActor != p_Other.m_rDraggedActor) return false;
	if (m_nGrabBoneID != p_Other.m_nGrabBoneID) return false;

	return true;
}

void SMovementDragBodySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);
	s_Object->~SMovementDragBodySaveData();
}

ZHMTypeInfo SMovementDrainPipeSaveData::TypeInfo = ZHMTypeInfo("SMovementDrainPipeSaveData", sizeof(SMovementDrainPipeSaveData), alignof(SMovementDrainPipeSaveData), SMovementDrainPipeSaveData::WriteSimpleJson, SMovementDrainPipeSaveData::FromSimpleJson, SMovementDrainPipeSaveData::Serialize, SMovementDrainPipeSaveData::Equals, SMovementDrainPipeSaveData::Destroy);

void SMovementDrainPipeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rDrainPipe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDrainPipe);

	p_Stream << "}";
}

void SMovementDrainPipeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Target);

	s_Object->m_rDrainPipe = simdjson::from_json_uint32(p_Document["m_rDrainPipe"]);

}

void SMovementDrainPipeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);

}

bool SMovementDrainPipeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDrainPipeSaveData::operator==(const SMovementDrainPipeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDrainPipeSaveData>)
		return false;

	if (m_rDrainPipe != p_Other.m_rDrainPipe) return false;

	return true;
}

void SMovementDrainPipeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);
	s_Object->~SMovementDrainPipeSaveData();
}

ZHMTypeInfo SMovementHideInClosetSaveData::TypeInfo = ZHMTypeInfo("SMovementHideInClosetSaveData", sizeof(SMovementHideInClosetSaveData), alignof(SMovementHideInClosetSaveData), SMovementHideInClosetSaveData::WriteSimpleJson, SMovementHideInClosetSaveData::FromSimpleJson, SMovementHideInClosetSaveData::Serialize, SMovementHideInClosetSaveData::Equals, SMovementHideInClosetSaveData::Destroy);

void SMovementHideInClosetSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eCurrentClosetType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ICloset.EClosetType", static_cast<int>(s_Object->m_eCurrentClosetType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCloset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCloset);

	p_Stream << "}";
}

void SMovementHideInClosetSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Target);

	s_Object->m_eCurrentClosetType = static_cast<ICloset::EClosetType>(ZHMEnums::GetEnumValueByName("ICloset.EClosetType", std::string_view(p_Document["m_eCurrentClosetType"])));

	s_Object->m_rCloset = simdjson::from_json_uint32(p_Document["m_rCloset"]);

}

void SMovementHideInClosetSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);

}

bool SMovementHideInClosetSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementHideInClosetSaveData::operator==(const SMovementHideInClosetSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementHideInClosetSaveData>)
		return false;

	if (m_eCurrentClosetType != p_Other.m_eCurrentClosetType) return false;
	if (m_rCloset != p_Other.m_rCloset) return false;

	return true;
}

void SMovementHideInClosetSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);
	s_Object->~SMovementHideInClosetSaveData();
}

ZHMTypeInfo SMovementLadderSaveData::TypeInfo = ZHMTypeInfo("SMovementLadderSaveData", sizeof(SMovementLadderSaveData), alignof(SMovementLadderSaveData), SMovementLadderSaveData::WriteSimpleJson, SMovementLadderSaveData::FromSimpleJson, SMovementLadderSaveData::Serialize, SMovementLadderSaveData::Equals, SMovementLadderSaveData::Destroy);

void SMovementLadderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rLadder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLadder);

	p_Stream << "}";
}

void SMovementLadderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Target);

	s_Object->m_rLadder = simdjson::from_json_uint32(p_Document["m_rLadder"]);

}

void SMovementLadderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);

}

bool SMovementLadderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementLadderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementLadderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementLadderSaveData::operator==(const SMovementLadderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementLadderSaveData>)
		return false;

	if (m_rLadder != p_Other.m_rLadder) return false;

	return true;
}

void SMovementLadderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);
	s_Object->~SMovementLadderSaveData();
}

ZHMTypeInfo SMovementLocomotionSaveData::TypeInfo = ZHMTypeInfo("SMovementLocomotionSaveData", sizeof(SMovementLocomotionSaveData), alignof(SMovementLocomotionSaveData), SMovementLocomotionSaveData::WriteSimpleJson, SMovementLocomotionSaveData::FromSimpleJson, SMovementLocomotionSaveData::Serialize, SMovementLocomotionSaveData::Equals, SMovementLocomotionSaveData::Destroy);

void SMovementLocomotionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsSneaking") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSneaking);

	p_Stream << "}";
}

void SMovementLocomotionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Target);

	s_Object->m_bIsSneaking = simdjson::from_json_bool(p_Document["m_bIsSneaking"]);

}

void SMovementLocomotionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);

}

bool SMovementLocomotionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementLocomotionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementLocomotionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementLocomotionSaveData::operator==(const SMovementLocomotionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementLocomotionSaveData>)
		return false;

	if (m_bIsSneaking != p_Other.m_bIsSneaking) return false;

	return true;
}

void SMovementLocomotionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);
	s_Object->~SMovementLocomotionSaveData();
}

ZHMTypeInfo SMusicGridData::TypeInfo = ZHMTypeInfo("SMusicGridData", sizeof(SMusicGridData), alignof(SMusicGridData), SMusicGridData::WriteSimpleJson, SMusicGridData::FromSimpleJson, SMusicGridData::Serialize, SMusicGridData::Equals, SMusicGridData::Destroy);

void SMusicGridData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fGridDurationSec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridDurationSec);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridOffsetSec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridOffsetSec);

	p_Stream << "}";
}

void SMusicGridData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SMusicGridData*>(p_Target);

	s_Object->m_fGridDurationSec = simdjson::from_json_float32(p_Document["m_fGridDurationSec"]);

	s_Object->m_fGridOffsetSec = simdjson::from_json_float32(p_Document["m_fGridOffsetSec"]);

}

void SMusicGridData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);

}

bool SMusicGridData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMusicGridData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMusicGridData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMusicGridData::operator==(const SMusicGridData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMusicGridData>)
		return false;

	if (m_fGridDurationSec != p_Other.m_fGridDurationSec) return false;
	if (m_fGridOffsetSec != p_Other.m_fGridOffsetSec) return false;

	return true;
}

void SMusicGridData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);
	s_Object->~SMusicGridData();
}

ZHMTypeInfo SNRange::TypeInfo = ZHMTypeInfo("SNRange", sizeof(SNRange), alignof(SNRange), SNRange::WriteSimpleJson, SNRange::FromSimpleJson, SNRange::Serialize, SNRange::Equals, SNRange::Destroy);

void SNRange::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nMin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMax);

	p_Stream << "}";
}

void SNRange::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SNRange*>(p_Target);

	s_Object->m_nMin = simdjson::from_json_int32(p_Document["m_nMin"]);

	s_Object->m_nMax = simdjson::from_json_int32(p_Document["m_nMax"]);

}

void SNRange::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);

}

bool SNRange::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SNRange*>(p_Left);
	auto* s_Right = reinterpret_cast<SNRange*>(p_Right);

	return *s_Left == *s_Right;
}

bool SNRange::operator==(const SNRange& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SNRange>)
		return false;

	if (m_nMin != p_Other.m_nMin) return false;
	if (m_nMax != p_Other.m_nMax) return false;

	return true;
}

void SNRange::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SNRange*>(p_Object);
	s_Object->~SNRange();
}

ZHMTypeInfo SObserversGroupSaveData::TypeInfo = ZHMTypeInfo("SObserversGroupSaveData", sizeof(SObserversGroupSaveData), alignof(SObserversGroupSaveData), SObserversGroupSaveData::WriteSimpleJson, SObserversGroupSaveData::FromSimpleJson, SObserversGroupSaveData::Serialize, SObserversGroupSaveData::Equals, SObserversGroupSaveData::Destroy);

void SObserversGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingObservers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingObservers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingObservers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aWaitingObservers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_observerDistanceMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_observerDistanceMax);

	p_Stream << "}";
}

void SObserversGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Target);

	s_Object->m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aWaitingObservers"];
	s_Object->m_aWaitingObservers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aWaitingObservers[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_observerDistanceMax = simdjson::from_json_float32(p_Document["m_observerDistanceMax"]);

}

void SObserversGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aWaitingObservers, p_Serializer, p_OwnOffset + offsetof(SObserversGroupSaveData, m_aWaitingObservers));
}

bool SObserversGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SObserversGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SObserversGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SObserversGroupSaveData::operator==(const SObserversGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SObserversGroupSaveData>)
		return false;

	if (m_target != p_Other.m_target) return false;
	if (m_aWaitingObservers != p_Other.m_aWaitingObservers) return false;
	if (m_observerDistanceMax != p_Other.m_observerDistanceMax) return false;

	return true;
}

void SObserversGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);
	s_Object->~SObserversGroupSaveData();
}

ZHMTypeInfo SOnlineEvent::TypeInfo = ZHMTypeInfo("SOnlineEvent", sizeof(SOnlineEvent), alignof(SOnlineEvent), SOnlineEvent::WriteSimpleJson, SOnlineEvent::FromSimpleJson, SOnlineEvent::Serialize, SOnlineEvent::Equals, SOnlineEvent::Destroy);

void SOnlineEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("data") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->data, p_Stream);

	p_Stream << "}";
}

void SOnlineEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SOnlineEvent*>(p_Target);

	s_Object->sName = std::string_view(p_Document["sName"]);

	ZDynamicObject::FromSimpleJson(p_Document["data"], &s_Object->data);

}

void SOnlineEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SOnlineEvent, sName));
	ZDynamicObject::Serialize(&s_Object->data, p_Serializer, p_OwnOffset + offsetof(SOnlineEvent, data));
}

bool SOnlineEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SOnlineEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<SOnlineEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool SOnlineEvent::operator==(const SOnlineEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SOnlineEvent>)
		return false;

	if (sName != p_Other.sName) return false;
	if (data != p_Other.data) return false;

	return true;
}

void SOnlineEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);
	s_Object->~SOnlineEvent();
}

ZHMTypeInfo SOptionValueSaveData::TypeInfo = ZHMTypeInfo("SOptionValueSaveData", sizeof(SOptionValueSaveData), alignof(SOptionValueSaveData), SOptionValueSaveData::WriteSimpleJson, SOptionValueSaveData::FromSimpleJson, SOptionValueSaveData::Serialize, SOptionValueSaveData::Equals, SOptionValueSaveData::Destroy);

void SOptionValueSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Value, p_Stream);

	p_Stream << "}";
}

void SOptionValueSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Target);

	ZVariant::FromSimpleJson(p_Document["m_Value"], &s_Object->m_Value);

}

void SOptionValueSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Value, p_Serializer, p_OwnOffset + offsetof(SOptionValueSaveData, m_Value));
}

bool SOptionValueSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SOptionValueSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SOptionValueSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SOptionValueSaveData::operator==(const SOptionValueSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SOptionValueSaveData>)
		return false;

	if (m_Value != p_Other.m_Value) return false;

	return true;
}

void SOptionValueSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);
	s_Object->~SOptionValueSaveData();
}

ZHMTypeInfo SPFObstactleSaveData::TypeInfo = ZHMTypeInfo("SPFObstactleSaveData", sizeof(SPFObstactleSaveData), alignof(SPFObstactleSaveData), SPFObstactleSaveData::WriteSimpleJson, SPFObstactleSaveData::FromSimpleJson, SPFObstactleSaveData::Serialize, SPFObstactleSaveData::Equals, SPFObstactleSaveData::Destroy);

void SPFObstactleSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SPFObstactleSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

}

void SPFObstactleSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);

}

bool SPFObstactleSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPFObstactleSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPFObstactleSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPFObstactleSaveData::operator==(const SPFObstactleSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPFObstactleSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SPFObstactleSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);
	s_Object->~SPFObstactleSaveData();
}

ZHMTypeInfo SPackedAnimSetEntry::TypeInfo = ZHMTypeInfo("SPackedAnimSetEntry", sizeof(SPackedAnimSetEntry), alignof(SPackedAnimSetEntry), SPackedAnimSetEntry::WriteSimpleJson, SPackedAnimSetEntry::FromSimpleJson, SPackedAnimSetEntry::Serialize, SPackedAnimSetEntry::Equals, SPackedAnimSetEntry::Destroy);

void SPackedAnimSetEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPackedAnimSetEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAnimation") << ":";
	TResourcePtr::WriteSimpleJson(&s_Object->m_pAnimation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pBoneMask") << ":";
	TResourcePtr::WriteSimpleJson(&s_Object->m_pBoneMask, p_Stream);

	p_Stream << "}";
}

void SPackedAnimSetEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPackedAnimSetEntry*>(p_Target);

	s_Object->m_sName = std::string_view(p_Document["m_sName"]);

	TResourcePtr::FromSimpleJson(p_Document["m_pAnimation"], &s_Object->m_pAnimation);

	TResourcePtr::FromSimpleJson(p_Document["m_pBoneMask"], &s_Object->m_pBoneMask);

}

void SPackedAnimSetEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPackedAnimSetEntry*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SPackedAnimSetEntry, m_sName));
	TResourcePtr::Serialize(&s_Object->m_pAnimation, p_Serializer, p_OwnOffset + offsetof(SPackedAnimSetEntry, m_pAnimation));
	TResourcePtr::Serialize(&s_Object->m_pBoneMask, p_Serializer, p_OwnOffset + offsetof(SPackedAnimSetEntry, m_pBoneMask));
}

bool SPackedAnimSetEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPackedAnimSetEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SPackedAnimSetEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPackedAnimSetEntry::operator==(const SPackedAnimSetEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPackedAnimSetEntry>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_pAnimation != p_Other.m_pAnimation) return false;
	if (m_pBoneMask != p_Other.m_pBoneMask) return false;

	return true;
}

void SPackedAnimSetEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPackedAnimSetEntry*>(p_Object);
	s_Object->~SPackedAnimSetEntry();
}

ZHMTypeInfo SPatrolGroupSaveData::TypeInfo = ZHMTypeInfo("SPatrolGroupSaveData", sizeof(SPatrolGroupSaveData), alignof(SPatrolGroupSaveData), SPatrolGroupSaveData::WriteSimpleJson, SPatrolGroupSaveData::FromSimpleJson, SPatrolGroupSaveData::Serialize, SPatrolGroupSaveData::Equals, SPatrolGroupSaveData::Destroy);

void SPatrolGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nRouteID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRouteID);

	p_Stream << "}";
}

void SPatrolGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Target);

	s_Object->m_nRouteID = simdjson::from_json_int32(p_Document["m_nRouteID"]);

}

void SPatrolGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);

}

bool SPatrolGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPatrolGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPatrolGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPatrolGroupSaveData::operator==(const SPatrolGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPatrolGroupSaveData>)
		return false;

	if (m_nRouteID != p_Other.m_nRouteID) return false;

	return true;
}

void SPatrolGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);
	s_Object->~SPatrolGroupSaveData();
}

ZHMTypeInfo SPatrolOrderSaveData::TypeInfo = ZHMTypeInfo("SPatrolOrderSaveData", sizeof(SPatrolOrderSaveData), alignof(SPatrolOrderSaveData), SPatrolOrderSaveData::WriteSimpleJson, SPatrolOrderSaveData::FromSimpleJson, SPatrolOrderSaveData::Serialize, SPatrolOrderSaveData::Equals, SPatrolOrderSaveData::Destroy);

void SPatrolOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SPatrolOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Target);

}

void SPatrolOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);

}

bool SPatrolOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPatrolOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPatrolOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPatrolOrderSaveData::operator==(const SPatrolOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPatrolOrderSaveData>)
		return false;


	return true;
}

void SPatrolOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);
	s_Object->~SPatrolOrderSaveData();
}

ZHMTypeInfo SPerceptibleCrowdBodySaveData::TypeInfo = ZHMTypeInfo("SPerceptibleCrowdBodySaveData", sizeof(SPerceptibleCrowdBodySaveData), alignof(SPerceptibleCrowdBodySaveData), SPerceptibleCrowdBodySaveData::WriteSimpleJson, SPerceptibleCrowdBodySaveData::FromSimpleJson, SPerceptibleCrowdBodySaveData::Serialize, SPerceptibleCrowdBodySaveData::Equals, SPerceptibleCrowdBodySaveData::Destroy);

void SPerceptibleCrowdBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCombatZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCombatZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSharedKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSharedKnowledge);

	p_Stream << "}";
}

void SPerceptibleCrowdBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Target);

	s_Object->m_rCombatZone = simdjson::from_json_uint32(p_Document["m_rCombatZone"]);

	s_Object->m_rSharedKnowledge = simdjson::from_json_int32(p_Document["m_rSharedKnowledge"]);

}

void SPerceptibleCrowdBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);

}

bool SPerceptibleCrowdBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPerceptibleCrowdBodySaveData::operator==(const SPerceptibleCrowdBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPerceptibleCrowdBodySaveData>)
		return false;

	if (m_rCombatZone != p_Other.m_rCombatZone) return false;
	if (m_rSharedKnowledge != p_Other.m_rSharedKnowledge) return false;

	return true;
}

void SPerceptibleCrowdBodySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);
	s_Object->~SPerceptibleCrowdBodySaveData();
}

ZHMTypeInfo SPersistentEntitySaveData::TypeInfo = ZHMTypeInfo("SPersistentEntitySaveData", sizeof(SPersistentEntitySaveData), alignof(SPersistentEntitySaveData), SPersistentEntitySaveData::WriteSimpleJson, SPersistentEntitySaveData::FromSimpleJson, SPersistentEntitySaveData::Serialize, SPersistentEntitySaveData::Equals, SPersistentEntitySaveData::Destroy);

void SPersistentEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nResourceId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nResourceId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityNames") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityNames.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityNames[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityNames.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPersistentEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Target);

	s_Object->m_nResourceId = simdjson::from_json_uint64(p_Document["m_nResourceId"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityNames"];
	s_Object->m_aEntityNames.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntityNames[s_Index0] = std::string_view(s_Item0);
		++s_Index0;
	}
	}

}

void SPersistentEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);

	TArray<ZString>::Serialize(&s_Object->m_aEntityNames, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveData, m_aEntityNames));
}

bool SPersistentEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPersistentEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPersistentEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPersistentEntitySaveData::operator==(const SPersistentEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPersistentEntitySaveData>)
		return false;

	if (m_nResourceId != p_Other.m_nResourceId) return false;
	if (m_aEntityNames != p_Other.m_aEntityNames) return false;

	return true;
}

void SPersistentEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);
	s_Object->~SPersistentEntitySaveData();
}

ZHMTypeInfo SPersistentEntitySaveDataList::TypeInfo = ZHMTypeInfo("SPersistentEntitySaveDataList", sizeof(SPersistentEntitySaveDataList), alignof(SPersistentEntitySaveDataList), SPersistentEntitySaveDataList::WriteSimpleJson, SPersistentEntitySaveDataList::FromSimpleJson, SPersistentEntitySaveDataList::Serialize, SPersistentEntitySaveDataList::Equals, SPersistentEntitySaveDataList::Destroy);

void SPersistentEntitySaveDataList::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntityDatas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityDatas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityDatas[i];
		SPersistentEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityDatas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPersistentEntitySaveDataList::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityDatas"];
	s_Object->m_aEntityDatas.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SPersistentEntitySaveData::FromSimpleJson(s_Item0, &s_Object->m_aEntityDatas[s_Index0]);
		++s_Index0;
	}
	}

}

void SPersistentEntitySaveDataList::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);

	TArray<SPersistentEntitySaveData>::Serialize(&s_Object->m_aEntityDatas, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveDataList, m_aEntityDatas));
}

bool SPersistentEntitySaveDataList::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Left);
	auto* s_Right = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPersistentEntitySaveDataList::operator==(const SPersistentEntitySaveDataList& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPersistentEntitySaveDataList>)
		return false;

	if (m_aEntityDatas != p_Other.m_aEntityDatas) return false;

	return true;
}

void SPersistentEntitySaveDataList::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);
	s_Object->~SPersistentEntitySaveDataList();
}

ZHMTypeInfo SPhysicsSaveData::TypeInfo = ZHMTypeInfo("SPhysicsSaveData", sizeof(SPhysicsSaveData), alignof(SPhysicsSaveData), SPhysicsSaveData::WriteSimpleJson, SPhysicsSaveData::FromSimpleJson, SPhysicsSaveData::Serialize, SPhysicsSaveData::Equals, SPhysicsSaveData::Destroy);

void SPhysicsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInPhysicsWorld") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInPhysicsWorld);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsKinematicBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsKinematicBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);

	p_Stream << "}";
}

void SPhysicsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Target);

	s_Object->m_bIsInPhysicsWorld = simdjson::from_json_bool(p_Document["m_bIsInPhysicsWorld"]);

	s_Object->m_bIsKinematicBody = simdjson::from_json_bool(p_Document["m_bIsKinematicBody"]);

	s_Object->m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

}

void SPhysicsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);

}

bool SPhysicsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPhysicsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPhysicsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPhysicsSaveData::operator==(const SPhysicsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPhysicsSaveData>)
		return false;

	if (m_bIsInPhysicsWorld != p_Other.m_bIsInPhysicsWorld) return false;
	if (m_bIsKinematicBody != p_Other.m_bIsKinematicBody) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;

	return true;
}

void SPhysicsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);
	s_Object->~SPhysicsSaveData();
}

ZHMTypeInfo SPhysicsListSaveData::TypeInfo = ZHMTypeInfo("SPhysicsListSaveData", sizeof(SPhysicsListSaveData), alignof(SPhysicsListSaveData), SPhysicsListSaveData::WriteSimpleJson, SPhysicsListSaveData::FromSimpleJson, SPhysicsListSaveData::Serialize, SPhysicsListSaveData::Equals, SPhysicsListSaveData::Destroy);

void SPhysicsListSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntityRefs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityRefs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityRefs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityRefs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityDatas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityDatas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityDatas[i];
		SPhysicsSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityDatas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPhysicsListSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityRefs"];
	s_Object->m_aEntityRefs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntityRefs[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityDatas"];
	s_Object->m_aEntityDatas.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SPhysicsSaveData::FromSimpleJson(s_Item0, &s_Object->m_aEntityDatas[s_Index0]);
		++s_Index0;
	}
	}

}

void SPhysicsListSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntityRefs, p_Serializer, p_OwnOffset + offsetof(SPhysicsListSaveData, m_aEntityRefs));
	TArray<SPhysicsSaveData>::Serialize(&s_Object->m_aEntityDatas, p_Serializer, p_OwnOffset + offsetof(SPhysicsListSaveData, m_aEntityDatas));
}

bool SPhysicsListSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPhysicsListSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPhysicsListSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPhysicsListSaveData::operator==(const SPhysicsListSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPhysicsListSaveData>)
		return false;

	if (m_aEntityRefs != p_Other.m_aEntityRefs) return false;
	if (m_aEntityDatas != p_Other.m_aEntityDatas) return false;

	return true;
}

void SPhysicsListSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);
	s_Object->~SPhysicsListSaveData();
}

ZHMTypeInfo SPrivateAreaSaveData::TypeInfo = ZHMTypeInfo("SPrivateAreaSaveData", sizeof(SPrivateAreaSaveData), alignof(SPrivateAreaSaveData), SPrivateAreaSaveData::WriteSimpleJson, SPrivateAreaSaveData::FromSimpleJson, SPrivateAreaSaveData::Serialize, SPrivateAreaSaveData::Equals, SPrivateAreaSaveData::Destroy);

void SPrivateAreaSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInside") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInside);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nHasEntered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHasEntered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasExited") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasExited);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpotted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpotted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHitmanEnterPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vHitmanEnterPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHitmanExitPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vHitmanExitPosition, p_Stream);

	p_Stream << "}";
}

void SPrivateAreaSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Target);

	s_Object->m_bIsInside = simdjson::from_json_bool(p_Document["m_bIsInside"]);

	s_Object->m_nHasEntered = simdjson::from_json_bool(p_Document["m_nHasEntered"]);

	s_Object->m_bHasExited = simdjson::from_json_bool(p_Document["m_bHasExited"]);

	s_Object->m_bSpotted = simdjson::from_json_bool(p_Document["m_bSpotted"]);

	float4::FromSimpleJson(p_Document["m_vHitmanEnterPosition"], &s_Object->m_vHitmanEnterPosition);

	float4::FromSimpleJson(p_Document["m_vHitmanExitPosition"], &s_Object->m_vHitmanExitPosition);

}

void SPrivateAreaSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vHitmanEnterPosition, p_Serializer, p_OwnOffset + offsetof(SPrivateAreaSaveData, m_vHitmanEnterPosition));
	float4::Serialize(&s_Object->m_vHitmanExitPosition, p_Serializer, p_OwnOffset + offsetof(SPrivateAreaSaveData, m_vHitmanExitPosition));
}

bool SPrivateAreaSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPrivateAreaSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPrivateAreaSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPrivateAreaSaveData::operator==(const SPrivateAreaSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPrivateAreaSaveData>)
		return false;

	if (m_bIsInside != p_Other.m_bIsInside) return false;
	if (m_nHasEntered != p_Other.m_nHasEntered) return false;
	if (m_bHasExited != p_Other.m_bHasExited) return false;
	if (m_bSpotted != p_Other.m_bSpotted) return false;
	if (m_vHitmanEnterPosition != p_Other.m_vHitmanEnterPosition) return false;
	if (m_vHitmanExitPosition != p_Other.m_vHitmanExitPosition) return false;

	return true;
}

void SPrivateAreaSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);
	s_Object->~SPrivateAreaSaveData();
}

ZHMTypeInfo SRandomTimerEntitySaveData::TypeInfo = ZHMTypeInfo("SRandomTimerEntitySaveData", sizeof(SRandomTimerEntitySaveData), alignof(SRandomTimerEntitySaveData), SRandomTimerEntitySaveData::WriteSimpleJson, SRandomTimerEntitySaveData::FromSimpleJson, SRandomTimerEntitySaveData::Serialize, SRandomTimerEntitySaveData::Equals, SRandomTimerEntitySaveData::Destroy);

void SRandomTimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegistered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMinTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMinTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMaxTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMaxTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProbability") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProbability);

	p_Stream << "}";
}

void SRandomTimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_bRegistered = simdjson::from_json_bool(p_Document["m_bRegistered"]);

	s_Object->m_fMinTime = simdjson::from_json_float32(p_Document["m_fMinTime"]);

	s_Object->m_fMaxTime = simdjson::from_json_float32(p_Document["m_fMaxTime"]);

	s_Object->m_fProbability = simdjson::from_json_float32(p_Document["m_fProbability"]);

}

void SRandomTimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);

}

bool SRandomTimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRandomTimerEntitySaveData::operator==(const SRandomTimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRandomTimerEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bRegistered != p_Other.m_bRegistered) return false;
	if (m_fMinTime != p_Other.m_fMinTime) return false;
	if (m_fMaxTime != p_Other.m_fMaxTime) return false;
	if (m_fProbability != p_Other.m_fProbability) return false;

	return true;
}

void SRandomTimerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);
	s_Object->~SRandomTimerEntitySaveData();
}

ZHMTypeInfo SRandomTimerEntitiesSaveData::TypeInfo = ZHMTypeInfo("SRandomTimerEntitiesSaveData", sizeof(SRandomTimerEntitiesSaveData), alignof(SRandomTimerEntitiesSaveData), SRandomTimerEntitiesSaveData::WriteSimpleJson, SRandomTimerEntitiesSaveData::FromSimpleJson, SRandomTimerEntitiesSaveData::Serialize, SRandomTimerEntitiesSaveData::Equals, SRandomTimerEntitiesSaveData::Destroy);

void SRandomTimerEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SRandomTimerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SRandomTimerEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SRandomTimerEntitySaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void SRandomTimerEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SRandomTimerEntitiesSaveData, m_aEntities));
	TArray<SRandomTimerEntitySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SRandomTimerEntitiesSaveData, m_aData));
}

bool SRandomTimerEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRandomTimerEntitiesSaveData::operator==(const SRandomTimerEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRandomTimerEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SRandomTimerEntitiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);
	s_Object->~SRandomTimerEntitiesSaveData();
}

ZHMTypeInfo ZBitArray::TypeInfo = ZHMTypeInfo("ZBitArray", sizeof(ZBitArray), alignof(ZBitArray), ZBitArray::WriteSimpleJson, ZBitArray::FromSimpleJson, ZBitArray::Serialize, ZBitArray::Equals, ZBitArray::Destroy);

void ZBitArray::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBytes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBytes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBytes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBytes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSize);

	p_Stream << "}";
}

void ZBitArray::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZBitArray*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBytes"];
	s_Object->m_aBytes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aBytes[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_nSize = simdjson::from_json_uint32(p_Document["m_nSize"]);

}

void ZBitArray::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aBytes, p_Serializer, p_OwnOffset + offsetof(ZBitArray, m_aBytes));
}

bool ZBitArray::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZBitArray*>(p_Left);
	auto* s_Right = reinterpret_cast<ZBitArray*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZBitArray::operator==(const ZBitArray& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZBitArray>)
		return false;

	if (m_aBytes != p_Other.m_aBytes) return false;
	if (m_nSize != p_Other.m_nSize) return false;

	return true;
}

void ZBitArray::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);
	s_Object->~ZBitArray();
}

ZHMTypeInfo SReasoningGrid::TypeInfo = ZHMTypeInfo("SReasoningGrid", sizeof(SReasoningGrid), alignof(SReasoningGrid), SReasoningGrid::WriteSimpleJson, SReasoningGrid::FromSimpleJson, SReasoningGrid::Serialize, SReasoningGrid::Equals, SReasoningGrid::Destroy);

void SReasoningGrid::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_WaypointList") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_WaypointList.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_WaypointList[i];
		SGWaypoint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_WaypointList.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LowVisibilityBits") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_LowVisibilityBits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighVisibilityBits") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_HighVisibilityBits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Properties") << ":";
	SGProperties::WriteSimpleJson(&s_Object->m_Properties, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNodeCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNodeCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pVisibilityData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_pVisibilityData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_pVisibilityData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_pVisibilityData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadEndData") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_deadEndData, p_Stream);

	p_Stream << "}";
}

void SReasoningGrid::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SReasoningGrid*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_WaypointList"];
	s_Object->m_WaypointList.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SGWaypoint::FromSimpleJson(s_Item0, &s_Object->m_WaypointList[s_Index0]);
		++s_Index0;
	}
	}

	ZBitArray::FromSimpleJson(p_Document["m_LowVisibilityBits"], &s_Object->m_LowVisibilityBits);

	ZBitArray::FromSimpleJson(p_Document["m_HighVisibilityBits"], &s_Object->m_HighVisibilityBits);

	SGProperties::FromSimpleJson(p_Document["m_Properties"], &s_Object->m_Properties);

	s_Object->m_nNodeCount = simdjson::from_json_uint32(p_Document["m_nNodeCount"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_pVisibilityData"];
	s_Object->m_pVisibilityData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_pVisibilityData[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

	ZBitArray::FromSimpleJson(p_Document["m_deadEndData"], &s_Object->m_deadEndData);

}

void SReasoningGrid::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	TArray<SGWaypoint>::Serialize(&s_Object->m_WaypointList, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_WaypointList));
	ZBitArray::Serialize(&s_Object->m_LowVisibilityBits, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_LowVisibilityBits));
	ZBitArray::Serialize(&s_Object->m_HighVisibilityBits, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_HighVisibilityBits));
	SGProperties::Serialize(&s_Object->m_Properties, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_Properties));
	TArray<uint8>::Serialize(&s_Object->m_pVisibilityData, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_pVisibilityData));
	ZBitArray::Serialize(&s_Object->m_deadEndData, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_deadEndData));
}

bool SReasoningGrid::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SReasoningGrid*>(p_Left);
	auto* s_Right = reinterpret_cast<SReasoningGrid*>(p_Right);

	return *s_Left == *s_Right;
}

bool SReasoningGrid::operator==(const SReasoningGrid& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SReasoningGrid>)
		return false;

	if (m_WaypointList != p_Other.m_WaypointList) return false;
	if (m_LowVisibilityBits != p_Other.m_LowVisibilityBits) return false;
	if (m_HighVisibilityBits != p_Other.m_HighVisibilityBits) return false;
	if (m_Properties != p_Other.m_Properties) return false;
	if (m_nNodeCount != p_Other.m_nNodeCount) return false;
	if (m_pVisibilityData != p_Other.m_pVisibilityData) return false;
	if (m_deadEndData != p_Other.m_deadEndData) return false;

	return true;
}

void SReasoningGrid::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);
	s_Object->~SReasoningGrid();
}

ZHMTypeInfo SRecoverUnconsciousGroupSaveData::TypeInfo = ZHMTypeInfo("SRecoverUnconsciousGroupSaveData", sizeof(SRecoverUnconsciousGroupSaveData), alignof(SRecoverUnconsciousGroupSaveData), SRecoverUnconsciousGroupSaveData::WriteSimpleJson, SRecoverUnconsciousGroupSaveData::FromSimpleJson, SRecoverUnconsciousGroupSaveData::Serialize, SRecoverUnconsciousGroupSaveData::Equals, SRecoverUnconsciousGroupSaveData::Destroy);

void SRecoverUnconsciousGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rWaker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rWaker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWokenUpInTheGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWokenUpInTheGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFastWakeUp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFastWakeUp);

	p_Stream << "}";
}

void SRecoverUnconsciousGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_rVictim = simdjson::from_json_uint32(p_Document["m_rVictim"]);

	s_Object->m_rWaker = simdjson::from_json_uint32(p_Document["m_rWaker"]);

	s_Object->m_fTimer = simdjson::from_json_float32(p_Document["m_fTimer"]);

	s_Object->m_bEscalate = simdjson::from_json_bool(p_Document["m_bEscalate"]);

	s_Object->m_bWokenUpInTheGroup = simdjson::from_json_bool(p_Document["m_bWokenUpInTheGroup"]);

	s_Object->m_bFastWakeUp = simdjson::from_json_bool(p_Document["m_bFastWakeUp"]);

}

void SRecoverUnconsciousGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SRecoverUnconsciousGroupSaveData, m_fsmState));
}

bool SRecoverUnconsciousGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRecoverUnconsciousGroupSaveData::operator==(const SRecoverUnconsciousGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRecoverUnconsciousGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rVictim != p_Other.m_rVictim) return false;
	if (m_rWaker != p_Other.m_rWaker) return false;
	if (m_fTimer != p_Other.m_fTimer) return false;
	if (m_bEscalate != p_Other.m_bEscalate) return false;
	if (m_bWokenUpInTheGroup != p_Other.m_bWokenUpInTheGroup) return false;
	if (m_bFastWakeUp != p_Other.m_bFastWakeUp) return false;

	return true;
}

void SRecoverUnconsciousGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);
	s_Object->~SRecoverUnconsciousGroupSaveData();
}

ZHMTypeInfo SRemoteControlReceiverSaveData::TypeInfo = ZHMTypeInfo("SRemoteControlReceiverSaveData", sizeof(SRemoteControlReceiverSaveData), alignof(SRemoteControlReceiverSaveData), SRemoteControlReceiverSaveData::WriteSimpleJson, SRemoteControlReceiverSaveData::FromSimpleJson, SRemoteControlReceiverSaveData::Serialize, SRemoteControlReceiverSaveData::Equals, SRemoteControlReceiverSaveData::Destroy);

void SRemoteControlReceiverSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReceiverActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReceiverActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);

	p_Stream << "}";
}

void SRemoteControlReceiverSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_bReceiverActivated = simdjson::from_json_bool(p_Document["m_bReceiverActivated"]);

	s_Object->m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

}

void SRemoteControlReceiverSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);

}

bool SRemoteControlReceiverSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRemoteControlReceiverSaveData::operator==(const SRemoteControlReceiverSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRemoteControlReceiverSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bReceiverActivated != p_Other.m_bReceiverActivated) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;

	return true;
}

void SRemoteControlReceiverSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);
	s_Object->~SRemoteControlReceiverSaveData();
}

ZHMTypeInfo SRenderVideoPlayerSaveData::TypeInfo = ZHMTypeInfo("SRenderVideoPlayerSaveData", sizeof(SRenderVideoPlayerSaveData), alignof(SRenderVideoPlayerSaveData), SRenderVideoPlayerSaveData::WriteSimpleJson, SRenderVideoPlayerSaveData::FromSimpleJson, SRenderVideoPlayerSaveData::Serialize, SRenderVideoPlayerSaveData::Equals, SRenderVideoPlayerSaveData::Destroy);

void SRenderVideoPlayerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPlaying") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlaying);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLooping") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLooping);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirstFrame") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirstFrame);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVideoError") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVideoError);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldBeStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldBeStopped);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastVisible") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_LastVisible, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_StartTime, p_Stream);

	p_Stream << "}";
}

void SRenderVideoPlayerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Target);

	s_Object->m_bPlaying = simdjson::from_json_bool(p_Document["m_bPlaying"]);

	s_Object->m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	s_Object->m_bLooping = simdjson::from_json_bool(p_Document["m_bLooping"]);

	s_Object->m_bUseAlpha = simdjson::from_json_bool(p_Document["m_bUseAlpha"]);

	s_Object->m_bFirstFrame = simdjson::from_json_bool(p_Document["m_bFirstFrame"]);

	s_Object->m_bRunning = simdjson::from_json_bool(p_Document["m_bRunning"]);

	s_Object->m_bVideoError = simdjson::from_json_bool(p_Document["m_bVideoError"]);

	s_Object->m_bShouldBeStopped = simdjson::from_json_bool(p_Document["m_bShouldBeStopped"]);

	ZGameTime::FromSimpleJson(p_Document["m_LastVisible"], &s_Object->m_LastVisible);

	ZGameTime::FromSimpleJson(p_Document["m_StartTime"], &s_Object->m_StartTime);

}

void SRenderVideoPlayerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_LastVisible, p_Serializer, p_OwnOffset + offsetof(SRenderVideoPlayerSaveData, m_LastVisible));
	ZGameTime::Serialize(&s_Object->m_StartTime, p_Serializer, p_OwnOffset + offsetof(SRenderVideoPlayerSaveData, m_StartTime));
}

bool SRenderVideoPlayerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRenderVideoPlayerSaveData::operator==(const SRenderVideoPlayerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRenderVideoPlayerSaveData>)
		return false;

	if (m_bPlaying != p_Other.m_bPlaying) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;
	if (m_bLooping != p_Other.m_bLooping) return false;
	if (m_bUseAlpha != p_Other.m_bUseAlpha) return false;
	if (m_bFirstFrame != p_Other.m_bFirstFrame) return false;
	if (m_bRunning != p_Other.m_bRunning) return false;
	if (m_bVideoError != p_Other.m_bVideoError) return false;
	if (m_bShouldBeStopped != p_Other.m_bShouldBeStopped) return false;
	if (m_LastVisible != p_Other.m_LastVisible) return false;
	if (m_StartTime != p_Other.m_StartTime) return false;

	return true;
}

void SRenderVideoPlayerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);
	s_Object->~SRenderVideoPlayerSaveData();
}

ZHMTypeInfo SRepositionOrderSaveData::TypeInfo = ZHMTypeInfo("SRepositionOrderSaveData", sizeof(SRepositionOrderSaveData), alignof(SRepositionOrderSaveData), SRepositionOrderSaveData::WriteSimpleJson, SRepositionOrderSaveData::FromSimpleJson, SRepositionOrderSaveData::Serialize, SRepositionOrderSaveData::Equals, SRepositionOrderSaveData::Destroy);

void SRepositionOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStrafe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStrafe);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAimAtTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAimAtTarget);

	p_Stream << "}";
}

void SRepositionOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Target);

	s_Object->m_bStrafe = simdjson::from_json_bool(p_Document["m_bStrafe"]);

	s_Object->m_bAimAtTarget = simdjson::from_json_bool(p_Document["m_bAimAtTarget"]);

}

void SRepositionOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);

}

bool SRepositionOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRepositionOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRepositionOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRepositionOrderSaveData::operator==(const SRepositionOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRepositionOrderSaveData>)
		return false;

	if (m_bStrafe != p_Other.m_bStrafe) return false;
	if (m_bAimAtTarget != p_Other.m_bAimAtTarget) return false;

	return true;
}

void SRepositionOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);
	s_Object->~SRepositionOrderSaveData();
}

ZHMTypeInfo SRotateEntitySaveData::TypeInfo = ZHMTypeInfo("SRotateEntitySaveData", sizeof(SRotateEntitySaveData), alignof(SRotateEntitySaveData), SRotateEntitySaveData::WriteSimpleJson, SRotateEntitySaveData::FromSimpleJson, SRotateEntitySaveData::Serialize, SRotateEntitySaveData::Equals, SRotateEntitySaveData::Destroy);

void SRotateEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fXAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fXAxisSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fYAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fYAxisSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fZAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fZAxisSpeed);

	p_Stream << "}";
}

void SRotateEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Target);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_fXAxisSpeed = simdjson::from_json_float32(p_Document["m_fXAxisSpeed"]);

	s_Object->m_fYAxisSpeed = simdjson::from_json_float32(p_Document["m_fYAxisSpeed"]);

	s_Object->m_fZAxisSpeed = simdjson::from_json_float32(p_Document["m_fZAxisSpeed"]);

}

void SRotateEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);

}

bool SRotateEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRotateEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRotateEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRotateEntitySaveData::operator==(const SRotateEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRotateEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fXAxisSpeed != p_Other.m_fXAxisSpeed) return false;
	if (m_fYAxisSpeed != p_Other.m_fYAxisSpeed) return false;
	if (m_fZAxisSpeed != p_Other.m_fZAxisSpeed) return false;

	return true;
}

void SRotateEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);
	s_Object->~SRotateEntitySaveData();
}

ZHMTypeInfo SSavableData::TypeInfo = ZHMTypeInfo("SSavableData", sizeof(SSavableData), alignof(SSavableData), SSavableData::WriteSimpleJson, SSavableData::FromSimpleJson, SSavableData::Serialize, SSavableData::Equals, SSavableData::Destroy);

void SSavableData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EntitiesData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_EntitiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nId);

	p_Stream << "}";
}

void SSavableData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSavableData*>(p_Target);

	ZVariant::FromSimpleJson(p_Document["m_EntitiesData"], &s_Object->m_EntitiesData);

	ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Object->m_Data);

	s_Object->m_nId = simdjson::from_json_uint32(p_Document["m_nId"]);

}

void SSavableData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_EntitiesData, p_Serializer, p_OwnOffset + offsetof(SSavableData, m_EntitiesData));
	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SSavableData, m_Data));
}

bool SSavableData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSavableData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSavableData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSavableData::operator==(const SSavableData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSavableData>)
		return false;

	if (m_EntitiesData != p_Other.m_EntitiesData) return false;
	if (m_Data != p_Other.m_Data) return false;
	if (m_nId != p_Other.m_nId) return false;

	return true;
}

void SSavableData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);
	s_Object->~SSavableData();
}

ZHMTypeInfo SVariantStruct::TypeInfo = ZHMTypeInfo("SVariantStruct", sizeof(SVariantStruct), alignof(SVariantStruct), SVariantStruct::WriteSimpleJson, SVariantStruct::FromSimpleJson, SVariantStruct::Serialize, SVariantStruct::Equals, SVariantStruct::Destroy);

void SVariantStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);

	p_Stream << "}";
}

void SVariantStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVariantStruct*>(p_Target);

	ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Object->m_Data);

}

void SVariantStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SVariantStruct, m_Data));
}

bool SVariantStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVariantStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SVariantStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVariantStruct::operator==(const SVariantStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVariantStruct>)
		return false;

	if (m_Data != p_Other.m_Data) return false;

	return true;
}

void SVariantStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);
	s_Object->~SVariantStruct();
}

ZHMTypeInfo SSavableEntitiesSaveData::TypeInfo = ZHMTypeInfo("SSavableEntitiesSaveData", sizeof(SSavableEntitiesSaveData), alignof(SSavableEntitiesSaveData), SSavableEntitiesSaveData::WriteSimpleJson, SSavableEntitiesSaveData::FromSimpleJson, SSavableEntitiesSaveData::Serialize, SSavableEntitiesSaveData::Equals, SSavableEntitiesSaveData::Destroy);

void SSavableEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityData[i];
		SVariantStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSavableEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityData"];
	s_Object->m_aEntityData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVariantStruct::FromSimpleJson(s_Item0, &s_Object->m_aEntityData[s_Index0]);
		++s_Index0;
	}
	}

}

void SSavableEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SSavableEntitiesSaveData, m_aEntities));
	TArray<SVariantStruct>::Serialize(&s_Object->m_aEntityData, p_Serializer, p_OwnOffset + offsetof(SSavableEntitiesSaveData, m_aEntityData));
}

bool SSavableEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSavableEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSavableEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSavableEntitiesSaveData::operator==(const SSavableEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSavableEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aEntityData != p_Other.m_aEntityData) return false;

	return true;
}

void SSavableEntitiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);
	s_Object->~SSavableEntitiesSaveData();
}

ZHMTypeInfo SSaveGameData::TypeInfo = ZHMTypeInfo("SSaveGameData", sizeof(SSaveGameData), alignof(SSaveGameData), SSaveGameData::WriteSimpleJson, SSaveGameData::FromSimpleJson, SSaveGameData::Serialize, SSaveGameData::Equals, SSaveGameData::Destroy);

void SSaveGameData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSavableObjectsData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSavableObjectsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSavableObjectsData[i];
		SSavableData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSavableObjectsData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityPaths") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityPaths.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityPaths[i];
		SEntityPath::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityPaths.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSaveGameData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSaveGameData*>(p_Target);

	s_Object->m_nVersion = simdjson::from_json_uint32(p_Document["m_nVersion"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSavableObjectsData"];
	s_Object->m_aSavableObjectsData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSavableData::FromSimpleJson(s_Item0, &s_Object->m_aSavableObjectsData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityPaths"];
	s_Object->m_aEntityPaths.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityPath::FromSimpleJson(s_Item0, &s_Object->m_aEntityPaths[s_Index0]);
		++s_Index0;
	}
	}

}

void SSaveGameData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);

	TArray<SSavableData>::Serialize(&s_Object->m_aSavableObjectsData, p_Serializer, p_OwnOffset + offsetof(SSaveGameData, m_aSavableObjectsData));
	TArray<SEntityPath>::Serialize(&s_Object->m_aEntityPaths, p_Serializer, p_OwnOffset + offsetof(SSaveGameData, m_aEntityPaths));
}

bool SSaveGameData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameData::operator==(const SSaveGameData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameData>)
		return false;

	if (m_nVersion != p_Other.m_nVersion) return false;
	if (m_aSavableObjectsData != p_Other.m_aSavableObjectsData) return false;
	if (m_aEntityPaths != p_Other.m_aEntityPaths) return false;

	return true;
}

void SSaveGameData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);
	s_Object->~SSaveGameData();
}

ZHMTypeInfo SSaveGameMetaData::TypeInfo = ZHMTypeInfo("SSaveGameMetaData", sizeof(SSaveGameMetaData), alignof(SSaveGameMetaData), SSaveGameMetaData::WriteSimpleJson, SSaveGameMetaData::FromSimpleJson, SSaveGameMetaData::Serialize, SSaveGameMetaData::Equals, SSaveGameMetaData::Destroy);

void SSaveGameMetaData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nSlot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSlot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eSaveType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESaveType", static_cast<int>(s_Object->eSaveType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractTitle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLocationId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sLocationId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractSessionId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractSessionId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLastEventToken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sLastEventToken);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsOnline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsOnline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aScreenShot") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aScreenShot.size(); ++i)
	{
		auto& s_Item0 = s_Object->aScreenShot[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aScreenShot.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aRequirements") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aRequirements.size(); ++i)
	{
		auto& s_Item0 = s_Object->aRequirements[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ERequirementId", static_cast<int>(s_Item0)));

		if (i < s_Object->aRequirements.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSaveGameMetaData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Target);

	s_Object->nSlot = simdjson::from_json_uint8(p_Document["nSlot"]);

	s_Object->eSaveType = static_cast<ESaveType>(ZHMEnums::GetEnumValueByName("ESaveType", std::string_view(p_Document["eSaveType"])));

	s_Object->sContractId = std::string_view(p_Document["sContractId"]);

	s_Object->sContractTitle = std::string_view(p_Document["sContractTitle"]);

	s_Object->sContractType = std::string_view(p_Document["sContractType"]);

	s_Object->sLocationId = std::string_view(p_Document["sLocationId"]);

	s_Object->sContractSessionId = std::string_view(p_Document["sContractSessionId"]);

	s_Object->sLastEventToken = std::string_view(p_Document["sLastEventToken"]);

	s_Object->bIsOnline = simdjson::from_json_bool(p_Document["bIsOnline"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aScreenShot"];
	s_Object->aScreenShot.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->aScreenShot[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aRequirements"];
	s_Object->aRequirements.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->aRequirements[s_Index0] = static_cast<ERequirementId>(ZHMEnums::GetEnumValueByName("ERequirementId", std::string_view(s_Item0)));
		++s_Index0;
	}
	}

}

void SSaveGameMetaData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);

	ZString::Serialize(&s_Object->sContractId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractId));
	ZString::Serialize(&s_Object->sContractTitle, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractTitle));
	ZString::Serialize(&s_Object->sContractType, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractType));
	ZString::Serialize(&s_Object->sLocationId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sLocationId));
	ZString::Serialize(&s_Object->sContractSessionId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractSessionId));
	ZString::Serialize(&s_Object->sLastEventToken, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sLastEventToken));
	TArray<uint32>::Serialize(&s_Object->aScreenShot, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, aScreenShot));
	TArray<ERequirementId>::Serialize(&s_Object->aRequirements, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, aRequirements));
}

bool SSaveGameMetaData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameMetaData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameMetaData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameMetaData::operator==(const SSaveGameMetaData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameMetaData>)
		return false;

	if (nSlot != p_Other.nSlot) return false;
	if (eSaveType != p_Other.eSaveType) return false;
	if (sContractId != p_Other.sContractId) return false;
	if (sContractTitle != p_Other.sContractTitle) return false;
	if (sContractType != p_Other.sContractType) return false;
	if (sLocationId != p_Other.sLocationId) return false;
	if (sContractSessionId != p_Other.sContractSessionId) return false;
	if (sLastEventToken != p_Other.sLastEventToken) return false;
	if (bIsOnline != p_Other.bIsOnline) return false;
	if (aScreenShot != p_Other.aScreenShot) return false;
	if (aRequirements != p_Other.aRequirements) return false;

	return true;
}

void SSaveGameMetaData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);
	s_Object->~SSaveGameMetaData();
}

ZHMTypeInfo SSaveGameHeader::TypeInfo = ZHMTypeInfo("SSaveGameHeader", sizeof(SSaveGameHeader), alignof(SSaveGameHeader), SSaveGameHeader::WriteSimpleJson, SSaveGameHeader::FromSimpleJson, SSaveGameHeader::Serialize, SSaveGameHeader::Equals, SSaveGameHeader::Destroy);

void SSaveGameHeader::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nFourCC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nFourCC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nCrc32") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nCrc32);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nTimeStamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nTimeStamp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("MetaData") << ":";
	SSaveGameMetaData::WriteSimpleJson(&s_Object->MetaData, p_Stream);

	p_Stream << "}";
}

void SSaveGameHeader::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSaveGameHeader*>(p_Target);

	s_Object->nFourCC = simdjson::from_json_uint32(p_Document["nFourCC"]);

	s_Object->nVersion = simdjson::from_json_uint32(p_Document["nVersion"]);

	s_Object->nCrc32 = simdjson::from_json_uint32(p_Document["nCrc32"]);

	s_Object->nSize = simdjson::from_json_uint32(p_Document["nSize"]);

	s_Object->nTimeStamp = simdjson::from_json_int64(p_Document["nTimeStamp"]);

	SSaveGameMetaData::FromSimpleJson(p_Document["MetaData"], &s_Object->MetaData);

}

void SSaveGameHeader::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);

	SSaveGameMetaData::Serialize(&s_Object->MetaData, p_Serializer, p_OwnOffset + offsetof(SSaveGameHeader, MetaData));
}

bool SSaveGameHeader::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameHeader*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameHeader*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameHeader::operator==(const SSaveGameHeader& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameHeader>)
		return false;

	if (nFourCC != p_Other.nFourCC) return false;
	if (nVersion != p_Other.nVersion) return false;
	if (nCrc32 != p_Other.nCrc32) return false;
	if (nSize != p_Other.nSize) return false;
	if (nTimeStamp != p_Other.nTimeStamp) return false;
	if (MetaData != p_Other.MetaData) return false;

	return true;
}

void SSaveGameHeader::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);
	s_Object->~SSaveGameHeader();
}

ZHMTypeInfo SScreenplayManagerSaveData::TypeInfo = ZHMTypeInfo("SScreenplayManagerSaveData", sizeof(SScreenplayManagerSaveData), alignof(SScreenplayManagerSaveData), SScreenplayManagerSaveData::WriteSimpleJson, SScreenplayManagerSaveData::FromSimpleJson, SScreenplayManagerSaveData::Serialize, SScreenplayManagerSaveData::Equals, SScreenplayManagerSaveData::Destroy);

void SScreenplayManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_DramaActorData") << ":";
	SDramaActorCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaActorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSituationData") << ":";
	SDramaSituationCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaSituationData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSetupData") << ":";
	SDramaSetupCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaSetupData, p_Stream);

	p_Stream << "}";
}

void SScreenplayManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Target);

	SDramaActorCollectionSaveData::FromSimpleJson(p_Document["m_DramaActorData"], &s_Object->m_DramaActorData);

	SDramaSituationCollectionSaveData::FromSimpleJson(p_Document["m_DramaSituationData"], &s_Object->m_DramaSituationData);

	SDramaSetupCollectionSaveData::FromSimpleJson(p_Document["m_DramaSetupData"], &s_Object->m_DramaSetupData);

}

void SScreenplayManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);

	SDramaActorCollectionSaveData::Serialize(&s_Object->m_DramaActorData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaActorData));
	SDramaSituationCollectionSaveData::Serialize(&s_Object->m_DramaSituationData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaSituationData));
	SDramaSetupCollectionSaveData::Serialize(&s_Object->m_DramaSetupData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaSetupData));
}

bool SScreenplayManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SScreenplayManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SScreenplayManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SScreenplayManagerSaveData::operator==(const SScreenplayManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SScreenplayManagerSaveData>)
		return false;

	if (m_DramaActorData != p_Other.m_DramaActorData) return false;
	if (m_DramaSituationData != p_Other.m_DramaSituationData) return false;
	if (m_DramaSetupData != p_Other.m_DramaSetupData) return false;

	return true;
}

void SScreenplayManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);
	s_Object->~SScreenplayManagerSaveData();
}

ZHMTypeInfo SSecuritySystemCameraSaveData::TypeInfo = ZHMTypeInfo("SSecuritySystemCameraSaveData", sizeof(SSecuritySystemCameraSaveData), alignof(SSecuritySystemCameraSaveData), SSecuritySystemCameraSaveData::WriteSimpleJson, SSecuritySystemCameraSaveData::FromSimpleJson, SSecuritySystemCameraSaveData::Serialize, SSecuritySystemCameraSaveData::Equals, SSecuritySystemCameraSaveData::Destroy);

void SSecuritySystemCameraSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEscalation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEscalation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFunctional") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFunctional);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasEnteredOnce") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasEnteredOnce);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);

	p_Stream << "}";
}

void SSecuritySystemCameraSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Target);

	s_Object->m_nEscalation = simdjson::from_json_uint16(p_Document["m_nEscalation"]);

	s_Object->m_bIsFunctional = simdjson::from_json_bool(p_Document["m_bIsFunctional"]);

	s_Object->m_bHasEnteredOnce = simdjson::from_json_bool(p_Document["m_bHasEnteredOnce"]);

	s_Object->m_bWasInvestigated = simdjson::from_json_bool(p_Document["m_bWasInvestigated"]);

	s_Object->m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

}

void SSecuritySystemCameraSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);

}

bool SSecuritySystemCameraSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSecuritySystemCameraSaveData::operator==(const SSecuritySystemCameraSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSecuritySystemCameraSaveData>)
		return false;

	if (m_nEscalation != p_Other.m_nEscalation) return false;
	if (m_bIsFunctional != p_Other.m_bIsFunctional) return false;
	if (m_bHasEnteredOnce != p_Other.m_bHasEnteredOnce) return false;
	if (m_bWasInvestigated != p_Other.m_bWasInvestigated) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;

	return true;
}

void SSecuritySystemCameraSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);
	s_Object->~SSecuritySystemCameraSaveData();
}

ZHMTypeInfo SSecuritySystemRecorderSaveData::TypeInfo = ZHMTypeInfo("SSecuritySystemRecorderSaveData", sizeof(SSecuritySystemRecorderSaveData), alignof(SSecuritySystemRecorderSaveData), SSecuritySystemRecorderSaveData::WriteSimpleJson, SSecuritySystemRecorderSaveData::FromSimpleJson, SSecuritySystemRecorderSaveData::Serialize, SSecuritySystemRecorderSaveData::Equals, SSecuritySystemRecorderSaveData::Destroy);

void SSecuritySystemRecorderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bHasRecordings") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRecordings);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFunctional") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFunctional);

	p_Stream << "}";
}

void SSecuritySystemRecorderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Target);

	s_Object->m_bHasRecordings = simdjson::from_json_bool(p_Document["m_bHasRecordings"]);

	s_Object->m_bIsFunctional = simdjson::from_json_bool(p_Document["m_bIsFunctional"]);

}

void SSecuritySystemRecorderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);

}

bool SSecuritySystemRecorderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSecuritySystemRecorderSaveData::operator==(const SSecuritySystemRecorderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSecuritySystemRecorderSaveData>)
		return false;

	if (m_bHasRecordings != p_Other.m_bHasRecordings) return false;
	if (m_bIsFunctional != p_Other.m_bIsFunctional) return false;

	return true;
}

void SSecuritySystemRecorderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);
	s_Object->~SSecuritySystemRecorderSaveData();
}

ZHMTypeInfo SSentryGroupSaveData::TypeInfo = ZHMTypeInfo("SSentryGroupSaveData", sizeof(SSentryGroupSaveData), alignof(SSentryGroupSaveData), SSentryGroupSaveData::WriteSimpleJson, SSentryGroupSaveData::FromSimpleJson, SSentryGroupSaveData::Serialize, SSentryGroupSaveData::Equals, SSentryGroupSaveData::Destroy);

void SSentryGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSentryZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSentryZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eActionPrompt") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESentryActionPrompt", static_cast<int>(s_Object->m_eActionPrompt)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRequestedAction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRequestedAction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowingWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowingWarning);

	p_Stream << "}";
}

void SSentryGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Target);

	s_Object->m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object->m_rSentryZone = simdjson::from_json_uint32(p_Document["m_rSentryZone"]);

	ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Object->m_tLastEscalateOrder);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_eActionPrompt = static_cast<ESentryActionPrompt>(ZHMEnums::GetEnumValueByName("ESentryActionPrompt", std::string_view(p_Document["m_eActionPrompt"])));

	s_Object->m_bRequestedAction = simdjson::from_json_bool(p_Document["m_bRequestedAction"]);

	s_Object->m_bShowingWarning = simdjson::from_json_bool(p_Document["m_bShowingWarning"]);

}

void SSentryGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(SSentryGroupSaveData, m_tLastEscalateOrder));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SSentryGroupSaveData, m_fsmState));
}

bool SSentryGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryGroupSaveData::operator==(const SSentryGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_rSentryZone != p_Other.m_rSentryZone) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_eActionPrompt != p_Other.m_eActionPrompt) return false;
	if (m_bRequestedAction != p_Other.m_bRequestedAction) return false;
	if (m_bShowingWarning != p_Other.m_bShowingWarning) return false;

	return true;
}

void SSentryGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);
	s_Object->~SSentryGroupSaveData();
}

ZHMTypeInfo SSentryOrderSaveData::TypeInfo = ZHMTypeInfo("SSentryOrderSaveData", sizeof(SSentryOrderSaveData), alignof(SSentryOrderSaveData), SSentryOrderSaveData::WriteSimpleJson, SSentryOrderSaveData::FromSimpleJson, SSentryOrderSaveData::Serialize, SSentryOrderSaveData::Equals, SSentryOrderSaveData::Destroy);

void SSentryOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSentryZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSentryZone);

	p_Stream << "}";
}

void SSentryOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Target);

	s_Object->m_rSentryZone = simdjson::from_json_uint32(p_Document["m_rSentryZone"]);

}

void SSentryOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);

}

bool SSentryOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryOrderSaveData::operator==(const SSentryOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryOrderSaveData>)
		return false;

	if (m_rSentryZone != p_Other.m_rSentryZone) return false;

	return true;
}

void SSentryOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);
	s_Object->~SSentryOrderSaveData();
}

ZHMTypeInfo SSentryZoneSaveData::TypeInfo = ZHMTypeInfo("SSentryZoneSaveData", sizeof(SSentryZoneSaveData), alignof(SSentryZoneSaveData), SSentryZoneSaveData::WriteSimpleJson, SSentryZoneSaveData::FromSimpleJson, SSentryZoneSaveData::Serialize, SSentryZoneSaveData::Equals, SSentryZoneSaveData::Destroy);

void SSentryZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tGreetingCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGreetingCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLoiteringCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLoiteringCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowingWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowingWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bLeftThroughWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bLeftThroughWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bEnteredThroughEntranceZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bEnteredThroughEntranceZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInEntranceZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInEntranceZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInGreetingZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInGreetingZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInReFriskZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInReFriskZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInRequiredDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInRequiredDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInFriskExemptDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInFriskExemptDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasRequiredItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRequiredItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanShowActionPrompt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanShowActionPrompt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInAnyZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInAnyZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrisked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrisked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItemChecked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemChecked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreeted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreeted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedInstruction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedInstruction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedLoitering") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedLoitering);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedUnexpected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedUnexpected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInFriskWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInFriskWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesAllowedDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesAllowedDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesAllowedDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesAllowedDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesFriskExemptDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesFriskExemptDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesFriskExemptDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesFriskExemptDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesDontEscalateOnLineCrossingDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSentryZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Target);

	ZGameTime::FromSimpleJson(p_Document["m_tGreetingCooldown"], &s_Object->m_tGreetingCooldown);

	ZGameTime::FromSimpleJson(p_Document["m_tLoiteringCooldown"], &s_Object->m_tLoiteringCooldown);

	s_Object->m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	s_Object->m_bShowingWarning = simdjson::from_json_bool(p_Document["m_bShowingWarning"]);

	s_Object->bLeftThroughWarningZone = simdjson::from_json_bool(p_Document["bLeftThroughWarningZone"]);

	s_Object->bEnteredThroughEntranceZone = simdjson::from_json_bool(p_Document["bEnteredThroughEntranceZone"]);

	s_Object->bInEntranceZone = simdjson::from_json_bool(p_Document["bInEntranceZone"]);

	s_Object->bInWarningZone = simdjson::from_json_bool(p_Document["bInWarningZone"]);

	s_Object->bInGreetingZone = simdjson::from_json_bool(p_Document["bInGreetingZone"]);

	s_Object->bInReFriskZone = simdjson::from_json_bool(p_Document["bInReFriskZone"]);

	s_Object->m_bInRequiredDisguise = simdjson::from_json_bool(p_Document["m_bInRequiredDisguise"]);

	s_Object->m_bInFriskExemptDisguise = simdjson::from_json_bool(p_Document["m_bInFriskExemptDisguise"]);

	s_Object->m_bHasRequiredItem = simdjson::from_json_bool(p_Document["m_bHasRequiredItem"]);

	s_Object->m_bCanShowActionPrompt = simdjson::from_json_bool(p_Document["m_bCanShowActionPrompt"]);

	s_Object->m_bTargetInAnyZone = simdjson::from_json_bool(p_Document["m_bTargetInAnyZone"]);

	s_Object->m_bSituationActive = simdjson::from_json_bool(p_Document["m_bSituationActive"]);

	s_Object->m_bFrisked = simdjson::from_json_bool(p_Document["m_bFrisked"]);

	s_Object->m_bItemChecked = simdjson::from_json_bool(p_Document["m_bItemChecked"]);

	s_Object->m_bGreeted = simdjson::from_json_bool(p_Document["m_bGreeted"]);

	s_Object->m_bGreetedInstruction = simdjson::from_json_bool(p_Document["m_bGreetedInstruction"]);

	s_Object->m_bGreetedLoitering = simdjson::from_json_bool(p_Document["m_bGreetedLoitering"]);

	s_Object->m_bGreetedUnexpected = simdjson::from_json_bool(p_Document["m_bGreetedUnexpected"]);

	s_Object->m_bInFriskWarningZone = simdjson::from_json_bool(p_Document["m_bInFriskWarningZone"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDisguisesAllowedDisabled"];
	s_Object->m_aDisguisesAllowedDisabled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aDisguisesAllowedDisabled[s_Index0] = simdjson::from_json_bool(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDisguisesFriskExemptDisabled"];
	s_Object->m_aDisguisesFriskExemptDisabled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aDisguisesFriskExemptDisabled[s_Index0] = simdjson::from_json_bool(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDisguisesDontEscalateOnLineCrossingDisabled"];
	s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled[s_Index0] = simdjson::from_json_bool(s_Item0);
		++s_Index0;
	}
	}

}

void SSentryZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGreetingCooldown, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_tGreetingCooldown));
	ZGameTime::Serialize(&s_Object->m_tLoiteringCooldown, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_tLoiteringCooldown));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesAllowedDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesAllowedDisabled));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesFriskExemptDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesFriskExemptDisabled));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesDontEscalateOnLineCrossingDisabled));
}

bool SSentryZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryZoneSaveData::operator==(const SSentryZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryZoneSaveData>)
		return false;

	if (m_tGreetingCooldown != p_Other.m_tGreetingCooldown) return false;
	if (m_tLoiteringCooldown != p_Other.m_tLoiteringCooldown) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_bShowingWarning != p_Other.m_bShowingWarning) return false;
	if (bLeftThroughWarningZone != p_Other.bLeftThroughWarningZone) return false;
	if (bEnteredThroughEntranceZone != p_Other.bEnteredThroughEntranceZone) return false;
	if (bInEntranceZone != p_Other.bInEntranceZone) return false;
	if (bInWarningZone != p_Other.bInWarningZone) return false;
	if (bInGreetingZone != p_Other.bInGreetingZone) return false;
	if (bInReFriskZone != p_Other.bInReFriskZone) return false;
	if (m_bInRequiredDisguise != p_Other.m_bInRequiredDisguise) return false;
	if (m_bInFriskExemptDisguise != p_Other.m_bInFriskExemptDisguise) return false;
	if (m_bHasRequiredItem != p_Other.m_bHasRequiredItem) return false;
	if (m_bCanShowActionPrompt != p_Other.m_bCanShowActionPrompt) return false;
	if (m_bTargetInAnyZone != p_Other.m_bTargetInAnyZone) return false;
	if (m_bSituationActive != p_Other.m_bSituationActive) return false;
	if (m_bFrisked != p_Other.m_bFrisked) return false;
	if (m_bItemChecked != p_Other.m_bItemChecked) return false;
	if (m_bGreeted != p_Other.m_bGreeted) return false;
	if (m_bGreetedInstruction != p_Other.m_bGreetedInstruction) return false;
	if (m_bGreetedLoitering != p_Other.m_bGreetedLoitering) return false;
	if (m_bGreetedUnexpected != p_Other.m_bGreetedUnexpected) return false;
	if (m_bInFriskWarningZone != p_Other.m_bInFriskWarningZone) return false;
	if (m_aDisguisesAllowedDisabled != p_Other.m_aDisguisesAllowedDisabled) return false;
	if (m_aDisguisesFriskExemptDisabled != p_Other.m_aDisguisesFriskExemptDisabled) return false;
	if (m_aDisguisesDontEscalateOnLineCrossingDisabled != p_Other.m_aDisguisesDontEscalateOnLineCrossingDisabled) return false;

	return true;
}

void SSentryZoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);
	s_Object->~SSentryZoneSaveData();
}

ZHMTypeInfo SSequenceTrackSaveData::TypeInfo = ZHMTypeInfo("SSequenceTrackSaveData", sizeof(SSequenceTrackSaveData), alignof(SSequenceTrackSaveData), SSequenceTrackSaveData::WriteSimpleJson, SSequenceTrackSaveData::FromSimpleJson, SSequenceTrackSaveData::Serialize, SSequenceTrackSaveData::Equals, SSequenceTrackSaveData::Destroy);

void SSequenceTrackSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTrackEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTrackEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomTrackData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomTrackData, p_Stream);

	p_Stream << "}";
}

void SSequenceTrackSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Target);

	s_Object->m_rTrackEntity = simdjson::from_json_uint32(p_Document["m_rTrackEntity"]);

	ZVariant::FromSimpleJson(p_Document["m_CustomTrackData"], &s_Object->m_CustomTrackData);

}

void SSequenceTrackSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_CustomTrackData, p_Serializer, p_OwnOffset + offsetof(SSequenceTrackSaveData, m_CustomTrackData));
}

bool SSequenceTrackSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceTrackSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceTrackSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceTrackSaveData::operator==(const SSequenceTrackSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceTrackSaveData>)
		return false;

	if (m_rTrackEntity != p_Other.m_rTrackEntity) return false;
	if (m_CustomTrackData != p_Other.m_CustomTrackData) return false;

	return true;
}

void SSequenceTrackSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);
	s_Object->~SSequenceTrackSaveData();
}

ZHMTypeInfo SSequenceSaveData::TypeInfo = ZHMTypeInfo("SSequenceSaveData", sizeof(SSequenceSaveData), alignof(SSequenceSaveData), SSequenceSaveData::WriteSimpleJson, SSequenceSaveData::FromSimpleJson, SSequenceSaveData::Serialize, SSequenceSaveData::Equals, SSequenceSaveData::Destroy);

void SSequenceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_commandQueue") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_commandQueue.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_commandQueue[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSequenceEntity.ECommand", static_cast<int>(s_Item0)));

		if (i < s_Object->m_commandQueue.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sequenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_sequenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sequenceOrigin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sequenceOrigin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasRunData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRunData);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTrackSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackSaveData[i];
		SSequenceTrackSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_effectiveSequenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_effectiveSequenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentLoop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentLoop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStateFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eStateFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPausedOnStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPausedOnStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivatedByIActivatable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivatedByIActivatable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGettingDeactivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGettingDeactivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOnGameStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOnGameStopped);

	p_Stream << "}";
}

void SSequenceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSequenceSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_commandQueue"];
	s_Object->m_commandQueue.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_commandQueue[s_Index0] = static_cast<ZSequenceEntity::ECommand>(ZHMEnums::GetEnumValueByName("ZSequenceEntity.ECommand", std::string_view(s_Item0)));
		++s_Index0;
	}
	}

	ZGameTime::FromSimpleJson(p_Document["m_sequenceTime"], &s_Object->m_sequenceTime);

	s_Object->m_sequenceOrigin = simdjson::from_json_uint32(p_Document["m_sequenceOrigin"]);

	s_Object->m_bHasRunData = simdjson::from_json_bool(p_Document["m_bHasRunData"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTrackSaveData"];
	s_Object->m_aTrackSaveData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSequenceTrackSaveData::FromSimpleJson(s_Item0, &s_Object->m_aTrackSaveData[s_Index0]);
		++s_Index0;
	}
	}

	ZGameTime::FromSimpleJson(p_Document["m_effectiveSequenceTime"], &s_Object->m_effectiveSequenceTime);

	s_Object->m_nCurrentLoop = simdjson::from_json_int32(p_Document["m_nCurrentLoop"]);

	s_Object->m_eStateFlags = simdjson::from_json_uint16(p_Document["m_eStateFlags"]);

	s_Object->m_bPausedOnStart = simdjson::from_json_bool(p_Document["m_bPausedOnStart"]);

	s_Object->m_bActivatedByIActivatable = simdjson::from_json_bool(p_Document["m_bActivatedByIActivatable"]);

	s_Object->m_bGettingDeactivated = simdjson::from_json_bool(p_Document["m_bGettingDeactivated"]);

	s_Object->m_bOnGameStopped = simdjson::from_json_bool(p_Document["m_bOnGameStopped"]);

}

void SSequenceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);

	TArray<ZSequenceEntity::ECommand>::Serialize(&s_Object->m_commandQueue, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_commandQueue));
	ZGameTime::Serialize(&s_Object->m_sequenceTime, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_sequenceTime));
	TArray<SSequenceTrackSaveData>::Serialize(&s_Object->m_aTrackSaveData, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_aTrackSaveData));
	ZGameTime::Serialize(&s_Object->m_effectiveSequenceTime, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_effectiveSequenceTime));
}

bool SSequenceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceSaveData::operator==(const SSequenceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceSaveData>)
		return false;

	if (m_commandQueue != p_Other.m_commandQueue) return false;
	if (m_sequenceTime != p_Other.m_sequenceTime) return false;
	if (m_sequenceOrigin != p_Other.m_sequenceOrigin) return false;
	if (m_bHasRunData != p_Other.m_bHasRunData) return false;
	if (m_aTrackSaveData != p_Other.m_aTrackSaveData) return false;
	if (m_effectiveSequenceTime != p_Other.m_effectiveSequenceTime) return false;
	if (m_nCurrentLoop != p_Other.m_nCurrentLoop) return false;
	if (m_eStateFlags != p_Other.m_eStateFlags) return false;
	if (m_bPausedOnStart != p_Other.m_bPausedOnStart) return false;
	if (m_bActivatedByIActivatable != p_Other.m_bActivatedByIActivatable) return false;
	if (m_bGettingDeactivated != p_Other.m_bGettingDeactivated) return false;
	if (m_bOnGameStopped != p_Other.m_bOnGameStopped) return false;

	return true;
}

void SSequenceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);
	s_Object->~SSequenceSaveData();
}

ZHMTypeInfo SSequenceManagerSaveData::TypeInfo = ZHMTypeInfo("SSequenceManagerSaveData", sizeof(SSequenceManagerSaveData), alignof(SSequenceManagerSaveData), SSequenceManagerSaveData::WriteSimpleJson, SSequenceManagerSaveData::FromSimpleJson, SSequenceManagerSaveData::Serialize, SSequenceManagerSaveData::Equals, SSequenceManagerSaveData::Destroy);

void SSequenceManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSequenceSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSequenceSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSequenceSaveData[i];
		SSequenceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSequenceSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSequenceManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSequenceSaveData"];
	s_Object->m_aSequenceSaveData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSequenceSaveData::FromSimpleJson(s_Item0, &s_Object->m_aSequenceSaveData[s_Index0]);
		++s_Index0;
	}
	}

}

void SSequenceManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SSequenceManagerSaveData, m_aEntities));
	TArray<SSequenceSaveData>::Serialize(&s_Object->m_aSequenceSaveData, p_Serializer, p_OwnOffset + offsetof(SSequenceManagerSaveData, m_aSequenceSaveData));
}

bool SSequenceManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceManagerSaveData::operator==(const SSequenceManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceManagerSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aSequenceSaveData != p_Other.m_aSequenceSaveData) return false;

	return true;
}

void SSequenceManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);
	s_Object->~SSequenceManagerSaveData();
}

ZHMTypeInfo SSerializedValue::TypeInfo = ZHMTypeInfo("SSerializedValue", sizeof(SSerializedValue), alignof(SSerializedValue), SSerializedValue::WriteSimpleJson, SSerializedValue::FromSimpleJson, SSerializedValue::Serialize, SSerializedValue::Equals, SSerializedValue::Destroy);

void SSerializedValue::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SSerializedValue::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSerializedValue*>(p_Target);

}

void SSerializedValue::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

}

bool SSerializedValue::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSerializedValue*>(p_Left);
	auto* s_Right = reinterpret_cast<SSerializedValue*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSerializedValue::operator==(const SSerializedValue& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSerializedValue>)
		return false;


	return true;
}

void SSerializedValue::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);
	s_Object->~SSerializedValue();
}

ZHMTypeInfo SSettingsParamMultiplier::TypeInfo = ZHMTypeInfo("SSettingsParamMultiplier", sizeof(SSettingsParamMultiplier), alignof(SSettingsParamMultiplier), SSettingsParamMultiplier::WriteSimpleJson, SSettingsParamMultiplier::FromSimpleJson, SSettingsParamMultiplier::Serialize, SSettingsParamMultiplier::Equals, SSettingsParamMultiplier::Destroy);

void SSettingsParamMultiplier::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSettingsParam") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESettingsParam", static_cast<int>(s_Object->m_eSettingsParam)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMultiplier);

	p_Stream << "}";
}

void SSettingsParamMultiplier::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Target);

	s_Object->m_eSettingsParam = static_cast<ESettingsParam>(ZHMEnums::GetEnumValueByName("ESettingsParam", std::string_view(p_Document["m_eSettingsParam"])));

	s_Object->m_fMultiplier = simdjson::from_json_float32(p_Document["m_fMultiplier"]);

}

void SSettingsParamMultiplier::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);

}

bool SSettingsParamMultiplier::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSettingsParamMultiplier*>(p_Left);
	auto* s_Right = reinterpret_cast<SSettingsParamMultiplier*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSettingsParamMultiplier::operator==(const SSettingsParamMultiplier& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSettingsParamMultiplier>)
		return false;

	if (m_eSettingsParam != p_Other.m_eSettingsParam) return false;
	if (m_fMultiplier != p_Other.m_fMultiplier) return false;

	return true;
}

void SSettingsParamMultiplier::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSettingsParamMultiplier*>(p_Object);
	s_Object->~SSettingsParamMultiplier();
}

ZHMTypeInfo SSituationConversationGroupSaveData::TypeInfo = ZHMTypeInfo("SSituationConversationGroupSaveData", sizeof(SSituationConversationGroupSaveData), alignof(SSituationConversationGroupSaveData), SSituationConversationGroupSaveData::WriteSimpleJson, SSituationConversationGroupSaveData::FromSimpleJson, SSituationConversationGroupSaveData::Serialize, SSituationConversationGroupSaveData::Equals, SSituationConversationGroupSaveData::Destroy);

void SSituationConversationGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_members") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_members.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_members[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_members.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSituationConversationGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_members"];
	s_Object->m_members.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_members[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SSituationConversationGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_members, p_Serializer, p_OwnOffset + offsetof(SSituationConversationGroupSaveData, m_members));
}

bool SSituationConversationGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationConversationGroupSaveData::operator==(const SSituationConversationGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationConversationGroupSaveData>)
		return false;

	if (m_members != p_Other.m_members) return false;

	return true;
}

void SSituationConversationGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);
	s_Object->~SSituationConversationGroupSaveData();
}

ZHMTypeInfo SSituationOrderSaveData::TypeInfo = ZHMTypeInfo("SSituationOrderSaveData", sizeof(SSituationOrderSaveData), alignof(SSituationOrderSaveData), SSituationOrderSaveData::WriteSimpleJson, SSituationOrderSaveData::FromSimpleJson, SSituationOrderSaveData::Serialize, SSituationOrderSaveData::Equals, SSituationOrderSaveData::Destroy);

void SSituationOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sClassTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sClassTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Target);

	s_Object->m_sClassTypeName = std::string_view(p_Document["m_sClassTypeName"]);

	s_Object->m_eType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eType"])));

	s_Object->m_nTarget = simdjson::from_json_int32(p_Document["m_nTarget"]);

	s_Object->m_bHasPosition = simdjson::from_json_bool(p_Document["m_bHasPosition"]);

	float4::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Object->m_CustomData);

}

void SSituationOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sClassTypeName, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_sClassTypeName));
	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_vPosition));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_CustomData));
}

bool SSituationOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationOrderSaveData::operator==(const SSituationOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationOrderSaveData>)
		return false;

	if (m_sClassTypeName != p_Other.m_sClassTypeName) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_nTarget != p_Other.m_nTarget) return false;
	if (m_bHasPosition != p_Other.m_bHasPosition) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

void SSituationOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);
	s_Object->~SSituationOrderSaveData();
}

ZHMTypeInfo SSmuggleSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SSmuggleSituationActorStateSaveData", sizeof(SSmuggleSituationActorStateSaveData), alignof(SSmuggleSituationActorStateSaveData), SSmuggleSituationActorStateSaveData::WriteSimpleJson, SSmuggleSituationActorStateSaveData::FromSimpleJson, SSmuggleSituationActorStateSaveData::Serialize, SSmuggleSituationActorStateSaveData::Equals, SSmuggleSituationActorStateSaveData::Destroy);

void SSmuggleSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSmuggleSituationEntity.ESmuggleState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSmuggleSituationEntity.ESmuggleState", static_cast<int>(s_Object->m_nStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStateTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStateTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetLocationIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetLocationIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);

	p_Stream << "}";
}

void SSmuggleSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Target);

	s_Object->m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object->m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object->m_nState = static_cast<ZSmuggleSituationEntity::ESmuggleState>(ZHMEnums::GetEnumValueByName("ZSmuggleSituationEntity.ESmuggleState", std::string_view(p_Document["m_nState"])));

	s_Object->m_nStatePrevious = static_cast<ZSmuggleSituationEntity::ESmuggleState>(ZHMEnums::GetEnumValueByName("ZSmuggleSituationEntity.ESmuggleState", std::string_view(p_Document["m_nStatePrevious"])));

	s_Object->m_fStateTimer = simdjson::from_json_float32(p_Document["m_fStateTimer"]);

	s_Object->m_nTargetLocationIndex = simdjson::from_json_int32(p_Document["m_nTargetLocationIndex"]);

	s_Object->m_rScreenplay = simdjson::from_json_uint32(p_Document["m_rScreenplay"]);

}

void SSmuggleSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);

}

bool SSmuggleSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSmuggleSituationActorStateSaveData::operator==(const SSmuggleSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSmuggleSituationActorStateSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_nStatePrevious != p_Other.m_nStatePrevious) return false;
	if (m_fStateTimer != p_Other.m_fStateTimer) return false;
	if (m_nTargetLocationIndex != p_Other.m_nTargetLocationIndex) return false;
	if (m_rScreenplay != p_Other.m_rScreenplay) return false;

	return true;
}

void SSmuggleSituationActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);
	s_Object->~SSmuggleSituationActorStateSaveData();
}

ZHMTypeInfo SSmuggleSituationSaveData::TypeInfo = ZHMTypeInfo("SSmuggleSituationSaveData", sizeof(SSmuggleSituationSaveData), alignof(SSmuggleSituationSaveData), SSmuggleSituationSaveData::WriteSimpleJson, SSmuggleSituationSaveData::FromSimpleJson, SSmuggleSituationSaveData::Serialize, SSmuggleSituationSaveData::Equals, SSmuggleSituationSaveData::Destroy);

void SSmuggleSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfPickups") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfPickups);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorsSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorsSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorsSaveData[i];
		SSmuggleSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorsSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMoveToActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMoveToActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMoveToActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aMoveToActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSmuggleSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Target);

	s_Object->m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object->m_bIsRunning = simdjson::from_json_bool(p_Document["m_bIsRunning"]);

	s_Object->m_nNumberOfPickups = simdjson::from_json_int32(p_Document["m_nNumberOfPickups"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActorsSaveData"];
	s_Object->m_aActorsSaveData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSmuggleSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_Object->m_aActorsSaveData[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aMoveToActs"];
	s_Object->m_aMoveToActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aMoveToActs[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void SSmuggleSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);

	TArray<SSmuggleSituationActorStateSaveData>::Serialize(&s_Object->m_aActorsSaveData, p_Serializer, p_OwnOffset + offsetof(SSmuggleSituationSaveData, m_aActorsSaveData));
	TArray<uint32>::Serialize(&s_Object->m_aMoveToActs, p_Serializer, p_OwnOffset + offsetof(SSmuggleSituationSaveData, m_aMoveToActs));
}

bool SSmuggleSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSmuggleSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSmuggleSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSmuggleSituationSaveData::operator==(const SSmuggleSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSmuggleSituationSaveData>)
		return false;

	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_bIsRunning != p_Other.m_bIsRunning) return false;
	if (m_nNumberOfPickups != p_Other.m_nNumberOfPickups) return false;
	if (m_aActorsSaveData != p_Other.m_aActorsSaveData) return false;
	if (m_aMoveToActs != p_Other.m_aMoveToActs) return false;

	return true;
}

void SSmuggleSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);
	s_Object->~SSmuggleSituationSaveData();
}

ZHMTypeInfo SSniperCombatGroupSaveData::TypeInfo = ZHMTypeInfo("SSniperCombatGroupSaveData", sizeof(SSniperCombatGroupSaveData), alignof(SSniperCombatGroupSaveData), SSniperCombatGroupSaveData::WriteSimpleJson, SSniperCombatGroupSaveData::FromSimpleJson, SSniperCombatGroupSaveData::Serialize, SSniperCombatGroupSaveData::Equals, SSniperCombatGroupSaveData::Destroy);

void SSniperCombatGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEscapeTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEscapeTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTauntTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTauntTime, p_Stream);

	p_Stream << "}";
}

void SSniperCombatGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object->m_bFailed = simdjson::from_json_bool(p_Document["m_bFailed"]);

	ZGameTime::FromSimpleJson(p_Document["m_tEscapeTime"], &s_Object->m_tEscapeTime);

	ZGameTime::FromSimpleJson(p_Document["m_tLastTauntTime"], &s_Object->m_tLastTauntTime);

}

void SSniperCombatGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tEscapeTime, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_tEscapeTime));
	ZGameTime::Serialize(&s_Object->m_tLastTauntTime, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_tLastTauntTime));
}

bool SSniperCombatGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSniperCombatGroupSaveData::operator==(const SSniperCombatGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSniperCombatGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_bFailed != p_Other.m_bFailed) return false;
	if (m_tEscapeTime != p_Other.m_tEscapeTime) return false;
	if (m_tLastTauntTime != p_Other.m_tLastTauntTime) return false;

	return true;
}

void SSniperCombatGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);
	s_Object->~SSniperCombatGroupSaveData();
}

ZHMTypeInfo SSpaceCollectionBehaviorConfiguration::TypeInfo = ZHMTypeInfo("SSpaceCollectionBehaviorConfiguration", sizeof(SSpaceCollectionBehaviorConfiguration), alignof(SSpaceCollectionBehaviorConfiguration), SSpaceCollectionBehaviorConfiguration::WriteSimpleJson, SSpaceCollectionBehaviorConfiguration::FromSimpleJson, SSpaceCollectionBehaviorConfiguration::Serialize, SSpaceCollectionBehaviorConfiguration::Equals, SSpaceCollectionBehaviorConfiguration::Destroy);

void SSpaceCollectionBehaviorConfiguration::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bInclusive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInclusive);

	p_Stream << "}";
}

void SSpaceCollectionBehaviorConfiguration::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Target);

	s_Object->m_bInclusive = simdjson::from_json_bool(p_Document["m_bInclusive"]);

}

void SSpaceCollectionBehaviorConfiguration::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);

}

bool SSpaceCollectionBehaviorConfiguration::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpaceCollectionBehaviorConfiguration::operator==(const SSpaceCollectionBehaviorConfiguration& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpaceCollectionBehaviorConfiguration>)
		return false;

	if (m_bInclusive != p_Other.m_bInclusive) return false;

	return true;
}

void SSpaceCollectionBehaviorConfiguration::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);
	s_Object->~SSpaceCollectionBehaviorConfiguration();
}

ZHMTypeInfo SSpatialMoverEntitySaveData::TypeInfo = ZHMTypeInfo("SSpatialMoverEntitySaveData", sizeof(SSpatialMoverEntitySaveData), alignof(SSpatialMoverEntitySaveData), SSpatialMoverEntitySaveData::WriteSimpleJson, SSpatialMoverEntitySaveData::FromSimpleJson, SSpatialMoverEntitySaveData::Serialize, SSpatialMoverEntitySaveData::Equals, SSpatialMoverEntitySaveData::Destroy);

void SSpatialMoverEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBackwards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBackwards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFrameUpdateRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFrameUpdateRegistered);

	p_Stream << "}";
}

void SSpatialMoverEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Target);

	s_Object->m_fSpeed = simdjson::from_json_float32(p_Document["m_fSpeed"]);

	SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_bBackwards = simdjson::from_json_bool(p_Document["m_bBackwards"]);

	s_Object->m_bIsFrameUpdateRegistered = simdjson::from_json_bool(p_Document["m_bIsFrameUpdateRegistered"]);

}

void SSpatialMoverEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSpatialMoverEntitySaveData, m_vPosition));
}

bool SSpatialMoverEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpatialMoverEntitySaveData::operator==(const SSpatialMoverEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpatialMoverEntitySaveData>)
		return false;

	if (m_fSpeed != p_Other.m_fSpeed) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bBackwards != p_Other.m_bBackwards) return false;
	if (m_bIsFrameUpdateRegistered != p_Other.m_bIsFrameUpdateRegistered) return false;

	return true;
}

void SSpatialMoverEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);
	s_Object->~SSpatialMoverEntitySaveData();
}

ZHMTypeInfo SSpatialSaveData::TypeInfo = ZHMTypeInfo("SSpatialSaveData", sizeof(SSpatialSaveData), alignof(SSpatialSaveData), SSpatialSaveData::WriteSimpleJson, SSpatialSaveData::FromSimpleJson, SSpatialSaveData::Serialize, SSpatialSaveData::Equals, SSpatialSaveData::Destroy);

void SSpatialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternionRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vQuaternionRotation, p_Stream);

	p_Stream << "}";
}

void SSpatialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSpatialSaveData*>(p_Target);

	s_Object->m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	SVector4::FromSimpleJson(p_Document["m_vQuaternionRotation"], &s_Object->m_vQuaternionRotation);

}

void SSpatialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSpatialSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vQuaternionRotation, p_Serializer, p_OwnOffset + offsetof(SSpatialSaveData, m_vQuaternionRotation));
}

bool SSpatialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpatialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpatialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpatialSaveData::operator==(const SSpatialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpatialSaveData>)
		return false;

	if (m_bVisible != p_Other.m_bVisible) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vQuaternionRotation != p_Other.m_vQuaternionRotation) return false;

	return true;
}

void SSpatialSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);
	s_Object->~SSpatialSaveData();
}

ZHMTypeInfo SSpeakEntitySaveData::TypeInfo = ZHMTypeInfo("SSpeakEntitySaveData", sizeof(SSpeakEntitySaveData), alignof(SSpeakEntitySaveData), SSpeakEntitySaveData::WriteSimpleJson, SSpeakEntitySaveData::FromSimpleJson, SSpeakEntitySaveData::Serialize, SSpeakEntitySaveData::Equals, SSpeakEntitySaveData::Destroy);

void SSpeakEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSeekPosition);

	p_Stream << "}";
}

void SSpeakEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Target);

	s_Object->m_fSeekPosition = simdjson::from_json_float32(p_Document["m_fSeekPosition"]);

}

void SSpeakEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);

}

bool SSpeakEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpeakEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpeakEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpeakEntitySaveData::operator==(const SSpeakEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpeakEntitySaveData>)
		return false;

	if (m_fSeekPosition != p_Other.m_fSeekPosition) return false;

	return true;
}

void SSpeakEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);
	s_Object->~SSpeakEntitySaveData();
}

ZHMTypeInfo SStateControllerSaveData::TypeInfo = ZHMTypeInfo("SStateControllerSaveData", sizeof(SStateControllerSaveData), alignof(SStateControllerSaveData), SStateControllerSaveData::WriteSimpleJson, SStateControllerSaveData::FromSimpleJson, SStateControllerSaveData::Serialize, SStateControllerSaveData::Equals, SStateControllerSaveData::Destroy);

void SStateControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SStateControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aData[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

}

void SStateControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SStateControllerSaveData, m_aEntities));
	TArray<int32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SStateControllerSaveData, m_aData));
}

bool SStateControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStateControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStateControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStateControllerSaveData::operator==(const SStateControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStateControllerSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SStateControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);
	s_Object->~SStateControllerSaveData();
}

ZHMTypeInfo SStepCounterEntitySaveData::TypeInfo = ZHMTypeInfo("SStepCounterEntitySaveData", sizeof(SStepCounterEntitySaveData), alignof(SStepCounterEntitySaveData), SStepCounterEntitySaveData::WriteSimpleJson, SStepCounterEntitySaveData::FromSimpleJson, SStepCounterEntitySaveData::Serialize, SStepCounterEntitySaveData::Equals, SStepCounterEntitySaveData::Destroy);

void SStepCounterEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLoopIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLoopIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirst") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirst);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCountFrom") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCountFrom);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCountTo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCountTo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStepSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStepSize);

	p_Stream << "}";
}

void SStepCounterEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Target);

	s_Object->m_nIndex = simdjson::from_json_float32(p_Document["m_nIndex"]);

	s_Object->m_nLoopIndex = simdjson::from_json_int32(p_Document["m_nLoopIndex"]);

	s_Object->m_bFirst = simdjson::from_json_bool(p_Document["m_bFirst"]);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_nCountFrom = simdjson::from_json_float32(p_Document["m_nCountFrom"]);

	s_Object->m_nCountTo = simdjson::from_json_float32(p_Document["m_nCountTo"]);

	s_Object->m_nStepSize = simdjson::from_json_float32(p_Document["m_nStepSize"]);

}

void SStepCounterEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);

}

bool SStepCounterEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStepCounterEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStepCounterEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStepCounterEntitySaveData::operator==(const SStepCounterEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStepCounterEntitySaveData>)
		return false;

	if (m_nIndex != p_Other.m_nIndex) return false;
	if (m_nLoopIndex != p_Other.m_nLoopIndex) return false;
	if (m_bFirst != p_Other.m_bFirst) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_nCountFrom != p_Other.m_nCountFrom) return false;
	if (m_nCountTo != p_Other.m_nCountTo) return false;
	if (m_nStepSize != p_Other.m_nStepSize) return false;

	return true;
}

void SStepCounterEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);
	s_Object->~SStepCounterEntitySaveData();
}

ZHMTypeInfo SSubtitleRef::TypeInfo = ZHMTypeInfo("SSubtitleRef", sizeof(SSubtitleRef), alignof(SSubtitleRef), SSubtitleRef::WriteSimpleJson, SSubtitleRef::FromSimpleJson, SSubtitleRef::Serialize, SSubtitleRef::Equals, SSubtitleRef::Destroy);

void SSubtitleRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSubtitleRef*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSubtitlesDisabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSubtitlesDisabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TextResource") << ":";
	TResourcePtr::WriteSimpleJson(&s_Object->m_TextResource, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLineId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLineId);

	p_Stream << "}";
}

void SSubtitleRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SSubtitleRef*>(p_Target);

	s_Object->m_bSubtitlesDisabled = simdjson::from_json_bool(p_Document["m_bSubtitlesDisabled"]);

	TResourcePtr::FromSimpleJson(p_Document["m_TextResource"], &s_Object->m_TextResource);

	s_Object->m_nLineId = simdjson::from_json_uint32(p_Document["m_nLineId"]);

}

void SSubtitleRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSubtitleRef*>(p_Object);

	TResourcePtr::Serialize(&s_Object->m_TextResource, p_Serializer, p_OwnOffset + offsetof(SSubtitleRef, m_TextResource));
}

bool SSubtitleRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSubtitleRef*>(p_Left);
	auto* s_Right = reinterpret_cast<SSubtitleRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSubtitleRef::operator==(const SSubtitleRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSubtitleRef>)
		return false;

	if (m_bSubtitlesDisabled != p_Other.m_bSubtitlesDisabled) return false;
	if (m_TextResource != p_Other.m_TextResource) return false;
	if (m_nLineId != p_Other.m_nLineId) return false;

	return true;
}

void SSubtitleRef::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSubtitleRef*>(p_Object);
	s_Object->~SSubtitleRef();
}

ZHMTypeInfo STargetInfoObjectiveCondition::TypeInfo = ZHMTypeInfo("STargetInfoObjectiveCondition", sizeof(STargetInfoObjectiveCondition), alignof(STargetInfoObjectiveCondition), STargetInfoObjectiveCondition::WriteSimpleJson, STargetInfoObjectiveCondition::FromSimpleJson, STargetInfoObjectiveCondition::Serialize, STargetInfoObjectiveCondition::Equals, STargetInfoObjectiveCondition::Destroy);

void STargetInfoObjectiveCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("header") << ":";
	p_Stream << simdjson::as_json_string(s_Object->header);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("title") << ":";
	p_Stream << simdjson::as_json_string(s_Object->title);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("hardCondition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->hardCondition);

	p_Stream << "}";
}

void STargetInfoObjectiveCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Target);

	s_Object->header = std::string_view(p_Document["header"]);

	s_Object->title = std::string_view(p_Document["title"]);

	s_Object->icon = std::string_view(p_Document["icon"]);

	s_Object->type = std::string_view(p_Document["type"]);

	s_Object->hardCondition = simdjson::from_json_bool(p_Document["hardCondition"]);

}

void STargetInfoObjectiveCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);

	ZString::Serialize(&s_Object->header, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, header));
	ZString::Serialize(&s_Object->title, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, title));
	ZString::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, icon));
	ZString::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, type));
}

bool STargetInfoObjectiveCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoObjectiveCondition::operator==(const STargetInfoObjectiveCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoObjectiveCondition>)
		return false;

	if (header != p_Other.header) return false;
	if (title != p_Other.title) return false;
	if (icon != p_Other.icon) return false;
	if (type != p_Other.type) return false;
	if (hardCondition != p_Other.hardCondition) return false;

	return true;
}

void STargetInfoObjectiveCondition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);
	s_Object->~STargetInfoObjectiveCondition();
}

ZHMTypeInfo STargetInfoDisplayData::TypeInfo = ZHMTypeInfo("STargetInfoDisplayData", sizeof(STargetInfoDisplayData), alignof(STargetInfoDisplayData), STargetInfoDisplayData::WriteSimpleJson, STargetInfoDisplayData::FromSimpleJson, STargetInfoDisplayData::Serialize, STargetInfoDisplayData::Equals, STargetInfoDisplayData::Destroy);

void STargetInfoDisplayData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("npcName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->npcName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("disguiseName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->disguiseName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->objectiveType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->objectiveConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->objectiveConditions[i];
		STargetInfoObjectiveCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->objectiveConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsTarget);

	p_Stream << "}";
}

void STargetInfoDisplayData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Target);

	s_Object->npcName = std::string_view(p_Document["npcName"]);

	s_Object->disguiseName = std::string_view(p_Document["disguiseName"]);

	s_Object->objectiveType = std::string_view(p_Document["objectiveType"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["objectiveConditions"];
	s_Object->objectiveConditions.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STargetInfoObjectiveCondition::FromSimpleJson(s_Item0, &s_Object->objectiveConditions[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->fX = simdjson::from_json_int32(p_Document["fX"]);

	s_Object->fY = simdjson::from_json_int32(p_Document["fY"]);

	s_Object->fAlpha = simdjson::from_json_float32(p_Document["fAlpha"]);

	s_Object->bIsTarget = simdjson::from_json_bool(p_Document["bIsTarget"]);

}

void STargetInfoDisplayData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);

	ZString::Serialize(&s_Object->npcName, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, npcName));
	ZString::Serialize(&s_Object->disguiseName, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, disguiseName));
	ZString::Serialize(&s_Object->objectiveType, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, objectiveType));
	TArray<STargetInfoObjectiveCondition>::Serialize(&s_Object->objectiveConditions, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, objectiveConditions));
}

bool STargetInfoDisplayData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoDisplayData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoDisplayData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoDisplayData::operator==(const STargetInfoDisplayData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoDisplayData>)
		return false;

	if (npcName != p_Other.npcName) return false;
	if (disguiseName != p_Other.disguiseName) return false;
	if (objectiveType != p_Other.objectiveType) return false;
	if (objectiveConditions != p_Other.objectiveConditions) return false;
	if (fX != p_Other.fX) return false;
	if (fY != p_Other.fY) return false;
	if (fAlpha != p_Other.fAlpha) return false;
	if (bIsTarget != p_Other.bIsTarget) return false;

	return true;
}

void STargetInfoDisplayData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);
	s_Object->~STargetInfoDisplayData();
}

ZHMTypeInfo STargetInfoDisplayData_Dummy::TypeInfo = ZHMTypeInfo("STargetInfoDisplayData_Dummy", sizeof(STargetInfoDisplayData_Dummy), alignof(STargetInfoDisplayData_Dummy), STargetInfoDisplayData_Dummy::WriteSimpleJson, STargetInfoDisplayData_Dummy::FromSimpleJson, STargetInfoDisplayData_Dummy::Serialize, STargetInfoDisplayData_Dummy::Equals, STargetInfoDisplayData_Dummy::Destroy);

void STargetInfoDisplayData_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("__dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->__dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->__dummy[i];
		STargetInfoDisplayData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->__dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STargetInfoDisplayData_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["__dummy"];
	s_Object->__dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STargetInfoDisplayData::FromSimpleJson(s_Item0, &s_Object->__dummy[s_Index0]);
		++s_Index0;
	}
	}

}

void STargetInfoDisplayData_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);

	TArray<STargetInfoDisplayData>::Serialize(&s_Object->__dummy, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData_Dummy, __dummy));
}

bool STargetInfoDisplayData_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoDisplayData_Dummy::operator==(const STargetInfoDisplayData_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoDisplayData_Dummy>)
		return false;

	if (__dummy != p_Other.__dummy) return false;

	return true;
}

void STargetInfoDisplayData_Dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);
	s_Object->~STargetInfoDisplayData_Dummy();
}

ZHMTypeInfo STargetTrackingSaveData::TypeInfo = ZHMTypeInfo("STargetTrackingSaveData", sizeof(STargetTrackingSaveData), alignof(STargetTrackingSaveData), STargetTrackingSaveData::WriteSimpleJson, STargetTrackingSaveData::FromSimpleJson, STargetTrackingSaveData::Serialize, STargetTrackingSaveData::Equals, STargetTrackingSaveData::Destroy);

void STargetTrackingSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sharedTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sharedTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_position") << ":";
	float4::WriteSimpleJson(&s_Object->m_position, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_time") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_time, p_Stream);

	p_Stream << "}";
}

void STargetTrackingSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Target);

	s_Object->m_sharedTarget = simdjson::from_json_int32(p_Document["m_sharedTarget"]);

	float4::FromSimpleJson(p_Document["m_position"], &s_Object->m_position);

	ZGameTime::FromSimpleJson(p_Document["m_time"], &s_Object->m_time);

}

void STargetTrackingSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_position, p_Serializer, p_OwnOffset + offsetof(STargetTrackingSaveData, m_position));
	ZGameTime::Serialize(&s_Object->m_time, p_Serializer, p_OwnOffset + offsetof(STargetTrackingSaveData, m_time));
}

bool STargetTrackingSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetTrackingSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetTrackingSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetTrackingSaveData::operator==(const STargetTrackingSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetTrackingSaveData>)
		return false;

	if (m_sharedTarget != p_Other.m_sharedTarget) return false;
	if (m_position != p_Other.m_position) return false;
	if (m_time != p_Other.m_time) return false;

	return true;
}

void STargetTrackingSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);
	s_Object->~STargetTrackingSaveData();
}

ZHMTypeInfo STargetTrackingServiceSaveData::TypeInfo = ZHMTypeInfo("STargetTrackingServiceSaveData", sizeof(STargetTrackingServiceSaveData), alignof(STargetTrackingServiceSaveData), STargetTrackingServiceSaveData::WriteSimpleJson, STargetTrackingServiceSaveData::FromSimpleJson, STargetTrackingServiceSaveData::Serialize, STargetTrackingServiceSaveData::Equals, STargetTrackingServiceSaveData::Destroy);

void STargetTrackingServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTrackedTargets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackedTargets.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackedTargets[i];
		STargetTrackingSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackedTargets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STargetTrackingServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTrackedTargets"];
	s_Object->m_aTrackedTargets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STargetTrackingSaveData::FromSimpleJson(s_Item0, &s_Object->m_aTrackedTargets[s_Index0]);
		++s_Index0;
	}
	}

}

void STargetTrackingServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);

	TArray<STargetTrackingSaveData>::Serialize(&s_Object->m_aTrackedTargets, p_Serializer, p_OwnOffset + offsetof(STargetTrackingServiceSaveData, m_aTrackedTargets));
}

bool STargetTrackingServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetTrackingServiceSaveData::operator==(const STargetTrackingServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetTrackingServiceSaveData>)
		return false;

	if (m_aTrackedTargets != p_Other.m_aTrackedTargets) return false;

	return true;
}

void STargetTrackingServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);
	s_Object->~STargetTrackingServiceSaveData();
}

ZHMTypeInfo STemplateSubEntity::TypeInfo = ZHMTypeInfo("STemplateSubEntity", sizeof(STemplateSubEntity), alignof(STemplateSubEntity), STemplateSubEntity::WriteSimpleJson, STemplateSubEntity::FromSimpleJson, STemplateSubEntity::Serialize, STemplateSubEntity::Equals, STemplateSubEntity::Destroy);

void STemplateSubEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("logicalParent") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->logicalParent, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("postInitPropertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->postInitPropertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->postInitPropertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->postInitPropertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateSubEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STemplateSubEntity*>(p_Target);

	SEntityTemplateReference::FromSimpleJson(p_Document["logicalParent"], &s_Object->logicalParent);

	s_Object->entityTypeResourceIndex = simdjson::from_json_int32(p_Document["entityTypeResourceIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyValues"];
	s_Object->propertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_Object->propertyValues[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["postInitPropertyValues"];
	s_Object->postInitPropertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_Object->postInitPropertyValues[s_Index0]);
		++s_Index0;
	}
	}

}

void STemplateSubEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->logicalParent, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntity, logicalParent));
	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntity, propertyValues));
	TArray<SEntityTemplateProperty>::Serialize(&s_Object->postInitPropertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntity, postInitPropertyValues));
}

bool STemplateSubEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateSubEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateSubEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateSubEntity::operator==(const STemplateSubEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateSubEntity>)
		return false;

	if (logicalParent != p_Other.logicalParent) return false;
	if (entityTypeResourceIndex != p_Other.entityTypeResourceIndex) return false;
	if (propertyValues != p_Other.propertyValues) return false;
	if (postInitPropertyValues != p_Other.postInitPropertyValues) return false;

	return true;
}

void STemplateSubEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntity*>(p_Object);
	s_Object->~STemplateSubEntity();
}

ZHMTypeInfo STemplateEntity::TypeInfo = ZHMTypeInfo("STemplateEntity", sizeof(STemplateEntity), alignof(STemplateEntity), STemplateEntity::WriteSimpleJson, STemplateEntity::FromSimpleJson, STemplateEntity::Serialize, STemplateEntity::Equals, STemplateEntity::Destroy);

void STemplateEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("subType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->subType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		STemplateSubEntity::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyOverrides") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyOverrides[i];
		SEntityTemplatePropertyOverride::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyOverrides.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneTypeIndicesInResourceHeader") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->externalSceneTypeIndicesInResourceHeader.size(); ++i)
	{
		auto& s_Item0 = s_Object->externalSceneTypeIndicesInResourceHeader[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->externalSceneTypeIndicesInResourceHeader.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STemplateEntity*>(p_Target);

	s_Object->subType = simdjson::from_json_int32(p_Document["subType"]);

	s_Object->blueprintIndexInResourceHeader = simdjson::from_json_int32(p_Document["blueprintIndexInResourceHeader"]);

	s_Object->rootEntityIndex = simdjson::from_json_int32(p_Document["rootEntityIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["entityTemplates"];
	s_Object->entityTemplates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STemplateSubEntity::FromSimpleJson(s_Item0, &s_Object->entityTemplates[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyOverrides"];
	s_Object->propertyOverrides.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePropertyOverride::FromSimpleJson(s_Item0, &s_Object->propertyOverrides[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["externalSceneTypeIndicesInResourceHeader"];
	s_Object->externalSceneTypeIndicesInResourceHeader.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->externalSceneTypeIndicesInResourceHeader[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

}

void STemplateEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);

	TArray<STemplateSubEntity>::Serialize(&s_Object->entityTemplates, p_Serializer, p_OwnOffset + offsetof(STemplateEntity, entityTemplates));
	TArray<SEntityTemplatePropertyOverride>::Serialize(&s_Object->propertyOverrides, p_Serializer, p_OwnOffset + offsetof(STemplateEntity, propertyOverrides));
	TArray<int32>::Serialize(&s_Object->externalSceneTypeIndicesInResourceHeader, p_Serializer, p_OwnOffset + offsetof(STemplateEntity, externalSceneTypeIndicesInResourceHeader));
}

bool STemplateEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateEntity::operator==(const STemplateEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateEntity>)
		return false;

	if (subType != p_Other.subType) return false;
	if (blueprintIndexInResourceHeader != p_Other.blueprintIndexInResourceHeader) return false;
	if (rootEntityIndex != p_Other.rootEntityIndex) return false;
	if (entityTemplates != p_Other.entityTemplates) return false;
	if (propertyOverrides != p_Other.propertyOverrides) return false;
	if (externalSceneTypeIndicesInResourceHeader != p_Other.externalSceneTypeIndicesInResourceHeader) return false;

	return true;
}

void STemplateEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STemplateEntity*>(p_Object);
	s_Object->~STemplateEntity();
}

ZHMTypeInfo STemplateSubEntityBlueprint::TypeInfo = ZHMTypeInfo("STemplateSubEntityBlueprint", sizeof(STemplateSubEntityBlueprint), alignof(STemplateSubEntityBlueprint), STemplateSubEntityBlueprint::WriteSimpleJson, STemplateSubEntityBlueprint::FromSimpleJson, STemplateSubEntityBlueprint::Serialize, STemplateSubEntityBlueprint::Equals, STemplateSubEntityBlueprint::Destroy);

void STemplateSubEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("logicalParent") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->logicalParent, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyAliases") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyAliases.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyAliases[i];
		SEntityTemplatePropertyAlias::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyAliases.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedEntities[i];
		TPair<ZString,SEntityTemplateReference>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedInterfaces") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedInterfaces.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedInterfaces[i];
		TPair<ZString,int32>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedInterfaces.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entitySubsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entitySubsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->entitySubsets[i];
		TPair<ZString,SEntityTemplateEntitySubset>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entitySubsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateSubEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Target);

	SEntityTemplateReference::FromSimpleJson(p_Document["logicalParent"], &s_Object->logicalParent);

	s_Object->entityTypeResourceIndex = simdjson::from_json_int32(p_Document["entityTypeResourceIndex"]);

	s_Object->entityId = simdjson::from_json_uint64(p_Document["entityId"]);

	s_Object->entityName = std::string_view(p_Document["entityName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyAliases"];
	s_Object->propertyAliases.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePropertyAlias::FromSimpleJson(s_Item0, &s_Object->propertyAliases[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["exposedEntities"];
	s_Object->exposedEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TPair<ZString,SEntityTemplateReference>::FromSimpleJson(s_Item0, &s_Object->exposedEntities[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["exposedInterfaces"];
	s_Object->exposedInterfaces.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TPair<ZString,int32>::FromSimpleJson(s_Item0, &s_Object->exposedInterfaces[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["entitySubsets"];
	s_Object->entitySubsets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TPair<ZString,SEntityTemplateEntitySubset>::FromSimpleJson(s_Item0, &s_Object->entitySubsets[s_Index0]);
		++s_Index0;
	}
	}

}

void STemplateSubEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->logicalParent, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, logicalParent));
	ZString::Serialize(&s_Object->entityName, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, entityName));
	TArray<SEntityTemplatePropertyAlias>::Serialize(&s_Object->propertyAliases, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, propertyAliases));
	TArray<TPair<ZString,SEntityTemplateReference>>::Serialize(&s_Object->exposedEntities, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, exposedEntities));
	TArray<TPair<ZString,int32>>::Serialize(&s_Object->exposedInterfaces, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, exposedInterfaces));
	TArray<TPair<ZString,SEntityTemplateEntitySubset>>::Serialize(&s_Object->entitySubsets, p_Serializer, p_OwnOffset + offsetof(STemplateSubEntityBlueprint, entitySubsets));
}

bool STemplateSubEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateSubEntityBlueprint::operator==(const STemplateSubEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateSubEntityBlueprint>)
		return false;

	if (logicalParent != p_Other.logicalParent) return false;
	if (entityTypeResourceIndex != p_Other.entityTypeResourceIndex) return false;
	if (entityId != p_Other.entityId) return false;
	if (entityName != p_Other.entityName) return false;
	if (propertyAliases != p_Other.propertyAliases) return false;
	if (exposedEntities != p_Other.exposedEntities) return false;
	if (exposedInterfaces != p_Other.exposedInterfaces) return false;
	if (entitySubsets != p_Other.entitySubsets) return false;

	return true;
}

void STemplateSubEntityBlueprint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STemplateSubEntityBlueprint*>(p_Object);
	s_Object->~STemplateSubEntityBlueprint();
}

ZHMTypeInfo STemplateEntityBlueprint::TypeInfo = ZHMTypeInfo("STemplateEntityBlueprint", sizeof(STemplateEntityBlueprint), alignof(STemplateEntityBlueprint), STemplateEntityBlueprint::WriteSimpleJson, STemplateEntityBlueprint::FromSimpleJson, STemplateEntityBlueprint::Serialize, STemplateEntityBlueprint::Equals, STemplateEntityBlueprint::Destroy);

void STemplateEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("subType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->subType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTemplates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entityTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->entityTemplates[i];
		STemplateSubEntityBlueprint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entityTemplates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneTypeIndicesInResourceHeader") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->externalSceneTypeIndicesInResourceHeader.size(); ++i)
	{
		auto& s_Item0 = s_Object->externalSceneTypeIndicesInResourceHeader[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->externalSceneTypeIndicesInResourceHeader.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("pinConnections") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pinConnections.size(); ++i)
	{
		auto& s_Item0 = s_Object->pinConnections[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pinConnections.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inputPinForwardings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->inputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->inputPinForwardings[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->inputPinForwardings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("outputPinForwardings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->outputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->outputPinForwardings[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->outputPinForwardings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("overrideDeletes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->overrideDeletes.size(); ++i)
	{
		auto& s_Item0 = s_Object->overrideDeletes[i];
		SEntityTemplateReference::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->overrideDeletes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Target);

	s_Object->subType = simdjson::from_json_int32(p_Document["subType"]);

	s_Object->rootEntityIndex = simdjson::from_json_int32(p_Document["rootEntityIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["entityTemplates"];
	s_Object->entityTemplates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STemplateSubEntityBlueprint::FromSimpleJson(s_Item0, &s_Object->entityTemplates[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["externalSceneTypeIndicesInResourceHeader"];
	s_Object->externalSceneTypeIndicesInResourceHeader.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->externalSceneTypeIndicesInResourceHeader[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["pinConnections"];
	s_Object->pinConnections.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_Object->pinConnections[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["inputPinForwardings"];
	s_Object->inputPinForwardings.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_Object->inputPinForwardings[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["outputPinForwardings"];
	s_Object->outputPinForwardings.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_Object->outputPinForwardings[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["overrideDeletes"];
	s_Object->overrideDeletes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateReference::FromSimpleJson(s_Item0, &s_Object->overrideDeletes[s_Index0]);
		++s_Index0;
	}
	}

}

void STemplateEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	TArray<STemplateSubEntityBlueprint>::Serialize(&s_Object->entityTemplates, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, entityTemplates));
	TArray<int32>::Serialize(&s_Object->externalSceneTypeIndicesInResourceHeader, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, externalSceneTypeIndicesInResourceHeader));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->pinConnections, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, pinConnections));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->inputPinForwardings, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, inputPinForwardings));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->outputPinForwardings, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, outputPinForwardings));
	TArray<SEntityTemplateReference>::Serialize(&s_Object->overrideDeletes, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, overrideDeletes));
}

bool STemplateEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateEntityBlueprint::operator==(const STemplateEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateEntityBlueprint>)
		return false;

	if (subType != p_Other.subType) return false;
	if (rootEntityIndex != p_Other.rootEntityIndex) return false;
	if (entityTemplates != p_Other.entityTemplates) return false;
	if (externalSceneTypeIndicesInResourceHeader != p_Other.externalSceneTypeIndicesInResourceHeader) return false;
	if (pinConnections != p_Other.pinConnections) return false;
	if (inputPinForwardings != p_Other.inputPinForwardings) return false;
	if (outputPinForwardings != p_Other.outputPinForwardings) return false;
	if (overrideDeletes != p_Other.overrideDeletes) return false;

	return true;
}

void STemplateEntityBlueprint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);
	s_Object->~STemplateEntityBlueprint();
}

ZHMTypeInfo STestMiniStruct::TypeInfo = ZHMTypeInfo("STestMiniStruct", sizeof(STestMiniStruct), alignof(STestMiniStruct), STestMiniStruct::WriteSimpleJson, STestMiniStruct::FromSimpleJson, STestMiniStruct::Serialize, STestMiniStruct::Equals, STestMiniStruct::Destroy);

void STestMiniStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iIntValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iIntValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFloatValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFloatValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);

	p_Stream << "}";
}

void STestMiniStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STestMiniStruct*>(p_Target);

	s_Object->m_iIntValue = simdjson::from_json_int32(p_Document["m_iIntValue"]);

	s_Object->m_fFloatValue = simdjson::from_json_float32(p_Document["m_fFloatValue"]);

	s_Object->m_sText = std::string_view(p_Document["m_sText"]);

}

void STestMiniStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);

	ZString::Serialize(&s_Object->m_sText, p_Serializer, p_OwnOffset + offsetof(STestMiniStruct, m_sText));
}

bool STestMiniStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestMiniStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<STestMiniStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestMiniStruct::operator==(const STestMiniStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestMiniStruct>)
		return false;

	if (m_iIntValue != p_Other.m_iIntValue) return false;
	if (m_fFloatValue != p_Other.m_fFloatValue) return false;
	if (m_sText != p_Other.m_sText) return false;

	return true;
}

void STestMiniStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STestMiniStruct*>(p_Object);
	s_Object->~STestMiniStruct();
}

ZHMTypeInfo STestStruct::TypeInfo = ZHMTypeInfo("STestStruct", sizeof(STestStruct), alignof(STestStruct), STestStruct::WriteSimpleJson, STestStruct::FromSimpleJson, STestStruct::Serialize, STestStruct::Equals, STestStruct::Destroy);

void STestStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("stringField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->stringField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->intField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("floatField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->floatField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("enumField") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("STestStruct.ETestEnum", static_cast<int>(s_Object->enumField)));

	p_Stream << "}";
}

void STestStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STestStruct*>(p_Target);

	s_Object->stringField = std::string_view(p_Document["stringField"]);

	s_Object->intField = simdjson::from_json_uint32(p_Document["intField"]);

	s_Object->floatField = simdjson::from_json_float32(p_Document["floatField"]);

	s_Object->enumField = static_cast<STestStruct::ETestEnum>(ZHMEnums::GetEnumValueByName("STestStruct.ETestEnum", std::string_view(p_Document["enumField"])));

}

void STestStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);

	ZString::Serialize(&s_Object->stringField, p_Serializer, p_OwnOffset + offsetof(STestStruct, stringField));
}

bool STestStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStruct::operator==(const STestStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStruct>)
		return false;

	if (stringField != p_Other.stringField) return false;
	if (intField != p_Other.intField) return false;
	if (floatField != p_Other.floatField) return false;
	if (enumField != p_Other.enumField) return false;

	return true;
}

void STestStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);
	s_Object->~STestStruct();
}

ZHMTypeInfo STestStruct2::TypeInfo = ZHMTypeInfo("STestStruct2", sizeof(STestStruct2), alignof(STestStruct2), STestStruct2::WriteSimpleJson, STestStruct2::FromSimpleJson, STestStruct2::Serialize, STestStruct2::Equals, STestStruct2::Destroy);

void STestStruct2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("arrayField") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->arrayField.size(); ++i)
	{
		auto& s_Item0 = s_Object->arrayField[i];
		STestStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->arrayField.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("variantField") << ":";
	ZVariant::WriteSimpleJson(&s_Object->variantField, p_Stream);

	p_Stream << "}";
}

void STestStruct2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STestStruct2*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["arrayField"];
	s_Object->arrayField.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STestStruct::FromSimpleJson(s_Item0, &s_Object->arrayField[s_Index0]);
		++s_Index0;
	}
	}

	ZVariant::FromSimpleJson(p_Document["variantField"], &s_Object->variantField);

}

void STestStruct2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);

	TArray<STestStruct>::Serialize(&s_Object->arrayField, p_Serializer, p_OwnOffset + offsetof(STestStruct2, arrayField));
	ZVariant::Serialize(&s_Object->variantField, p_Serializer, p_OwnOffset + offsetof(STestStruct2, variantField));
}

bool STestStruct2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStruct2*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStruct2*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStruct2::operator==(const STestStruct2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStruct2>)
		return false;

	if (arrayField != p_Other.arrayField) return false;
	if (variantField != p_Other.variantField) return false;

	return true;
}

void STestStruct2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);
	s_Object->~STestStruct2();
}

ZHMTypeInfo STestStructure::TypeInfo = ZHMTypeInfo("STestStructure", sizeof(STestStructure), alignof(STestStructure), STestStructure::WriteSimpleJson, STestStructure::FromSimpleJson, STestStructure::Serialize, STestStructure::Equals, STestStructure::Destroy);

void STestStructure::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWidth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Mini") << ":";
	STestMiniStruct::WriteSimpleJson(&s_Object->m_Mini, p_Stream);

	p_Stream << "}";
}

void STestStructure::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STestStructure*>(p_Target);

	s_Object->m_fWidth = simdjson::from_json_float32(p_Document["m_fWidth"]);

	s_Object->m_fHeight = simdjson::from_json_float32(p_Document["m_fHeight"]);

	s_Object->m_fAngle = simdjson::from_json_float32(p_Document["m_fAngle"]);

	s_Object->m_sDescription = std::string_view(p_Document["m_sDescription"]);

	STestMiniStruct::FromSimpleJson(p_Document["m_Mini"], &s_Object->m_Mini);

}

void STestStructure::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);

	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(STestStructure, m_sDescription));
	STestMiniStruct::Serialize(&s_Object->m_Mini, p_Serializer, p_OwnOffset + offsetof(STestStructure, m_Mini));
}

bool STestStructure::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStructure*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStructure*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStructure::operator==(const STestStructure& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStructure>)
		return false;

	if (m_fWidth != p_Other.m_fWidth) return false;
	if (m_fHeight != p_Other.m_fHeight) return false;
	if (m_fAngle != p_Other.m_fAngle) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_Mini != p_Other.m_Mini) return false;

	return true;
}

void STestStructure::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STestStructure*>(p_Object);
	s_Object->~STestStructure();
}

ZHMTypeInfo STimerEntitySaveData::TypeInfo = ZHMTypeInfo("STimerEntitySaveData", sizeof(STimerEntitySaveData), alignof(STimerEntitySaveData), STimerEntitySaveData::WriteSimpleJson, STimerEntitySaveData::FromSimpleJson, STimerEntitySaveData::Serialize, STimerEntitySaveData::Equals, STimerEntitySaveData::Destroy);

void STimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeToNextEvent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeToNextEvent);

	p_Stream << "}";
}

void STimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Target);

	s_Object->m_nInterval = simdjson::from_json_int32(p_Document["m_nInterval"]);

	s_Object->m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object->m_fTimeToNextEvent = simdjson::from_json_float32(p_Document["m_fTimeToNextEvent"]);

}

void STimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);

}

bool STimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntitySaveData::operator==(const STimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntitySaveData>)
		return false;

	if (m_nInterval != p_Other.m_nInterval) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fTimeToNextEvent != p_Other.m_fTimeToNextEvent) return false;

	return true;
}

void STimerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);
	s_Object->~STimerEntitySaveData();
}

ZHMTypeInfo STimerEntitiesSaveData::TypeInfo = ZHMTypeInfo("STimerEntitiesSaveData", sizeof(STimerEntitiesSaveData), alignof(STimerEntitiesSaveData), STimerEntitiesSaveData::WriteSimpleJson, STimerEntitiesSaveData::FromSimpleJson, STimerEntitiesSaveData::Serialize, STimerEntitiesSaveData::Equals, STimerEntitiesSaveData::Destroy);

void STimerEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		STimerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STimerEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STimerEntitySaveData::FromSimpleJson(s_Item0, &s_Object->m_aData[s_Index0]);
		++s_Index0;
	}
	}

}

void STimerEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(STimerEntitiesSaveData, m_aEntities));
	TArray<STimerEntitySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(STimerEntitiesSaveData, m_aData));
}

bool STimerEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntitiesSaveData::operator==(const STimerEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void STimerEntitiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);
	s_Object->~STimerEntitiesSaveData();
}

ZHMTypeInfo STimerManagerSaveData::TypeInfo = ZHMTypeInfo("STimerManagerSaveData", sizeof(STimerManagerSaveData), alignof(STimerManagerSaveData), STimerManagerSaveData::WriteSimpleJson, STimerManagerSaveData::FromSimpleJson, STimerManagerSaveData::Serialize, STimerManagerSaveData::Equals, STimerManagerSaveData::Destroy);

void STimerManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_TimersData") << ":";
	STimerEntitiesSaveData::WriteSimpleJson(&s_Object->m_TimersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RandomTimersData") << ":";
	SRandomTimerEntitiesSaveData::WriteSimpleJson(&s_Object->m_RandomTimersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GameTimersData") << ":";
	SGameTimersSaveData::WriteSimpleJson(&s_Object->m_GameTimersData, p_Stream);

	p_Stream << "}";
}

void STimerManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Target);

	STimerEntitiesSaveData::FromSimpleJson(p_Document["m_TimersData"], &s_Object->m_TimersData);

	SRandomTimerEntitiesSaveData::FromSimpleJson(p_Document["m_RandomTimersData"], &s_Object->m_RandomTimersData);

	SGameTimersSaveData::FromSimpleJson(p_Document["m_GameTimersData"], &s_Object->m_GameTimersData);

}

void STimerManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);

	STimerEntitiesSaveData::Serialize(&s_Object->m_TimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_TimersData));
	SRandomTimerEntitiesSaveData::Serialize(&s_Object->m_RandomTimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_RandomTimersData));
	SGameTimersSaveData::Serialize(&s_Object->m_GameTimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_GameTimersData));
}

bool STimerManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerManagerSaveData::operator==(const STimerManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerManagerSaveData>)
		return false;

	if (m_TimersData != p_Other.m_TimersData) return false;
	if (m_RandomTimersData != p_Other.m_RandomTimersData) return false;
	if (m_GameTimersData != p_Other.m_GameTimersData) return false;

	return true;
}

void STimerManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);
	s_Object->~STimerManagerSaveData();
}

ZHMTypeInfo STokenID::TypeInfo = ZHMTypeInfo("STokenID", sizeof(STokenID), alignof(STokenID), STokenID::WriteSimpleJson, STokenID::FromSimpleJson, STokenID::Serialize, STokenID::Equals, STokenID::Destroy);

void STokenID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValid);

	p_Stream << "}";
}

void STokenID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STokenID*>(p_Target);

	s_Object->m_iValue = simdjson::from_json_uint32(p_Document["m_iValue"]);

	s_Object->m_bValid = simdjson::from_json_bool(p_Document["m_bValid"]);

}

void STokenID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

}

bool STokenID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STokenID*>(p_Left);
	auto* s_Right = reinterpret_cast<STokenID*>(p_Right);

	return *s_Left == *s_Right;
}

bool STokenID::operator==(const STokenID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STokenID>)
		return false;

	if (m_iValue != p_Other.m_iValue) return false;
	if (m_bValid != p_Other.m_bValid) return false;

	return true;
}

void STokenID::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);
	s_Object->~STokenID();
}

ZHMTypeInfo STrackDollyControllerSaveData::TypeInfo = ZHMTypeInfo("STrackDollyControllerSaveData", sizeof(STrackDollyControllerSaveData), alignof(STrackDollyControllerSaveData), STrackDollyControllerSaveData::WriteSimpleJson, STrackDollyControllerSaveData::FromSimpleJson, STrackDollyControllerSaveData::Serialize, STrackDollyControllerSaveData::Equals, STrackDollyControllerSaveData::Destroy);

void STrackDollyControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTrackEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTrackEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTrackPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTrackPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDollyAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDollyAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDollyPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vDollyPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDollyRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vDollyRotation, p_Stream);

	p_Stream << "}";
}

void STrackDollyControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Target);

	s_Object->m_rTrackEntity = simdjson::from_json_uint32(p_Document["m_rTrackEntity"]);

	s_Object->m_fTrackPosition = simdjson::from_json_float32(p_Document["m_fTrackPosition"]);

	s_Object->m_bIsDollyAttached = simdjson::from_json_bool(p_Document["m_bIsDollyAttached"]);

	SVector3::FromSimpleJson(p_Document["m_vDollyPosition"], &s_Object->m_vDollyPosition);

	SVector4::FromSimpleJson(p_Document["m_vDollyRotation"], &s_Object->m_vDollyRotation);

}

void STrackDollyControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vDollyPosition, p_Serializer, p_OwnOffset + offsetof(STrackDollyControllerSaveData, m_vDollyPosition));
	SVector4::Serialize(&s_Object->m_vDollyRotation, p_Serializer, p_OwnOffset + offsetof(STrackDollyControllerSaveData, m_vDollyRotation));
}

bool STrackDollyControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackDollyControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackDollyControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackDollyControllerSaveData::operator==(const STrackDollyControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackDollyControllerSaveData>)
		return false;

	if (m_rTrackEntity != p_Other.m_rTrackEntity) return false;
	if (m_fTrackPosition != p_Other.m_fTrackPosition) return false;
	if (m_bIsDollyAttached != p_Other.m_bIsDollyAttached) return false;
	if (m_vDollyPosition != p_Other.m_vDollyPosition) return false;
	if (m_vDollyRotation != p_Other.m_vDollyRotation) return false;

	return true;
}

void STrackDollyControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);
	s_Object->~STrackDollyControllerSaveData();
}

ZHMTypeInfo STrackerEntitySaveData::TypeInfo = ZHMTypeInfo("STrackerEntitySaveData", sizeof(STrackerEntitySaveData), alignof(STrackerEntitySaveData), STrackerEntitySaveData::WriteSimpleJson, STrackerEntitySaveData::FromSimpleJson, STrackerEntitySaveData::Serialize, STrackerEntitySaveData::Equals, STrackerEntitySaveData::Destroy);

void STrackerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTracker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTracker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpatialVisibility") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpatialVisibility);

	p_Stream << "}";
}

void STrackerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Target);

	s_Object->m_rTracker = simdjson::from_json_uint32(p_Document["m_rTracker"]);

	s_Object->m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	s_Object->m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object->m_bSpatialVisibility = simdjson::from_json_bool(p_Document["m_bSpatialVisibility"]);

}

void STrackerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);

}

bool STrackerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackerEntitySaveData::operator==(const STrackerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackerEntitySaveData>)
		return false;

	if (m_rTracker != p_Other.m_rTracker) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;
	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_bSpatialVisibility != p_Other.m_bSpatialVisibility) return false;

	return true;
}

void STrackerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);
	s_Object->~STrackerEntitySaveData();
}

ZHMTypeInfo STrackerManagerSaveData::TypeInfo = ZHMTypeInfo("STrackerManagerSaveData", sizeof(STrackerManagerSaveData), alignof(STrackerManagerSaveData), STrackerManagerSaveData::WriteSimpleJson, STrackerManagerSaveData::FromSimpleJson, STrackerManagerSaveData::Serialize, STrackerManagerSaveData::Equals, STrackerManagerSaveData::Destroy);

void STrackerManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTrackerData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackerData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackerData[i];
		STrackerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackerData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrackerManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTrackerData"];
	s_Object->m_aTrackerData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STrackerEntitySaveData::FromSimpleJson(s_Item0, &s_Object->m_aTrackerData[s_Index0]);
		++s_Index0;
	}
	}

}

void STrackerManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);

	TArray<STrackerEntitySaveData>::Serialize(&s_Object->m_aTrackerData, p_Serializer, p_OwnOffset + offsetof(STrackerManagerSaveData, m_aTrackerData));
}

bool STrackerManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackerManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackerManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackerManagerSaveData::operator==(const STrackerManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackerManagerSaveData>)
		return false;

	if (m_aTrackerData != p_Other.m_aTrackerData) return false;

	return true;
}

void STrackerManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);
	s_Object->~STrackerManagerSaveData();
}

ZHMTypeInfo STrajectoryTrackSaveData::TypeInfo = ZHMTypeInfo("STrajectoryTrackSaveData", sizeof(STrajectoryTrackSaveData), alignof(STrajectoryTrackSaveData), STrajectoryTrackSaveData::WriteSimpleJson, STrajectoryTrackSaveData::FromSimpleJson, STrajectoryTrackSaveData::Serialize, STrajectoryTrackSaveData::Equals, STrajectoryTrackSaveData::Destroy);

void STrajectoryTrackSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vOriginalEntityTransform") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_vOriginalEntityTransform, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTargetStartTransform") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_vTargetStartTransform, p_Stream);

	p_Stream << "}";
}

void STrajectoryTrackSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Target);

	SMatrix::FromSimpleJson(p_Document["m_vOriginalEntityTransform"], &s_Object->m_vOriginalEntityTransform);

	SMatrix::FromSimpleJson(p_Document["m_vTargetStartTransform"], &s_Object->m_vTargetStartTransform);

}

void STrajectoryTrackSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);

	SMatrix::Serialize(&s_Object->m_vOriginalEntityTransform, p_Serializer, p_OwnOffset + offsetof(STrajectoryTrackSaveData, m_vOriginalEntityTransform));
	SMatrix::Serialize(&s_Object->m_vTargetStartTransform, p_Serializer, p_OwnOffset + offsetof(STrajectoryTrackSaveData, m_vTargetStartTransform));
}

bool STrajectoryTrackSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrajectoryTrackSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrajectoryTrackSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrajectoryTrackSaveData::operator==(const STrajectoryTrackSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrajectoryTrackSaveData>)
		return false;

	if (m_vOriginalEntityTransform != p_Other.m_vOriginalEntityTransform) return false;
	if (m_vTargetStartTransform != p_Other.m_vTargetStartTransform) return false;

	return true;
}

void STrajectoryTrackSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);
	s_Object->~STrajectoryTrackSaveData();
}

ZHMTypeInfo STrespassingRuleEntitySaveData::TypeInfo = ZHMTypeInfo("STrespassingRuleEntitySaveData", sizeof(STrespassingRuleEntitySaveData), alignof(STrespassingRuleEntitySaveData), STrespassingRuleEntitySaveData::WriteSimpleJson, STrespassingRuleEntitySaveData::FromSimpleJson, STrespassingRuleEntitySaveData::Serialize, STrespassingRuleEntitySaveData::Equals, STrespassingRuleEntitySaveData::Destroy);

void STrespassingRuleEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAllowedProfessionsDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAllowedProfessionsDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAllowedProfessionsDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAllowedProfessionsDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrespassingRuleEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAllowedProfessionsDisabled"];
	s_Object->m_aAllowedProfessionsDisabled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aAllowedProfessionsDisabled[s_Index0] = simdjson::from_json_bool(s_Item0);
		++s_Index0;
	}
	}

}

void STrespassingRuleEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);

	TArray<bool>::Serialize(&s_Object->m_aAllowedProfessionsDisabled, p_Serializer, p_OwnOffset + offsetof(STrespassingRuleEntitySaveData, m_aAllowedProfessionsDisabled));
}

bool STrespassingRuleEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrespassingRuleEntitySaveData::operator==(const STrespassingRuleEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrespassingRuleEntitySaveData>)
		return false;

	if (m_aAllowedProfessionsDisabled != p_Other.m_aAllowedProfessionsDisabled) return false;

	return true;
}

void STrespassingRuleEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);
	s_Object->~STrespassingRuleEntitySaveData();
}

ZHMTypeInfo STriggerAlarmGroupSaveData::TypeInfo = ZHMTypeInfo("STriggerAlarmGroupSaveData", sizeof(STriggerAlarmGroupSaveData), alignof(STriggerAlarmGroupSaveData), STriggerAlarmGroupSaveData::WriteSimpleJson, STriggerAlarmGroupSaveData::FromSimpleJson, STriggerAlarmGroupSaveData::Serialize, STriggerAlarmGroupSaveData::Equals, STriggerAlarmGroupSaveData::Destroy);

void STriggerAlarmGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggeredAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggeredAlarm);

	p_Stream << "}";
}

void STriggerAlarmGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Target);

	s_Object->m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object->m_rAlarm = simdjson::from_json_uint32(p_Document["m_rAlarm"]);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_bTriggeredAlarm = simdjson::from_json_bool(p_Document["m_bTriggeredAlarm"]);

}

void STriggerAlarmGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(STriggerAlarmGroupSaveData, m_fsmState));
}

bool STriggerAlarmGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STriggerAlarmGroupSaveData::operator==(const STriggerAlarmGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STriggerAlarmGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_rAlarm != p_Other.m_rAlarm) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_bTriggeredAlarm != p_Other.m_bTriggeredAlarm) return false;

	return true;
}

void STriggerAlarmGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);
	s_Object->~STriggerAlarmGroupSaveData();
}

ZHMTypeInfo SUIGridCellPosition::TypeInfo = ZHMTypeInfo("SUIGridCellPosition", sizeof(SUIGridCellPosition), alignof(SUIGridCellPosition), SUIGridCellPosition::WriteSimpleJson, SUIGridCellPosition::FromSimpleJson, SUIGridCellPosition::Serialize, SUIGridCellPosition::Equals, SUIGridCellPosition::Destroy);

void SUIGridCellPosition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nColumnIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColumnIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nRowIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nRowIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nColumnSpan") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColumnSpan);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nRowSpan") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nRowSpan);

	p_Stream << "}";
}

void SUIGridCellPosition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Target);

	s_Object->nColumnIndex = simdjson::from_json_int32(p_Document["nColumnIndex"]);

	s_Object->nRowIndex = simdjson::from_json_int32(p_Document["nRowIndex"]);

	s_Object->nColumnSpan = simdjson::from_json_int32(p_Document["nColumnSpan"]);

	s_Object->nRowSpan = simdjson::from_json_int32(p_Document["nRowSpan"]);

}

void SUIGridCellPosition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);

}

bool SUIGridCellPosition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIGridCellPosition*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIGridCellPosition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIGridCellPosition::operator==(const SUIGridCellPosition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIGridCellPosition>)
		return false;

	if (nColumnIndex != p_Other.nColumnIndex) return false;
	if (nRowIndex != p_Other.nRowIndex) return false;
	if (nColumnSpan != p_Other.nColumnSpan) return false;
	if (nRowSpan != p_Other.nRowSpan) return false;

	return true;
}

void SUIGridCellPosition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);
	s_Object->~SUIGridCellPosition();
}

ZHMTypeInfo SUIOptionsSaveData::TypeInfo = ZHMTypeInfo("SUIOptionsSaveData", sizeof(SUIOptionsSaveData), alignof(SUIOptionsSaveData), SUIOptionsSaveData::WriteSimpleJson, SUIOptionsSaveData::FromSimpleJson, SUIOptionsSaveData::Serialize, SUIOptionsSaveData::Equals, SUIOptionsSaveData::Destroy);

void SUIOptionsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKeys") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeys[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("_EUIOptionKey", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aKeys.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		SOptionValueSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUIOptionsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKeys"];
	s_Object->m_aKeys.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aKeys[s_Index0] = static_cast<_EUIOptionKey>(ZHMEnums::GetEnumValueByName("_EUIOptionKey", std::string_view(s_Item0)));
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aValues"];
	s_Object->m_aValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SOptionValueSaveData::FromSimpleJson(s_Item0, &s_Object->m_aValues[s_Index0]);
		++s_Index0;
	}
	}

}

void SUIOptionsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);

	TArray<_EUIOptionKey>::Serialize(&s_Object->m_aKeys, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, m_aKeys));
	TArray<SOptionValueSaveData>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, m_aValues));
}

bool SUIOptionsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIOptionsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIOptionsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIOptionsSaveData::operator==(const SUIOptionsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIOptionsSaveData>)
		return false;

	if (m_aKeys != p_Other.m_aKeys) return false;
	if (m_aValues != p_Other.m_aValues) return false;

	return true;
}

void SUIOptionsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);
	s_Object->~SUIOptionsSaveData();
}

ZHMTypeInfo SUITestData::TypeInfo = ZHMTypeInfo("SUITestData", sizeof(SUITestData), alignof(SUITestData), SUITestData::WriteSimpleJson, SUITestData::FromSimpleJson, SUITestData::Serialize, SUITestData::Equals, SUITestData::Destroy);

void SUITestData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nIntProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nIntProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fInt16Prop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fInt16Prop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fUInt32Prop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fUInt32Prop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFloatProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFloatProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sStringProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sStringProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eEnumProp") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SUITestData.ETestEnum", static_cast<int>(s_Object->eEnumProp)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ridProp") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->ridProp, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aStringArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aStringArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aStringArray[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aStringArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aSubStructArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSubStructArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSubStructArray[i];
		SUITestData::SSubStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aSubStructArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aFixedArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aFixedArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aFixedArray[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aFixedArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUITestData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SUITestData*>(p_Target);

	s_Object->nIntProp = simdjson::from_json_int32(p_Document["nIntProp"]);

	s_Object->fInt16Prop = simdjson::from_json_int16(p_Document["fInt16Prop"]);

	s_Object->fUInt32Prop = simdjson::from_json_uint32(p_Document["fUInt32Prop"]);

	s_Object->fFloatProp = simdjson::from_json_float32(p_Document["fFloatProp"]);

	s_Object->sStringProp = std::string_view(p_Document["sStringProp"]);

	s_Object->eEnumProp = static_cast<SUITestData::ETestEnum>(ZHMEnums::GetEnumValueByName("SUITestData.ETestEnum", std::string_view(p_Document["eEnumProp"])));

	ZRuntimeResourceID::FromSimpleJson(p_Document["ridProp"], &s_Object->ridProp);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aStringArray"];
	s_Object->aStringArray.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->aStringArray[s_Index0] = std::string_view(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aSubStructArray"];
	s_Object->aSubStructArray.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SUITestData::SSubStruct::FromSimpleJson(s_Item0, &s_Object->aSubStructArray[s_Index0]);
		++s_Index0;
	}
	}

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["aFixedArray"])
	{
		s_Object->aFixedArray[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

}

void SUITestData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);

	ZString::Serialize(&s_Object->sStringProp, p_Serializer, p_OwnOffset + offsetof(SUITestData, sStringProp));
	ZRuntimeResourceID::Serialize(&s_Object->ridProp, p_Serializer, p_OwnOffset + offsetof(SUITestData, ridProp));
	TArray<ZString>::Serialize(&s_Object->aStringArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aStringArray));
	TArray<SUITestData::SSubStruct>::Serialize(&s_Object->aSubStructArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aSubStructArray));
	TFixedArray<int32, 3>::Serialize(&s_Object->aFixedArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aFixedArray));
}

bool SUITestData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData::operator==(const SUITestData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData>)
		return false;

	if (nIntProp != p_Other.nIntProp) return false;
	if (fInt16Prop != p_Other.fInt16Prop) return false;
	if (fUInt32Prop != p_Other.fUInt32Prop) return false;
	if (fFloatProp != p_Other.fFloatProp) return false;
	if (sStringProp != p_Other.sStringProp) return false;
	if (eEnumProp != p_Other.eEnumProp) return false;
	if (ridProp != p_Other.ridProp) return false;
	if (aStringArray != p_Other.aStringArray) return false;
	if (aSubStructArray != p_Other.aSubStructArray) return false;
	if (aFixedArray != p_Other.aFixedArray) return false;

	return true;
}

void SUITestData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);
	s_Object->~SUITestData();
}

ZHMTypeInfo SUITestData::SSubSubStruct::TypeInfo = ZHMTypeInfo("SUITestData.SSubSubStruct", sizeof(SUITestData::SSubSubStruct), alignof(SUITestData::SSubSubStruct), SUITestData::SSubSubStruct::WriteSimpleJson, SUITestData::SSubSubStruct::FromSimpleJson, SUITestData::SSubSubStruct::Serialize, SUITestData::SSubSubStruct::Equals, SUITestData::SSubSubStruct::Destroy);

void SUITestData::SSubSubStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData::SSubSubStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sDeepString") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDeepString);

	p_Stream << "}";
}

void SUITestData::SSubSubStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SUITestData::SSubSubStruct*>(p_Target);

	s_Object->sDeepString = std::string_view(p_Document["sDeepString"]);

}

void SUITestData::SSubSubStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData::SSubSubStruct*>(p_Object);

	ZString::Serialize(&s_Object->sDeepString, p_Serializer, p_OwnOffset + offsetof(SUITestData::SSubSubStruct, sDeepString));
}

bool SUITestData::SSubSubStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData::SSubSubStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData::SSubSubStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData::SSubSubStruct::operator==(const SUITestData::SSubSubStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData::SSubSubStruct>)
		return false;

	if (sDeepString != p_Other.sDeepString) return false;

	return true;
}

void SUITestData::SSubSubStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUITestData::SSubSubStruct*>(p_Object);
	s_Object->~SSubSubStruct();
}

ZHMTypeInfo SUITestData::SSubStruct::TypeInfo = ZHMTypeInfo("SUITestData.SSubStruct", sizeof(SUITestData::SSubStruct), alignof(SUITestData::SSubStruct), SUITestData::SSubStruct::WriteSimpleJson, SUITestData::SSubStruct::FromSimpleJson, SUITestData::SSubStruct::Serialize, SUITestData::SSubStruct::Equals, SUITestData::SSubStruct::Destroy);

void SUITestData::SSubStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData::SSubStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("aSubSubStructs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSubSubStructs.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSubSubStructs[i];
		SUITestData::SSubSubStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aSubSubStructs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUITestData::SSubStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SUITestData::SSubStruct*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aSubSubStructs"];
	s_Object->aSubSubStructs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SUITestData::SSubSubStruct::FromSimpleJson(s_Item0, &s_Object->aSubSubStructs[s_Index0]);
		++s_Index0;
	}
	}

}

void SUITestData::SSubStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData::SSubStruct*>(p_Object);

	TArray<SUITestData::SSubSubStruct>::Serialize(&s_Object->aSubSubStructs, p_Serializer, p_OwnOffset + offsetof(SUITestData::SSubStruct, aSubSubStructs));
}

bool SUITestData::SSubStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData::SSubStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData::SSubStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData::SSubStruct::operator==(const SUITestData::SSubStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData::SSubStruct>)
		return false;

	if (aSubSubStructs != p_Other.aSubSubStructs) return false;

	return true;
}

void SUITestData::SSubStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUITestData::SSubStruct*>(p_Object);
	s_Object->~SSubStruct();
}

ZHMTypeInfo SVIPInvestigateGroupSaveData::TypeInfo = ZHMTypeInfo("SVIPInvestigateGroupSaveData", sizeof(SVIPInvestigateGroupSaveData), alignof(SVIPInvestigateGroupSaveData), SVIPInvestigateGroupSaveData::WriteSimpleJson, SVIPInvestigateGroupSaveData::FromSimpleJson, SVIPInvestigateGroupSaveData::Serialize, SVIPInvestigateGroupSaveData::Equals, SVIPInvestigateGroupSaveData::Destroy);

void SVIPInvestigateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIP") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIP);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSelectedBodyguard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSelectedBodyguard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInvestigator") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInvestigator);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSelectedBodyguardActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSelectedBodyguardActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EVIPInvestigateReason", static_cast<int>(s_Object->m_eReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBodyguardNotFound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBodyguardNotFound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOrderDialogStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOrderDialogStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReporting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReporting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWait") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWait);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginalVIPPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vOriginalVIPPosition, p_Stream);

	p_Stream << "}";
}

void SVIPInvestigateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Target);

	SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Object->m_fsmState);

	s_Object->m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	s_Object->m_rVIP = simdjson::from_json_uint32(p_Document["m_rVIP"]);

	s_Object->m_rSelectedBodyguard = simdjson::from_json_uint32(p_Document["m_rSelectedBodyguard"]);

	s_Object->m_rInvestigator = simdjson::from_json_uint32(p_Document["m_rInvestigator"]);

	s_Object->m_rSelectedBodyguardActor = simdjson::from_json_uint32(p_Document["m_rSelectedBodyguardActor"]);

	s_Object->m_eReason = static_cast<EVIPInvestigateReason>(ZHMEnums::GetEnumValueByName("EVIPInvestigateReason", std::string_view(p_Document["m_eReason"])));

	s_Object->m_bBodyguardNotFound = simdjson::from_json_bool(p_Document["m_bBodyguardNotFound"]);

	s_Object->m_bOrderDialogStarted = simdjson::from_json_bool(p_Document["m_bOrderDialogStarted"]);

	s_Object->m_bReporting = simdjson::from_json_bool(p_Document["m_bReporting"]);

	s_Object->m_bWait = simdjson::from_json_bool(p_Document["m_bWait"]);

	float4::FromSimpleJson(p_Document["m_vOriginalVIPPosition"], &s_Object->m_vOriginalVIPPosition);

}

void SVIPInvestigateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SVIPInvestigateGroupSaveData, m_fsmState));
	float4::Serialize(&s_Object->m_vOriginalVIPPosition, p_Serializer, p_OwnOffset + offsetof(SVIPInvestigateGroupSaveData, m_vOriginalVIPPosition));
}

bool SVIPInvestigateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVIPInvestigateGroupSaveData::operator==(const SVIPInvestigateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVIPInvestigateGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_rVIP != p_Other.m_rVIP) return false;
	if (m_rSelectedBodyguard != p_Other.m_rSelectedBodyguard) return false;
	if (m_rInvestigator != p_Other.m_rInvestigator) return false;
	if (m_rSelectedBodyguardActor != p_Other.m_rSelectedBodyguardActor) return false;
	if (m_eReason != p_Other.m_eReason) return false;
	if (m_bBodyguardNotFound != p_Other.m_bBodyguardNotFound) return false;
	if (m_bOrderDialogStarted != p_Other.m_bOrderDialogStarted) return false;
	if (m_bReporting != p_Other.m_bReporting) return false;
	if (m_bWait != p_Other.m_bWait) return false;
	if (m_vOriginalVIPPosition != p_Other.m_vOriginalVIPPosition) return false;

	return true;
}

void SVIPInvestigateGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVIPInvestigateGroupSaveData*>(p_Object);
	s_Object->~SVIPInvestigateGroupSaveData();
}

ZHMTypeInfo SValueBoolsSaveData::TypeInfo = ZHMTypeInfo("SValueBoolsSaveData", sizeof(SValueBoolsSaveData), alignof(SValueBoolsSaveData), SValueBoolsSaveData::WriteSimpleJson, SValueBoolsSaveData::FromSimpleJson, SValueBoolsSaveData::Serialize, SValueBoolsSaveData::Equals, SValueBoolsSaveData::Destroy);

void SValueBoolsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueBoolsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aData[s_Index0] = simdjson::from_json_bool(s_Item0);
		++s_Index0;
	}
	}

}

void SValueBoolsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueBoolsSaveData, m_aEntities));
	TArray<bool>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueBoolsSaveData, m_aData));
}

bool SValueBoolsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueBoolsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueBoolsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueBoolsSaveData::operator==(const SValueBoolsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueBoolsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SValueBoolsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);
	s_Object->~SValueBoolsSaveData();
}

ZHMTypeInfo SValueFloatSaveData::TypeInfo = ZHMTypeInfo("SValueFloatSaveData", sizeof(SValueFloatSaveData), alignof(SValueFloatSaveData), SValueFloatSaveData::WriteSimpleJson, SValueFloatSaveData::FromSimpleJson, SValueFloatSaveData::Serialize, SValueFloatSaveData::Equals, SValueFloatSaveData::Destroy);

void SValueFloatSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueFloatSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aData[s_Index0] = simdjson::from_json_float32(s_Item0);
		++s_Index0;
	}
	}

}

void SValueFloatSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueFloatSaveData, m_aEntities));
	TArray<float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueFloatSaveData, m_aData));
}

bool SValueFloatSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueFloatSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueFloatSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueFloatSaveData::operator==(const SValueFloatSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueFloatSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SValueFloatSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);
	s_Object->~SValueFloatSaveData();
}

ZHMTypeInfo SValueIntSaveData::TypeInfo = ZHMTypeInfo("SValueIntSaveData", sizeof(SValueIntSaveData), alignof(SValueIntSaveData), SValueIntSaveData::WriteSimpleJson, SValueIntSaveData::FromSimpleJson, SValueIntSaveData::Serialize, SValueIntSaveData::Equals, SValueIntSaveData::Destroy);

void SValueIntSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueIntSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SValueIntSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object->m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aEntities[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object->m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aData[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

}

void SValueIntSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueIntSaveData, m_aEntities));
	TArray<int32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueIntSaveData, m_aData));
}

bool SValueIntSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueIntSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueIntSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueIntSaveData::operator==(const SValueIntSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueIntSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SValueIntSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);
	s_Object->~SValueIntSaveData();
}

ZHMTypeInfo SValueSaveData::TypeInfo = ZHMTypeInfo("SValueSaveData", sizeof(SValueSaveData), alignof(SValueSaveData), SValueSaveData::WriteSimpleJson, SValueSaveData::FromSimpleJson, SValueSaveData::Serialize, SValueSaveData::Equals, SValueSaveData::Destroy);

void SValueSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ValueBool") << ":";
	SValueBoolsSaveData::WriteSimpleJson(&s_Object->m_ValueBool, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueFloat") << ":";
	SValueFloatSaveData::WriteSimpleJson(&s_Object->m_ValueFloat, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueInt") << ":";
	SValueIntSaveData::WriteSimpleJson(&s_Object->m_ValueInt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StateController") << ":";
	SStateControllerSaveData::WriteSimpleJson(&s_Object->m_StateController, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueColorRGB") << ":";
	SColorRGBSaveData::WriteSimpleJson(&s_Object->m_ValueColorRGB, p_Stream);

	p_Stream << "}";
}

void SValueSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SValueSaveData*>(p_Target);

	SValueBoolsSaveData::FromSimpleJson(p_Document["m_ValueBool"], &s_Object->m_ValueBool);

	SValueFloatSaveData::FromSimpleJson(p_Document["m_ValueFloat"], &s_Object->m_ValueFloat);

	SValueIntSaveData::FromSimpleJson(p_Document["m_ValueInt"], &s_Object->m_ValueInt);

	SStateControllerSaveData::FromSimpleJson(p_Document["m_StateController"], &s_Object->m_StateController);

	SColorRGBSaveData::FromSimpleJson(p_Document["m_ValueColorRGB"], &s_Object->m_ValueColorRGB);

}

void SValueSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);

	SValueBoolsSaveData::Serialize(&s_Object->m_ValueBool, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueBool));
	SValueFloatSaveData::Serialize(&s_Object->m_ValueFloat, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueFloat));
	SValueIntSaveData::Serialize(&s_Object->m_ValueInt, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueInt));
	SStateControllerSaveData::Serialize(&s_Object->m_StateController, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_StateController));
	SColorRGBSaveData::Serialize(&s_Object->m_ValueColorRGB, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueColorRGB));
}

bool SValueSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueSaveData::operator==(const SValueSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueSaveData>)
		return false;

	if (m_ValueBool != p_Other.m_ValueBool) return false;
	if (m_ValueFloat != p_Other.m_ValueFloat) return false;
	if (m_ValueInt != p_Other.m_ValueInt) return false;
	if (m_StateController != p_Other.m_StateController) return false;
	if (m_ValueColorRGB != p_Other.m_ValueColorRGB) return false;

	return true;
}

void SValueSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);
	s_Object->~SValueSaveData();
}

ZHMTypeInfo SVideoDatabaseEntry::TypeInfo = ZHMTypeInfo("SVideoDatabaseEntry", sizeof(SVideoDatabaseEntry), alignof(SVideoDatabaseEntry), SVideoDatabaseEntry::WriteSimpleJson, SVideoDatabaseEntry::FromSimpleJson, SVideoDatabaseEntry::Serialize, SVideoDatabaseEntry::Equals, SVideoDatabaseEntry::Destroy);

void SVideoDatabaseEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("VideoId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->VideoId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("RuntimeLocalizedVideoRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->RuntimeLocalizedVideoRid, p_Stream);

	p_Stream << "}";
}

void SVideoDatabaseEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Target);

	s_Object->VideoId = std::string_view(p_Document["VideoId"]);

	ZRuntimeResourceID::FromSimpleJson(p_Document["RuntimeLocalizedVideoRid"], &s_Object->RuntimeLocalizedVideoRid);

}

void SVideoDatabaseEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);

	ZString::Serialize(&s_Object->VideoId, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseEntry, VideoId));
	ZRuntimeResourceID::Serialize(&s_Object->RuntimeLocalizedVideoRid, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseEntry, RuntimeLocalizedVideoRid));
}

bool SVideoDatabaseEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVideoDatabaseEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SVideoDatabaseEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVideoDatabaseEntry::operator==(const SVideoDatabaseEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVideoDatabaseEntry>)
		return false;

	if (VideoId != p_Other.VideoId) return false;
	if (RuntimeLocalizedVideoRid != p_Other.RuntimeLocalizedVideoRid) return false;

	return true;
}

void SVideoDatabaseEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);
	s_Object->~SVideoDatabaseEntry();
}

ZHMTypeInfo SVideoDatabaseData::TypeInfo = ZHMTypeInfo("SVideoDatabaseData", sizeof(SVideoDatabaseData), alignof(SVideoDatabaseData), SVideoDatabaseData::WriteSimpleJson, SVideoDatabaseData::FromSimpleJson, SVideoDatabaseData::Serialize, SVideoDatabaseData::Equals, SVideoDatabaseData::Destroy);

void SVideoDatabaseData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Videos") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Videos.size(); ++i)
	{
		auto& s_Item0 = s_Object->Videos[i];
		SVideoDatabaseEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->Videos.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVideoDatabaseData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["Videos"];
	s_Object->Videos.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVideoDatabaseEntry::FromSimpleJson(s_Item0, &s_Object->Videos[s_Index0]);
		++s_Index0;
	}
	}

}

void SVideoDatabaseData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);

	TArray<SVideoDatabaseEntry>::Serialize(&s_Object->Videos, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseData, Videos));
}

bool SVideoDatabaseData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVideoDatabaseData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVideoDatabaseData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVideoDatabaseData::operator==(const SVideoDatabaseData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVideoDatabaseData>)
		return false;

	if (Videos != p_Other.Videos) return false;

	return true;
}

void SVideoDatabaseData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);
	s_Object->~SVideoDatabaseData();
}

ZHMTypeInfo SVisibilitySaveData::TypeInfo = ZHMTypeInfo("SVisibilitySaveData", sizeof(SVisibilitySaveData), alignof(SVisibilitySaveData), SVisibilitySaveData::WriteSimpleJson, SVisibilitySaveData::FromSimpleJson, SVisibilitySaveData::Serialize, SVisibilitySaveData::Equals, SVisibilitySaveData::Destroy);

void SVisibilitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);

	p_Stream << "}";
}

void SVisibilitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Target);

	s_Object->m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

}

void SVisibilitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);

}

bool SVisibilitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVisibilitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVisibilitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVisibilitySaveData::operator==(const SVisibilitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVisibilitySaveData>)
		return false;

	if (m_bIsVisible != p_Other.m_bIsVisible) return false;

	return true;
}

void SVisibilitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);
	s_Object->~SVisibilitySaveData();
}

ZHMTypeInfo SVoidSignalEntitySaveData::TypeInfo = ZHMTypeInfo("SVoidSignalEntitySaveData", sizeof(SVoidSignalEntitySaveData), alignof(SVoidSignalEntitySaveData), SVoidSignalEntitySaveData::WriteSimpleJson, SVoidSignalEntitySaveData::FromSimpleJson, SVoidSignalEntitySaveData::Serialize, SVoidSignalEntitySaveData::Equals, SVoidSignalEntitySaveData::Destroy);

void SVoidSignalEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSignaling") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSignaling);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFiredAtTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFiredAtTime);

	p_Stream << "}";
}

void SVoidSignalEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Target);

	s_Object->m_bSignaling = simdjson::from_json_bool(p_Document["m_bSignaling"]);

	s_Object->m_fFiredAtTime = simdjson::from_json_float32(p_Document["m_fFiredAtTime"]);

}

void SVoidSignalEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);

}

bool SVoidSignalEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVoidSignalEntitySaveData::operator==(const SVoidSignalEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVoidSignalEntitySaveData>)
		return false;

	if (m_bSignaling != p_Other.m_bSignaling) return false;
	if (m_fFiredAtTime != p_Other.m_fFiredAtTime) return false;

	return true;
}

void SVoidSignalEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);
	s_Object->~SVoidSignalEntitySaveData();
}

ZHMTypeInfo SWaveformGeneratorSaveData::TypeInfo = ZHMTypeInfo("SWaveformGeneratorSaveData", sizeof(SWaveformGeneratorSaveData), alignof(SWaveformGeneratorSaveData), SWaveformGeneratorSaveData::WriteSimpleJson, SWaveformGeneratorSaveData::FromSimpleJson, SWaveformGeneratorSaveData::Serialize, SWaveformGeneratorSaveData::Equals, SWaveformGeneratorSaveData::Destroy);

void SWaveformGeneratorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFrequency") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFrequency);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStartTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStartTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCount);

	p_Stream << "}";
}

void SWaveformGeneratorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Target);

	s_Object->m_fTime = simdjson::from_json_float32(p_Document["m_fTime"]);

	s_Object->m_fFrequency = simdjson::from_json_float32(p_Document["m_fFrequency"]);

	s_Object->m_fOffset = simdjson::from_json_float32(p_Document["m_fOffset"]);

	s_Object->m_fScale = simdjson::from_json_float32(p_Document["m_fScale"]);

	s_Object->m_fStartTime = simdjson::from_json_float32(p_Document["m_fStartTime"]);

	s_Object->m_nCount = simdjson::from_json_uint32(p_Document["m_nCount"]);

}

void SWaveformGeneratorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);

}

bool SWaveformGeneratorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWaveformGeneratorSaveData::operator==(const SWaveformGeneratorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWaveformGeneratorSaveData>)
		return false;

	if (m_fTime != p_Other.m_fTime) return false;
	if (m_fFrequency != p_Other.m_fFrequency) return false;
	if (m_fOffset != p_Other.m_fOffset) return false;
	if (m_fScale != p_Other.m_fScale) return false;
	if (m_fStartTime != p_Other.m_fStartTime) return false;
	if (m_nCount != p_Other.m_nCount) return false;

	return true;
}

void SWaveformGeneratorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);
	s_Object->~SWaveformGeneratorSaveData();
}

ZHMTypeInfo SWaveformGeneratorManagerSaveData::TypeInfo = ZHMTypeInfo("SWaveformGeneratorManagerSaveData", sizeof(SWaveformGeneratorManagerSaveData), alignof(SWaveformGeneratorManagerSaveData), SWaveformGeneratorManagerSaveData::WriteSimpleJson, SWaveformGeneratorManagerSaveData::FromSimpleJson, SWaveformGeneratorManagerSaveData::Serialize, SWaveformGeneratorManagerSaveData::Equals, SWaveformGeneratorManagerSaveData::Destroy);

void SWaveformGeneratorManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aGenerators") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGenerators.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGenerators[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aGenerators.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGeneratorData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGeneratorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGeneratorData[i];
		SWaveformGeneratorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGeneratorData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SWaveformGeneratorManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGenerators"];
	s_Object->m_aGenerators.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aGenerators[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGeneratorData"];
	s_Object->m_aGeneratorData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SWaveformGeneratorSaveData::FromSimpleJson(s_Item0, &s_Object->m_aGeneratorData[s_Index0]);
		++s_Index0;
	}
	}

}

void SWaveformGeneratorManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aGenerators, p_Serializer, p_OwnOffset + offsetof(SWaveformGeneratorManagerSaveData, m_aGenerators));
	TArray<SWaveformGeneratorSaveData>::Serialize(&s_Object->m_aGeneratorData, p_Serializer, p_OwnOffset + offsetof(SWaveformGeneratorManagerSaveData, m_aGeneratorData));
}

bool SWaveformGeneratorManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWaveformGeneratorManagerSaveData::operator==(const SWaveformGeneratorManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWaveformGeneratorManagerSaveData>)
		return false;

	if (m_aGenerators != p_Other.m_aGenerators) return false;
	if (m_aGeneratorData != p_Other.m_aGeneratorData) return false;

	return true;
}

void SWaveformGeneratorManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);
	s_Object->~SWaveformGeneratorManagerSaveData();
}

ZHMTypeInfo SWeaponSoundDefs::TypeInfo = ZHMTypeInfo("SWeaponSoundDefs", sizeof(SWeaponSoundDefs), alignof(SWeaponSoundDefs), SWeaponSoundDefs::WriteSimpleJson, SWeaponSoundDefs::FromSimpleJson, SWeaponSoundDefs::Serialize, SWeaponSoundDefs::Equals, SWeaponSoundDefs::Destroy);

void SWeaponSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SWeaponSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Target);

}

void SWeaponSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);

}

bool SWeaponSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWeaponSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SWeaponSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWeaponSoundDefs::operator==(const SWeaponSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWeaponSoundDefs>)
		return false;


	return true;
}

void SWeaponSoundDefs::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWeaponSoundDefs*>(p_Object);
	s_Object->~SWeaponSoundDefs();
}

ZHMTypeInfo ZAMDEvent::TypeInfo = ZHMTypeInfo("ZAMDEvent", sizeof(ZAMDEvent), alignof(ZAMDEvent), ZAMDEvent::WriteSimpleJson, ZAMDEvent::FromSimpleJson, ZAMDEvent::Serialize, ZAMDEvent::Equals, ZAMDEvent::Destroy);

void ZAMDEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStartFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStartFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_customData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_customData, p_Stream);

	p_Stream << "}";
}

void ZAMDEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZAMDEvent*>(p_Target);

	s_Object->m_nEventID = simdjson::from_json_uint32(p_Document["m_nEventID"]);

	s_Object->m_fStartFraction = simdjson::from_json_float32(p_Document["m_fStartFraction"]);

	s_Object->m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	ZVariant::FromSimpleJson(p_Document["m_customData"], &s_Object->m_customData);

}

void ZAMDEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);

	ZVariant::Serialize(&s_Object->m_customData, p_Serializer, p_OwnOffset + offsetof(ZAMDEvent, m_customData));
}

bool ZAMDEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDEvent::operator==(const ZAMDEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDEvent>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;
	if (m_fStartFraction != p_Other.m_fStartFraction) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_customData != p_Other.m_customData) return false;

	return true;
}

void ZAMDEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);
	s_Object->~ZAMDEvent();
}

ZHMTypeInfo ZAMDEventTrack::TypeInfo = ZHMTypeInfo("ZAMDEventTrack", sizeof(ZAMDEventTrack), alignof(ZAMDEventTrack), ZAMDEventTrack::WriteSimpleJson, ZAMDEventTrack::FromSimpleJson, ZAMDEventTrack::Serialize, ZAMDEventTrack::Equals, ZAMDEventTrack::Destroy);

void ZAMDEventTrack::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_events") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_events.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_events[i];
		ZAMDEvent::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_events.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZAMDEventTrack::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Target);

	s_Object->m_sName = std::string_view(p_Document["m_sName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_events"];
	s_Object->m_events.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZAMDEvent::FromSimpleJson(s_Item0, &s_Object->m_events[s_Index0]);
		++s_Index0;
	}
	}

}

void ZAMDEventTrack::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(ZAMDEventTrack, m_sName));
	TArray<ZAMDEvent>::Serialize(&s_Object->m_events, p_Serializer, p_OwnOffset + offsetof(ZAMDEventTrack, m_events));
}

bool ZAMDEventTrack::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDEventTrack*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDEventTrack*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDEventTrack::operator==(const ZAMDEventTrack& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDEventTrack>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_events != p_Other.m_events) return false;

	return true;
}

void ZAMDEventTrack::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);
	s_Object->~ZAMDEventTrack();
}

ZHMTypeInfo ZAMDTake::TypeInfo = ZHMTypeInfo("ZAMDTake", sizeof(ZAMDTake), alignof(ZAMDTake), ZAMDTake::WriteSimpleJson, ZAMDTake::FromSimpleJson, ZAMDTake::Serialize, ZAMDTake::Equals, ZAMDTake::Destroy);

void ZAMDTake::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eventTracks") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_eventTracks.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_eventTracks[i];
		ZAMDEventTrack::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_eventTracks.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_customData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_customData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSyncTrackIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSyncTrackIndex);

	p_Stream << "}";
}

void ZAMDTake::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZAMDTake*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_eventTracks"];
	s_Object->m_eventTracks.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZAMDEventTrack::FromSimpleJson(s_Item0, &s_Object->m_eventTracks[s_Index0]);
		++s_Index0;
	}
	}

	ZVariant::FromSimpleJson(p_Document["m_customData"], &s_Object->m_customData);

	s_Object->m_nSyncTrackIndex = simdjson::from_json_int32(p_Document["m_nSyncTrackIndex"]);

}

void ZAMDTake::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);

	TArray<ZAMDEventTrack>::Serialize(&s_Object->m_eventTracks, p_Serializer, p_OwnOffset + offsetof(ZAMDTake, m_eventTracks));
	ZVariant::Serialize(&s_Object->m_customData, p_Serializer, p_OwnOffset + offsetof(ZAMDTake, m_customData));
}

bool ZAMDTake::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDTake*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDTake*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDTake::operator==(const ZAMDTake& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDTake>)
		return false;

	if (m_eventTracks != p_Other.m_eventTracks) return false;
	if (m_customData != p_Other.m_customData) return false;
	if (m_nSyncTrackIndex != p_Other.m_nSyncTrackIndex) return false;

	return true;
}

void ZAMDTake::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);
	s_Object->~ZAMDTake();
}

ZHMTypeInfo ZAT2Controller::SEventPreviewInfo::TypeInfo = ZHMTypeInfo("ZAT2Controller.SEventPreviewInfo", sizeof(ZAT2Controller::SEventPreviewInfo), alignof(ZAT2Controller::SEventPreviewInfo), ZAT2Controller::SEventPreviewInfo::WriteSimpleJson, ZAT2Controller::SEventPreviewInfo::FromSimpleJson, ZAT2Controller::SEventPreviewInfo::Serialize, ZAT2Controller::SEventPreviewInfo::Equals, ZAT2Controller::SEventPreviewInfo::Destroy);

void ZAT2Controller::SEventPreviewInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller::SEventPreviewInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sConsumerID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sConsumerID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExtraDataTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExtraDataTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_extraDataProperties") << ":";
	TMap<ZString,ZVariant>::WriteSimpleJson(&s_Object->m_extraDataProperties, p_Stream);

	p_Stream << "}";
}

void ZAT2Controller::SEventPreviewInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZAT2Controller::SEventPreviewInfo*>(p_Target);

	s_Object->m_nEventID = simdjson::from_json_int32(p_Document["m_nEventID"]);

	s_Object->m_sConsumerID = std::string_view(p_Document["m_sConsumerID"]);

	s_Object->m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object->m_sExtraDataTypeName = std::string_view(p_Document["m_sExtraDataTypeName"]);

	TMap<ZString,ZVariant>::FromSimpleJson(p_Document["m_extraDataProperties"], &s_Object->m_extraDataProperties);

}

void ZAT2Controller::SEventPreviewInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller::SEventPreviewInfo*>(p_Object);

	ZString::Serialize(&s_Object->m_sConsumerID, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller::SEventPreviewInfo, m_sConsumerID));
	ZString::Serialize(&s_Object->m_sExtraDataTypeName, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller::SEventPreviewInfo, m_sExtraDataTypeName));
	TMap<ZString,ZVariant>::Serialize(&s_Object->m_extraDataProperties, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller::SEventPreviewInfo, m_extraDataProperties));
}

bool ZAT2Controller::SEventPreviewInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAT2Controller::SEventPreviewInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAT2Controller::SEventPreviewInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAT2Controller::SEventPreviewInfo::operator==(const ZAT2Controller::SEventPreviewInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAT2Controller::SEventPreviewInfo>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;
	if (m_sConsumerID != p_Other.m_sConsumerID) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_sExtraDataTypeName != p_Other.m_sExtraDataTypeName) return false;
	if (m_extraDataProperties != p_Other.m_extraDataProperties) return false;

	return true;
}

void ZAT2Controller::SEventPreviewInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller::SEventPreviewInfo*>(p_Object);
	s_Object->~SEventPreviewInfo();
}

ZHMTypeInfo ZAT2Controller::SGeneratedFootstepEvent::TypeInfo = ZHMTypeInfo("ZAT2Controller.SGeneratedFootstepEvent", sizeof(ZAT2Controller::SGeneratedFootstepEvent), alignof(ZAT2Controller::SGeneratedFootstepEvent), ZAT2Controller::SGeneratedFootstepEvent::WriteSimpleJson, ZAT2Controller::SGeneratedFootstepEvent::FromSimpleJson, ZAT2Controller::SGeneratedFootstepEvent::Serialize, ZAT2Controller::SGeneratedFootstepEvent::Equals, ZAT2Controller::SGeneratedFootstepEvent::Destroy);

void ZAT2Controller::SGeneratedFootstepEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller::SGeneratedFootstepEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFoot") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZAT2Controller.EFoot", static_cast<int>(s_Object->m_eFoot)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFrame") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFrame);

	p_Stream << "}";
}

void ZAT2Controller::SGeneratedFootstepEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZAT2Controller::SGeneratedFootstepEvent*>(p_Target);

	s_Object->m_eFoot = static_cast<ZAT2Controller::EFoot>(ZHMEnums::GetEnumValueByName("ZAT2Controller.EFoot", std::string_view(p_Document["m_eFoot"])));

	s_Object->m_fFrame = simdjson::from_json_float32(p_Document["m_fFrame"]);

}

void ZAT2Controller::SGeneratedFootstepEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller::SGeneratedFootstepEvent*>(p_Object);

}

bool ZAT2Controller::SGeneratedFootstepEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAT2Controller::SGeneratedFootstepEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAT2Controller::SGeneratedFootstepEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAT2Controller::SGeneratedFootstepEvent::operator==(const ZAT2Controller::SGeneratedFootstepEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAT2Controller::SGeneratedFootstepEvent>)
		return false;

	if (m_eFoot != p_Other.m_eFoot) return false;
	if (m_fFrame != p_Other.m_fFrame) return false;

	return true;
}

void ZAT2Controller::SGeneratedFootstepEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller::SGeneratedFootstepEvent*>(p_Object);
	s_Object->~SGeneratedFootstepEvent();
}

ZHMTypeInfo ZApproachOrder::SApproachOrderSaveData::TypeInfo = ZHMTypeInfo("ZApproachOrder.SApproachOrderSaveData", sizeof(ZApproachOrder::SApproachOrderSaveData), alignof(ZApproachOrder::SApproachOrderSaveData), ZApproachOrder::SApproachOrderSaveData::WriteSimpleJson, ZApproachOrder::SApproachOrderSaveData::FromSimpleJson, ZApproachOrder::SApproachOrderSaveData::Serialize, ZApproachOrder::SApproachOrderSaveData::Equals, ZApproachOrder::SApproachOrderSaveData::Destroy);

void ZApproachOrder::SApproachOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder::SApproachOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_style") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZApproachOrder.EApproachStyle", static_cast<int>(s_Object->m_style)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceStand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceStand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);

	p_Stream << "}";
}

void ZApproachOrder::SApproachOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZApproachOrder::SApproachOrderSaveData*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Object->m_vStopDirection);

	s_Object->m_style = static_cast<ZApproachOrder::EApproachStyle>(ZHMEnums::GetEnumValueByName("ZApproachOrder.EApproachStyle", std::string_view(p_Document["m_style"])));

	s_Object->m_bForceStand = simdjson::from_json_bool(p_Document["m_bForceStand"]);

	s_Object->m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

}

void ZApproachOrder::SApproachOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder::SApproachOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZApproachOrder::SApproachOrderSaveData, m_vStopDirection));
}

bool ZApproachOrder::SApproachOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZApproachOrder::SApproachOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZApproachOrder::SApproachOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZApproachOrder::SApproachOrderSaveData::operator==(const ZApproachOrder::SApproachOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZApproachOrder::SApproachOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_style != p_Other.m_style) return false;
	if (m_bForceStand != p_Other.m_bForceStand) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;

	return true;
}

void ZApproachOrder::SApproachOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder::SApproachOrderSaveData*>(p_Object);
	s_Object->~SApproachOrderSaveData();
}

ZHMTypeInfo ZCurve::TypeInfo = ZHMTypeInfo("ZCurve", sizeof(ZCurve), alignof(ZCurve), ZCurve::WriteSimpleJson, ZCurve::FromSimpleJson, ZCurve::Serialize, ZCurve::Equals, ZCurve::Destroy);

void ZCurve::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->data.size(); ++i)
	{
		auto& s_Item0 = s_Object->data[i];
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << simdjson::as_json_string(s_Item1);

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}

		p_Stream << "]";

		if (i < s_Object->data.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZCurve::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZCurve*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["data"];
	s_Object->data.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		{
		size_t s_Index1 = 0;
		for (simdjson::ondemand::value s_Item1 : s_Item0)
		{
			s_Object->data[s_Index0][s_Index1] = simdjson::from_json_float32(s_Item1);
			++s_Index1;
		}
		}
		++s_Index0;
	}
	}

}

void ZCurve::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	TArray<TFixedArray<float32, 8>>::Serialize(&s_Object->data, p_Serializer, p_OwnOffset + offsetof(ZCurve, data));
}

bool ZCurve::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCurve*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCurve*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCurve::operator==(const ZCurve& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCurve>)
		return false;

	if (data != p_Other.data) return false;

	return true;
}

void ZCurve::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);
	s_Object->~ZCurve();
}

ZHMTypeInfo ZAutoNullEntityRef::TypeInfo = ZHMTypeInfo("ZAutoNullEntityRef", sizeof(ZAutoNullEntityRef), alignof(ZAutoNullEntityRef), ZAutoNullEntityRef::WriteSimpleJson, ZAutoNullEntityRef::FromSimpleJson, ZAutoNullEntityRef::Serialize, ZAutoNullEntityRef::Equals, ZAutoNullEntityRef::Destroy);

void ZAutoNullEntityRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZAutoNullEntityRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Target);

}

void ZAutoNullEntityRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);

}

bool ZAutoNullEntityRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAutoNullEntityRef*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAutoNullEntityRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAutoNullEntityRef::operator==(const ZAutoNullEntityRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAutoNullEntityRef>)
		return false;


	return true;
}

void ZAutoNullEntityRef::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);
	s_Object->~ZAutoNullEntityRef();
}

ZHMTypeInfo ZAvoidDangerousAreaSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZAvoidDangerousAreaSituation.SSituationSaveData", sizeof(ZAvoidDangerousAreaSituation::SSituationSaveData), alignof(ZAvoidDangerousAreaSituation::SSituationSaveData), ZAvoidDangerousAreaSituation::SSituationSaveData::WriteSimpleJson, ZAvoidDangerousAreaSituation::SSituationSaveData::FromSimpleJson, ZAvoidDangerousAreaSituation::SSituationSaveData::Serialize, ZAvoidDangerousAreaSituation::SSituationSaveData::Equals, ZAvoidDangerousAreaSituation::SSituationSaveData::Destroy);

void ZAvoidDangerousAreaSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerousAreaGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerousAreaGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerousAreaGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerousAreaGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZAvoidDangerousAreaSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation::SSituationSaveData*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAvoidDangerousAreaGroups"];
	s_Object->m_aAvoidDangerousAreaGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aAvoidDangerousAreaGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

}

void ZAvoidDangerousAreaSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation::SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerousAreaGroups, p_Serializer, p_OwnOffset + offsetof(ZAvoidDangerousAreaSituation::SSituationSaveData, m_aAvoidDangerousAreaGroups));
}

bool ZAvoidDangerousAreaSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAvoidDangerousAreaSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAvoidDangerousAreaSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAvoidDangerousAreaSituation::SSituationSaveData::operator==(const ZAvoidDangerousAreaSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAvoidDangerousAreaSituation::SSituationSaveData>)
		return false;

	if (m_aAvoidDangerousAreaGroups != p_Other.m_aAvoidDangerousAreaGroups) return false;

	return true;
}

void ZAvoidDangerousAreaSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZCloseCombatDef::SActorNoise::TypeInfo = ZHMTypeInfo("ZCloseCombatDef.SActorNoise", sizeof(ZCloseCombatDef::SActorNoise), alignof(ZCloseCombatDef::SActorNoise), ZCloseCombatDef::SActorNoise::WriteSimpleJson, ZCloseCombatDef::SActorNoise::FromSimpleJson, ZCloseCombatDef::SActorNoise::Serialize, ZCloseCombatDef::SActorNoise::Equals, ZCloseCombatDef::SActorNoise::Destroy);

void ZCloseCombatDef::SActorNoise::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef::SActorNoise*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iSpeak") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SActorSoundDefs.EDefinition", static_cast<int>(s_Object->m_iSpeak)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAIEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eAIEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAIEventDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAIEventDistance);

	p_Stream << "}";
}

void ZCloseCombatDef::SActorNoise::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZCloseCombatDef::SActorNoise*>(p_Target);

	s_Object->m_iSpeak = static_cast<SActorSoundDefs::EDefinition>(ZHMEnums::GetEnumValueByName("SActorSoundDefs.EDefinition", std::string_view(p_Document["m_iSpeak"])));

	s_Object->m_eAIEvent = static_cast<EAIEventType>(ZHMEnums::GetEnumValueByName("EAIEventType", std::string_view(p_Document["m_eAIEvent"])));

	s_Object->m_fAIEventDistance = simdjson::from_json_float32(p_Document["m_fAIEventDistance"]);

}

void ZCloseCombatDef::SActorNoise::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef::SActorNoise*>(p_Object);

}

bool ZCloseCombatDef::SActorNoise::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCloseCombatDef::SActorNoise*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCloseCombatDef::SActorNoise*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCloseCombatDef::SActorNoise::operator==(const ZCloseCombatDef::SActorNoise& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCloseCombatDef::SActorNoise>)
		return false;

	if (m_iSpeak != p_Other.m_iSpeak) return false;
	if (m_eAIEvent != p_Other.m_eAIEvent) return false;
	if (m_fAIEventDistance != p_Other.m_fAIEventDistance) return false;

	return true;
}

void ZCloseCombatDef::SActorNoise::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZCloseCombatDef::SActorNoise*>(p_Object);
	s_Object->~SActorNoise();
}

ZHMTypeInfo ZComponentCreator::TypeInfo = ZHMTypeInfo("ZComponentCreator", sizeof(ZComponentCreator), alignof(ZComponentCreator), ZComponentCreator::WriteSimpleJson, ZComponentCreator::FromSimpleJson, ZComponentCreator::Serialize, ZComponentCreator::Equals, ZComponentCreator::Destroy);

void ZComponentCreator::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sComponentName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sComponentName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aArgs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aArgs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aArgs[i];
		ZVariant::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aArgs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZComponentCreator::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZComponentCreator*>(p_Target);

	s_Object->m_sComponentName = std::string_view(p_Document["m_sComponentName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aArgs"];
	s_Object->m_aArgs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZVariant::FromSimpleJson(s_Item0, &s_Object->m_aArgs[s_Index0]);
		++s_Index0;
	}
	}

}

void ZComponentCreator::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	ZString::Serialize(&s_Object->m_sComponentName, p_Serializer, p_OwnOffset + offsetof(ZComponentCreator, m_sComponentName));
	TArray<ZVariant>::Serialize(&s_Object->m_aArgs, p_Serializer, p_OwnOffset + offsetof(ZComponentCreator, m_aArgs));
}

bool ZComponentCreator::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZComponentCreator*>(p_Left);
	auto* s_Right = reinterpret_cast<ZComponentCreator*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZComponentCreator::operator==(const ZComponentCreator& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZComponentCreator>)
		return false;

	if (m_sComponentName != p_Other.m_sComponentName) return false;
	if (m_aArgs != p_Other.m_aArgs) return false;

	return true;
}

void ZComponentCreator::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);
	s_Object->~ZComponentCreator();
}

ZHMTypeInfo ZContractEvaluationContext::TypeInfo = ZHMTypeInfo("ZContractEvaluationContext", sizeof(ZContractEvaluationContext), alignof(ZContractEvaluationContext), ZContractEvaluationContext::WriteSimpleJson, ZContractEvaluationContext::FromSimpleJson, ZContractEvaluationContext::Serialize, ZContractEvaluationContext::Equals, ZContractEvaluationContext::Destroy);

void ZContractEvaluationContext::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZContractEvaluationContext::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Target);

}

void ZContractEvaluationContext::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);

}

bool ZContractEvaluationContext::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZContractEvaluationContext*>(p_Left);
	auto* s_Right = reinterpret_cast<ZContractEvaluationContext*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZContractEvaluationContext::operator==(const ZContractEvaluationContext& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZContractEvaluationContext>)
		return false;


	return true;
}

void ZContractEvaluationContext::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);
	s_Object->~ZContractEvaluationContext();
}

ZHMTypeInfo ZDeadBodySituation::SIncidentSaveData::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SIncidentSaveData", sizeof(ZDeadBodySituation::SIncidentSaveData), alignof(ZDeadBodySituation::SIncidentSaveData), ZDeadBodySituation::SIncidentSaveData::WriteSimpleJson, ZDeadBodySituation::SIncidentSaveData::FromSimpleJson, ZDeadBodySituation::SIncidentSaveData::Serialize, ZDeadBodySituation::SIncidentSaveData::Equals, ZDeadBodySituation::SIncidentSaveData::Destroy);

void ZDeadBodySituation::SIncidentSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SIncidentSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_body") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_body);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_blood") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_blood);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAccident") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAccident);

	p_Stream << "}";
}

void ZDeadBodySituation::SIncidentSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZDeadBodySituation::SIncidentSaveData*>(p_Target);

	s_Object->m_body = simdjson::from_json_uint32(p_Document["m_body"]);

	s_Object->m_blood = simdjson::from_json_uint32(p_Document["m_blood"]);

	s_Object->m_bAccident = simdjson::from_json_bool(p_Document["m_bAccident"]);

}

void ZDeadBodySituation::SIncidentSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SIncidentSaveData*>(p_Object);

}

bool ZDeadBodySituation::SIncidentSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation::SIncidentSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation::SIncidentSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation::SIncidentSaveData::operator==(const ZDeadBodySituation::SIncidentSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation::SIncidentSaveData>)
		return false;

	if (m_body != p_Other.m_body) return false;
	if (m_blood != p_Other.m_blood) return false;
	if (m_bAccident != p_Other.m_bAccident) return false;

	return true;
}

void ZDeadBodySituation::SIncidentSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SIncidentSaveData*>(p_Object);
	s_Object->~SIncidentSaveData();
}

ZHMTypeInfo ZDeadBodySituation::SState::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SState", sizeof(ZDeadBodySituation::SState), alignof(ZDeadBodySituation::SState), ZDeadBodySituation::SState::WriteSimpleJson, ZDeadBodySituation::SState::FromSimpleJson, ZDeadBodySituation::SState::Serialize, ZDeadBodySituation::SState::Equals, ZDeadBodySituation::SState::Destroy);

void ZDeadBodySituation::SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFlavor") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZDeadBodySituation.ESituationFlavor", static_cast<int>(s_Object->m_eFlavor)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNextStanddownTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNextStanddownTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSuspiciousDeaths") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSuspiciousDeaths);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAcknowledged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAcknowledged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInspected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInspected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAccidentsResolved") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAccidentsResolved);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStanddownComplete") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStanddownComplete);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandDownUnconscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandDownUnconscious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalateUnconscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalateUnconscious);

	p_Stream << "}";
}

void ZDeadBodySituation::SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZDeadBodySituation::SState*>(p_Target);

	s_Object->m_eFlavor = static_cast<ZDeadBodySituation::ESituationFlavor>(ZHMEnums::GetEnumValueByName("ZDeadBodySituation.ESituationFlavor", std::string_view(p_Document["m_eFlavor"])));

	ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Object->m_tLastEscalateOrder);

	ZGameTime::FromSimpleJson(p_Document["m_tNextStanddownTime"], &s_Object->m_tNextStanddownTime);

	s_Object->m_nSuspiciousDeaths = simdjson::from_json_int32(p_Document["m_nSuspiciousDeaths"]);

	s_Object->m_bAcknowledged = simdjson::from_json_bool(p_Document["m_bAcknowledged"]);

	s_Object->m_bInspected = simdjson::from_json_bool(p_Document["m_bInspected"]);

	s_Object->m_bAccidentsResolved = simdjson::from_json_bool(p_Document["m_bAccidentsResolved"]);

	s_Object->m_bStanddownComplete = simdjson::from_json_bool(p_Document["m_bStanddownComplete"]);

	s_Object->m_bStandDownUnconscious = simdjson::from_json_bool(p_Document["m_bStandDownUnconscious"]);

	s_Object->m_bEscalateUnconscious = simdjson::from_json_bool(p_Document["m_bEscalateUnconscious"]);

}

void ZDeadBodySituation::SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation::SState, m_tLastEscalateOrder));
	ZGameTime::Serialize(&s_Object->m_tNextStanddownTime, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation::SState, m_tNextStanddownTime));
}

bool ZDeadBodySituation::SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation::SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation::SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation::SState::operator==(const ZDeadBodySituation::SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation::SState>)
		return false;

	if (m_eFlavor != p_Other.m_eFlavor) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_tNextStanddownTime != p_Other.m_tNextStanddownTime) return false;
	if (m_nSuspiciousDeaths != p_Other.m_nSuspiciousDeaths) return false;
	if (m_bAcknowledged != p_Other.m_bAcknowledged) return false;
	if (m_bInspected != p_Other.m_bInspected) return false;
	if (m_bAccidentsResolved != p_Other.m_bAccidentsResolved) return false;
	if (m_bStanddownComplete != p_Other.m_bStanddownComplete) return false;
	if (m_bStandDownUnconscious != p_Other.m_bStandDownUnconscious) return false;
	if (m_bEscalateUnconscious != p_Other.m_bEscalateUnconscious) return false;

	return true;
}

void ZDeadBodySituation::SState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SState*>(p_Object);
	s_Object->~SState();
}

ZHMTypeInfo ZDeadBodySituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SSituationSaveData", sizeof(ZDeadBodySituation::SSituationSaveData), alignof(ZDeadBodySituation::SSituationSaveData), ZDeadBodySituation::SSituationSaveData::WriteSimpleJson, ZDeadBodySituation::SSituationSaveData::FromSimpleJson, ZDeadBodySituation::SSituationSaveData::Serialize, ZDeadBodySituation::SSituationSaveData::Equals, ZDeadBodySituation::SSituationSaveData::Destroy);

void ZDeadBodySituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZDeadBodySituation::SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIncidents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIncidents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIncidents[i];
		ZDeadBodySituation::SIncidentSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aIncidents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pObserversGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pObserversGroup);

	p_Stream << "}";
}

void ZDeadBodySituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZDeadBodySituation::SSituationSaveData*>(p_Target);

	ZDeadBodySituation::SState::FromSimpleJson(p_Document["m_State"], &s_Object->m_State);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIncidents"];
	s_Object->m_aIncidents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZDeadBodySituation::SIncidentSaveData::FromSimpleJson(s_Item0, &s_Object->m_aIncidents[s_Index0]);
		++s_Index0;
	}
	}

	s_Object->m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	s_Object->m_pObserversGroup = simdjson::from_json_int32(p_Document["m_pObserversGroup"]);

}

void ZDeadBodySituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SSituationSaveData*>(p_Object);

	ZDeadBodySituation::SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation::SSituationSaveData, m_State));
	TArray<ZDeadBodySituation::SIncidentSaveData>::Serialize(&s_Object->m_aIncidents, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation::SSituationSaveData, m_aIncidents));
}

bool ZDeadBodySituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation::SSituationSaveData::operator==(const ZDeadBodySituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation::SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_aIncidents != p_Other.m_aIncidents) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_pObserversGroup != p_Other.m_pObserversGroup) return false;

	return true;
}

void ZDeadBodySituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZDetectedInPrivateSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDetectedInPrivateSituation.SSituationSaveData", sizeof(ZDetectedInPrivateSituation::SSituationSaveData), alignof(ZDetectedInPrivateSituation::SSituationSaveData), ZDetectedInPrivateSituation::SSituationSaveData::WriteSimpleJson, ZDetectedInPrivateSituation::SSituationSaveData::FromSimpleJson, ZDetectedInPrivateSituation::SSituationSaveData::Serialize, ZDetectedInPrivateSituation::SSituationSaveData::Equals, ZDetectedInPrivateSituation::SSituationSaveData::Destroy);

void ZDetectedInPrivateSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pDetectedInPrivateGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pDetectedInPrivateGroup);

	p_Stream << "}";
}

void ZDetectedInPrivateSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZDetectedInPrivateSituation::SSituationSaveData*>(p_Target);

	s_Object->m_pDetectedInPrivateGroup = simdjson::from_json_int32(p_Document["m_pDetectedInPrivateGroup"]);

}

void ZDetectedInPrivateSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation::SSituationSaveData*>(p_Object);

}

bool ZDetectedInPrivateSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDetectedInPrivateSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDetectedInPrivateSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDetectedInPrivateSituation::SSituationSaveData::operator==(const ZDetectedInPrivateSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDetectedInPrivateSituation::SSituationSaveData>)
		return false;

	if (m_pDetectedInPrivateGroup != p_Other.m_pDetectedInPrivateGroup) return false;

	return true;
}

void ZDetectedInPrivateSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZDialogEventItemTypedIndex::TypeInfo = ZHMTypeInfo("ZDialogEventItemTypedIndex", sizeof(ZDialogEventItemTypedIndex), alignof(ZDialogEventItemTypedIndex), ZDialogEventItemTypedIndex::WriteSimpleJson, ZDialogEventItemTypedIndex::FromSimpleJson, ZDialogEventItemTypedIndex::Serialize, ZDialogEventItemTypedIndex::Equals, ZDialogEventItemTypedIndex::Destroy);

void ZDialogEventItemTypedIndex::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZDialogEventItemTypedIndex::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Target);

}

void ZDialogEventItemTypedIndex::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);

}

bool ZDialogEventItemTypedIndex::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDialogEventItemTypedIndex::operator==(const ZDialogEventItemTypedIndex& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDialogEventItemTypedIndex>)
		return false;


	return true;
}

void ZDialogEventItemTypedIndex::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);
	s_Object->~ZDialogEventItemTypedIndex();
}

ZHMTypeInfo ZSharedSensorDef::SVisibilitySetting::TypeInfo = ZHMTypeInfo("ZSharedSensorDef.SVisibilitySetting", sizeof(ZSharedSensorDef::SVisibilitySetting), alignof(ZSharedSensorDef::SVisibilitySetting), ZSharedSensorDef::SVisibilitySetting::WriteSimpleJson, ZSharedSensorDef::SVisibilitySetting::FromSimpleJson, ZSharedSensorDef::SVisibilitySetting::Serialize, ZSharedSensorDef::SVisibilitySetting::Equals, ZSharedSensorDef::SVisibilitySetting::Destroy);

void ZSharedSensorDef::SVisibilitySetting::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef::SVisibilitySetting*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSensitivity") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorPerceptionSensitivity", static_cast<int>(s_Object->m_eSensitivity)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCloseRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCloseRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngleWhileMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngleWhileMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralHigh") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralHigh);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralLow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralLow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeWidthAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeWidthAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeHeightAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeHeightAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeBackWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeBackWidth);

	p_Stream << "}";
}

void ZSharedSensorDef::SVisibilitySetting::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSharedSensorDef::SVisibilitySetting*>(p_Target);

	s_Object->m_eSensitivity = static_cast<EActorPerceptionSensitivity>(ZHMEnums::GetEnumValueByName("EActorPerceptionSensitivity", std::string_view(p_Document["m_eSensitivity"])));

	s_Object->m_fCloseRange = simdjson::from_json_float32(p_Document["m_fCloseRange"]);

	s_Object->m_fPeripheralAngle = simdjson::from_json_float32(p_Document["m_fPeripheralAngle"]);

	s_Object->m_fPeripheralAngleWhileMoving = simdjson::from_json_float32(p_Document["m_fPeripheralAngleWhileMoving"]);

	s_Object->m_fPeripheralHigh = simdjson::from_json_float32(p_Document["m_fPeripheralHigh"]);

	s_Object->m_fPeripheralLow = simdjson::from_json_float32(p_Document["m_fPeripheralLow"]);

	s_Object->m_fFocusConeWidthAngle = simdjson::from_json_float32(p_Document["m_fFocusConeWidthAngle"]);

	s_Object->m_fFocusConeHeightAngle = simdjson::from_json_float32(p_Document["m_fFocusConeHeightAngle"]);

	s_Object->m_fFocusConeRange = simdjson::from_json_float32(p_Document["m_fFocusConeRange"]);

	s_Object->m_fFocusConeBackWidth = simdjson::from_json_float32(p_Document["m_fFocusConeBackWidth"]);

}

void ZSharedSensorDef::SVisibilitySetting::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef::SVisibilitySetting*>(p_Object);

}

bool ZSharedSensorDef::SVisibilitySetting::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSharedSensorDef::SVisibilitySetting*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSharedSensorDef::SVisibilitySetting*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSharedSensorDef::SVisibilitySetting::operator==(const ZSharedSensorDef::SVisibilitySetting& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSharedSensorDef::SVisibilitySetting>)
		return false;

	if (m_eSensitivity != p_Other.m_eSensitivity) return false;
	if (m_fCloseRange != p_Other.m_fCloseRange) return false;
	if (m_fPeripheralAngle != p_Other.m_fPeripheralAngle) return false;
	if (m_fPeripheralAngleWhileMoving != p_Other.m_fPeripheralAngleWhileMoving) return false;
	if (m_fPeripheralHigh != p_Other.m_fPeripheralHigh) return false;
	if (m_fPeripheralLow != p_Other.m_fPeripheralLow) return false;
	if (m_fFocusConeWidthAngle != p_Other.m_fFocusConeWidthAngle) return false;
	if (m_fFocusConeHeightAngle != p_Other.m_fFocusConeHeightAngle) return false;
	if (m_fFocusConeRange != p_Other.m_fFocusConeRange) return false;
	if (m_fFocusConeBackWidth != p_Other.m_fFocusConeBackWidth) return false;

	return true;
}

void ZSharedSensorDef::SVisibilitySetting::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef::SVisibilitySetting*>(p_Object);
	s_Object->~SVisibilitySetting();
}

ZHMTypeInfo ZDisguiseSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDisguiseSituation.SSituationSaveData", sizeof(ZDisguiseSituation::SSituationSaveData), alignof(ZDisguiseSituation::SSituationSaveData), ZDisguiseSituation::SSituationSaveData::WriteSimpleJson, ZDisguiseSituation::SSituationSaveData::FromSimpleJson, ZDisguiseSituation::SSituationSaveData::Serialize, ZDisguiseSituation::SSituationSaveData::Equals, ZDisguiseSituation::SSituationSaveData::Destroy);

void ZDisguiseSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aInvestigateDisguiseGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aInvestigateDisguiseGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aInvestigateDisguiseGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aInvestigateDisguiseGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEventSetOnEscalation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eEventSetOnEscalation)));

	p_Stream << "}";
}

void ZDisguiseSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZDisguiseSituation::SSituationSaveData*>(p_Target);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aInvestigateDisguiseGroups"];
	s_Object->m_aInvestigateDisguiseGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aInvestigateDisguiseGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_eEventSetOnEscalation = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eEventSetOnEscalation"])));

}

void ZDisguiseSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation::SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aInvestigateDisguiseGroups, p_Serializer, p_OwnOffset + offsetof(ZDisguiseSituation::SSituationSaveData, m_aInvestigateDisguiseGroups));
}

bool ZDisguiseSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDisguiseSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDisguiseSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDisguiseSituation::SSituationSaveData::operator==(const ZDisguiseSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDisguiseSituation::SSituationSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_aInvestigateDisguiseGroups != p_Other.m_aInvestigateDisguiseGroups) return false;
	if (m_eEventSetOnEscalation != p_Other.m_eEventSetOnEscalation) return false;

	return true;
}

void ZDisguiseSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZER64::TypeInfo = ZHMTypeInfo("ZER64", sizeof(ZER64), alignof(ZER64), ZER64::WriteSimpleJson, ZER64::FromSimpleJson, ZER64::Serialize, ZER64::Equals, ZER64::Destroy);

void ZER64::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEntityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEntityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);

	p_Stream << "}";
}

void ZER64::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZER64*>(p_Target);

	s_Object->m_nEntityID = simdjson::from_json_uint64(p_Document["m_nEntityID"]);

	s_Object->m_sExposedEntity = std::string_view(p_Document["m_sExposedEntity"]);

}

void ZER64::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);

	ZString::Serialize(&s_Object->m_sExposedEntity, p_Serializer, p_OwnOffset + offsetof(ZER64, m_sExposedEntity));
}

bool ZER64::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZER64*>(p_Left);
	auto* s_Right = reinterpret_cast<ZER64*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZER64::operator==(const ZER64& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZER64>)
		return false;

	if (m_nEntityID != p_Other.m_nEntityID) return false;
	if (m_sExposedEntity != p_Other.m_sExposedEntity) return false;

	return true;
}

void ZER64::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);
	s_Object->~ZER64();
}

ZHMTypeInfo ZEntityID::TypeInfo = ZHMTypeInfo("ZEntityID", sizeof(ZEntityID), alignof(ZEntityID), ZEntityID::WriteSimpleJson, ZEntityID::FromSimpleJson, ZEntityID::Serialize, ZEntityID::Equals, ZEntityID::Destroy);

void ZEntityID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sStr") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sStr);

	p_Stream << "}";
}

void ZEntityID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZEntityID*>(p_Target);

	s_Object->m_sStr = std::string_view(p_Document["m_sStr"]);

}

void ZEntityID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	ZString::Serialize(&s_Object->m_sStr, p_Serializer, p_OwnOffset + offsetof(ZEntityID, m_sStr));
}

bool ZEntityID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityID::operator==(const ZEntityID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityID>)
		return false;

	if (m_sStr != p_Other.m_sStr) return false;

	return true;
}

void ZEntityID::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);
	s_Object->~ZEntityID();
}

ZHMTypeInfo ZEntityReference::TypeInfo = ZHMTypeInfo("ZEntityReference", sizeof(ZEntityReference), alignof(ZEntityReference), ZEntityReference::WriteSimpleJson, ZEntityReference::FromSimpleJson, ZEntityReference::Serialize, ZEntityReference::Equals, ZEntityReference::Destroy);

void ZEntityReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EntityID") << ":";
	ZEntityID::WriteSimpleJson(&s_Object->m_EntityID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);

	p_Stream << "}";
}

void ZEntityReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZEntityReference*>(p_Target);

	ZEntityID::FromSimpleJson(p_Document["m_EntityID"], &s_Object->m_EntityID);

	s_Object->m_sExposedEntity = std::string_view(p_Document["m_sExposedEntity"]);

}

void ZEntityReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	ZEntityID::Serialize(&s_Object->m_EntityID, p_Serializer, p_OwnOffset + offsetof(ZEntityReference, m_EntityID));
	ZString::Serialize(&s_Object->m_sExposedEntity, p_Serializer, p_OwnOffset + offsetof(ZEntityReference, m_sExposedEntity));
}

bool ZEntityReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityReference*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityReference::operator==(const ZEntityReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityReference>)
		return false;

	if (m_EntityID != p_Other.m_EntityID) return false;
	if (m_sExposedEntity != p_Other.m_sExposedEntity) return false;

	return true;
}

void ZEntityReference::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);
	s_Object->~ZEntityReference();
}

ZHMTypeInfo ZStringBuilder::TypeInfo = ZHMTypeInfo("ZStringBuilder", sizeof(ZStringBuilder), alignof(ZStringBuilder), ZStringBuilder::WriteSimpleJson, ZStringBuilder::FromSimpleJson, ZStringBuilder::Serialize, ZStringBuilder::Equals, ZStringBuilder::Destroy);

void ZStringBuilder::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStringBuilder*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_chars") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_chars.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_chars[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_chars.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZStringBuilder::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZStringBuilder*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_chars"];
	s_Object->m_chars.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_chars[s_Index0] = simdjson::from_json_int8(s_Item0);
		++s_Index0;
	}
	}

}

void ZStringBuilder::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZStringBuilder*>(p_Object);

	TArray<char>::Serialize(&s_Object->m_chars, p_Serializer, p_OwnOffset + offsetof(ZStringBuilder, m_chars));
}

bool ZStringBuilder::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZStringBuilder*>(p_Left);
	auto* s_Right = reinterpret_cast<ZStringBuilder*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZStringBuilder::operator==(const ZStringBuilder& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZStringBuilder>)
		return false;

	if (m_chars != p_Other.m_chars) return false;

	return true;
}

void ZStringBuilder::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZStringBuilder*>(p_Object);
	s_Object->~ZStringBuilder();
}

ZHMTypeInfo ZPath::TypeInfo = ZHMTypeInfo("ZPath", sizeof(ZPath), alignof(ZPath), ZPath::WriteSimpleJson, ZPath::FromSimpleJson, ZPath::Serialize, ZPath::Equals, ZPath::Destroy);

void ZPath::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPath*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_value") << ":";
	ZStringBuilder::WriteSimpleJson(&s_Object->m_value, p_Stream);

	p_Stream << "}";
}

void ZPath::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZPath*>(p_Target);

	ZStringBuilder::FromSimpleJson(p_Document["m_value"], &s_Object->m_value);

}

void ZPath::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPath*>(p_Object);

	ZStringBuilder::Serialize(&s_Object->m_value, p_Serializer, p_OwnOffset + offsetof(ZPath, m_value));
}

bool ZPath::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPath*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPath*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPath::operator==(const ZPath& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPath>)
		return false;

	if (m_value != p_Other.m_value) return false;

	return true;
}

void ZPath::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZPath*>(p_Object);
	s_Object->~ZPath();
}

ZHMTypeInfo ZFilePath::TypeInfo = ZHMTypeInfo("ZFilePath", sizeof(ZFilePath), alignof(ZFilePath), ZFilePath::WriteSimpleJson, ZFilePath::FromSimpleJson, ZFilePath::Serialize, ZFilePath::Equals, ZFilePath::Destroy);

void ZFilePath::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZFilePath*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_path") << ":";
	ZPath::WriteSimpleJson(&s_Object->m_path, p_Stream);

	p_Stream << "}";
}

void ZFilePath::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZFilePath*>(p_Target);

	ZPath::FromSimpleJson(p_Document["m_path"], &s_Object->m_path);

}

void ZFilePath::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZFilePath*>(p_Object);

	ZPath::Serialize(&s_Object->m_path, p_Serializer, p_OwnOffset + offsetof(ZFilePath, m_path));
}

bool ZFilePath::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZFilePath*>(p_Left);
	auto* s_Right = reinterpret_cast<ZFilePath*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZFilePath::operator==(const ZFilePath& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZFilePath>)
		return false;

	if (m_path != p_Other.m_path) return false;

	return true;
}

void ZFilePath::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZFilePath*>(p_Object);
	s_Object->~ZFilePath();
}

ZHMTypeInfo ZFormationMoveOrder::SFormationMoveOrderSaveData::TypeInfo = ZHMTypeInfo("ZFormationMoveOrder.SFormationMoveOrderSaveData", sizeof(ZFormationMoveOrder::SFormationMoveOrderSaveData), alignof(ZFormationMoveOrder::SFormationMoveOrderSaveData), ZFormationMoveOrder::SFormationMoveOrderSaveData::WriteSimpleJson, ZFormationMoveOrder::SFormationMoveOrderSaveData::FromSimpleJson, ZFormationMoveOrder::SFormationMoveOrderSaveData::Serialize, ZFormationMoveOrder::SFormationMoveOrderSaveData::Equals, ZFormationMoveOrder::SFormationMoveOrderSaveData::Destroy);

void ZFormationMoveOrder::SFormationMoveOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder::SFormationMoveOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleBlockageFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleBlockageFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EMoveSpeed", static_cast<int>(s_Object->m_eMoveSpeed)));

	p_Stream << "}";
}

void ZFormationMoveOrder::SFormationMoveOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZFormationMoveOrder::SFormationMoveOrderSaveData*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Object->m_vStopDirection);

	s_Object->m_nObstacleBlockageFlags = simdjson::from_json_uint32(p_Document["m_nObstacleBlockageFlags"]);

	s_Object->m_eMoveSpeed = static_cast<EMoveSpeed>(ZHMEnums::GetEnumValueByName("EMoveSpeed", std::string_view(p_Document["m_eMoveSpeed"])));

}

void ZFormationMoveOrder::SFormationMoveOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder::SFormationMoveOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZFormationMoveOrder::SFormationMoveOrderSaveData, m_vStopDirection));
}

bool ZFormationMoveOrder::SFormationMoveOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZFormationMoveOrder::SFormationMoveOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZFormationMoveOrder::SFormationMoveOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZFormationMoveOrder::SFormationMoveOrderSaveData::operator==(const ZFormationMoveOrder::SFormationMoveOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZFormationMoveOrder::SFormationMoveOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_nObstacleBlockageFlags != p_Other.m_nObstacleBlockageFlags) return false;
	if (m_eMoveSpeed != p_Other.m_eMoveSpeed) return false;

	return true;
}

void ZFormationMoveOrder::SFormationMoveOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder::SFormationMoveOrderSaveData*>(p_Object);
	s_Object->~SFormationMoveOrderSaveData();
}

ZHMTypeInfo ZGfxValueWrapper::TypeInfo = ZHMTypeInfo("ZGfxValueWrapper", sizeof(ZGfxValueWrapper), alignof(ZGfxValueWrapper), ZGfxValueWrapper::WriteSimpleJson, ZGfxValueWrapper::FromSimpleJson, ZGfxValueWrapper::Serialize, ZGfxValueWrapper::Equals, ZGfxValueWrapper::Destroy);

void ZGfxValueWrapper::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZGfxValueWrapper::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Target);

}

void ZGfxValueWrapper::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);

}

bool ZGfxValueWrapper::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGfxValueWrapper*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGfxValueWrapper*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGfxValueWrapper::operator==(const ZGfxValueWrapper& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGfxValueWrapper>)
		return false;


	return true;
}

void ZGfxValueWrapper::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);
	s_Object->~ZGfxValueWrapper();
}

ZHMTypeInfo ZGridFloatField::TypeInfo = ZHMTypeInfo("ZGridFloatField", sizeof(ZGridFloatField), alignof(ZGridFloatField), ZGridFloatField::WriteSimpleJson, ZGridFloatField::FromSimpleJson, ZGridFloatField::Serialize, ZGridFloatField::Equals, ZGridFloatField::Destroy);

void ZGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_field") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_field.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_field[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_field.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZGridFloatField*>(p_Target);

	s_Object->m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_field"];
	s_Object->m_field.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_field[s_Index0] = simdjson::from_json_float32(s_Item0);
		++s_Index0;
	}
	}

}

void ZGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);

	TArray<float32>::Serialize(&s_Object->m_field, p_Serializer, p_OwnOffset + offsetof(ZGridFloatField, m_field));
}

bool ZGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGridFloatField::operator==(const ZGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGridFloatField>)
		return false;

	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_field != p_Other.m_field) return false;

	return true;
}

void ZGridFloatField::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);
	s_Object->~ZGridFloatField();
}

ZHMTypeInfo ZHM5AgilityEventConsumer::SAgilityEventData::TypeInfo = ZHMTypeInfo("ZHM5AgilityEventConsumer.SAgilityEventData", sizeof(ZHM5AgilityEventConsumer::SAgilityEventData), alignof(ZHM5AgilityEventConsumer::SAgilityEventData), ZHM5AgilityEventConsumer::SAgilityEventData::WriteSimpleJson, ZHM5AgilityEventConsumer::SAgilityEventData::FromSimpleJson, ZHM5AgilityEventConsumer::SAgilityEventData::Serialize, ZHM5AgilityEventConsumer::SAgilityEventData::Equals, ZHM5AgilityEventConsumer::SAgilityEventData::Destroy);

void ZHM5AgilityEventConsumer::SAgilityEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer::SAgilityEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5AgilityEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5AgilityEventConsumer::SAgilityEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5AgilityEventConsumer::SAgilityEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZHM5AgilityEventConsumer::EEvent>(ZHMEnums::GetEnumValueByName("ZHM5AgilityEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

}

void ZHM5AgilityEventConsumer::SAgilityEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer::SAgilityEventData*>(p_Object);

}

bool ZHM5AgilityEventConsumer::SAgilityEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5AgilityEventConsumer::SAgilityEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5AgilityEventConsumer::SAgilityEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5AgilityEventConsumer::SAgilityEventData::operator==(const ZHM5AgilityEventConsumer::SAgilityEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5AgilityEventConsumer::SAgilityEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5AgilityEventConsumer::SAgilityEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer::SAgilityEventData*>(p_Object);
	s_Object->~SAgilityEventData();
}

ZHMTypeInfo ZHM5AudioEventConsumer::SAudioAnimationEventData::TypeInfo = ZHMTypeInfo("ZHM5AudioEventConsumer.SAudioAnimationEventData", sizeof(ZHM5AudioEventConsumer::SAudioAnimationEventData), alignof(ZHM5AudioEventConsumer::SAudioAnimationEventData), ZHM5AudioEventConsumer::SAudioAnimationEventData::WriteSimpleJson, ZHM5AudioEventConsumer::SAudioAnimationEventData::FromSimpleJson, ZHM5AudioEventConsumer::SAudioAnimationEventData::Serialize, ZHM5AudioEventConsumer::SAudioAnimationEventData::Equals, ZHM5AudioEventConsumer::SAudioAnimationEventData::Destroy);

void ZHM5AudioEventConsumer::SAudioAnimationEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer::SAudioAnimationEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pAudioEventRes") << ":";
	ZResourcePtr::WriteSimpleJson(&s_Object->m_pAudioEventRes, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5AudioEventConsumer::SAudioAnimationEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5AudioEventConsumer::SAudioAnimationEventData*>(p_Target);

	ZResourcePtr::FromSimpleJson(p_Document["m_pAudioEventRes"], &s_Object->m_pAudioEventRes);

	s_Object->m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object->m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

}

void ZHM5AudioEventConsumer::SAudioAnimationEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer::SAudioAnimationEventData*>(p_Object);

	ZResourcePtr::Serialize(&s_Object->m_pAudioEventRes, p_Serializer, p_OwnOffset + offsetof(ZHM5AudioEventConsumer::SAudioAnimationEventData, m_pAudioEventRes));
}

bool ZHM5AudioEventConsumer::SAudioAnimationEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5AudioEventConsumer::SAudioAnimationEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5AudioEventConsumer::SAudioAnimationEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5AudioEventConsumer::SAudioAnimationEventData::operator==(const ZHM5AudioEventConsumer::SAudioAnimationEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5AudioEventConsumer::SAudioAnimationEventData>)
		return false;

	if (m_pAudioEventRes != p_Other.m_pAudioEventRes) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

void ZHM5AudioEventConsumer::SAudioAnimationEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer::SAudioAnimationEventData*>(p_Object);
	s_Object->~SAudioAnimationEventData();
}

ZHMTypeInfo ZHM5BodySoundEventConsumer::SBodySoundEventData::TypeInfo = ZHMTypeInfo("ZHM5BodySoundEventConsumer.SBodySoundEventData", sizeof(ZHM5BodySoundEventConsumer::SBodySoundEventData), alignof(ZHM5BodySoundEventConsumer::SBodySoundEventData), ZHM5BodySoundEventConsumer::SBodySoundEventData::WriteSimpleJson, ZHM5BodySoundEventConsumer::SBodySoundEventData::FromSimpleJson, ZHM5BodySoundEventConsumer::SBodySoundEventData::Serialize, ZHM5BodySoundEventConsumer::SBodySoundEventData::Equals, ZHM5BodySoundEventConsumer::SBodySoundEventData::Destroy);

void ZHM5BodySoundEventConsumer::SBodySoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer::SBodySoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5BodySoundEventConsumer.EAnimSoundBody", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5BodySoundEventConsumer::SBodySoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer::SBodySoundEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZHM5BodySoundEventConsumer::EAnimSoundBody>(ZHMEnums::GetEnumValueByName("ZHM5BodySoundEventConsumer.EAnimSoundBody", std::string_view(p_Document["m_nEvent"])));

}

void ZHM5BodySoundEventConsumer::SBodySoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer::SBodySoundEventData*>(p_Object);

}

bool ZHM5BodySoundEventConsumer::SBodySoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5BodySoundEventConsumer::SBodySoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5BodySoundEventConsumer::SBodySoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5BodySoundEventConsumer::SBodySoundEventData::operator==(const ZHM5BodySoundEventConsumer::SBodySoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5BodySoundEventConsumer::SBodySoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5BodySoundEventConsumer::SBodySoundEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer::SBodySoundEventData*>(p_Object);
	s_Object->~SBodySoundEventData();
}

ZHMTypeInfo ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5CloseCombatEventConsumer.SCloseCombatSoundEventData", sizeof(ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData), alignof(ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData), ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::WriteSimpleJson, ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::FromSimpleJson, ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::Serialize, ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::Equals, ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::Destroy);

void ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHM5SoundCloseCombatEvent", static_cast<int>(s_Object->m_nEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<EHM5SoundCloseCombatEvent>(ZHMEnums::GetEnumValueByName("EHM5SoundCloseCombatEvent", std::string_view(p_Document["m_nEvent"])));

	s_Object->m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object->m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

}

void ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData*>(p_Object);

}

bool ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::operator==(const ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

void ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer::SCloseCombatSoundEventData*>(p_Object);
	s_Object->~SCloseCombatSoundEventData();
}

ZHMTypeInfo ZHM5CrowdEventConsumer::SCrowdSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5CrowdEventConsumer.SCrowdSoundEventData", sizeof(ZHM5CrowdEventConsumer::SCrowdSoundEventData), alignof(ZHM5CrowdEventConsumer::SCrowdSoundEventData), ZHM5CrowdEventConsumer::SCrowdSoundEventData::WriteSimpleJson, ZHM5CrowdEventConsumer::SCrowdSoundEventData::FromSimpleJson, ZHM5CrowdEventConsumer::SCrowdSoundEventData::Serialize, ZHM5CrowdEventConsumer::SCrowdSoundEventData::Equals, ZHM5CrowdEventConsumer::SCrowdSoundEventData::Destroy);

void ZHM5CrowdEventConsumer::SCrowdSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer::SCrowdSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pAudioEventRes") << ":";
	ZResourcePtr::WriteSimpleJson(&s_Object->m_pAudioEventRes, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5CrowdEventConsumer::SCrowdSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5CrowdEventConsumer::SCrowdSoundEventData*>(p_Target);

	ZResourcePtr::FromSimpleJson(p_Document["m_pAudioEventRes"], &s_Object->m_pAudioEventRes);

	s_Object->m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object->m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

}

void ZHM5CrowdEventConsumer::SCrowdSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer::SCrowdSoundEventData*>(p_Object);

	ZResourcePtr::Serialize(&s_Object->m_pAudioEventRes, p_Serializer, p_OwnOffset + offsetof(ZHM5CrowdEventConsumer::SCrowdSoundEventData, m_pAudioEventRes));
}

bool ZHM5CrowdEventConsumer::SCrowdSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CrowdEventConsumer::SCrowdSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CrowdEventConsumer::SCrowdSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CrowdEventConsumer::SCrowdSoundEventData::operator==(const ZHM5CrowdEventConsumer::SCrowdSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CrowdEventConsumer::SCrowdSoundEventData>)
		return false;

	if (m_pAudioEventRes != p_Other.m_pAudioEventRes) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

void ZHM5CrowdEventConsumer::SCrowdSoundEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer::SCrowdSoundEventData*>(p_Object);
	s_Object->~SCrowdSoundEventData();
}

ZHMTypeInfo ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::TypeInfo = ZHMTypeInfo("ZHM5CrowdGenericEventConsumer.SCrowdSoundGenericEventData", sizeof(ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData), alignof(ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData), ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::WriteSimpleJson, ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::FromSimpleJson, ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::Serialize, ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::Equals, ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::Destroy);

void ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5CrowdGenericEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZHM5CrowdGenericEventConsumer::EEvent>(ZHMEnums::GetEnumValueByName("ZHM5CrowdGenericEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

}

void ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData*>(p_Object);

}

bool ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::operator==(const ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer::SCrowdSoundGenericEventData*>(p_Object);
	s_Object->~SCrowdSoundGenericEventData();
}

ZHMTypeInfo ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::TypeInfo = ZHMTypeInfo("ZHM5FaceFXReactionEventConsumer.SFaceFXEventData", sizeof(ZHM5FaceFXReactionEventConsumer::SFaceFXEventData), alignof(ZHM5FaceFXReactionEventConsumer::SFaceFXEventData), ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::WriteSimpleJson, ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::FromSimpleJson, ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::Serialize, ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::Equals, ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::Destroy);

void ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer::SFaceFXEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5FaceFXReactionEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer::SFaceFXEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZHM5FaceFXReactionEventConsumer::EEvent>(ZHMEnums::GetEnumValueByName("ZHM5FaceFXReactionEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

}

void ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer::SFaceFXEventData*>(p_Object);

}

bool ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FaceFXReactionEventConsumer::SFaceFXEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FaceFXReactionEventConsumer::SFaceFXEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::operator==(const ZHM5FaceFXReactionEventConsumer::SFaceFXEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FaceFXReactionEventConsumer::SFaceFXEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5FaceFXReactionEventConsumer::SFaceFXEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer::SFaceFXEventData*>(p_Object);
	s_Object->~SFaceFXEventData();
}

ZHMTypeInfo ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::TypeInfo = ZHMTypeInfo("ZHM5FaceFXSpecificEventConsumer.SFaceFXEventData", sizeof(ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData), alignof(ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData), ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::WriteSimpleJson, ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::FromSimpleJson, ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::Serialize, ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::Equals, ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::Destroy);

void ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5FaceFXSpecificEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sFaceExpression") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sFaceExpression);

	p_Stream << "}";
}

void ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZHM5FaceFXSpecificEventConsumer::EEvent>(ZHMEnums::GetEnumValueByName("ZHM5FaceFXSpecificEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	s_Object->m_sFaceExpression = std::string_view(p_Document["m_sFaceExpression"]);

}

void ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData*>(p_Object);

	ZString::Serialize(&s_Object->m_sFaceExpression, p_Serializer, p_OwnOffset + offsetof(ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData, m_sFaceExpression));
}

bool ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::operator==(const ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;
	if (m_sFaceExpression != p_Other.m_sFaceExpression) return false;

	return true;
}

void ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer::SFaceFXEventData*>(p_Object);
	s_Object->~SFaceFXEventData();
}

ZHMTypeInfo ZHM5FootstepEventConsumer::SFootstepSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5FootstepEventConsumer.SFootstepSoundEventData", sizeof(ZHM5FootstepEventConsumer::SFootstepSoundEventData), alignof(ZHM5FootstepEventConsumer::SFootstepSoundEventData), ZHM5FootstepEventConsumer::SFootstepSoundEventData::WriteSimpleJson, ZHM5FootstepEventConsumer::SFootstepSoundEventData::FromSimpleJson, ZHM5FootstepEventConsumer::SFootstepSoundEventData::Serialize, ZHM5FootstepEventConsumer::SFootstepSoundEventData::Equals, ZHM5FootstepEventConsumer::SFootstepSoundEventData::Destroy);

void ZHM5FootstepEventConsumer::SFootstepSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer::SFootstepSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHM5SoundFootstepEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5FootstepEventConsumer::SFootstepSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5FootstepEventConsumer::SFootstepSoundEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<EHM5SoundFootstepEvent>(ZHMEnums::GetEnumValueByName("EHM5SoundFootstepEvent", std::string_view(p_Document["m_nEvent"])));

}

void ZHM5FootstepEventConsumer::SFootstepSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer::SFootstepSoundEventData*>(p_Object);

}

bool ZHM5FootstepEventConsumer::SFootstepSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FootstepEventConsumer::SFootstepSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FootstepEventConsumer::SFootstepSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FootstepEventConsumer::SFootstepSoundEventData::operator==(const ZHM5FootstepEventConsumer::SFootstepSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FootstepEventConsumer::SFootstepSoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5FootstepEventConsumer::SFootstepSoundEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer::SFootstepSoundEventData*>(p_Object);
	s_Object->~SFootstepSoundEventData();
}

ZHMTypeInfo ZHM5GenericEventConsumer::SGenericEventData::TypeInfo = ZHMTypeInfo("ZHM5GenericEventConsumer.SGenericEventData", sizeof(ZHM5GenericEventConsumer::SGenericEventData), alignof(ZHM5GenericEventConsumer::SGenericEventData), ZHM5GenericEventConsumer::SGenericEventData::WriteSimpleJson, ZHM5GenericEventConsumer::SGenericEventData::FromSimpleJson, ZHM5GenericEventConsumer::SGenericEventData::Serialize, ZHM5GenericEventConsumer::SGenericEventData::Equals, ZHM5GenericEventConsumer::SGenericEventData::Destroy);

void ZHM5GenericEventConsumer::SGenericEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer::SGenericEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5GenericEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5GenericEventConsumer::SGenericEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5GenericEventConsumer::SGenericEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZHM5GenericEventConsumer::EEvent>(ZHMEnums::GetEnumValueByName("ZHM5GenericEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

}

void ZHM5GenericEventConsumer::SGenericEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer::SGenericEventData*>(p_Object);

}

bool ZHM5GenericEventConsumer::SGenericEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5GenericEventConsumer::SGenericEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5GenericEventConsumer::SGenericEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5GenericEventConsumer::SGenericEventData::operator==(const ZHM5GenericEventConsumer::SGenericEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5GenericEventConsumer::SGenericEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5GenericEventConsumer::SGenericEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer::SGenericEventData*>(p_Object);
	s_Object->~SGenericEventData();
}

ZHMTypeInfo ZHM5HIKEventConsumer::SZHM5HIKEventData::TypeInfo = ZHMTypeInfo("ZHM5HIKEventConsumer.SZHM5HIKEventData", sizeof(ZHM5HIKEventConsumer::SZHM5HIKEventData), alignof(ZHM5HIKEventConsumer::SZHM5HIKEventData), ZHM5HIKEventConsumer::SZHM5HIKEventData::WriteSimpleJson, ZHM5HIKEventConsumer::SZHM5HIKEventData::FromSimpleJson, ZHM5HIKEventConsumer::SZHM5HIKEventData::Serialize, ZHM5HIKEventConsumer::SZHM5HIKEventData::Equals, ZHM5HIKEventConsumer::SZHM5HIKEventData::Destroy);

void ZHM5HIKEventConsumer::SZHM5HIKEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer::SZHM5HIKEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEffector") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5HIKEventConsumer.EEffector", static_cast<int>(s_Object->m_nEffector)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBlend") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5HIKEventConsumer.EBlend", static_cast<int>(s_Object->m_nBlend)));

	p_Stream << "}";
}

void ZHM5HIKEventConsumer::SZHM5HIKEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5HIKEventConsumer::SZHM5HIKEventData*>(p_Target);

	s_Object->m_nEffector = static_cast<ZHM5HIKEventConsumer::EEffector>(ZHMEnums::GetEnumValueByName("ZHM5HIKEventConsumer.EEffector", std::string_view(p_Document["m_nEffector"])));

	s_Object->m_nBlend = static_cast<ZHM5HIKEventConsumer::EBlend>(ZHMEnums::GetEnumValueByName("ZHM5HIKEventConsumer.EBlend", std::string_view(p_Document["m_nBlend"])));

}

void ZHM5HIKEventConsumer::SZHM5HIKEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer::SZHM5HIKEventData*>(p_Object);

}

bool ZHM5HIKEventConsumer::SZHM5HIKEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5HIKEventConsumer::SZHM5HIKEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5HIKEventConsumer::SZHM5HIKEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5HIKEventConsumer::SZHM5HIKEventData::operator==(const ZHM5HIKEventConsumer::SZHM5HIKEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5HIKEventConsumer::SZHM5HIKEventData>)
		return false;

	if (m_nEffector != p_Other.m_nEffector) return false;
	if (m_nBlend != p_Other.m_nBlend) return false;

	return true;
}

void ZHM5HIKEventConsumer::SZHM5HIKEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer::SZHM5HIKEventData*>(p_Object);
	s_Object->~SZHM5HIKEventData();
}

ZHMTypeInfo ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::TypeInfo = ZHMTypeInfo("ZHM5ItemInteractionEventConsumer.SItemInteractionEventData", sizeof(ZHM5ItemInteractionEventConsumer::SItemInteractionEventData), alignof(ZHM5ItemInteractionEventConsumer::SItemInteractionEventData), ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::WriteSimpleJson, ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::FromSimpleJson, ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::Serialize, ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::Equals, ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::Destroy);

void ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer::SItemInteractionEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5ItemInteractionEventConsumer.EHM5SoundItemInteractionEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer::SItemInteractionEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZHM5ItemInteractionEventConsumer::EHM5SoundItemInteractionEvent>(ZHMEnums::GetEnumValueByName("ZHM5ItemInteractionEventConsumer.EHM5SoundItemInteractionEvent", std::string_view(p_Document["m_nEvent"])));

}

void ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer::SItemInteractionEventData*>(p_Object);

}

bool ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5ItemInteractionEventConsumer::SItemInteractionEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5ItemInteractionEventConsumer::SItemInteractionEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::operator==(const ZHM5ItemInteractionEventConsumer::SItemInteractionEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5ItemInteractionEventConsumer::SItemInteractionEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5ItemInteractionEventConsumer::SItemInteractionEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer::SItemInteractionEventData*>(p_Object);
	s_Object->~SItemInteractionEventData();
}

ZHMTypeInfo ZHM5WeaponEventConsumer::SWeaponEventData::TypeInfo = ZHMTypeInfo("ZHM5WeaponEventConsumer.SWeaponEventData", sizeof(ZHM5WeaponEventConsumer::SWeaponEventData), alignof(ZHM5WeaponEventConsumer::SWeaponEventData), ZHM5WeaponEventConsumer::SWeaponEventData::WriteSimpleJson, ZHM5WeaponEventConsumer::SWeaponEventData::FromSimpleJson, ZHM5WeaponEventConsumer::SWeaponEventData::Serialize, ZHM5WeaponEventConsumer::SWeaponEventData::Equals, ZHM5WeaponEventConsumer::SWeaponEventData::Destroy);

void ZHM5WeaponEventConsumer::SWeaponEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer::SWeaponEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5WeaponEventConsumer.EAnimWeapon", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5WeaponEventConsumer::SWeaponEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHM5WeaponEventConsumer::SWeaponEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZHM5WeaponEventConsumer::EAnimWeapon>(ZHMEnums::GetEnumValueByName("ZHM5WeaponEventConsumer.EAnimWeapon", std::string_view(p_Document["m_nEvent"])));

}

void ZHM5WeaponEventConsumer::SWeaponEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer::SWeaponEventData*>(p_Object);

}

bool ZHM5WeaponEventConsumer::SWeaponEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5WeaponEventConsumer::SWeaponEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5WeaponEventConsumer::SWeaponEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5WeaponEventConsumer::SWeaponEventData::operator==(const ZHM5WeaponEventConsumer::SWeaponEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5WeaponEventConsumer::SWeaponEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5WeaponEventConsumer::SWeaponEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer::SWeaponEventData*>(p_Object);
	s_Object->~SWeaponEventData();
}

ZHMTypeInfo ZHUDAIGuide::SData::TypeInfo = ZHMTypeInfo("ZHUDAIGuide.SData", sizeof(ZHUDAIGuide::SData), alignof(ZHUDAIGuide::SData), ZHUDAIGuide::SData::WriteSimpleJson, ZHUDAIGuide::SData::FromSimpleJson, ZHUDAIGuide::SData::Serialize, ZHUDAIGuide::SData::Equals, ZHUDAIGuide::SData::Destroy);

void ZHUDAIGuide::SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide::SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("bDisguiseBroken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDisguiseBroken);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInsideCrimeScene") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInsideCrimeScene);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bNearDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bNearDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bVisiblyArmed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bVisiblyArmed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDisguiseSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDisguiseSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDeepTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDeepTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG);

	p_Stream << "}";
}

void ZHUDAIGuide::SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHUDAIGuide::SData*>(p_Target);

	s_Object->bDisguiseBroken = simdjson::from_json_bool(p_Document["bDisguiseBroken"]);

	s_Object->bTrespassing = simdjson::from_json_bool(p_Document["bTrespassing"]);

	s_Object->bInsideCrimeScene = simdjson::from_json_bool(p_Document["bInsideCrimeScene"]);

	s_Object->bNearDeadBody = simdjson::from_json_bool(p_Document["bNearDeadBody"]);

	s_Object->bVisiblyArmed = simdjson::from_json_bool(p_Document["bVisiblyArmed"]);

	s_Object->bDisguiseSuspicious = simdjson::from_json_bool(p_Document["bDisguiseSuspicious"]);

	s_Object->bDeepTrespassing = simdjson::from_json_bool(p_Document["bDeepTrespassing"]);

	s_Object->bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG = simdjson::from_json_bool(p_Document["bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG"]);

}

void ZHUDAIGuide::SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide::SData*>(p_Object);

}

bool ZHUDAIGuide::SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDAIGuide::SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDAIGuide::SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDAIGuide::SData::operator==(const ZHUDAIGuide::SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDAIGuide::SData>)
		return false;

	if (bDisguiseBroken != p_Other.bDisguiseBroken) return false;
	if (bTrespassing != p_Other.bTrespassing) return false;
	if (bInsideCrimeScene != p_Other.bInsideCrimeScene) return false;
	if (bNearDeadBody != p_Other.bNearDeadBody) return false;
	if (bVisiblyArmed != p_Other.bVisiblyArmed) return false;
	if (bDisguiseSuspicious != p_Other.bDisguiseSuspicious) return false;
	if (bDeepTrespassing != p_Other.bDeepTrespassing) return false;
	if (bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG != p_Other.bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG) return false;

	return true;
}

void ZHUDAIGuide::SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide::SData*>(p_Object);
	s_Object->~SData();
}

ZHMTypeInfo ZHUDHintController::SData::TypeInfo = ZHMTypeInfo("ZHUDHintController.SData", sizeof(ZHUDHintController::SData), alignof(ZHUDHintController::SData), ZHUDHintController::SData::WriteSimpleJson, ZHUDHintController::SData::FromSimpleJson, ZHUDHintController::SData::Serialize, ZHUDHintController::SData::Equals, ZHUDHintController::SData::Destroy);

void ZHUDHintController::SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController::SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sTitleText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sTitleText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyText);

	p_Stream << "}";
}

void ZHUDHintController::SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHUDHintController::SData*>(p_Target);

	s_Object->m_sTitleText = std::string_view(p_Document["m_sTitleText"]);

	s_Object->m_sBodyText = std::string_view(p_Document["m_sBodyText"]);

}

void ZHUDHintController::SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController::SData*>(p_Object);

	ZString::Serialize(&s_Object->m_sTitleText, p_Serializer, p_OwnOffset + offsetof(ZHUDHintController::SData, m_sTitleText));
	ZString::Serialize(&s_Object->m_sBodyText, p_Serializer, p_OwnOffset + offsetof(ZHUDHintController::SData, m_sBodyText));
}

bool ZHUDHintController::SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDHintController::SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDHintController::SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDHintController::SData::operator==(const ZHUDHintController::SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDHintController::SData>)
		return false;

	if (m_sTitleText != p_Other.m_sTitleText) return false;
	if (m_sBodyText != p_Other.m_sBodyText) return false;

	return true;
}

void ZHUDHintController::SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController::SData*>(p_Object);
	s_Object->~SData();
}

ZHMTypeInfo ZHttpUrl::TypeInfo = ZHMTypeInfo("ZHttpUrl", sizeof(ZHttpUrl), alignof(ZHttpUrl), ZHttpUrl::WriteSimpleJson, ZHttpUrl::FromSimpleJson, ZHttpUrl::Serialize, ZHttpUrl::Equals, ZHttpUrl::Destroy);

void ZHttpUrl::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZHttpUrl::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZHttpUrl*>(p_Target);

}

void ZHttpUrl::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);

}

bool ZHttpUrl::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHttpUrl*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHttpUrl*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHttpUrl::operator==(const ZHttpUrl& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHttpUrl>)
		return false;


	return true;
}

void ZHttpUrl::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);
	s_Object->~ZHttpUrl();
}

ZHMTypeInfo ZInteractionData::TypeInfo = ZHMTypeInfo("ZInteractionData", sizeof(ZInteractionData), alignof(ZInteractionData), ZInteractionData::WriteSimpleJson, ZInteractionData::FromSimpleJson, ZInteractionData::Serialize, ZInteractionData::Equals, ZInteractionData::Destroy);

void ZInteractionData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInteractionData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInteractionData*>(p_Target);

}

void ZInteractionData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);

}

bool ZInteractionData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionData::operator==(const ZInteractionData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionData>)
		return false;


	return true;
}

void ZInteractionData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);
	s_Object->~ZInteractionData();
}

ZHMTypeInfo ZInteractionEventConsumer::SInteractionEventData::TypeInfo = ZHMTypeInfo("ZInteractionEventConsumer.SInteractionEventData", sizeof(ZInteractionEventConsumer::SInteractionEventData), alignof(ZInteractionEventConsumer::SInteractionEventData), ZInteractionEventConsumer::SInteractionEventData::WriteSimpleJson, ZInteractionEventConsumer::SInteractionEventData::FromSimpleJson, ZInteractionEventConsumer::SInteractionEventData::Serialize, ZInteractionEventConsumer::SInteractionEventData::Equals, ZInteractionEventConsumer::SInteractionEventData::Destroy);

void ZInteractionEventConsumer::SInteractionEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer::SInteractionEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInteractionEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZInteractionEventConsumer::SInteractionEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInteractionEventConsumer::SInteractionEventData*>(p_Target);

	s_Object->m_nEvent = static_cast<ZInteractionEventConsumer::EEvent>(ZHMEnums::GetEnumValueByName("ZInteractionEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

}

void ZInteractionEventConsumer::SInteractionEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer::SInteractionEventData*>(p_Object);

}

bool ZInteractionEventConsumer::SInteractionEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionEventConsumer::SInteractionEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionEventConsumer::SInteractionEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionEventConsumer::SInteractionEventData::operator==(const ZInteractionEventConsumer::SInteractionEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionEventConsumer::SInteractionEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZInteractionEventConsumer::SInteractionEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer::SInteractionEventData*>(p_Object);
	s_Object->~SInteractionEventData();
}

ZHMTypeInfo ZInteractionGuideData::TypeInfo = ZHMTypeInfo("ZInteractionGuideData", sizeof(ZInteractionGuideData), alignof(ZInteractionGuideData), ZInteractionGuideData::WriteSimpleJson, ZInteractionGuideData::FromSimpleJson, ZInteractionGuideData::Serialize, ZInteractionGuideData::Equals, ZInteractionGuideData::Destroy);

void ZInteractionGuideData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInteractionGuideData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Target);

}

void ZInteractionGuideData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);

}

bool ZInteractionGuideData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionGuideData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionGuideData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionGuideData::operator==(const ZInteractionGuideData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionGuideData>)
		return false;


	return true;
}

void ZInteractionGuideData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);
	s_Object->~ZInteractionGuideData();
}

ZHMTypeInfo ZInventorySlot::TypeInfo = ZHMTypeInfo("ZInventorySlot", sizeof(ZInventorySlot), alignof(ZInventorySlot), ZInventorySlot::WriteSimpleJson, ZInventorySlot::FromSimpleJson, ZInventorySlot::Serialize, ZInventorySlot::Equals, ZInventorySlot::Destroy);

void ZInventorySlot::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInventorySlot::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInventorySlot*>(p_Target);

}

void ZInventorySlot::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);

}

bool ZInventorySlot::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInventorySlot*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInventorySlot*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInventorySlot::operator==(const ZInventorySlot& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInventorySlot>)
		return false;


	return true;
}

void ZInventorySlot::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInventorySlot*>(p_Object);
	s_Object->~ZInventorySlot();
}

ZHMTypeInfo ZInvestigateStandingSituation::SState::TypeInfo = ZHMTypeInfo("ZInvestigateStandingSituation.SState", sizeof(ZInvestigateStandingSituation::SState), alignof(ZInvestigateStandingSituation::SState), ZInvestigateStandingSituation::SState::WriteSimpleJson, ZInvestigateStandingSituation::SState::FromSimpleJson, ZInvestigateStandingSituation::SState::Serialize, ZInvestigateStandingSituation::SState::Equals, ZInvestigateStandingSituation::SState::Destroy);

void ZInvestigateStandingSituation::SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation::SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bHitmanInvadingPrivacy") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanInvadingPrivacy);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanBizarre") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanBizarre);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanWasBizarre") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanWasBizarre);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanWarned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanWarned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldReactToWeaponPickup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldReactToWeaponPickup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReactedToWeaponPickup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReactedToWeaponPickup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateStandingSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eFlavor") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateStandingSituation.ESituationFlavor", static_cast<int>(s_Object->m_eFlavor)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHitmanBizarre") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tHitmanBizarre, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastComment") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastComment, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastBump") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastBump, p_Stream);

	p_Stream << "}";
}

void ZInvestigateStandingSituation::SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInvestigateStandingSituation::SState*>(p_Target);

	s_Object->m_bHitmanInvadingPrivacy = simdjson::from_json_bool(p_Document["m_bHitmanInvadingPrivacy"]);

	s_Object->m_bHitmanBizarre = simdjson::from_json_bool(p_Document["m_bHitmanBizarre"]);

	s_Object->m_bHitmanWasBizarre = simdjson::from_json_bool(p_Document["m_bHitmanWasBizarre"]);

	s_Object->m_bHitmanWarned = simdjson::from_json_bool(p_Document["m_bHitmanWarned"]);

	s_Object->m_bShouldReactToWeaponPickup = simdjson::from_json_bool(p_Document["m_bShouldReactToWeaponPickup"]);

	s_Object->m_bReactedToWeaponPickup = simdjson::from_json_bool(p_Document["m_bReactedToWeaponPickup"]);

	s_Object->m_eSituationState = static_cast<ZInvestigateStandingSituation::ESituationState>(ZHMEnums::GetEnumValueByName("ZInvestigateStandingSituation.ESituationState", std::string_view(p_Document["m_eSituationState"])));

	s_Object->m_eFlavor = static_cast<ZInvestigateStandingSituation::ESituationFlavor>(ZHMEnums::GetEnumValueByName("ZInvestigateStandingSituation.ESituationFlavor", std::string_view(p_Document["m_eFlavor"])));

	ZGameTime::FromSimpleJson(p_Document["m_tHitmanBizarre"], &s_Object->m_tHitmanBizarre);

	ZGameTime::FromSimpleJson(p_Document["m_tLastComment"], &s_Object->m_tLastComment);

	ZGameTime::FromSimpleJson(p_Document["m_tLastBump"], &s_Object->m_tLastBump);

}

void ZInvestigateStandingSituation::SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation::SState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tHitmanBizarre, p_Serializer, p_OwnOffset + offsetof(ZInvestigateStandingSituation::SState, m_tHitmanBizarre));
	ZGameTime::Serialize(&s_Object->m_tLastComment, p_Serializer, p_OwnOffset + offsetof(ZInvestigateStandingSituation::SState, m_tLastComment));
	ZGameTime::Serialize(&s_Object->m_tLastBump, p_Serializer, p_OwnOffset + offsetof(ZInvestigateStandingSituation::SState, m_tLastBump));
}

bool ZInvestigateStandingSituation::SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateStandingSituation::SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateStandingSituation::SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateStandingSituation::SState::operator==(const ZInvestigateStandingSituation::SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateStandingSituation::SState>)
		return false;

	if (m_bHitmanInvadingPrivacy != p_Other.m_bHitmanInvadingPrivacy) return false;
	if (m_bHitmanBizarre != p_Other.m_bHitmanBizarre) return false;
	if (m_bHitmanWasBizarre != p_Other.m_bHitmanWasBizarre) return false;
	if (m_bHitmanWarned != p_Other.m_bHitmanWarned) return false;
	if (m_bShouldReactToWeaponPickup != p_Other.m_bShouldReactToWeaponPickup) return false;
	if (m_bReactedToWeaponPickup != p_Other.m_bReactedToWeaponPickup) return false;
	if (m_eSituationState != p_Other.m_eSituationState) return false;
	if (m_eFlavor != p_Other.m_eFlavor) return false;
	if (m_tHitmanBizarre != p_Other.m_tHitmanBizarre) return false;
	if (m_tLastComment != p_Other.m_tLastComment) return false;
	if (m_tLastBump != p_Other.m_tLastBump) return false;

	return true;
}

void ZInvestigateStandingSituation::SState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation::SState*>(p_Object);
	s_Object->~SState();
}

ZHMTypeInfo ZInvestigateStandingSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZInvestigateStandingSituation.SSituationSaveData", sizeof(ZInvestigateStandingSituation::SSituationSaveData), alignof(ZInvestigateStandingSituation::SSituationSaveData), ZInvestigateStandingSituation::SSituationSaveData::WriteSimpleJson, ZInvestigateStandingSituation::SSituationSaveData::FromSimpleJson, ZInvestigateStandingSituation::SSituationSaveData::Serialize, ZInvestigateStandingSituation::SSituationSaveData::Equals, ZInvestigateStandingSituation::SSituationSaveData::Destroy);

void ZInvestigateStandingSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZInvestigateStandingSituation::SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);

	p_Stream << "}";
}

void ZInvestigateStandingSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInvestigateStandingSituation::SSituationSaveData*>(p_Target);

	ZInvestigateStandingSituation::SState::FromSimpleJson(p_Document["m_State"], &s_Object->m_State);

	s_Object->m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

}

void ZInvestigateStandingSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation::SSituationSaveData*>(p_Object);

	ZInvestigateStandingSituation::SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZInvestigateStandingSituation::SSituationSaveData, m_State));
}

bool ZInvestigateStandingSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateStandingSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateStandingSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateStandingSituation::SSituationSaveData::operator==(const ZInvestigateStandingSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateStandingSituation::SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;

	return true;
}

void ZInvestigateStandingSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInvestigateStandingSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZInvestigateWeaponSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZInvestigateWeaponSituation.SSituationSaveData", sizeof(ZInvestigateWeaponSituation::SSituationSaveData), alignof(ZInvestigateWeaponSituation::SSituationSaveData), ZInvestigateWeaponSituation::SSituationSaveData::WriteSimpleJson, ZInvestigateWeaponSituation::SSituationSaveData::FromSimpleJson, ZInvestigateWeaponSituation::SSituationSaveData::Serialize, ZInvestigateWeaponSituation::SSituationSaveData::Equals, ZInvestigateWeaponSituation::SSituationSaveData::Destroy);

void ZInvestigateWeaponSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nCurrentState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mainStateStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_mainStateStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nActiveInvestigationGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nActiveInvestigationGroup);

	p_Stream << "}";
}

void ZInvestigateWeaponSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZInvestigateWeaponSituation::SSituationSaveData*>(p_Target);

	s_Object->m_nCurrentState = simdjson::from_json_int32(p_Document["m_nCurrentState"]);

	ZGameTime::FromSimpleJson(p_Document["m_mainStateStartTime"], &s_Object->m_mainStateStartTime);

	ZGameTime::FromSimpleJson(p_Document["m_tLastStandDown"], &s_Object->m_tLastStandDown);

	s_Object->m_nActiveInvestigationGroup = simdjson::from_json_int32(p_Document["m_nActiveInvestigationGroup"]);

}

void ZInvestigateWeaponSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation::SSituationSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_mainStateStartTime, p_Serializer, p_OwnOffset + offsetof(ZInvestigateWeaponSituation::SSituationSaveData, m_mainStateStartTime));
	ZGameTime::Serialize(&s_Object->m_tLastStandDown, p_Serializer, p_OwnOffset + offsetof(ZInvestigateWeaponSituation::SSituationSaveData, m_tLastStandDown));
}

bool ZInvestigateWeaponSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateWeaponSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateWeaponSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateWeaponSituation::SSituationSaveData::operator==(const ZInvestigateWeaponSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateWeaponSituation::SSituationSaveData>)
		return false;

	if (m_nCurrentState != p_Other.m_nCurrentState) return false;
	if (m_mainStateStartTime != p_Other.m_mainStateStartTime) return false;
	if (m_tLastStandDown != p_Other.m_tLastStandDown) return false;
	if (m_nActiveInvestigationGroup != p_Other.m_nActiveInvestigationGroup) return false;

	return true;
}

void ZInvestigateWeaponSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZJumpToOrder::SJumpToOrderSaveData::TypeInfo = ZHMTypeInfo("ZJumpToOrder.SJumpToOrderSaveData", sizeof(ZJumpToOrder::SJumpToOrderSaveData), alignof(ZJumpToOrder::SJumpToOrderSaveData), ZJumpToOrder::SJumpToOrderSaveData::WriteSimpleJson, ZJumpToOrder::SJumpToOrderSaveData::FromSimpleJson, ZJumpToOrder::SJumpToOrderSaveData::Serialize, ZJumpToOrder::SJumpToOrderSaveData::Equals, ZJumpToOrder::SJumpToOrderSaveData::Destroy);

void ZJumpToOrder::SJumpToOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder::SJumpToOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTargetPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vTargetPosition, p_Stream);

	p_Stream << "}";
}

void ZJumpToOrder::SJumpToOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZJumpToOrder::SJumpToOrderSaveData*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Object->m_vStopDirection);

	float4::FromSimpleJson(p_Document["m_vTargetPosition"], &s_Object->m_vTargetPosition);

}

void ZJumpToOrder::SJumpToOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder::SJumpToOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZJumpToOrder::SJumpToOrderSaveData, m_vStopDirection));
	float4::Serialize(&s_Object->m_vTargetPosition, p_Serializer, p_OwnOffset + offsetof(ZJumpToOrder::SJumpToOrderSaveData, m_vTargetPosition));
}

bool ZJumpToOrder::SJumpToOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZJumpToOrder::SJumpToOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZJumpToOrder::SJumpToOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZJumpToOrder::SJumpToOrderSaveData::operator==(const ZJumpToOrder::SJumpToOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZJumpToOrder::SJumpToOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_vTargetPosition != p_Other.m_vTargetPosition) return false;

	return true;
}

void ZJumpToOrder::SJumpToOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder::SJumpToOrderSaveData*>(p_Object);
	s_Object->~SJumpToOrderSaveData();
}

ZHMTypeInfo ZPlanningObjectiveInfoBuilder::TypeInfo = ZHMTypeInfo("ZPlanningObjectiveInfoBuilder", sizeof(ZPlanningObjectiveInfoBuilder), alignof(ZPlanningObjectiveInfoBuilder), ZPlanningObjectiveInfoBuilder::WriteSimpleJson, ZPlanningObjectiveInfoBuilder::FromSimpleJson, ZPlanningObjectiveInfoBuilder::Serialize, ZPlanningObjectiveInfoBuilder::Equals, ZPlanningObjectiveInfoBuilder::Destroy);

void ZPlanningObjectiveInfoBuilder::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZPlanningObjectiveInfoBuilder::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Target);

}

void ZPlanningObjectiveInfoBuilder::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);

}

bool ZPlanningObjectiveInfoBuilder::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPlanningObjectiveInfoBuilder::operator==(const ZPlanningObjectiveInfoBuilder& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPlanningObjectiveInfoBuilder>)
		return false;


	return true;
}

void ZPlanningObjectiveInfoBuilder::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);
	s_Object->~ZPlanningObjectiveInfoBuilder();
}

ZHMTypeInfo ZPostfilterGraphBaseNode::TypeInfo = ZHMTypeInfo("ZPostfilterGraphBaseNode", sizeof(ZPostfilterGraphBaseNode), alignof(ZPostfilterGraphBaseNode), ZPostfilterGraphBaseNode::WriteSimpleJson, ZPostfilterGraphBaseNode::FromSimpleJson, ZPostfilterGraphBaseNode::Serialize, ZPostfilterGraphBaseNode::Equals, ZPostfilterGraphBaseNode::Destroy);

void ZPostfilterGraphBaseNode::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZPostfilterGraphBaseNode::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Target);

}

void ZPostfilterGraphBaseNode::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

}

bool ZPostfilterGraphBaseNode::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPostfilterGraphBaseNode::operator==(const ZPostfilterGraphBaseNode& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPostfilterGraphBaseNode>)
		return false;


	return true;
}

void ZPostfilterGraphBaseNode::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);
	s_Object->~ZPostfilterGraphBaseNode();
}

ZHMTypeInfo ZRecoverUnconsciousSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZRecoverUnconsciousSituation.SSituationSaveData", sizeof(ZRecoverUnconsciousSituation::SSituationSaveData), alignof(ZRecoverUnconsciousSituation::SSituationSaveData), ZRecoverUnconsciousSituation::SSituationSaveData::WriteSimpleJson, ZRecoverUnconsciousSituation::SSituationSaveData::FromSimpleJson, ZRecoverUnconsciousSituation::SSituationSaveData::Serialize, ZRecoverUnconsciousSituation::SSituationSaveData::Equals, ZRecoverUnconsciousSituation::SSituationSaveData::Destroy);

void ZRecoverUnconsciousSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pRecoverUnconsciousGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pRecoverUnconsciousGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pObserversGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pObserversGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVictimPacified") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVictimPacified);

	p_Stream << "}";
}

void ZRecoverUnconsciousSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZRecoverUnconsciousSituation::SSituationSaveData*>(p_Target);

	s_Object->m_rVictim = simdjson::from_json_uint32(p_Document["m_rVictim"]);

	s_Object->m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	s_Object->m_pRecoverUnconsciousGroup = simdjson::from_json_int32(p_Document["m_pRecoverUnconsciousGroup"]);

	s_Object->m_pObserversGroup = simdjson::from_json_int32(p_Document["m_pObserversGroup"]);

	s_Object->m_bEscalate = simdjson::from_json_bool(p_Document["m_bEscalate"]);

	s_Object->m_bVictimPacified = simdjson::from_json_bool(p_Document["m_bVictimPacified"]);

}

void ZRecoverUnconsciousSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation::SSituationSaveData*>(p_Object);

}

bool ZRecoverUnconsciousSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRecoverUnconsciousSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRecoverUnconsciousSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRecoverUnconsciousSituation::SSituationSaveData::operator==(const ZRecoverUnconsciousSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRecoverUnconsciousSituation::SSituationSaveData>)
		return false;

	if (m_rVictim != p_Other.m_rVictim) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_pRecoverUnconsciousGroup != p_Other.m_pRecoverUnconsciousGroup) return false;
	if (m_pObserversGroup != p_Other.m_pObserversGroup) return false;
	if (m_bEscalate != p_Other.m_bEscalate) return false;
	if (m_bVictimPacified != p_Other.m_bVictimPacified) return false;

	return true;
}

void ZRecoverUnconsciousSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZScopedER64::TypeInfo = ZHMTypeInfo("ZScopedER64", sizeof(ZScopedER64), alignof(ZScopedER64), ZScopedER64::WriteSimpleJson, ZScopedER64::FromSimpleJson, ZScopedER64::Serialize, ZScopedER64::Equals, ZScopedER64::Destroy);

void ZScopedER64::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_er64") << ":";
	ZER64::WriteSimpleJson(&s_Object->m_er64, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aScopePath") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aScopePath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aScopePath[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aScopePath.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZScopedER64::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZScopedER64*>(p_Target);

	ZER64::FromSimpleJson(p_Document["m_er64"], &s_Object->m_er64);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aScopePath"];
	s_Object->m_aScopePath.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aScopePath[s_Index0] = simdjson::from_json_uint64(s_Item0);
		++s_Index0;
	}
	}

}

void ZScopedER64::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);

	ZER64::Serialize(&s_Object->m_er64, p_Serializer, p_OwnOffset + offsetof(ZScopedER64, m_er64));
	TArray<uint64>::Serialize(&s_Object->m_aScopePath, p_Serializer, p_OwnOffset + offsetof(ZScopedER64, m_aScopePath));
}

bool ZScopedER64::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZScopedER64*>(p_Left);
	auto* s_Right = reinterpret_cast<ZScopedER64*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZScopedER64::operator==(const ZScopedER64& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZScopedER64>)
		return false;

	if (m_er64 != p_Other.m_er64) return false;
	if (m_aScopePath != p_Other.m_aScopePath) return false;

	return true;
}

void ZScopedER64::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);
	s_Object->~ZScopedER64();
}

ZHMTypeInfo ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::TypeInfo = ZHMTypeInfo("ZSecuritySystemCameraConfiguration.SDeadBodyVisibleEscalationRule", sizeof(ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule), alignof(ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule), ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::WriteSimpleJson, ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::FromSimpleJson, ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::Serialize, ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::Equals, ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::Destroy);

void ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_NrGuardsToSend") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_NrGuardsToSend);

	p_Stream << "}";
}

void ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule*>(p_Target);

	s_Object->m_NrGuardsToSend = simdjson::from_json_int32(p_Document["m_NrGuardsToSend"]);

}

void ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule*>(p_Object);

}

bool ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::operator==(const ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule>)
		return false;

	if (m_NrGuardsToSend != p_Other.m_NrGuardsToSend) return false;

	return true;
}

void ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration::SDeadBodyVisibleEscalationRule*>(p_Object);
	s_Object->~SDeadBodyVisibleEscalationRule();
}

ZHMTypeInfo ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::TypeInfo = ZHMTypeInfo("ZSecuritySystemCameraConfiguration.SHitmanVisibleEscalationRule", sizeof(ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule), alignof(ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule), ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::WriteSimpleJson, ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::FromSimpleJson, ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::Serialize, ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::Equals, ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::Destroy);

void ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_NrGuardsToSend") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_NrGuardsToSend);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Situation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSecuritySystemCameraConfiguration.ECameraEscalationSituations", static_cast<int>(s_Object->m_Situation)));

	p_Stream << "}";
}

void ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule*>(p_Target);

	s_Object->m_NrGuardsToSend = simdjson::from_json_int32(p_Document["m_NrGuardsToSend"]);

	s_Object->m_Situation = static_cast<ZSecuritySystemCameraConfiguration::ECameraEscalationSituations>(ZHMEnums::GetEnumValueByName("ZSecuritySystemCameraConfiguration.ECameraEscalationSituations", std::string_view(p_Document["m_Situation"])));

}

void ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule*>(p_Object);

}

bool ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::operator==(const ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule>)
		return false;

	if (m_NrGuardsToSend != p_Other.m_NrGuardsToSend) return false;
	if (m_Situation != p_Other.m_Situation) return false;

	return true;
}

void ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration::SHitmanVisibleEscalationRule*>(p_Object);
	s_Object->~SHitmanVisibleEscalationRule();
}

ZHMTypeInfo ZSetPieceIconEntity::SIconData::TypeInfo = ZHMTypeInfo("ZSetPieceIconEntity.SIconData", sizeof(ZSetPieceIconEntity::SIconData), alignof(ZSetPieceIconEntity::SIconData), ZSetPieceIconEntity::SIconData::WriteSimpleJson, ZSetPieceIconEntity::SIconData::FromSimpleJson, ZSetPieceIconEntity::SIconData::Serialize, ZSetPieceIconEntity::SIconData::Equals, ZSetPieceIconEntity::SIconData::Destroy);

void ZSetPieceIconEntity::SIconData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity::SIconData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("iCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction1") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction1);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction2") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction2);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction3") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction3);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sMissingToolText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sMissingToolText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bShowMissingTool") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bShowMissingTool);

	p_Stream << "}";
}

void ZSetPieceIconEntity::SIconData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSetPieceIconEntity::SIconData*>(p_Target);

	s_Object->iCategory = std::string_view(p_Document["iCategory"]);

	s_Object->iInteraction1 = std::string_view(p_Document["iInteraction1"]);

	s_Object->iInteraction2 = std::string_view(p_Document["iInteraction2"]);

	s_Object->iInteraction3 = std::string_view(p_Document["iInteraction3"]);

	s_Object->sMissingToolText = std::string_view(p_Document["sMissingToolText"]);

	s_Object->bShowMissingTool = simdjson::from_json_bool(p_Document["bShowMissingTool"]);

}

void ZSetPieceIconEntity::SIconData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity::SIconData*>(p_Object);

	ZString::Serialize(&s_Object->iCategory, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity::SIconData, iCategory));
	ZString::Serialize(&s_Object->iInteraction1, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity::SIconData, iInteraction1));
	ZString::Serialize(&s_Object->iInteraction2, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity::SIconData, iInteraction2));
	ZString::Serialize(&s_Object->iInteraction3, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity::SIconData, iInteraction3));
	ZString::Serialize(&s_Object->sMissingToolText, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity::SIconData, sMissingToolText));
}

bool ZSetPieceIconEntity::SIconData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSetPieceIconEntity::SIconData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSetPieceIconEntity::SIconData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSetPieceIconEntity::SIconData::operator==(const ZSetPieceIconEntity::SIconData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSetPieceIconEntity::SIconData>)
		return false;

	if (iCategory != p_Other.iCategory) return false;
	if (iInteraction1 != p_Other.iInteraction1) return false;
	if (iInteraction2 != p_Other.iInteraction2) return false;
	if (iInteraction3 != p_Other.iInteraction3) return false;
	if (sMissingToolText != p_Other.sMissingToolText) return false;
	if (bShowMissingTool != p_Other.bShowMissingTool) return false;

	return true;
}

void ZSetPieceIconEntity::SIconData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity::SIconData*>(p_Object);
	s_Object->~SIconData();
}

ZHMTypeInfo ZSniperCombatSituation::SSniperSuspiciousArea::TypeInfo = ZHMTypeInfo("ZSniperCombatSituation.SSniperSuspiciousArea", sizeof(ZSniperCombatSituation::SSniperSuspiciousArea), alignof(ZSniperCombatSituation::SSniperSuspiciousArea), ZSniperCombatSituation::SSniperSuspiciousArea::WriteSimpleJson, ZSniperCombatSituation::SSniperSuspiciousArea::FromSimpleJson, ZSniperCombatSituation::SSniperSuspiciousArea::Serialize, ZSniperCombatSituation::SSniperSuspiciousArea::Equals, ZSniperCombatSituation::SSniperSuspiciousArea::Destroy);

void ZSniperCombatSituation::SSniperSuspiciousArea::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation::SSniperSuspiciousArea*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsIslandEntrance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsIslandEntrance);

	p_Stream << "}";
}

void ZSniperCombatSituation::SSniperSuspiciousArea::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSniperCombatSituation::SSniperSuspiciousArea*>(p_Target);

	float4::FromSimpleJson(p_Document["m_vPosition"], &s_Object->m_vPosition);

	s_Object->m_fRange = simdjson::from_json_float32(p_Document["m_fRange"]);

	s_Object->m_bIsIslandEntrance = simdjson::from_json_bool(p_Document["m_bIsIslandEntrance"]);

}

void ZSniperCombatSituation::SSniperSuspiciousArea::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation::SSniperSuspiciousArea*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation::SSniperSuspiciousArea, m_vPosition));
}

bool ZSniperCombatSituation::SSniperSuspiciousArea::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSniperCombatSituation::SSniperSuspiciousArea*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSniperCombatSituation::SSniperSuspiciousArea*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSniperCombatSituation::SSniperSuspiciousArea::operator==(const ZSniperCombatSituation::SSniperSuspiciousArea& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSniperCombatSituation::SSniperSuspiciousArea>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_fRange != p_Other.m_fRange) return false;
	if (m_bIsIslandEntrance != p_Other.m_bIsIslandEntrance) return false;

	return true;
}

void ZSniperCombatSituation::SSniperSuspiciousArea::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation::SSniperSuspiciousArea*>(p_Object);
	s_Object->~SSniperSuspiciousArea();
}

ZHMTypeInfo ZSniperCombatSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZSniperCombatSituation.SSituationSaveData", sizeof(ZSniperCombatSituation::SSituationSaveData), alignof(ZSniperCombatSituation::SSituationSaveData), ZSniperCombatSituation::SSituationSaveData::WriteSimpleJson, ZSniperCombatSituation::SSituationSaveData::FromSimpleJson, ZSniperCombatSituation::SSituationSaveData::Serialize, ZSniperCombatSituation::SSituationSaveData::Equals, ZSniperCombatSituation::SSituationSaveData::Destroy);

void ZSniperCombatSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSniperLocation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSniperLocation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSniperCombatGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSniperCombatGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSniperCombatGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSniperCombatGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAggressive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAggressive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKiller") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKiller);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rIsland") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rIsland);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSuspiciousAreas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSuspiciousAreas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSuspiciousAreas[i];
		ZSniperCombatSituation::SSniperSuspiciousArea::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSuspiciousAreas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aWaitingGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFleeCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFleeCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFleeCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFleeCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSniperCombatSituation.ESituationState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGuards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGuards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSniperCombatSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSniperCombatSituation::SSituationSaveData*>(p_Target);

	s_Object->m_rSniperLocation = simdjson::from_json_uint32(p_Document["m_rSniperLocation"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSniperCombatGroups"];
	s_Object->m_aSniperCombatGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aSniperCombatGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_bAggressive = simdjson::from_json_bool(p_Document["m_bAggressive"]);

	s_Object->m_bKiller = simdjson::from_json_bool(p_Document["m_bKiller"]);

	s_Object->m_rIsland = simdjson::from_json_uint32(p_Document["m_rIsland"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSuspiciousAreas"];
	s_Object->m_aSuspiciousAreas.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZSniperCombatSituation::SSniperSuspiciousArea::FromSimpleJson(s_Item0, &s_Object->m_aSuspiciousAreas[s_Index0]);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aWaitingGuards"];
	s_Object->m_aWaitingGuards.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aWaitingGuards[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFleeCandidates"];
	s_Object->m_aFleeCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aFleeCandidates[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

	s_Object->m_bHasFailed = simdjson::from_json_bool(p_Document["m_bHasFailed"]);

	s_Object->m_eState = static_cast<ZSniperCombatSituation::ESituationState>(ZHMEnums::GetEnumValueByName("ZSniperCombatSituation.ESituationState", std::string_view(p_Document["m_eState"])));

	s_Object->m_nGuards = simdjson::from_json_uint32(p_Document["m_nGuards"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAvoidDangerGroups"];
	s_Object->m_aAvoidDangerGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aAvoidDangerGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

}

void ZSniperCombatSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation::SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aSniperCombatGroups, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation::SSituationSaveData, m_aSniperCombatGroups));
	TArray<ZSniperCombatSituation::SSniperSuspiciousArea>::Serialize(&s_Object->m_aSuspiciousAreas, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation::SSituationSaveData, m_aSuspiciousAreas));
	TArray<uint32>::Serialize(&s_Object->m_aWaitingGuards, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation::SSituationSaveData, m_aWaitingGuards));
	TArray<uint32>::Serialize(&s_Object->m_aFleeCandidates, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation::SSituationSaveData, m_aFleeCandidates));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation::SSituationSaveData, m_aAvoidDangerGroups));
}

bool ZSniperCombatSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSniperCombatSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSniperCombatSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSniperCombatSituation::SSituationSaveData::operator==(const ZSniperCombatSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSniperCombatSituation::SSituationSaveData>)
		return false;

	if (m_rSniperLocation != p_Other.m_rSniperLocation) return false;
	if (m_aSniperCombatGroups != p_Other.m_aSniperCombatGroups) return false;
	if (m_bAggressive != p_Other.m_bAggressive) return false;
	if (m_bKiller != p_Other.m_bKiller) return false;
	if (m_rIsland != p_Other.m_rIsland) return false;
	if (m_aSuspiciousAreas != p_Other.m_aSuspiciousAreas) return false;
	if (m_aWaitingGuards != p_Other.m_aWaitingGuards) return false;
	if (m_aFleeCandidates != p_Other.m_aFleeCandidates) return false;
	if (m_bHasFailed != p_Other.m_bHasFailed) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_nGuards != p_Other.m_nGuards) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;

	return true;
}

void ZSniperCombatSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZSoundCollisionInfo::TypeInfo = ZHMTypeInfo("ZSoundCollisionInfo", sizeof(ZSoundCollisionInfo), alignof(ZSoundCollisionInfo), ZSoundCollisionInfo::WriteSimpleJson, ZSoundCollisionInfo::FromSimpleJson, ZSoundCollisionInfo::Serialize, ZSoundCollisionInfo::Equals, ZSoundCollisionInfo::Destroy);

void ZSoundCollisionInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSoundCollisionInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Target);

}

void ZSoundCollisionInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);

}

bool ZSoundCollisionInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSoundCollisionInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSoundCollisionInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSoundCollisionInfo::operator==(const ZSoundCollisionInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSoundCollisionInfo>)
		return false;


	return true;
}

void ZSoundCollisionInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);
	s_Object->~ZSoundCollisionInfo();
}

ZHMTypeInfo ZSpeakerLevels::TypeInfo = ZHMTypeInfo("ZSpeakerLevels", sizeof(ZSpeakerLevels), alignof(ZSpeakerLevels), ZSpeakerLevels::WriteSimpleJson, ZSpeakerLevels::FromSimpleJson, ZSpeakerLevels::Serialize, ZSpeakerLevels::Equals, ZSpeakerLevels::Destroy);

void ZSpeakerLevels::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSpeakerMatrix") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpeakerMatrix.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpeakerMatrix[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSpeakerMatrix.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSpeakerLevels::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Target);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSpeakerMatrix"];
	s_Object->m_aSpeakerMatrix.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aSpeakerMatrix[s_Index0] = simdjson::from_json_float32(s_Item0);
		++s_Index0;
	}
	}

}

void ZSpeakerLevels::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);

	TArray<float32>::Serialize(&s_Object->m_aSpeakerMatrix, p_Serializer, p_OwnOffset + offsetof(ZSpeakerLevels, m_aSpeakerMatrix));
}

bool ZSpeakerLevels::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSpeakerLevels*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSpeakerLevels*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSpeakerLevels::operator==(const ZSpeakerLevels& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSpeakerLevels>)
		return false;

	if (m_aSpeakerMatrix != p_Other.m_aSpeakerMatrix) return false;

	return true;
}

void ZSpeakerLevels::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSpeakerLevels*>(p_Object);
	s_Object->~ZSpeakerLevels();
}

ZHMTypeInfo ZSpectatorSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZSpectatorSituation.SSituationSaveData", sizeof(ZSpectatorSituation::SSituationSaveData), alignof(ZSpectatorSituation::SSituationSaveData), ZSpectatorSituation::SSituationSaveData::WriteSimpleJson, ZSpectatorSituation::SSituationSaveData::FromSimpleJson, ZSpectatorSituation::SSituationSaveData::Serialize, ZSpectatorSituation::SSituationSaveData::Equals, ZSpectatorSituation::SSituationSaveData::Destroy);

void ZSpectatorSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStandingDown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandingDown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aObserverGroupIDs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aObserverGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aObserverGroupIDs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aObserverGroupIDs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aNonObserverMembers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aNonObserverMembers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aNonObserverMembers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aNonObserverMembers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSpectatorSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZSpectatorSituation::SSituationSaveData*>(p_Target);

	s_Object->m_bStandingDown = simdjson::from_json_bool(p_Document["m_bStandingDown"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aObserverGroupIDs"];
	s_Object->m_aObserverGroupIDs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aObserverGroupIDs[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aNonObserverMembers"];
	s_Object->m_aNonObserverMembers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aNonObserverMembers[s_Index0] = simdjson::from_json_uint32(s_Item0);
		++s_Index0;
	}
	}

}

void ZSpectatorSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation::SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aObserverGroupIDs, p_Serializer, p_OwnOffset + offsetof(ZSpectatorSituation::SSituationSaveData, m_aObserverGroupIDs));
	TArray<uint32>::Serialize(&s_Object->m_aNonObserverMembers, p_Serializer, p_OwnOffset + offsetof(ZSpectatorSituation::SSituationSaveData, m_aNonObserverMembers));
}

bool ZSpectatorSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSpectatorSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSpectatorSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSpectatorSituation::SSituationSaveData::operator==(const ZSpectatorSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSpectatorSituation::SSituationSaveData>)
		return false;

	if (m_bStandingDown != p_Other.m_bStandingDown) return false;
	if (m_aObserverGroupIDs != p_Other.m_aObserverGroupIDs) return false;
	if (m_aNonObserverMembers != p_Other.m_aNonObserverMembers) return false;

	return true;
}

void ZSpectatorSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZStandOffSituation::SState::TypeInfo = ZHMTypeInfo("ZStandOffSituation.SState", sizeof(ZStandOffSituation::SState), alignof(ZStandOffSituation::SState), ZStandOffSituation::SState::WriteSimpleJson, ZStandOffSituation::SState::FromSimpleJson, ZStandOffSituation::SState::Serialize, ZStandOffSituation::SState::Equals, ZStandOffSituation::SState::Destroy);

void ZStandOffSituation::SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation::SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZStandOffSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningPriority") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningPriority);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nResetCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nResetCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bArrestReasonStated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bArrestReasonStated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetOnStairs") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetOnStairs);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateApproachPositions") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateApproachPositions);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHelpOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHelpOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCivilianTransferredKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCivilianTransferredKnowledge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetLost") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetLost);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGetHelpGroupStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGetHelpGroupStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastKnownPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vLastKnownPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEquippedWeaponTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEquippedWeaponTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarning3Given") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarning3Given);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mainStateStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_mainStateStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeTargetLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeTargetLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeGuardHadLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeGuardHadLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNextCivBark") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNextCivBark, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartSearchCountdown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartSearchCountdown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDialogState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZStandOffSituation.EDialogState", static_cast<int>(s_Object->m_eDialogState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopWarningGiven") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopWarningGiven);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_reportedTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_reportedTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggeredBySecurityCameras") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggeredBySecurityCameras);

	p_Stream << "}";
}

void ZStandOffSituation::SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZStandOffSituation::SState*>(p_Target);

	s_Object->m_eSituationState = static_cast<ZStandOffSituation::ESituationState>(ZHMEnums::GetEnumValueByName("ZStandOffSituation.ESituationState", std::string_view(p_Document["m_eSituationState"])));

	s_Object->m_eArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eArrestReason"])));

	s_Object->m_nWarningPriority = simdjson::from_json_uint32(p_Document["m_nWarningPriority"]);

	s_Object->m_nResetCount = simdjson::from_json_int32(p_Document["m_nResetCount"]);

	s_Object->m_bArrestReasonStated = simdjson::from_json_bool(p_Document["m_bArrestReasonStated"]);

	s_Object->m_bTargetOnStairs = simdjson::from_json_bool(p_Document["m_bTargetOnStairs"]);

	s_Object->m_bUpdateApproachPositions = simdjson::from_json_bool(p_Document["m_bUpdateApproachPositions"]);

	s_Object->m_bHelpOrderAssigned = simdjson::from_json_bool(p_Document["m_bHelpOrderAssigned"]);

	s_Object->m_bCivilianTransferredKnowledge = simdjson::from_json_bool(p_Document["m_bCivilianTransferredKnowledge"]);

	s_Object->m_bTargetLost = simdjson::from_json_bool(p_Document["m_bTargetLost"]);

	s_Object->m_bGetHelpGroupStarted = simdjson::from_json_bool(p_Document["m_bGetHelpGroupStarted"]);

	float4::FromSimpleJson(p_Document["m_vLastKnownPosition"], &s_Object->m_vLastKnownPosition);

	s_Object->m_fMovingTime = simdjson::from_json_float32(p_Document["m_fMovingTime"]);

	s_Object->m_fRunningTime = simdjson::from_json_float32(p_Document["m_fRunningTime"]);

	s_Object->m_fEquippedWeaponTime = simdjson::from_json_float32(p_Document["m_fEquippedWeaponTime"]);

	s_Object->m_bWarning3Given = simdjson::from_json_bool(p_Document["m_bWarning3Given"]);

	ZGameTime::FromSimpleJson(p_Document["m_mainStateStartTime"], &s_Object->m_mainStateStartTime);

	ZGameTime::FromSimpleJson(p_Document["m_tLastTimeTargetLOS"], &s_Object->m_tLastTimeTargetLOS);

	ZGameTime::FromSimpleJson(p_Document["m_tLastTimeGuardHadLOS"], &s_Object->m_tLastTimeGuardHadLOS);

	ZGameTime::FromSimpleJson(p_Document["m_tNextCivBark"], &s_Object->m_tNextCivBark);

	ZGameTime::FromSimpleJson(p_Document["m_tStartSearchCountdown"], &s_Object->m_tStartSearchCountdown);

	s_Object->m_eDialogState = static_cast<ZStandOffSituation::EDialogState>(ZHMEnums::GetEnumValueByName("ZStandOffSituation.EDialogState", std::string_view(p_Document["m_eDialogState"])));

	s_Object->m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	s_Object->m_bStopWarningGiven = simdjson::from_json_bool(p_Document["m_bStopWarningGiven"]);

	s_Object->m_reportedTarget = simdjson::from_json_bool(p_Document["m_reportedTarget"]);

	s_Object->m_bTriggeredBySecurityCameras = simdjson::from_json_bool(p_Document["m_bTriggeredBySecurityCameras"]);

}

void ZStandOffSituation::SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation::SState*>(p_Object);

	float4::Serialize(&s_Object->m_vLastKnownPosition, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SState, m_vLastKnownPosition));
	ZGameTime::Serialize(&s_Object->m_mainStateStartTime, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SState, m_mainStateStartTime));
	ZGameTime::Serialize(&s_Object->m_tLastTimeTargetLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SState, m_tLastTimeTargetLOS));
	ZGameTime::Serialize(&s_Object->m_tLastTimeGuardHadLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SState, m_tLastTimeGuardHadLOS));
	ZGameTime::Serialize(&s_Object->m_tNextCivBark, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SState, m_tNextCivBark));
	ZGameTime::Serialize(&s_Object->m_tStartSearchCountdown, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SState, m_tStartSearchCountdown));
}

bool ZStandOffSituation::SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZStandOffSituation::SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZStandOffSituation::SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZStandOffSituation::SState::operator==(const ZStandOffSituation::SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZStandOffSituation::SState>)
		return false;

	if (m_eSituationState != p_Other.m_eSituationState) return false;
	if (m_eArrestReason != p_Other.m_eArrestReason) return false;
	if (m_nWarningPriority != p_Other.m_nWarningPriority) return false;
	if (m_nResetCount != p_Other.m_nResetCount) return false;
	if (m_bArrestReasonStated != p_Other.m_bArrestReasonStated) return false;
	if (m_bTargetOnStairs != p_Other.m_bTargetOnStairs) return false;
	if (m_bUpdateApproachPositions != p_Other.m_bUpdateApproachPositions) return false;
	if (m_bHelpOrderAssigned != p_Other.m_bHelpOrderAssigned) return false;
	if (m_bCivilianTransferredKnowledge != p_Other.m_bCivilianTransferredKnowledge) return false;
	if (m_bTargetLost != p_Other.m_bTargetLost) return false;
	if (m_bGetHelpGroupStarted != p_Other.m_bGetHelpGroupStarted) return false;
	if (m_vLastKnownPosition != p_Other.m_vLastKnownPosition) return false;
	if (m_fMovingTime != p_Other.m_fMovingTime) return false;
	if (m_fRunningTime != p_Other.m_fRunningTime) return false;
	if (m_fEquippedWeaponTime != p_Other.m_fEquippedWeaponTime) return false;
	if (m_bWarning3Given != p_Other.m_bWarning3Given) return false;
	if (m_mainStateStartTime != p_Other.m_mainStateStartTime) return false;
	if (m_tLastTimeTargetLOS != p_Other.m_tLastTimeTargetLOS) return false;
	if (m_tLastTimeGuardHadLOS != p_Other.m_tLastTimeGuardHadLOS) return false;
	if (m_tNextCivBark != p_Other.m_tNextCivBark) return false;
	if (m_tStartSearchCountdown != p_Other.m_tStartSearchCountdown) return false;
	if (m_eDialogState != p_Other.m_eDialogState) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_bStopWarningGiven != p_Other.m_bStopWarningGiven) return false;
	if (m_reportedTarget != p_Other.m_reportedTarget) return false;
	if (m_bTriggeredBySecurityCameras != p_Other.m_bTriggeredBySecurityCameras) return false;

	return true;
}

void ZStandOffSituation::SState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation::SState*>(p_Object);
	s_Object->~SState();
}

ZHMTypeInfo ZStandOffSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZStandOffSituation.SSituationSaveData", sizeof(ZStandOffSituation::SSituationSaveData), alignof(ZStandOffSituation::SSituationSaveData), ZStandOffSituation::SSituationSaveData::WriteSimpleJson, ZStandOffSituation::SSituationSaveData::FromSimpleJson, ZStandOffSituation::SSituationSaveData::Serialize, ZStandOffSituation::SSituationSaveData::Equals, ZStandOffSituation::SSituationSaveData::Destroy);

void ZStandOffSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZStandOffSituation::SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pArrestor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pArrestor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pSpeaker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pSpeaker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rIsland") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rIsland);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeTargetLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeTargetLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZStandOffSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZStandOffSituation::SSituationSaveData*>(p_Target);

	ZStandOffSituation::SState::FromSimpleJson(p_Document["m_State"], &s_Object->m_State);

	s_Object->m_pArrestor = simdjson::from_json_uint32(p_Document["m_pArrestor"]);

	s_Object->m_pSpeaker = simdjson::from_json_uint32(p_Document["m_pSpeaker"]);

	s_Object->m_pGetHelpGroup = simdjson::from_json_int32(p_Document["m_pGetHelpGroup"]);

	s_Object->m_rIsland = simdjson::from_json_uint32(p_Document["m_rIsland"]);

	ZGameTime::FromSimpleJson(p_Document["m_tLastTimeTargetLOS"], &s_Object->m_tLastTimeTargetLOS);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAvoidDangerGroups"];
	s_Object->m_aAvoidDangerGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object->m_aAvoidDangerGroups[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

}

void ZStandOffSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation::SSituationSaveData*>(p_Object);

	ZStandOffSituation::SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SSituationSaveData, m_State));
	ZGameTime::Serialize(&s_Object->m_tLastTimeTargetLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SSituationSaveData, m_tLastTimeTargetLOS));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation::SSituationSaveData, m_aAvoidDangerGroups));
}

bool ZStandOffSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZStandOffSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZStandOffSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZStandOffSituation::SSituationSaveData::operator==(const ZStandOffSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZStandOffSituation::SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_pArrestor != p_Other.m_pArrestor) return false;
	if (m_pSpeaker != p_Other.m_pSpeaker) return false;
	if (m_pGetHelpGroup != p_Other.m_pGetHelpGroup) return false;
	if (m_rIsland != p_Other.m_rIsland) return false;
	if (m_tLastTimeTargetLOS != p_Other.m_tLastTimeTargetLOS) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;

	return true;
}

void ZStandOffSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZTime::TypeInfo = ZHMTypeInfo("ZTime", sizeof(ZTime), alignof(ZTime), ZTime::WriteSimpleJson, ZTime::FromSimpleJson, ZTime::Serialize, ZTime::Equals, ZTime::Destroy);

void ZTime::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nValue);

	p_Stream << "}";
}

void ZTime::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZTime*>(p_Target);

	s_Object->m_nValue = simdjson::from_json_uint64(p_Document["m_nValue"]);

}

void ZTime::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

}

bool ZTime::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTime*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTime*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTime::operator==(const ZTime& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTime>)
		return false;

	if (m_nValue != p_Other.m_nValue) return false;

	return true;
}

void ZTime::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);
	s_Object->~ZTime();
}

ZHMTypeInfo ZTrespassingSituation::SState::TypeInfo = ZHMTypeInfo("ZTrespassingSituation.SState", sizeof(ZTrespassingSituation::SState), alignof(ZTrespassingSituation::SState), ZTrespassingSituation::SState::WriteSimpleJson, ZTrespassingSituation::SState::FromSimpleJson, ZTrespassingSituation::SState::Serialize, ZTrespassingSituation::SState::Equals, ZTrespassingSituation::SState::Destroy);

void ZTrespassingSituation::SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation::SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZTrespassingSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tDeepTrespassingTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tDeepTrespassingTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTargetVisible") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTargetVisible, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopWarningGiven") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopWarningGiven);

	p_Stream << "}";
}

void ZTrespassingSituation::SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZTrespassingSituation::SState*>(p_Target);

	s_Object->m_eSituationState = static_cast<ZTrespassingSituation::ESituationState>(ZHMEnums::GetEnumValueByName("ZTrespassingSituation.ESituationState", std::string_view(p_Document["m_eSituationState"])));

	ZGameTime::FromSimpleJson(p_Document["m_tDeepTrespassingTime"], &s_Object->m_tDeepTrespassingTime);

	ZGameTime::FromSimpleJson(p_Document["m_tStartStandDown"], &s_Object->m_tStartStandDown);

	ZGameTime::FromSimpleJson(p_Document["m_tLastTargetVisible"], &s_Object->m_tLastTargetVisible);

	s_Object->m_bStopWarningGiven = simdjson::from_json_bool(p_Document["m_bStopWarningGiven"]);

}

void ZTrespassingSituation::SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation::SState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tDeepTrespassingTime, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation::SState, m_tDeepTrespassingTime));
	ZGameTime::Serialize(&s_Object->m_tStartStandDown, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation::SState, m_tStartStandDown));
	ZGameTime::Serialize(&s_Object->m_tLastTargetVisible, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation::SState, m_tLastTargetVisible));
}

bool ZTrespassingSituation::SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTrespassingSituation::SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTrespassingSituation::SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTrespassingSituation::SState::operator==(const ZTrespassingSituation::SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTrespassingSituation::SState>)
		return false;

	if (m_eSituationState != p_Other.m_eSituationState) return false;
	if (m_tDeepTrespassingTime != p_Other.m_tDeepTrespassingTime) return false;
	if (m_tStartStandDown != p_Other.m_tStartStandDown) return false;
	if (m_tLastTargetVisible != p_Other.m_tLastTargetVisible) return false;
	if (m_bStopWarningGiven != p_Other.m_bStopWarningGiven) return false;

	return true;
}

void ZTrespassingSituation::SState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation::SState*>(p_Object);
	s_Object->~SState();
}

ZHMTypeInfo ZTrespassingSituation::SSituationSaveData::TypeInfo = ZHMTypeInfo("ZTrespassingSituation.SSituationSaveData", sizeof(ZTrespassingSituation::SSituationSaveData), alignof(ZTrespassingSituation::SSituationSaveData), ZTrespassingSituation::SSituationSaveData::WriteSimpleJson, ZTrespassingSituation::SSituationSaveData::FromSimpleJson, ZTrespassingSituation::SSituationSaveData::Serialize, ZTrespassingSituation::SSituationSaveData::Equals, ZTrespassingSituation::SSituationSaveData::Destroy);

void ZTrespassingSituation::SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation::SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZTrespassingSituation::SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEscortingMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEscortingMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHelpingGuardMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHelpingGuardMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vEscortOutExitLocation") << ":";
	float4::WriteSimpleJson(&s_Object->m_vEscortOutExitLocation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPropagationEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPropagationEnabled);

	p_Stream << "}";
}

void ZTrespassingSituation::SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZTrespassingSituation::SSituationSaveData*>(p_Target);

	ZTrespassingSituation::SState::FromSimpleJson(p_Document["m_State"], &s_Object->m_State);

	s_Object->m_rEscortingMember = simdjson::from_json_uint32(p_Document["m_rEscortingMember"]);

	s_Object->m_rHelpingGuardMember = simdjson::from_json_uint32(p_Document["m_rHelpingGuardMember"]);

	float4::FromSimpleJson(p_Document["m_vEscortOutExitLocation"], &s_Object->m_vEscortOutExitLocation);

	s_Object->m_nGetHelpGroup = simdjson::from_json_int32(p_Document["m_nGetHelpGroup"]);

	s_Object->m_bPropagationEnabled = simdjson::from_json_bool(p_Document["m_bPropagationEnabled"]);

}

void ZTrespassingSituation::SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation::SSituationSaveData*>(p_Object);

	ZTrespassingSituation::SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation::SSituationSaveData, m_State));
	float4::Serialize(&s_Object->m_vEscortOutExitLocation, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation::SSituationSaveData, m_vEscortOutExitLocation));
}

bool ZTrespassingSituation::SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTrespassingSituation::SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTrespassingSituation::SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTrespassingSituation::SSituationSaveData::operator==(const ZTrespassingSituation::SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTrespassingSituation::SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_rEscortingMember != p_Other.m_rEscortingMember) return false;
	if (m_rHelpingGuardMember != p_Other.m_rHelpingGuardMember) return false;
	if (m_vEscortOutExitLocation != p_Other.m_vEscortOutExitLocation) return false;
	if (m_nGetHelpGroup != p_Other.m_nGetHelpGroup) return false;
	if (m_bPropagationEnabled != p_Other.m_bPropagationEnabled) return false;

	return true;
}

void ZTrespassingSituation::SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation::SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo ZWorldMapMetaData::TypeInfo = ZHMTypeInfo("ZWorldMapMetaData", sizeof(ZWorldMapMetaData), alignof(ZWorldMapMetaData), ZWorldMapMetaData::WriteSimpleJson, ZWorldMapMetaData::FromSimpleJson, ZWorldMapMetaData::Serialize, ZWorldMapMetaData::Equals, ZWorldMapMetaData::Destroy);

void ZWorldMapMetaData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZWorldMapMetaData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	auto s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Target);

}

void ZWorldMapMetaData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);

}

bool ZWorldMapMetaData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZWorldMapMetaData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZWorldMapMetaData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZWorldMapMetaData::operator==(const ZWorldMapMetaData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZWorldMapMetaData>)
		return false;


	return true;
}

void ZWorldMapMetaData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);
	s_Object->~ZWorldMapMetaData();
}

