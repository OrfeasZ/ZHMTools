/*
 * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing.
 *
 * If you wish to regenerate this file because of a game update use the ZHMTools CodeGen tool:
 * https://github.com/OrfeasZ/ZHMTools/releases
 */

#include "ZHMGen.h"
#include "ZHMProperties.h"
#include "ZHMEnums.h"
#include <External/simdjson_helpers.h>
#include <utility>

ZHMTypeInfo AI_Private_Details_SBaseStimulus_Pool_SaveData::TypeInfo = ZHMTypeInfo("AI.Private.Details.SBaseStimulus_Pool_SaveData", sizeof(AI_Private_Details_SBaseStimulus_Pool_SaveData), alignof(AI_Private_Details_SBaseStimulus_Pool_SaveData), AI_Private_Details_SBaseStimulus_Pool_SaveData::WriteSimpleJson, AI_Private_Details_SBaseStimulus_Pool_SaveData::FromSimpleJson, AI_Private_Details_SBaseStimulus_Pool_SaveData::Serialize, AI_Private_Details_SBaseStimulus_Pool_SaveData::Equals, AI_Private_Details_SBaseStimulus_Pool_SaveData::Destroy);

void AI_Private_Details_SBaseStimulus_Pool_SaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_Private_Details_SBaseStimulus_Pool_SaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_SlotDetails") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_SlotDetails.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_SlotDetails[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_SlotDetails.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_UsageRepresentation") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_UsageRepresentation.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_UsageRepresentation[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_UsageRepresentation.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_FreeIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_FreeIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_FreeIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_FreeIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void AI_Private_Details_SBaseStimulus_Pool_SaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_Private_Details_SBaseStimulus_Pool_SaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_SlotDetails"];
	s_Object.m_SlotDetails.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_SlotDetails[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_UsageRepresentation"];
	s_Object.m_UsageRepresentation.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_UsageRepresentation[s_Index0++] = simdjson::from_json_int16(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_FreeIndices"];
	s_Object.m_FreeIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_FreeIndices[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	*reinterpret_cast<AI_Private_Details_SBaseStimulus_Pool_SaveData*>(p_Target) = s_Object;
}

void AI_Private_Details_SBaseStimulus_Pool_SaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_Private_Details_SBaseStimulus_Pool_SaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_SlotDetails, p_Serializer, p_OwnOffset + offsetof(AI_Private_Details_SBaseStimulus_Pool_SaveData, m_SlotDetails));
	TArray<int16>::Serialize(&s_Object->m_UsageRepresentation, p_Serializer, p_OwnOffset + offsetof(AI_Private_Details_SBaseStimulus_Pool_SaveData, m_UsageRepresentation));
	TArray<uint16>::Serialize(&s_Object->m_FreeIndices, p_Serializer, p_OwnOffset + offsetof(AI_Private_Details_SBaseStimulus_Pool_SaveData, m_FreeIndices));
}

bool AI_Private_Details_SBaseStimulus_Pool_SaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_Private_Details_SBaseStimulus_Pool_SaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_Private_Details_SBaseStimulus_Pool_SaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_Private_Details_SBaseStimulus_Pool_SaveData::operator==(const AI_Private_Details_SBaseStimulus_Pool_SaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_Private_Details_SBaseStimulus_Pool_SaveData>)
		return false;

	if (m_SlotDetails != p_Other.m_SlotDetails) return false;
	if (m_UsageRepresentation != p_Other.m_UsageRepresentation) return false;
	if (m_FreeIndices != p_Other.m_FreeIndices) return false;

	return true;
}

void AI_Private_Details_SBaseStimulus_Pool_SaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_Private_Details_SBaseStimulus_Pool_SaveData*>(p_Object);
	s_Object->~AI_Private_Details_SBaseStimulus_Pool_SaveData();
}

ZHMTypeInfo AI_Private_Details_SStimulus_AgentData_SaveData::TypeInfo = ZHMTypeInfo("AI.Private.Details.SStimulus_AgentData_SaveData", sizeof(AI_Private_Details_SStimulus_AgentData_SaveData), alignof(AI_Private_Details_SStimulus_AgentData_SaveData), AI_Private_Details_SStimulus_AgentData_SaveData::WriteSimpleJson, AI_Private_Details_SStimulus_AgentData_SaveData::FromSimpleJson, AI_Private_Details_SStimulus_AgentData_SaveData::Serialize, AI_Private_Details_SStimulus_AgentData_SaveData::Equals, AI_Private_Details_SStimulus_AgentData_SaveData::Destroy);

void AI_Private_Details_SStimulus_AgentData_SaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_Private_Details_SStimulus_AgentData_SaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_AgentData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_AgentData);

	p_Stream << "}";
}

void AI_Private_Details_SStimulus_AgentData_SaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_Private_Details_SStimulus_AgentData_SaveData s_Object {};

	s_Object.m_AgentData = simdjson::from_json_uint32(p_Document["m_AgentData"]);

	*reinterpret_cast<AI_Private_Details_SStimulus_AgentData_SaveData*>(p_Target) = s_Object;
}

void AI_Private_Details_SStimulus_AgentData_SaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_Private_Details_SStimulus_AgentData_SaveData*>(p_Object);

}

bool AI_Private_Details_SStimulus_AgentData_SaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_Private_Details_SStimulus_AgentData_SaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_Private_Details_SStimulus_AgentData_SaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_Private_Details_SStimulus_AgentData_SaveData::operator==(const AI_Private_Details_SStimulus_AgentData_SaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_Private_Details_SStimulus_AgentData_SaveData>)
		return false;

	if (m_AgentData != p_Other.m_AgentData) return false;

	return true;
}

void AI_Private_Details_SStimulus_AgentData_SaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_Private_Details_SStimulus_AgentData_SaveData*>(p_Object);
	s_Object->~AI_Private_Details_SStimulus_AgentData_SaveData();
}

ZHMTypeInfo AI_Private_SStimulusSnapshot::TypeInfo = ZHMTypeInfo("AI.Private.SStimulusSnapshot", sizeof(AI_Private_SStimulusSnapshot), alignof(AI_Private_SStimulusSnapshot), AI_Private_SStimulusSnapshot::WriteSimpleJson, AI_Private_SStimulusSnapshot::FromSimpleJson, AI_Private_SStimulusSnapshot::Serialize, AI_Private_SStimulusSnapshot::Equals, AI_Private_SStimulusSnapshot::Destroy);

void AI_Private_SStimulusSnapshot::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_Private_SStimulusSnapshot*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("SlotIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->SlotIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("StimulusData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->StimulusData);

	p_Stream << "}";
}

void AI_Private_SStimulusSnapshot::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_Private_SStimulusSnapshot s_Object {};

	s_Object.SlotIndex = simdjson::from_json_uint32(p_Document["SlotIndex"]);

	s_Object.StimulusData = std::string_view(p_Document["StimulusData"]);

	*reinterpret_cast<AI_Private_SStimulusSnapshot*>(p_Target) = s_Object;
}

void AI_Private_SStimulusSnapshot::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_Private_SStimulusSnapshot*>(p_Object);

	ZString::Serialize(&s_Object->StimulusData, p_Serializer, p_OwnOffset + offsetof(AI_Private_SStimulusSnapshot, StimulusData));
}

bool AI_Private_SStimulusSnapshot::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_Private_SStimulusSnapshot*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_Private_SStimulusSnapshot*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_Private_SStimulusSnapshot::operator==(const AI_Private_SStimulusSnapshot& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_Private_SStimulusSnapshot>)
		return false;

	if (SlotIndex != p_Other.SlotIndex) return false;
	if (StimulusData != p_Other.StimulusData) return false;

	return true;
}

void AI_Private_SStimulusSnapshot::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_Private_SStimulusSnapshot*>(p_Object);
	s_Object->~AI_Private_SStimulusSnapshot();
}

ZHMTypeInfo AI_Private_SPoolSnapshot::TypeInfo = ZHMTypeInfo("AI.Private.SPoolSnapshot", sizeof(AI_Private_SPoolSnapshot), alignof(AI_Private_SPoolSnapshot), AI_Private_SPoolSnapshot::WriteSimpleJson, AI_Private_SPoolSnapshot::FromSimpleJson, AI_Private_SPoolSnapshot::Serialize, AI_Private_SPoolSnapshot::Equals, AI_Private_SPoolSnapshot::Destroy);

void AI_Private_SPoolSnapshot::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolSnapshot*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("StimulusTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->StimulusTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("StimulusTypeId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->StimulusTypeId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("PoolSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->PoolSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Stimuli") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Stimuli.size(); ++i)
	{
		auto& s_Item0 = s_Object->Stimuli[i];
		AI_Private_SStimulusSnapshot::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->Stimuli.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void AI_Private_SPoolSnapshot::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_Private_SPoolSnapshot s_Object {};

	s_Object.StimulusTypeName = std::string_view(p_Document["StimulusTypeName"]);

	s_Object.StimulusTypeId = simdjson::from_json_uint32(p_Document["StimulusTypeId"]);

	s_Object.PoolSize = simdjson::from_json_uint32(p_Document["PoolSize"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["Stimuli"];
	s_Object.Stimuli.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		AI_Private_SStimulusSnapshot s_ArrayItem0;
		AI_Private_SStimulusSnapshot::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.Stimuli[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<AI_Private_SPoolSnapshot*>(p_Target) = s_Object;
}

void AI_Private_SPoolSnapshot::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolSnapshot*>(p_Object);

	ZString::Serialize(&s_Object->StimulusTypeName, p_Serializer, p_OwnOffset + offsetof(AI_Private_SPoolSnapshot, StimulusTypeName));
	TArray<AI_Private_SStimulusSnapshot>::Serialize(&s_Object->Stimuli, p_Serializer, p_OwnOffset + offsetof(AI_Private_SPoolSnapshot, Stimuli));
}

bool AI_Private_SPoolSnapshot::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_Private_SPoolSnapshot*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_Private_SPoolSnapshot*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_Private_SPoolSnapshot::operator==(const AI_Private_SPoolSnapshot& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_Private_SPoolSnapshot>)
		return false;

	if (StimulusTypeName != p_Other.StimulusTypeName) return false;
	if (StimulusTypeId != p_Other.StimulusTypeId) return false;
	if (PoolSize != p_Other.PoolSize) return false;
	if (Stimuli != p_Other.Stimuli) return false;

	return true;
}

void AI_Private_SPoolSnapshot::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolSnapshot*>(p_Object);
	s_Object->~AI_Private_SPoolSnapshot();
}

ZHMTypeInfo AI_Private_SFullDataSnapshotEvent::TypeInfo = ZHMTypeInfo("AI.Private.SFullDataSnapshotEvent", sizeof(AI_Private_SFullDataSnapshotEvent), alignof(AI_Private_SFullDataSnapshotEvent), AI_Private_SFullDataSnapshotEvent::WriteSimpleJson, AI_Private_SFullDataSnapshotEvent::FromSimpleJson, AI_Private_SFullDataSnapshotEvent::Serialize, AI_Private_SFullDataSnapshotEvent::Equals, AI_Private_SFullDataSnapshotEvent::Destroy);

void AI_Private_SFullDataSnapshotEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_Private_SFullDataSnapshotEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Timestamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Timestamp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("EventIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->EventIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("StimulusPools") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->StimulusPools.size(); ++i)
	{
		auto& s_Item0 = s_Object->StimulusPools[i];
		AI_Private_SPoolSnapshot::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->StimulusPools.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void AI_Private_SFullDataSnapshotEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_Private_SFullDataSnapshotEvent s_Object {};

	s_Object.Timestamp = simdjson::from_json_uint64(p_Document["Timestamp"]);

	s_Object.EventIndex = simdjson::from_json_uint32(p_Document["EventIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["StimulusPools"];
	s_Object.StimulusPools.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		AI_Private_SPoolSnapshot s_ArrayItem0;
		AI_Private_SPoolSnapshot::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.StimulusPools[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<AI_Private_SFullDataSnapshotEvent*>(p_Target) = s_Object;
}

void AI_Private_SFullDataSnapshotEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_Private_SFullDataSnapshotEvent*>(p_Object);

	TArray<AI_Private_SPoolSnapshot>::Serialize(&s_Object->StimulusPools, p_Serializer, p_OwnOffset + offsetof(AI_Private_SFullDataSnapshotEvent, StimulusPools));
}

bool AI_Private_SFullDataSnapshotEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_Private_SFullDataSnapshotEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_Private_SFullDataSnapshotEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_Private_SFullDataSnapshotEvent::operator==(const AI_Private_SFullDataSnapshotEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_Private_SFullDataSnapshotEvent>)
		return false;

	if (Timestamp != p_Other.Timestamp) return false;
	if (EventIndex != p_Other.EventIndex) return false;
	if (StimulusPools != p_Other.StimulusPools) return false;

	return true;
}

void AI_Private_SFullDataSnapshotEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_Private_SFullDataSnapshotEvent*>(p_Object);
	s_Object->~AI_Private_SFullDataSnapshotEvent();
}

ZHMTypeInfo AI_Private_SPoolModificationEvent::TypeInfo = ZHMTypeInfo("AI.Private.SPoolModificationEvent", sizeof(AI_Private_SPoolModificationEvent), alignof(AI_Private_SPoolModificationEvent), AI_Private_SPoolModificationEvent::WriteSimpleJson, AI_Private_SPoolModificationEvent::FromSimpleJson, AI_Private_SPoolModificationEvent::Serialize, AI_Private_SPoolModificationEvent::Equals, AI_Private_SPoolModificationEvent::Destroy);

void AI_Private_SPoolModificationEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolModificationEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("StimulusTypeId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->StimulusTypeId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SlotIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->SlotIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("OperationId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->OperationId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("StimulusData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->StimulusData);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Timestamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Timestamp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("EventIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->EventIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("EventMetaData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->EventMetaData);

	p_Stream << "}";
}

void AI_Private_SPoolModificationEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_Private_SPoolModificationEvent s_Object {};

	s_Object.StimulusTypeId = simdjson::from_json_uint32(p_Document["StimulusTypeId"]);

	s_Object.SlotIndex = simdjson::from_json_uint32(p_Document["SlotIndex"]);

	s_Object.OperationId = simdjson::from_json_uint32(p_Document["OperationId"]);

	s_Object.StimulusData = std::string_view(p_Document["StimulusData"]);

	s_Object.Timestamp = simdjson::from_json_uint64(p_Document["Timestamp"]);

	s_Object.EventIndex = simdjson::from_json_uint32(p_Document["EventIndex"]);

	s_Object.EventMetaData = std::string_view(p_Document["EventMetaData"]);

	*reinterpret_cast<AI_Private_SPoolModificationEvent*>(p_Target) = s_Object;
}

void AI_Private_SPoolModificationEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolModificationEvent*>(p_Object);

	ZString::Serialize(&s_Object->StimulusData, p_Serializer, p_OwnOffset + offsetof(AI_Private_SPoolModificationEvent, StimulusData));
	ZString::Serialize(&s_Object->EventMetaData, p_Serializer, p_OwnOffset + offsetof(AI_Private_SPoolModificationEvent, EventMetaData));
}

bool AI_Private_SPoolModificationEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_Private_SPoolModificationEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_Private_SPoolModificationEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_Private_SPoolModificationEvent::operator==(const AI_Private_SPoolModificationEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_Private_SPoolModificationEvent>)
		return false;

	if (StimulusTypeId != p_Other.StimulusTypeId) return false;
	if (SlotIndex != p_Other.SlotIndex) return false;
	if (OperationId != p_Other.OperationId) return false;
	if (StimulusData != p_Other.StimulusData) return false;
	if (Timestamp != p_Other.Timestamp) return false;
	if (EventIndex != p_Other.EventIndex) return false;
	if (EventMetaData != p_Other.EventMetaData) return false;

	return true;
}

void AI_Private_SPoolModificationEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolModificationEvent*>(p_Object);
	s_Object->~AI_Private_SPoolModificationEvent();
}

ZHMTypeInfo AI_Private_SPoolModificationCollectionEvent::TypeInfo = ZHMTypeInfo("AI.Private.SPoolModificationCollectionEvent", sizeof(AI_Private_SPoolModificationCollectionEvent), alignof(AI_Private_SPoolModificationCollectionEvent), AI_Private_SPoolModificationCollectionEvent::WriteSimpleJson, AI_Private_SPoolModificationCollectionEvent::FromSimpleJson, AI_Private_SPoolModificationCollectionEvent::Serialize, AI_Private_SPoolModificationCollectionEvent::Equals, AI_Private_SPoolModificationCollectionEvent::Destroy);

void AI_Private_SPoolModificationCollectionEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolModificationCollectionEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("PoolModificationEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->PoolModificationEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->PoolModificationEvents[i];
		AI_Private_SPoolModificationEvent::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->PoolModificationEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void AI_Private_SPoolModificationCollectionEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_Private_SPoolModificationCollectionEvent s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["PoolModificationEvents"];
	s_Object.PoolModificationEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		AI_Private_SPoolModificationEvent s_ArrayItem0;
		AI_Private_SPoolModificationEvent::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.PoolModificationEvents[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<AI_Private_SPoolModificationCollectionEvent*>(p_Target) = s_Object;
}

void AI_Private_SPoolModificationCollectionEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolModificationCollectionEvent*>(p_Object);

	TArray<AI_Private_SPoolModificationEvent>::Serialize(&s_Object->PoolModificationEvents, p_Serializer, p_OwnOffset + offsetof(AI_Private_SPoolModificationCollectionEvent, PoolModificationEvents));
}

bool AI_Private_SPoolModificationCollectionEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_Private_SPoolModificationCollectionEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_Private_SPoolModificationCollectionEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_Private_SPoolModificationCollectionEvent::operator==(const AI_Private_SPoolModificationCollectionEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_Private_SPoolModificationCollectionEvent>)
		return false;

	if (PoolModificationEvents != p_Other.PoolModificationEvents) return false;

	return true;
}

void AI_Private_SPoolModificationCollectionEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_Private_SPoolModificationCollectionEvent*>(p_Object);
	s_Object->~AI_Private_SPoolModificationCollectionEvent();
}

ZHMTypeInfo AI_SEventDescription::TypeInfo = ZHMTypeInfo("AI.SEventDescription", sizeof(AI_SEventDescription), alignof(AI_SEventDescription), AI_SEventDescription::WriteSimpleJson, AI_SEventDescription::FromSimpleJson, AI_SEventDescription::Serialize, AI_SEventDescription::Equals, AI_SEventDescription::Destroy);

void AI_SEventDescription::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_SEventDescription*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eEventType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eEventType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPulsing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPulsing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLoudness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLoudness);

	p_Stream << "}";
}

void AI_SEventDescription::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_SEventDescription s_Object {};

	s_Object.m_eEventType = static_cast<EAIEventType>(ZHMEnums::GetEnumValueByName("EAIEventType", std::string_view(p_Document["m_eEventType"])));

	s_Object.m_bPulsing = simdjson::from_json_bool(p_Document["m_bPulsing"]);

	s_Object.m_fRange = simdjson::from_json_float32(p_Document["m_fRange"]);

	s_Object.m_fLoudness = simdjson::from_json_float32(p_Document["m_fLoudness"]);

	*reinterpret_cast<AI_SEventDescription*>(p_Target) = s_Object;
}

void AI_SEventDescription::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_SEventDescription*>(p_Object);

}

bool AI_SEventDescription::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_SEventDescription*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_SEventDescription*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_SEventDescription::operator==(const AI_SEventDescription& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_SEventDescription>)
		return false;

	if (m_eEventType != p_Other.m_eEventType) return false;
	if (m_bPulsing != p_Other.m_bPulsing) return false;
	if (m_fRange != p_Other.m_fRange) return false;
	if (m_fLoudness != p_Other.m_fLoudness) return false;

	return true;
}

void AI_SEventDescription::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_SEventDescription*>(p_Object);
	s_Object->~AI_SEventDescription();
}

ZHMTypeInfo AI_SFirePattern01_SData::TypeInfo = ZHMTypeInfo("AI.SFirePattern01.SData", sizeof(AI_SFirePattern01_SData), alignof(AI_SFirePattern01_SData), AI_SFirePattern01_SData::WriteSimpleJson, AI_SFirePattern01_SData::FromSimpleJson, AI_SFirePattern01_SData::Serialize, AI_SFirePattern01_SData::Equals, AI_SFirePattern01_SData::Destroy);

void AI_SFirePattern01_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern01_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_BulletsToFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_BulletsToFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_WaitMinSeconds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_WaitMinSeconds);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_WaitMaxSeconds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_WaitMaxSeconds);

	p_Stream << "}";
}

void AI_SFirePattern01_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_SFirePattern01_SData s_Object {};

	s_Object.m_BulletsToFire = simdjson::from_json_uint32(p_Document["m_BulletsToFire"]);

	s_Object.m_WaitMinSeconds = simdjson::from_json_float32(p_Document["m_WaitMinSeconds"]);

	s_Object.m_WaitMaxSeconds = simdjson::from_json_float32(p_Document["m_WaitMaxSeconds"]);

	*reinterpret_cast<AI_SFirePattern01_SData*>(p_Target) = s_Object;
}

void AI_SFirePattern01_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern01_SData*>(p_Object);

}

bool AI_SFirePattern01_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_SFirePattern01_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_SFirePattern01_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_SFirePattern01_SData::operator==(const AI_SFirePattern01_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_SFirePattern01_SData>)
		return false;

	if (m_BulletsToFire != p_Other.m_BulletsToFire) return false;
	if (m_WaitMinSeconds != p_Other.m_WaitMinSeconds) return false;
	if (m_WaitMaxSeconds != p_Other.m_WaitMaxSeconds) return false;

	return true;
}

void AI_SFirePattern01_SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern01_SData*>(p_Object);
	s_Object->~AI_SFirePattern01_SData();
}

ZHMTypeInfo AI_SFirePattern01::TypeInfo = ZHMTypeInfo("AI.SFirePattern01", sizeof(AI_SFirePattern01), alignof(AI_SFirePattern01), AI_SFirePattern01::WriteSimpleJson, AI_SFirePattern01::FromSimpleJson, AI_SFirePattern01::Serialize, AI_SFirePattern01::Equals, AI_SFirePattern01::Destroy);

void AI_SFirePattern01::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern01*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_PatternSequenceData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_PatternSequenceData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_PatternSequenceData[i];
		AI_SFirePattern01_SData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_PatternSequenceData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void AI_SFirePattern01::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_SFirePattern01 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_PatternSequenceData"];
	s_Object.m_PatternSequenceData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		AI_SFirePattern01_SData s_ArrayItem0;
		AI_SFirePattern01_SData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_PatternSequenceData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<AI_SFirePattern01*>(p_Target) = s_Object;
}

void AI_SFirePattern01::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern01*>(p_Object);

	TArray<AI_SFirePattern01_SData>::Serialize(&s_Object->m_PatternSequenceData, p_Serializer, p_OwnOffset + offsetof(AI_SFirePattern01, m_PatternSequenceData));
}

bool AI_SFirePattern01::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_SFirePattern01*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_SFirePattern01*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_SFirePattern01::operator==(const AI_SFirePattern01& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_SFirePattern01>)
		return false;

	if (m_PatternSequenceData != p_Other.m_PatternSequenceData) return false;

	return true;
}

void AI_SFirePattern01::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern01*>(p_Object);
	s_Object->~AI_SFirePattern01();
}

ZHMTypeInfo AI_SFirePattern02_SData::TypeInfo = ZHMTypeInfo("AI.SFirePattern02.SData", sizeof(AI_SFirePattern02_SData), alignof(AI_SFirePattern02_SData), AI_SFirePattern02_SData::WriteSimpleJson, AI_SFirePattern02_SData::FromSimpleJson, AI_SFirePattern02_SData::Serialize, AI_SFirePattern02_SData::Equals, AI_SFirePattern02_SData::Destroy);

void AI_SFirePattern02_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern02_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_FireMinSeconds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_FireMinSeconds);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_FireMaxSeconds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_FireMaxSeconds);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_WaitMinSeconds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_WaitMinSeconds);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_WaitMaxSeconds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_WaitMaxSeconds);

	p_Stream << "}";
}

void AI_SFirePattern02_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_SFirePattern02_SData s_Object {};

	s_Object.m_FireMinSeconds = simdjson::from_json_float32(p_Document["m_FireMinSeconds"]);

	s_Object.m_FireMaxSeconds = simdjson::from_json_float32(p_Document["m_FireMaxSeconds"]);

	s_Object.m_WaitMinSeconds = simdjson::from_json_float32(p_Document["m_WaitMinSeconds"]);

	s_Object.m_WaitMaxSeconds = simdjson::from_json_float32(p_Document["m_WaitMaxSeconds"]);

	*reinterpret_cast<AI_SFirePattern02_SData*>(p_Target) = s_Object;
}

void AI_SFirePattern02_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern02_SData*>(p_Object);

}

bool AI_SFirePattern02_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_SFirePattern02_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_SFirePattern02_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_SFirePattern02_SData::operator==(const AI_SFirePattern02_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_SFirePattern02_SData>)
		return false;

	if (m_FireMinSeconds != p_Other.m_FireMinSeconds) return false;
	if (m_FireMaxSeconds != p_Other.m_FireMaxSeconds) return false;
	if (m_WaitMinSeconds != p_Other.m_WaitMinSeconds) return false;
	if (m_WaitMaxSeconds != p_Other.m_WaitMaxSeconds) return false;

	return true;
}

void AI_SFirePattern02_SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern02_SData*>(p_Object);
	s_Object->~AI_SFirePattern02_SData();
}

ZHMTypeInfo AI_SFirePattern02::TypeInfo = ZHMTypeInfo("AI.SFirePattern02", sizeof(AI_SFirePattern02), alignof(AI_SFirePattern02), AI_SFirePattern02::WriteSimpleJson, AI_SFirePattern02::FromSimpleJson, AI_SFirePattern02::Serialize, AI_SFirePattern02::Equals, AI_SFirePattern02::Destroy);

void AI_SFirePattern02::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern02*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_PatternSequenceData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_PatternSequenceData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_PatternSequenceData[i];
		AI_SFirePattern02_SData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_PatternSequenceData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void AI_SFirePattern02::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_SFirePattern02 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_PatternSequenceData"];
	s_Object.m_PatternSequenceData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		AI_SFirePattern02_SData s_ArrayItem0;
		AI_SFirePattern02_SData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_PatternSequenceData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<AI_SFirePattern02*>(p_Target) = s_Object;
}

void AI_SFirePattern02::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern02*>(p_Object);

	TArray<AI_SFirePattern02_SData>::Serialize(&s_Object->m_PatternSequenceData, p_Serializer, p_OwnOffset + offsetof(AI_SFirePattern02, m_PatternSequenceData));
}

bool AI_SFirePattern02::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_SFirePattern02*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_SFirePattern02*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_SFirePattern02::operator==(const AI_SFirePattern02& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_SFirePattern02>)
		return false;

	if (m_PatternSequenceData != p_Other.m_PatternSequenceData) return false;

	return true;
}

void AI_SFirePattern02::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_SFirePattern02*>(p_Object);
	s_Object->~AI_SFirePattern02();
}

ZHMTypeInfo AI_SSoundEventModifierState::TypeInfo = ZHMTypeInfo("AI.SSoundEventModifierState", sizeof(AI_SSoundEventModifierState), alignof(AI_SSoundEventModifierState), AI_SSoundEventModifierState::WriteSimpleJson, AI_SSoundEventModifierState::FromSimpleJson, AI_SSoundEventModifierState::Serialize, AI_SSoundEventModifierState::Equals, AI_SSoundEventModifierState::Destroy);

void AI_SSoundEventModifierState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AI_SSoundEventModifierState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fRangeModifier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRangeModifier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLoudnessModifier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLoudnessModifier);

	p_Stream << "}";
}

void AI_SSoundEventModifierState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AI_SSoundEventModifierState s_Object {};

	s_Object.m_fRangeModifier = simdjson::from_json_float32(p_Document["m_fRangeModifier"]);

	s_Object.m_fLoudnessModifier = simdjson::from_json_float32(p_Document["m_fLoudnessModifier"]);

	*reinterpret_cast<AI_SSoundEventModifierState*>(p_Target) = s_Object;
}

void AI_SSoundEventModifierState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AI_SSoundEventModifierState*>(p_Object);

}

bool AI_SSoundEventModifierState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AI_SSoundEventModifierState*>(p_Left);
	auto* s_Right = reinterpret_cast<AI_SSoundEventModifierState*>(p_Right);

	return *s_Left == *s_Right;
}

bool AI_SSoundEventModifierState::operator==(const AI_SSoundEventModifierState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AI_SSoundEventModifierState>)
		return false;

	if (m_fRangeModifier != p_Other.m_fRangeModifier) return false;
	if (m_fLoudnessModifier != p_Other.m_fLoudnessModifier) return false;

	return true;
}

void AI_SSoundEventModifierState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AI_SSoundEventModifierState*>(p_Object);
	s_Object->~AI_SSoundEventModifierState();
}

ZHMTypeInfo AnimationEventDataTypes_SBlend::TypeInfo = ZHMTypeInfo("AnimationEventDataTypes.SBlend", sizeof(AnimationEventDataTypes_SBlend), alignof(AnimationEventDataTypes_SBlend), AnimationEventDataTypes_SBlend::WriteSimpleJson, AnimationEventDataTypes_SBlend::FromSimpleJson, AnimationEventDataTypes_SBlend::Serialize, AnimationEventDataTypes_SBlend::Equals, AnimationEventDataTypes_SBlend::Destroy);

void AnimationEventDataTypes_SBlend::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fBlendTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fBlendTime);

	p_Stream << "}";
}

void AnimationEventDataTypes_SBlend::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AnimationEventDataTypes_SBlend s_Object {};

	s_Object.m_fBlendTime = simdjson::from_json_float32(p_Document["m_fBlendTime"]);

	*reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Target) = s_Object;
}

void AnimationEventDataTypes_SBlend::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Object);

}

bool AnimationEventDataTypes_SBlend::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationEventDataTypes_SBlend::operator==(const AnimationEventDataTypes_SBlend& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationEventDataTypes_SBlend>)
		return false;

	if (m_fBlendTime != p_Other.m_fBlendTime) return false;

	return true;
}

void AnimationEventDataTypes_SBlend::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SBlend*>(p_Object);
	s_Object->~AnimationEventDataTypes_SBlend();
}

ZHMTypeInfo AnimationEventDataTypes_SLegacy::TypeInfo = ZHMTypeInfo("AnimationEventDataTypes.SLegacy", sizeof(AnimationEventDataTypes_SLegacy), alignof(AnimationEventDataTypes_SLegacy), AnimationEventDataTypes_SLegacy::WriteSimpleJson, AnimationEventDataTypes_SLegacy::FromSimpleJson, AnimationEventDataTypes_SLegacy::Serialize, AnimationEventDataTypes_SLegacy::Equals, AnimationEventDataTypes_SLegacy::Destroy);

void AnimationEventDataTypes_SLegacy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);

	p_Stream << "}";
}

void AnimationEventDataTypes_SLegacy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AnimationEventDataTypes_SLegacy s_Object {};

	s_Object.m_nEventID = simdjson::from_json_int32(p_Document["m_nEventID"]);

	*reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Target) = s_Object;
}

void AnimationEventDataTypes_SLegacy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Object);

}

bool AnimationEventDataTypes_SLegacy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationEventDataTypes_SLegacy::operator==(const AnimationEventDataTypes_SLegacy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationEventDataTypes_SLegacy>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;

	return true;
}

void AnimationEventDataTypes_SLegacy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AnimationEventDataTypes_SLegacy*>(p_Object);
	s_Object->~AnimationEventDataTypes_SLegacy();
}

ZHMTypeInfo ZRuntimeResourceID::TypeInfo = ZHMTypeInfo("ZRuntimeResourceID", sizeof(ZRuntimeResourceID), alignof(ZRuntimeResourceID), ZRuntimeResourceID::WriteSimpleJson, ZRuntimeResourceID::FromSimpleJson, ZRuntimeResourceID::Serialize, ZRuntimeResourceID::Equals, ZRuntimeResourceID::Destroy);

void ZRuntimeResourceID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_IDHigh") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDHigh);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IDLow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IDLow);

	p_Stream << "}";
}

void ZRuntimeResourceID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRuntimeResourceID s_Object {};

	s_Object.m_IDHigh = simdjson::from_json_uint32(p_Document["m_IDHigh"]);

	s_Object.m_IDLow = simdjson::from_json_uint32(p_Document["m_IDLow"]);

	*reinterpret_cast<ZRuntimeResourceID*>(p_Target) = s_Object;
}

void ZRuntimeResourceID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);

	p_Serializer.RegisterRuntimeResourceId(p_OwnOffset);
}

bool ZRuntimeResourceID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRuntimeResourceID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRuntimeResourceID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRuntimeResourceID::operator==(const ZRuntimeResourceID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRuntimeResourceID>)
		return false;

	if (m_IDHigh != p_Other.m_IDHigh) return false;
	if (m_IDLow != p_Other.m_IDLow) return false;

	return true;
}

void ZRuntimeResourceID::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZRuntimeResourceID*>(p_Object);
	s_Object->~ZRuntimeResourceID();
}

ZHMTypeInfo AnimationTakeDataTypes_SGeneric::TypeInfo = ZHMTypeInfo("AnimationTakeDataTypes.SGeneric", sizeof(AnimationTakeDataTypes_SGeneric), alignof(AnimationTakeDataTypes_SGeneric), AnimationTakeDataTypes_SGeneric::WriteSimpleJson, AnimationTakeDataTypes_SGeneric::FromSimpleJson, AnimationTakeDataTypes_SGeneric::Serialize, AnimationTakeDataTypes_SGeneric::Equals, AnimationTakeDataTypes_SGeneric::Destroy);

void AnimationTakeDataTypes_SGeneric::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fTest") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTest);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fResourceTest") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->m_fResourceTest, p_Stream);

	p_Stream << "}";
}

void AnimationTakeDataTypes_SGeneric::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	AnimationTakeDataTypes_SGeneric s_Object {};

	s_Object.m_fTest = simdjson::from_json_float32(p_Document["m_fTest"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["m_fResourceTest"], &s_Item);
		s_Object.m_fResourceTest = s_Item;
	}

	*reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Target) = s_Object;
}

void AnimationTakeDataTypes_SGeneric::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->m_fResourceTest, p_Serializer, p_OwnOffset + offsetof(AnimationTakeDataTypes_SGeneric, m_fResourceTest));
}

bool AnimationTakeDataTypes_SGeneric::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Left);
	auto* s_Right = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Right);

	return *s_Left == *s_Right;
}

bool AnimationTakeDataTypes_SGeneric::operator==(const AnimationTakeDataTypes_SGeneric& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<AnimationTakeDataTypes_SGeneric>)
		return false;

	if (m_fTest != p_Other.m_fTest) return false;
	if (m_fResourceTest != p_Other.m_fResourceTest) return false;

	return true;
}

void AnimationTakeDataTypes_SGeneric::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<AnimationTakeDataTypes_SGeneric*>(p_Object);
	s_Object->~AnimationTakeDataTypes_SGeneric();
}

ZHMTypeInfo BoneId::TypeInfo = ZHMTypeInfo("BoneId", sizeof(BoneId), alignof(BoneId), BoneId::WriteSimpleJson, BoneId::FromSimpleJson, BoneId::Serialize, BoneId::Equals, BoneId::Destroy);

void BoneId::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void BoneId::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	BoneId s_Object {};

	*reinterpret_cast<BoneId*>(p_Target) = s_Object;
}

void BoneId::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);

}

bool BoneId::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<BoneId*>(p_Left);
	auto* s_Right = reinterpret_cast<BoneId*>(p_Right);

	return *s_Left == *s_Right;
}

bool BoneId::operator==(const BoneId& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<BoneId>)
		return false;


	return true;
}

void BoneId::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<BoneId*>(p_Object);
	s_Object->~BoneId();
}

ZHMTypeInfo IActor::TypeInfo = ZHMTypeInfo("IActor", sizeof(IActor), alignof(IActor), IActor::WriteSimpleJson, IActor::FromSimpleJson, IActor::Serialize, IActor::Equals, IActor::Destroy);

void IActor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IActor s_Object {};

	*reinterpret_cast<IActor*>(p_Target) = s_Object;
}

void IActor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);

}

bool IActor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActor*>(p_Left);
	auto* s_Right = reinterpret_cast<IActor*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActor::operator==(const IActor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActor>)
		return false;


	return true;
}

void IActor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IActor*>(p_Object);
	s_Object->~IActor();
}

ZHMTypeInfo IActorProvider::TypeInfo = ZHMTypeInfo("IActorProvider", sizeof(IActorProvider), alignof(IActorProvider), IActorProvider::WriteSimpleJson, IActorProvider::FromSimpleJson, IActorProvider::Serialize, IActorProvider::Equals, IActorProvider::Destroy);

void IActorProvider::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActorProvider::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IActorProvider s_Object {};

	*reinterpret_cast<IActorProvider*>(p_Target) = s_Object;
}

void IActorProvider::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);

}

bool IActorProvider::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActorProvider*>(p_Left);
	auto* s_Right = reinterpret_cast<IActorProvider*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActorProvider::operator==(const IActorProvider& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActorProvider>)
		return false;


	return true;
}

void IActorProvider::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IActorProvider*>(p_Object);
	s_Object->~IActorProvider();
}

ZHMTypeInfo IActorProviderFilter::TypeInfo = ZHMTypeInfo("IActorProviderFilter", sizeof(IActorProviderFilter), alignof(IActorProviderFilter), IActorProviderFilter::WriteSimpleJson, IActorProviderFilter::FromSimpleJson, IActorProviderFilter::Serialize, IActorProviderFilter::Equals, IActorProviderFilter::Destroy);

void IActorProviderFilter::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IActorProviderFilter::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IActorProviderFilter s_Object {};

	*reinterpret_cast<IActorProviderFilter*>(p_Target) = s_Object;
}

void IActorProviderFilter::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);

}

bool IActorProviderFilter::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IActorProviderFilter*>(p_Left);
	auto* s_Right = reinterpret_cast<IActorProviderFilter*>(p_Right);

	return *s_Left == *s_Right;
}

bool IActorProviderFilter::operator==(const IActorProviderFilter& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IActorProviderFilter>)
		return false;


	return true;
}

void IActorProviderFilter::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IActorProviderFilter*>(p_Object);
	s_Object->~IActorProviderFilter();
}

ZHMTypeInfo IAnimPlayerEntity::TypeInfo = ZHMTypeInfo("IAnimPlayerEntity", sizeof(IAnimPlayerEntity), alignof(IAnimPlayerEntity), IAnimPlayerEntity::WriteSimpleJson, IAnimPlayerEntity::FromSimpleJson, IAnimPlayerEntity::Serialize, IAnimPlayerEntity::Equals, IAnimPlayerEntity::Destroy);

void IAnimPlayerEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IAnimPlayerEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IAnimPlayerEntity s_Object {};

	*reinterpret_cast<IAnimPlayerEntity*>(p_Target) = s_Object;
}

void IAnimPlayerEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);

}

bool IAnimPlayerEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IAnimPlayerEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IAnimPlayerEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IAnimPlayerEntity::operator==(const IAnimPlayerEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IAnimPlayerEntity>)
		return false;


	return true;
}

void IAnimPlayerEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IAnimPlayerEntity*>(p_Object);
	s_Object->~IAnimPlayerEntity();
}

ZHMTypeInfo IBodybagEntity::TypeInfo = ZHMTypeInfo("IBodybagEntity", sizeof(IBodybagEntity), alignof(IBodybagEntity), IBodybagEntity::WriteSimpleJson, IBodybagEntity::FromSimpleJson, IBodybagEntity::Serialize, IBodybagEntity::Equals, IBodybagEntity::Destroy);

void IBodybagEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBodybagEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBodybagEntity s_Object {};

	*reinterpret_cast<IBodybagEntity*>(p_Target) = s_Object;
}

void IBodybagEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);

}

bool IBodybagEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBodybagEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IBodybagEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBodybagEntity::operator==(const IBodybagEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBodybagEntity>)
		return false;


	return true;
}

void IBodybagEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IBodybagEntity*>(p_Object);
	s_Object->~IBodybagEntity();
}

ZHMTypeInfo IBoneAnimator::TypeInfo = ZHMTypeInfo("IBoneAnimator", sizeof(IBoneAnimator), alignof(IBoneAnimator), IBoneAnimator::WriteSimpleJson, IBoneAnimator::FromSimpleJson, IBoneAnimator::Serialize, IBoneAnimator::Equals, IBoneAnimator::Destroy);

void IBoneAnimator::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBoneAnimator::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBoneAnimator s_Object {};

	*reinterpret_cast<IBoneAnimator*>(p_Target) = s_Object;
}

void IBoneAnimator::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);

}

bool IBoneAnimator::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBoneAnimator*>(p_Left);
	auto* s_Right = reinterpret_cast<IBoneAnimator*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBoneAnimator::operator==(const IBoneAnimator& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBoneAnimator>)
		return false;


	return true;
}

void IBoneAnimator::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IBoneAnimator*>(p_Object);
	s_Object->~IBoneAnimator();
}

ZHMTypeInfo IBoneCollidable::TypeInfo = ZHMTypeInfo("IBoneCollidable", sizeof(IBoneCollidable), alignof(IBoneCollidable), IBoneCollidable::WriteSimpleJson, IBoneCollidable::FromSimpleJson, IBoneCollidable::Serialize, IBoneCollidable::Equals, IBoneCollidable::Destroy);

void IBoneCollidable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBoneCollidable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBoneCollidable s_Object {};

	*reinterpret_cast<IBoneCollidable*>(p_Target) = s_Object;
}

void IBoneCollidable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);

}

bool IBoneCollidable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBoneCollidable*>(p_Left);
	auto* s_Right = reinterpret_cast<IBoneCollidable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBoneCollidable::operator==(const IBoneCollidable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBoneCollidable>)
		return false;


	return true;
}

void IBoneCollidable::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IBoneCollidable*>(p_Object);
	s_Object->~IBoneCollidable();
}

ZHMTypeInfo IBulletImpactListener::TypeInfo = ZHMTypeInfo("IBulletImpactListener", sizeof(IBulletImpactListener), alignof(IBulletImpactListener), IBulletImpactListener::WriteSimpleJson, IBulletImpactListener::FromSimpleJson, IBulletImpactListener::Serialize, IBulletImpactListener::Equals, IBulletImpactListener::Destroy);

void IBulletImpactListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IBulletImpactListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IBulletImpactListener s_Object {};

	*reinterpret_cast<IBulletImpactListener*>(p_Target) = s_Object;
}

void IBulletImpactListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);

}

bool IBulletImpactListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IBulletImpactListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IBulletImpactListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IBulletImpactListener::operator==(const IBulletImpactListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IBulletImpactListener>)
		return false;


	return true;
}

void IBulletImpactListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IBulletImpactListener*>(p_Object);
	s_Object->~IBulletImpactListener();
}

ZHMTypeInfo IComponentInterface::TypeInfo = ZHMTypeInfo("IComponentInterface", sizeof(IComponentInterface), alignof(IComponentInterface), IComponentInterface::WriteSimpleJson, IComponentInterface::FromSimpleJson, IComponentInterface::Serialize, IComponentInterface::Equals, IComponentInterface::Destroy);

void IComponentInterface::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IComponentInterface::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IComponentInterface s_Object {};

	*reinterpret_cast<IComponentInterface*>(p_Target) = s_Object;
}

void IComponentInterface::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);

}

bool IComponentInterface::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IComponentInterface*>(p_Left);
	auto* s_Right = reinterpret_cast<IComponentInterface*>(p_Right);

	return *s_Left == *s_Right;
}

bool IComponentInterface::operator==(const IComponentInterface& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IComponentInterface>)
		return false;


	return true;
}

void IComponentInterface::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IComponentInterface*>(p_Object);
	s_Object->~IComponentInterface();
}

ZHMTypeInfo IContractEvaluationContextListener::TypeInfo = ZHMTypeInfo("IContractEvaluationContextListener", sizeof(IContractEvaluationContextListener), alignof(IContractEvaluationContextListener), IContractEvaluationContextListener::WriteSimpleJson, IContractEvaluationContextListener::FromSimpleJson, IContractEvaluationContextListener::Serialize, IContractEvaluationContextListener::Equals, IContractEvaluationContextListener::Destroy);

void IContractEvaluationContextListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IContractEvaluationContextListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IContractEvaluationContextListener s_Object {};

	*reinterpret_cast<IContractEvaluationContextListener*>(p_Target) = s_Object;
}

void IContractEvaluationContextListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);

}

bool IContractEvaluationContextListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractEvaluationContextListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractEvaluationContextListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractEvaluationContextListener::operator==(const IContractEvaluationContextListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractEvaluationContextListener>)
		return false;


	return true;
}

void IContractEvaluationContextListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IContractEvaluationContextListener*>(p_Object);
	s_Object->~IContractEvaluationContextListener();
}

ZHMTypeInfo IContractModule::TypeInfo = ZHMTypeInfo("IContractModule", sizeof(IContractModule), alignof(IContractModule), IContractModule::WriteSimpleJson, IContractModule::FromSimpleJson, IContractModule::Serialize, IContractModule::Equals, IContractModule::Destroy);

void IContractModule::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractModule*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IContractModule::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IContractModule s_Object {};

	*reinterpret_cast<IContractModule*>(p_Target) = s_Object;
}

void IContractModule::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractModule*>(p_Object);

}

bool IContractModule::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractModule*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractModule*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractModule::operator==(const IContractModule& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractModule>)
		return false;


	return true;
}

void IContractModule::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IContractModule*>(p_Object);
	s_Object->~IContractModule();
}

ZHMTypeInfo IContractObjective::TypeInfo = ZHMTypeInfo("IContractObjective", sizeof(IContractObjective), alignof(IContractObjective), IContractObjective::WriteSimpleJson, IContractObjective::FromSimpleJson, IContractObjective::Serialize, IContractObjective::Equals, IContractObjective::Destroy);

void IContractObjective::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IContractObjective::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IContractObjective s_Object {};

	*reinterpret_cast<IContractObjective*>(p_Target) = s_Object;
}

void IContractObjective::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);

}

bool IContractObjective::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractObjective*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractObjective*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractObjective::operator==(const IContractObjective& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractObjective>)
		return false;


	return true;
}

void IContractObjective::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IContractObjective*>(p_Object);
	s_Object->~IContractObjective();
}

ZHMTypeInfo ZDynamicObject::TypeInfo = ZHMTypeInfo("ZDynamicObject", sizeof(ZDynamicObject), alignof(ZDynamicObject), ZDynamicObject::WriteSimpleJson, ZDynamicObject::FromSimpleJson, ZDynamicObject::Serialize, ZDynamicObject::Equals, ZDynamicObject::Destroy);

void ZDynamicObject::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_value, p_Stream);

	p_Stream << "}";
}

void ZDynamicObject::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDynamicObject s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_value"], &s_Item);
		s_Object.m_value = s_Item;
	}

	*reinterpret_cast<ZDynamicObject*>(p_Target) = s_Object;
}

void ZDynamicObject::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);

	ZVariant::Serialize(&s_Object->m_value, p_Serializer, p_OwnOffset + offsetof(ZDynamicObject, m_value));
}

bool ZDynamicObject::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDynamicObject*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDynamicObject*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDynamicObject::operator==(const ZDynamicObject& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDynamicObject>)
		return false;

	if (m_value != p_Other.m_value) return false;

	return true;
}

void ZDynamicObject::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject*>(p_Object);
	s_Object->~ZDynamicObject();
}

ZHMTypeInfo IContractObjective_SCounterData::TypeInfo = ZHMTypeInfo("IContractObjective.SCounterData", sizeof(IContractObjective_SCounterData), alignof(IContractObjective_SCounterData), IContractObjective_SCounterData::WriteSimpleJson, IContractObjective_SCounterData::FromSimpleJson, IContractObjective_SCounterData::Serialize, IContractObjective_SCounterData::Equals, IContractObjective_SCounterData::Destroy);

void IContractObjective_SCounterData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractObjective_SCounterData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDeactivate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDeactivate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_dExtraData") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_dExtraData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.SCounterData.ECounterType", static_cast<int>(s_Object->m_eType)));

	p_Stream << "}";
}

void IContractObjective_SCounterData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IContractObjective_SCounterData s_Object {};

	s_Object.m_sHeader = std::string_view(p_Document["m_sHeader"]);

	s_Object.m_nCount = simdjson::from_json_int32(p_Document["m_nCount"]);

	s_Object.m_nDeactivate = simdjson::from_json_int32(p_Document["m_nDeactivate"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_dExtraData"], &s_Item);
		s_Object.m_dExtraData = s_Item;
	}

	s_Object.m_eType = static_cast<IContractObjective_SCounterData_ECounterType>(ZHMEnums::GetEnumValueByName("IContractObjective.SCounterData.ECounterType", std::string_view(p_Document["m_eType"])));

	*reinterpret_cast<IContractObjective_SCounterData*>(p_Target) = s_Object;
}

void IContractObjective_SCounterData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractObjective_SCounterData*>(p_Object);

	ZString::Serialize(&s_Object->m_sHeader, p_Serializer, p_OwnOffset + offsetof(IContractObjective_SCounterData, m_sHeader));
	ZDynamicObject::Serialize(&s_Object->m_dExtraData, p_Serializer, p_OwnOffset + offsetof(IContractObjective_SCounterData, m_dExtraData));
}

bool IContractObjective_SCounterData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractObjective_SCounterData*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractObjective_SCounterData*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractObjective_SCounterData::operator==(const IContractObjective_SCounterData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractObjective_SCounterData>)
		return false;

	if (m_sHeader != p_Other.m_sHeader) return false;
	if (m_nCount != p_Other.m_nCount) return false;
	if (m_nDeactivate != p_Other.m_nDeactivate) return false;
	if (m_dExtraData != p_Other.m_dExtraData) return false;
	if (m_eType != p_Other.m_eType) return false;

	return true;
}

void IContractObjective_SCounterData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IContractObjective_SCounterData*>(p_Object);
	s_Object->~IContractObjective_SCounterData();
}

ZHMTypeInfo ZGuid::TypeInfo = ZHMTypeInfo("ZGuid", sizeof(ZGuid), alignof(ZGuid), ZGuid::WriteSimpleJson, ZGuid::FromSimpleJson, ZGuid::Serialize, ZGuid::Equals, ZGuid::Destroy);

void ZGuid::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("_a") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_a);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_b);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_c") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_c);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_d") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_d);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_e") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_e);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_f") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_f);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_h") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_h);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_i") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_i);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_j") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_j);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_k") << ":";
	p_Stream << simdjson::as_json_string(s_Object->_k);

	p_Stream << "}";
}

void ZGuid::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGuid s_Object {};

	s_Object._a = simdjson::from_json_uint32(p_Document["_a"]);

	s_Object._b = simdjson::from_json_uint16(p_Document["_b"]);

	s_Object._c = simdjson::from_json_uint16(p_Document["_c"]);

	s_Object._d = simdjson::from_json_uint8(p_Document["_d"]);

	s_Object._e = simdjson::from_json_uint8(p_Document["_e"]);

	s_Object._f = simdjson::from_json_uint8(p_Document["_f"]);

	s_Object._g = simdjson::from_json_uint8(p_Document["_g"]);

	s_Object._h = simdjson::from_json_uint8(p_Document["_h"]);

	s_Object._i = simdjson::from_json_uint8(p_Document["_i"]);

	s_Object._j = simdjson::from_json_uint8(p_Document["_j"]);

	s_Object._k = simdjson::from_json_uint8(p_Document["_k"]);

	*reinterpret_cast<ZGuid*>(p_Target) = s_Object;
}

void ZGuid::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);

}

bool ZGuid::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGuid*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGuid*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGuid::operator==(const ZGuid& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGuid>)
		return false;

	if (_a != p_Other._a) return false;
	if (_b != p_Other._b) return false;
	if (_c != p_Other._c) return false;
	if (_d != p_Other._d) return false;
	if (_e != p_Other._e) return false;
	if (_f != p_Other._f) return false;
	if (_g != p_Other._g) return false;
	if (_h != p_Other._h) return false;
	if (_i != p_Other._i) return false;
	if (_j != p_Other._j) return false;
	if (_k != p_Other._k) return false;

	return true;
}

void ZGuid::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGuid*>(p_Object);
	s_Object->~ZGuid();
}

ZHMTypeInfo IContractObjective_STargetCondition::TypeInfo = ZHMTypeInfo("IContractObjective.STargetCondition", sizeof(IContractObjective_STargetCondition), alignof(IContractObjective_STargetCondition), IContractObjective_STargetCondition::WriteSimpleJson, IContractObjective_STargetCondition::FromSimpleJson, IContractObjective_STargetCondition::Serialize, IContractObjective_STargetCondition::Equals, IContractObjective_STargetCondition::Destroy);

void IContractObjective_STargetCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IContractObjective_STargetCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repositoryId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->repositoryId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("hardCondition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->hardCondition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveId") << ":";
	ZGuid::WriteSimpleJson(&s_Object->objectiveId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sKillMethod") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sKillMethod);

	p_Stream << "}";
}

void IContractObjective_STargetCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IContractObjective_STargetCondition s_Object {};

	s_Object.type = std::string_view(p_Document["type"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["repositoryId"], &s_Item);
		s_Object.repositoryId = s_Item;
	}

	s_Object.hardCondition = simdjson::from_json_bool(p_Document["hardCondition"]);

	{
		ZGuid s_Item {};
		ZGuid::FromSimpleJson(p_Document["objectiveId"], &s_Item);
		s_Object.objectiveId = s_Item;
	}

	s_Object.sKillMethod = std::string_view(p_Document["sKillMethod"]);

	*reinterpret_cast<IContractObjective_STargetCondition*>(p_Target) = s_Object;
}

void IContractObjective_STargetCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IContractObjective_STargetCondition*>(p_Object);

	ZString::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(IContractObjective_STargetCondition, type));
	ZRepositoryID::Serialize(&s_Object->repositoryId, p_Serializer, p_OwnOffset + offsetof(IContractObjective_STargetCondition, repositoryId));
	ZGuid::Serialize(&s_Object->objectiveId, p_Serializer, p_OwnOffset + offsetof(IContractObjective_STargetCondition, objectiveId));
	ZString::Serialize(&s_Object->sKillMethod, p_Serializer, p_OwnOffset + offsetof(IContractObjective_STargetCondition, sKillMethod));
}

bool IContractObjective_STargetCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IContractObjective_STargetCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<IContractObjective_STargetCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool IContractObjective_STargetCondition::operator==(const IContractObjective_STargetCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IContractObjective_STargetCondition>)
		return false;

	if (type != p_Other.type) return false;
	if (repositoryId != p_Other.repositoryId) return false;
	if (hardCondition != p_Other.hardCondition) return false;
	if (objectiveId != p_Other.objectiveId) return false;
	if (sKillMethod != p_Other.sKillMethod) return false;

	return true;
}

void IContractObjective_STargetCondition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IContractObjective_STargetCondition*>(p_Object);
	s_Object->~IContractObjective_STargetCondition();
}

ZHMTypeInfo IEscortOutSituation::TypeInfo = ZHMTypeInfo("IEscortOutSituation", sizeof(IEscortOutSituation), alignof(IEscortOutSituation), IEscortOutSituation::WriteSimpleJson, IEscortOutSituation::FromSimpleJson, IEscortOutSituation::Serialize, IEscortOutSituation::Equals, IEscortOutSituation::Destroy);

void IEscortOutSituation::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IEscortOutSituation::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IEscortOutSituation s_Object {};

	*reinterpret_cast<IEscortOutSituation*>(p_Target) = s_Object;
}

void IEscortOutSituation::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);

}

bool IEscortOutSituation::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IEscortOutSituation*>(p_Left);
	auto* s_Right = reinterpret_cast<IEscortOutSituation*>(p_Right);

	return *s_Left == *s_Right;
}

bool IEscortOutSituation::operator==(const IEscortOutSituation& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IEscortOutSituation>)
		return false;


	return true;
}

void IEscortOutSituation::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IEscortOutSituation*>(p_Object);
	s_Object->~IEscortOutSituation();
}

ZHMTypeInfo IEventConsumerCollection::TypeInfo = ZHMTypeInfo("IEventConsumerCollection", sizeof(IEventConsumerCollection), alignof(IEventConsumerCollection), IEventConsumerCollection::WriteSimpleJson, IEventConsumerCollection::FromSimpleJson, IEventConsumerCollection::Serialize, IEventConsumerCollection::Equals, IEventConsumerCollection::Destroy);

void IEventConsumerCollection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IEventConsumerCollection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IEventConsumerCollection s_Object {};

	*reinterpret_cast<IEventConsumerCollection*>(p_Target) = s_Object;
}

void IEventConsumerCollection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);

}

bool IEventConsumerCollection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IEventConsumerCollection*>(p_Left);
	auto* s_Right = reinterpret_cast<IEventConsumerCollection*>(p_Right);

	return *s_Left == *s_Right;
}

bool IEventConsumerCollection::operator==(const IEventConsumerCollection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IEventConsumerCollection>)
		return false;


	return true;
}

void IEventConsumerCollection::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IEventConsumerCollection*>(p_Object);
	s_Object->~IEventConsumerCollection();
}

ZHMTypeInfo IFreeCameraControl::TypeInfo = ZHMTypeInfo("IFreeCameraControl", sizeof(IFreeCameraControl), alignof(IFreeCameraControl), IFreeCameraControl::WriteSimpleJson, IFreeCameraControl::FromSimpleJson, IFreeCameraControl::Serialize, IFreeCameraControl::Equals, IFreeCameraControl::Destroy);

void IFreeCameraControl::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IFreeCameraControl::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IFreeCameraControl s_Object {};

	*reinterpret_cast<IFreeCameraControl*>(p_Target) = s_Object;
}

void IFreeCameraControl::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);

}

bool IFreeCameraControl::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IFreeCameraControl*>(p_Left);
	auto* s_Right = reinterpret_cast<IFreeCameraControl*>(p_Right);

	return *s_Left == *s_Right;
}

bool IFreeCameraControl::operator==(const IFreeCameraControl& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IFreeCameraControl>)
		return false;


	return true;
}

void IFreeCameraControl::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IFreeCameraControl*>(p_Object);
	s_Object->~IFreeCameraControl();
}

ZHMTypeInfo IHM5WeaponInventory::TypeInfo = ZHMTypeInfo("IHM5WeaponInventory", sizeof(IHM5WeaponInventory), alignof(IHM5WeaponInventory), IHM5WeaponInventory::WriteSimpleJson, IHM5WeaponInventory::FromSimpleJson, IHM5WeaponInventory::Serialize, IHM5WeaponInventory::Equals, IHM5WeaponInventory::Destroy);

void IHM5WeaponInventory::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHM5WeaponInventory::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IHM5WeaponInventory s_Object {};

	*reinterpret_cast<IHM5WeaponInventory*>(p_Target) = s_Object;
}

void IHM5WeaponInventory::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);

}

bool IHM5WeaponInventory::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHM5WeaponInventory*>(p_Left);
	auto* s_Right = reinterpret_cast<IHM5WeaponInventory*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHM5WeaponInventory::operator==(const IHM5WeaponInventory& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHM5WeaponInventory>)
		return false;


	return true;
}

void IHM5WeaponInventory::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IHM5WeaponInventory*>(p_Object);
	s_Object->~IHM5WeaponInventory();
}

ZHMTypeInfo IHumanBody::TypeInfo = ZHMTypeInfo("IHumanBody", sizeof(IHumanBody), alignof(IHumanBody), IHumanBody::WriteSimpleJson, IHumanBody::FromSimpleJson, IHumanBody::Serialize, IHumanBody::Equals, IHumanBody::Destroy);

void IHumanBody::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IHumanBody::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IHumanBody s_Object {};

	*reinterpret_cast<IHumanBody*>(p_Target) = s_Object;
}

void IHumanBody::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);

}

bool IHumanBody::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IHumanBody*>(p_Left);
	auto* s_Right = reinterpret_cast<IHumanBody*>(p_Right);

	return *s_Left == *s_Right;
}

bool IHumanBody::operator==(const IHumanBody& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IHumanBody>)
		return false;


	return true;
}

void IHumanBody::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IHumanBody*>(p_Object);
	s_Object->~IHumanBody();
}

ZHMTypeInfo IMetricValue::TypeInfo = ZHMTypeInfo("IMetricValue", sizeof(IMetricValue), alignof(IMetricValue), IMetricValue::WriteSimpleJson, IMetricValue::FromSimpleJson, IMetricValue::Serialize, IMetricValue::Equals, IMetricValue::Destroy);

void IMetricValue::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMetricValue::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMetricValue s_Object {};

	*reinterpret_cast<IMetricValue*>(p_Target) = s_Object;
}

void IMetricValue::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);

}

bool IMetricValue::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMetricValue*>(p_Left);
	auto* s_Right = reinterpret_cast<IMetricValue*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMetricValue::operator==(const IMetricValue& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMetricValue>)
		return false;


	return true;
}

void IMetricValue::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IMetricValue*>(p_Object);
	s_Object->~IMetricValue();
}

ZHMTypeInfo IMorphemeCutSequenceAnimatable::TypeInfo = ZHMTypeInfo("IMorphemeCutSequenceAnimatable", sizeof(IMorphemeCutSequenceAnimatable), alignof(IMorphemeCutSequenceAnimatable), IMorphemeCutSequenceAnimatable::WriteSimpleJson, IMorphemeCutSequenceAnimatable::FromSimpleJson, IMorphemeCutSequenceAnimatable::Serialize, IMorphemeCutSequenceAnimatable::Equals, IMorphemeCutSequenceAnimatable::Destroy);

void IMorphemeCutSequenceAnimatable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeCutSequenceAnimatable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMorphemeCutSequenceAnimatable s_Object {};

	*reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Target) = s_Object;
}

void IMorphemeCutSequenceAnimatable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);

}

bool IMorphemeCutSequenceAnimatable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeCutSequenceAnimatable::operator==(const IMorphemeCutSequenceAnimatable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeCutSequenceAnimatable>)
		return false;


	return true;
}

void IMorphemeCutSequenceAnimatable::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimatable*>(p_Object);
	s_Object->~IMorphemeCutSequenceAnimatable();
}

ZHMTypeInfo IMorphemeCutSequenceAnimationEntity::TypeInfo = ZHMTypeInfo("IMorphemeCutSequenceAnimationEntity", sizeof(IMorphemeCutSequenceAnimationEntity), alignof(IMorphemeCutSequenceAnimationEntity), IMorphemeCutSequenceAnimationEntity::WriteSimpleJson, IMorphemeCutSequenceAnimationEntity::FromSimpleJson, IMorphemeCutSequenceAnimationEntity::Serialize, IMorphemeCutSequenceAnimationEntity::Equals, IMorphemeCutSequenceAnimationEntity::Destroy);

void IMorphemeCutSequenceAnimationEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeCutSequenceAnimationEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMorphemeCutSequenceAnimationEntity s_Object {};

	*reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Target) = s_Object;
}

void IMorphemeCutSequenceAnimationEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);

}

bool IMorphemeCutSequenceAnimationEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeCutSequenceAnimationEntity::operator==(const IMorphemeCutSequenceAnimationEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeCutSequenceAnimationEntity>)
		return false;


	return true;
}

void IMorphemeCutSequenceAnimationEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IMorphemeCutSequenceAnimationEntity*>(p_Object);
	s_Object->~IMorphemeCutSequenceAnimationEntity();
}

ZHMTypeInfo IMorphemeEventConsumer::TypeInfo = ZHMTypeInfo("IMorphemeEventConsumer", sizeof(IMorphemeEventConsumer), alignof(IMorphemeEventConsumer), IMorphemeEventConsumer::WriteSimpleJson, IMorphemeEventConsumer::FromSimpleJson, IMorphemeEventConsumer::Serialize, IMorphemeEventConsumer::Equals, IMorphemeEventConsumer::Destroy);

void IMorphemeEventConsumer::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IMorphemeEventConsumer::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IMorphemeEventConsumer s_Object {};

	*reinterpret_cast<IMorphemeEventConsumer*>(p_Target) = s_Object;
}

void IMorphemeEventConsumer::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);

}

bool IMorphemeEventConsumer::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IMorphemeEventConsumer*>(p_Left);
	auto* s_Right = reinterpret_cast<IMorphemeEventConsumer*>(p_Right);

	return *s_Left == *s_Right;
}

bool IMorphemeEventConsumer::operator==(const IMorphemeEventConsumer& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IMorphemeEventConsumer>)
		return false;


	return true;
}

void IMorphemeEventConsumer::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IMorphemeEventConsumer*>(p_Object);
	s_Object->~IMorphemeEventConsumer();
}

ZHMTypeInfo INetRelevancy::TypeInfo = ZHMTypeInfo("INetRelevancy", sizeof(INetRelevancy), alignof(INetRelevancy), INetRelevancy::WriteSimpleJson, INetRelevancy::FromSimpleJson, INetRelevancy::Serialize, INetRelevancy::Equals, INetRelevancy::Destroy);

void INetRelevancy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<INetRelevancy*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void INetRelevancy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	INetRelevancy s_Object {};

	*reinterpret_cast<INetRelevancy*>(p_Target) = s_Object;
}

void INetRelevancy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<INetRelevancy*>(p_Object);

}

bool INetRelevancy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<INetRelevancy*>(p_Left);
	auto* s_Right = reinterpret_cast<INetRelevancy*>(p_Right);

	return *s_Left == *s_Right;
}

bool INetRelevancy::operator==(const INetRelevancy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<INetRelevancy>)
		return false;


	return true;
}

void INetRelevancy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<INetRelevancy*>(p_Object);
	s_Object->~INetRelevancy();
}

ZHMTypeInfo IOnlineConfigurationListener::TypeInfo = ZHMTypeInfo("IOnlineConfigurationListener", sizeof(IOnlineConfigurationListener), alignof(IOnlineConfigurationListener), IOnlineConfigurationListener::WriteSimpleJson, IOnlineConfigurationListener::FromSimpleJson, IOnlineConfigurationListener::Serialize, IOnlineConfigurationListener::Equals, IOnlineConfigurationListener::Destroy);

void IOnlineConfigurationListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IOnlineConfigurationListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IOnlineConfigurationListener s_Object {};

	*reinterpret_cast<IOnlineConfigurationListener*>(p_Target) = s_Object;
}

void IOnlineConfigurationListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);

}

bool IOnlineConfigurationListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IOnlineConfigurationListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IOnlineConfigurationListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IOnlineConfigurationListener::operator==(const IOnlineConfigurationListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IOnlineConfigurationListener>)
		return false;


	return true;
}

void IOnlineConfigurationListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IOnlineConfigurationListener*>(p_Object);
	s_Object->~IOnlineConfigurationListener();
}

ZHMTypeInfo IPureWaterReflectable::TypeInfo = ZHMTypeInfo("IPureWaterReflectable", sizeof(IPureWaterReflectable), alignof(IPureWaterReflectable), IPureWaterReflectable::WriteSimpleJson, IPureWaterReflectable::FromSimpleJson, IPureWaterReflectable::Serialize, IPureWaterReflectable::Equals, IPureWaterReflectable::Destroy);

void IPureWaterReflectable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IPureWaterReflectable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IPureWaterReflectable s_Object {};

	*reinterpret_cast<IPureWaterReflectable*>(p_Target) = s_Object;
}

void IPureWaterReflectable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);

}

bool IPureWaterReflectable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IPureWaterReflectable*>(p_Left);
	auto* s_Right = reinterpret_cast<IPureWaterReflectable*>(p_Right);

	return *s_Left == *s_Right;
}

bool IPureWaterReflectable::operator==(const IPureWaterReflectable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IPureWaterReflectable>)
		return false;


	return true;
}

void IPureWaterReflectable::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IPureWaterReflectable*>(p_Object);
	s_Object->~IPureWaterReflectable();
}

ZHMTypeInfo IRenderCompositorEntity::TypeInfo = ZHMTypeInfo("IRenderCompositorEntity", sizeof(IRenderCompositorEntity), alignof(IRenderCompositorEntity), IRenderCompositorEntity::WriteSimpleJson, IRenderCompositorEntity::FromSimpleJson, IRenderCompositorEntity::Serialize, IRenderCompositorEntity::Equals, IRenderCompositorEntity::Destroy);

void IRenderCompositorEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IRenderCompositorEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IRenderCompositorEntity s_Object {};

	*reinterpret_cast<IRenderCompositorEntity*>(p_Target) = s_Object;
}

void IRenderCompositorEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);

}

bool IRenderCompositorEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IRenderCompositorEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IRenderCompositorEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IRenderCompositorEntity::operator==(const IRenderCompositorEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IRenderCompositorEntity>)
		return false;


	return true;
}

void IRenderCompositorEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IRenderCompositorEntity*>(p_Object);
	s_Object->~IRenderCompositorEntity();
}

ZHMTypeInfo ISequenceTarget::TypeInfo = ZHMTypeInfo("ISequenceTarget", sizeof(ISequenceTarget), alignof(ISequenceTarget), ISequenceTarget::WriteSimpleJson, ISequenceTarget::FromSimpleJson, ISequenceTarget::Serialize, ISequenceTarget::Equals, ISequenceTarget::Destroy);

void ISequenceTarget::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISequenceTarget::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISequenceTarget s_Object {};

	*reinterpret_cast<ISequenceTarget*>(p_Target) = s_Object;
}

void ISequenceTarget::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);

}

bool ISequenceTarget::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISequenceTarget*>(p_Left);
	auto* s_Right = reinterpret_cast<ISequenceTarget*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISequenceTarget::operator==(const ISequenceTarget& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISequenceTarget>)
		return false;


	return true;
}

void ISequenceTarget::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ISequenceTarget*>(p_Object);
	s_Object->~ISequenceTarget();
}

ZHMTypeInfo ISituation::TypeInfo = ZHMTypeInfo("ISituation", sizeof(ISituation), alignof(ISituation), ISituation::WriteSimpleJson, ISituation::FromSimpleJson, ISituation::Serialize, ISituation::Equals, ISituation::Destroy);

void ISituation::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISituation::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISituation s_Object {};

	*reinterpret_cast<ISituation*>(p_Target) = s_Object;
}

void ISituation::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);

}

bool ISituation::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISituation*>(p_Left);
	auto* s_Right = reinterpret_cast<ISituation*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISituation::operator==(const ISituation& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISituation>)
		return false;


	return true;
}

void ISituation::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ISituation*>(p_Object);
	s_Object->~ISituation();
}

ZHMTypeInfo ISoundGateController::TypeInfo = ZHMTypeInfo("ISoundGateController", sizeof(ISoundGateController), alignof(ISoundGateController), ISoundGateController::WriteSimpleJson, ISoundGateController::FromSimpleJson, ISoundGateController::Serialize, ISoundGateController::Equals, ISoundGateController::Destroy);

void ISoundGateController::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundGateController*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISoundGateController::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISoundGateController s_Object {};

	*reinterpret_cast<ISoundGateController*>(p_Target) = s_Object;
}

void ISoundGateController::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISoundGateController*>(p_Object);

}

bool ISoundGateController::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISoundGateController*>(p_Left);
	auto* s_Right = reinterpret_cast<ISoundGateController*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISoundGateController::operator==(const ISoundGateController& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISoundGateController>)
		return false;


	return true;
}

void ISoundGateController::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ISoundGateController*>(p_Object);
	s_Object->~ISoundGateController();
}

ZHMTypeInfo ISoundMaterialDescriptor::TypeInfo = ZHMTypeInfo("ISoundMaterialDescriptor", sizeof(ISoundMaterialDescriptor), alignof(ISoundMaterialDescriptor), ISoundMaterialDescriptor::WriteSimpleJson, ISoundMaterialDescriptor::FromSimpleJson, ISoundMaterialDescriptor::Serialize, ISoundMaterialDescriptor::Equals, ISoundMaterialDescriptor::Destroy);

void ISoundMaterialDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ISoundMaterialDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ISoundMaterialDescriptor s_Object {};

	*reinterpret_cast<ISoundMaterialDescriptor*>(p_Target) = s_Object;
}

void ISoundMaterialDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);

}

bool ISoundMaterialDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ISoundMaterialDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<ISoundMaterialDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool ISoundMaterialDescriptor::operator==(const ISoundMaterialDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ISoundMaterialDescriptor>)
		return false;


	return true;
}

void ISoundMaterialDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ISoundMaterialDescriptor*>(p_Object);
	s_Object->~ISoundMaterialDescriptor();
}

ZHMTypeInfo ITriggerListener::TypeInfo = ZHMTypeInfo("ITriggerListener", sizeof(ITriggerListener), alignof(ITriggerListener), ITriggerListener::WriteSimpleJson, ITriggerListener::FromSimpleJson, ITriggerListener::Serialize, ITriggerListener::Equals, ITriggerListener::Destroy);

void ITriggerListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ITriggerListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ITriggerListener s_Object {};

	*reinterpret_cast<ITriggerListener*>(p_Target) = s_Object;
}

void ITriggerListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);

}

bool ITriggerListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ITriggerListener*>(p_Left);
	auto* s_Right = reinterpret_cast<ITriggerListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool ITriggerListener::operator==(const ITriggerListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ITriggerListener>)
		return false;


	return true;
}

void ITriggerListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ITriggerListener*>(p_Object);
	s_Object->~ITriggerListener();
}

ZHMTypeInfo IUIDataListener::TypeInfo = ZHMTypeInfo("IUIDataListener", sizeof(IUIDataListener), alignof(IUIDataListener), IUIDataListener::WriteSimpleJson, IUIDataListener::FromSimpleJson, IUIDataListener::Serialize, IUIDataListener::Equals, IUIDataListener::Destroy);

void IUIDataListener::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IUIDataListener::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IUIDataListener s_Object {};

	*reinterpret_cast<IUIDataListener*>(p_Target) = s_Object;
}

void IUIDataListener::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);

}

bool IUIDataListener::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IUIDataListener*>(p_Left);
	auto* s_Right = reinterpret_cast<IUIDataListener*>(p_Right);

	return *s_Left == *s_Right;
}

bool IUIDataListener::operator==(const IUIDataListener& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IUIDataListener>)
		return false;


	return true;
}

void IUIDataListener::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IUIDataListener*>(p_Object);
	s_Object->~IUIDataListener();
}

ZHMTypeInfo IValueEntity::TypeInfo = ZHMTypeInfo("IValueEntity", sizeof(IValueEntity), alignof(IValueEntity), IValueEntity::WriteSimpleJson, IValueEntity::FromSimpleJson, IValueEntity::Serialize, IValueEntity::Equals, IValueEntity::Destroy);

void IValueEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IValueEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IValueEntity s_Object {};

	*reinterpret_cast<IValueEntity*>(p_Target) = s_Object;
}

void IValueEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);

}

bool IValueEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IValueEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<IValueEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool IValueEntity::operator==(const IValueEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IValueEntity>)
		return false;


	return true;
}

void IValueEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IValueEntity*>(p_Object);
	s_Object->~IValueEntity();
}

ZHMTypeInfo IWorldMapMarker::TypeInfo = ZHMTypeInfo("IWorldMapMarker", sizeof(IWorldMapMarker), alignof(IWorldMapMarker), IWorldMapMarker::WriteSimpleJson, IWorldMapMarker::FromSimpleJson, IWorldMapMarker::Serialize, IWorldMapMarker::Equals, IWorldMapMarker::Destroy);

void IWorldMapMarker::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void IWorldMapMarker::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	IWorldMapMarker s_Object {};

	*reinterpret_cast<IWorldMapMarker*>(p_Target) = s_Object;
}

void IWorldMapMarker::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);

}

bool IWorldMapMarker::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<IWorldMapMarker*>(p_Left);
	auto* s_Right = reinterpret_cast<IWorldMapMarker*>(p_Right);

	return *s_Left == *s_Right;
}

bool IWorldMapMarker::operator==(const IWorldMapMarker& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<IWorldMapMarker>)
		return false;


	return true;
}

void IWorldMapMarker::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<IWorldMapMarker*>(p_Object);
	s_Object->~IWorldMapMarker();
}

ZHMTypeInfo S25DProjectionSettingsCurveEntry::TypeInfo = ZHMTypeInfo("S25DProjectionSettingsCurveEntry", sizeof(S25DProjectionSettingsCurveEntry), alignof(S25DProjectionSettingsCurveEntry), S25DProjectionSettingsCurveEntry::WriteSimpleJson, S25DProjectionSettingsCurveEntry::FromSimpleJson, S25DProjectionSettingsCurveEntry::Serialize, S25DProjectionSettingsCurveEntry::Equals, S25DProjectionSettingsCurveEntry::Destroy);

void S25DProjectionSettingsCurveEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettingsCurveEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fValue);

	p_Stream << "}";
}

void S25DProjectionSettingsCurveEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	S25DProjectionSettingsCurveEntry s_Object {};

	s_Object.fDistance = simdjson::from_json_float32(p_Document["fDistance"]);

	s_Object.fValue = simdjson::from_json_float32(p_Document["fValue"]);

	*reinterpret_cast<S25DProjectionSettingsCurveEntry*>(p_Target) = s_Object;
}

void S25DProjectionSettingsCurveEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettingsCurveEntry*>(p_Object);

}

bool S25DProjectionSettingsCurveEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<S25DProjectionSettingsCurveEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<S25DProjectionSettingsCurveEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool S25DProjectionSettingsCurveEntry::operator==(const S25DProjectionSettingsCurveEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<S25DProjectionSettingsCurveEntry>)
		return false;

	if (fDistance != p_Other.fDistance) return false;
	if (fValue != p_Other.fValue) return false;

	return true;
}

void S25DProjectionSettingsCurveEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettingsCurveEntry*>(p_Object);
	s_Object->~S25DProjectionSettingsCurveEntry();
}

ZHMTypeInfo SWorldSpaceSettings::TypeInfo = ZHMTypeInfo("SWorldSpaceSettings", sizeof(SWorldSpaceSettings), alignof(SWorldSpaceSettings), SWorldSpaceSettings::WriteSimpleJson, SWorldSpaceSettings::FromSimpleJson, SWorldSpaceSettings::Serialize, SWorldSpaceSettings::Equals, SWorldSpaceSettings::Destroy);

void SWorldSpaceSettings::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWorldSpaceSettings*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fCloseupDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fCloseupDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDynamicScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDynamicScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fDynamicScaleAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fDynamicScaleAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fDynamicScaleNearDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fDynamicScaleNearDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fDynamicScaleBlendRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fDynamicScaleBlendRange);

	p_Stream << "}";
}

void SWorldSpaceSettings::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWorldSpaceSettings s_Object {};

	s_Object.fCloseupDistance = simdjson::from_json_float32(p_Document["fCloseupDistance"]);

	s_Object.fScale = simdjson::from_json_float32(p_Document["fScale"]);

	s_Object.bDynamicScale = simdjson::from_json_bool(p_Document["bDynamicScale"]);

	s_Object.fDynamicScaleAlpha = simdjson::from_json_float32(p_Document["fDynamicScaleAlpha"]);

	s_Object.fDynamicScaleNearDistance = simdjson::from_json_float32(p_Document["fDynamicScaleNearDistance"]);

	s_Object.fDynamicScaleBlendRange = simdjson::from_json_float32(p_Document["fDynamicScaleBlendRange"]);

	*reinterpret_cast<SWorldSpaceSettings*>(p_Target) = s_Object;
}

void SWorldSpaceSettings::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWorldSpaceSettings*>(p_Object);

}

bool SWorldSpaceSettings::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWorldSpaceSettings*>(p_Left);
	auto* s_Right = reinterpret_cast<SWorldSpaceSettings*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWorldSpaceSettings::operator==(const SWorldSpaceSettings& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWorldSpaceSettings>)
		return false;

	if (fCloseupDistance != p_Other.fCloseupDistance) return false;
	if (fScale != p_Other.fScale) return false;
	if (bDynamicScale != p_Other.bDynamicScale) return false;
	if (fDynamicScaleAlpha != p_Other.fDynamicScaleAlpha) return false;
	if (fDynamicScaleNearDistance != p_Other.fDynamicScaleNearDistance) return false;
	if (fDynamicScaleBlendRange != p_Other.fDynamicScaleBlendRange) return false;

	return true;
}

void SWorldSpaceSettings::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWorldSpaceSettings*>(p_Object);
	s_Object->~SWorldSpaceSettings();
}

ZHMTypeInfo S25DProjectionSettings::TypeInfo = ZHMTypeInfo("S25DProjectionSettings", sizeof(S25DProjectionSettings), alignof(S25DProjectionSettings), S25DProjectionSettings::WriteSimpleJson, S25DProjectionSettings::FromSimpleJson, S25DProjectionSettings::Serialize, S25DProjectionSettings::Equals, S25DProjectionSettings::Destroy);

void S25DProjectionSettings::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fNearDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearFov") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearFov);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarFov") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarFov);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearScaleFov") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearScaleFov);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarScaleFov") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarScaleFov);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScaleFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fScaleFactor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fNearAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fNearAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFarAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFarAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlphaFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlphaFactor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aScaleCurve") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aScaleCurve.size(); ++i)
	{
		auto& s_Item0 = s_Object->aScaleCurve[i];
		S25DProjectionSettingsCurveEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aScaleCurve.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aAlphaCurve") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aAlphaCurve.size(); ++i)
	{
		auto& s_Item0 = s_Object->aAlphaCurve[i];
		S25DProjectionSettingsCurveEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aAlphaCurve.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eViewportLock") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EViewportLock", static_cast<int>(s_Object->eViewportLock)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fViewportGutter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fViewportGutter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sWorldSpaceSettings") << ":";
	SWorldSpaceSettings::WriteSimpleJson(&s_Object->sWorldSpaceSettings, p_Stream);

	p_Stream << "}";
}

void S25DProjectionSettings::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	S25DProjectionSettings s_Object {};

	s_Object.fNearDistance = simdjson::from_json_float32(p_Document["fNearDistance"]);

	s_Object.fFarDistance = simdjson::from_json_float32(p_Document["fFarDistance"]);

	s_Object.fNearScale = simdjson::from_json_float32(p_Document["fNearScale"]);

	s_Object.fFarScale = simdjson::from_json_float32(p_Document["fFarScale"]);

	s_Object.fNearFov = simdjson::from_json_float32(p_Document["fNearFov"]);

	s_Object.fFarFov = simdjson::from_json_float32(p_Document["fFarFov"]);

	s_Object.fNearScaleFov = simdjson::from_json_float32(p_Document["fNearScaleFov"]);

	s_Object.fFarScaleFov = simdjson::from_json_float32(p_Document["fFarScaleFov"]);

	s_Object.fScaleFactor = simdjson::from_json_float32(p_Document["fScaleFactor"]);

	s_Object.fNearAlpha = simdjson::from_json_float32(p_Document["fNearAlpha"]);

	s_Object.fFarAlpha = simdjson::from_json_float32(p_Document["fFarAlpha"]);

	s_Object.fAlphaFactor = simdjson::from_json_float32(p_Document["fAlphaFactor"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aScaleCurve"];
	s_Object.aScaleCurve.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		S25DProjectionSettingsCurveEntry s_ArrayItem0;
		S25DProjectionSettingsCurveEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aScaleCurve[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aAlphaCurve"];
	s_Object.aAlphaCurve.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		S25DProjectionSettingsCurveEntry s_ArrayItem0;
		S25DProjectionSettingsCurveEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aAlphaCurve[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.eViewportLock = static_cast<EViewportLock>(ZHMEnums::GetEnumValueByName("EViewportLock", std::string_view(p_Document["eViewportLock"])));

	s_Object.fViewportGutter = simdjson::from_json_float32(p_Document["fViewportGutter"]);

	{
		SWorldSpaceSettings s_Item {};
		SWorldSpaceSettings::FromSimpleJson(p_Document["sWorldSpaceSettings"], &s_Item);
		s_Object.sWorldSpaceSettings = s_Item;
	}

	*reinterpret_cast<S25DProjectionSettings*>(p_Target) = s_Object;
}

void S25DProjectionSettings::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);

	TArray<S25DProjectionSettingsCurveEntry>::Serialize(&s_Object->aScaleCurve, p_Serializer, p_OwnOffset + offsetof(S25DProjectionSettings, aScaleCurve));
	TArray<S25DProjectionSettingsCurveEntry>::Serialize(&s_Object->aAlphaCurve, p_Serializer, p_OwnOffset + offsetof(S25DProjectionSettings, aAlphaCurve));
	SWorldSpaceSettings::Serialize(&s_Object->sWorldSpaceSettings, p_Serializer, p_OwnOffset + offsetof(S25DProjectionSettings, sWorldSpaceSettings));
}

bool S25DProjectionSettings::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<S25DProjectionSettings*>(p_Left);
	auto* s_Right = reinterpret_cast<S25DProjectionSettings*>(p_Right);

	return *s_Left == *s_Right;
}

bool S25DProjectionSettings::operator==(const S25DProjectionSettings& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<S25DProjectionSettings>)
		return false;

	if (fNearDistance != p_Other.fNearDistance) return false;
	if (fFarDistance != p_Other.fFarDistance) return false;
	if (fNearScale != p_Other.fNearScale) return false;
	if (fFarScale != p_Other.fFarScale) return false;
	if (fNearFov != p_Other.fNearFov) return false;
	if (fFarFov != p_Other.fFarFov) return false;
	if (fNearScaleFov != p_Other.fNearScaleFov) return false;
	if (fFarScaleFov != p_Other.fFarScaleFov) return false;
	if (fScaleFactor != p_Other.fScaleFactor) return false;
	if (fNearAlpha != p_Other.fNearAlpha) return false;
	if (fFarAlpha != p_Other.fFarAlpha) return false;
	if (fAlphaFactor != p_Other.fAlphaFactor) return false;
	if (aScaleCurve != p_Other.aScaleCurve) return false;
	if (aAlphaCurve != p_Other.aAlphaCurve) return false;
	if (eViewportLock != p_Other.eViewportLock) return false;
	if (fViewportGutter != p_Other.fViewportGutter) return false;
	if (sWorldSpaceSettings != p_Other.sWorldSpaceSettings) return false;

	return true;
}

void S25DProjectionSettings::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<S25DProjectionSettings*>(p_Object);
	s_Object->~S25DProjectionSettings();
}

ZHMTypeInfo S3rdPersonCameraSaveData::TypeInfo = ZHMTypeInfo("S3rdPersonCameraSaveData", sizeof(S3rdPersonCameraSaveData), alignof(S3rdPersonCameraSaveData), S3rdPersonCameraSaveData::WriteSimpleJson, S3rdPersonCameraSaveData::FromSimpleJson, S3rdPersonCameraSaveData::Serialize, S3rdPersonCameraSaveData::Equals, S3rdPersonCameraSaveData::Destroy);

void S3rdPersonCameraSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fAngleYaw") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngleYaw);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnglePitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnglePitch);

	p_Stream << "}";
}

void S3rdPersonCameraSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	S3rdPersonCameraSaveData s_Object {};

	s_Object.m_fAngleYaw = simdjson::from_json_float32(p_Document["m_fAngleYaw"]);

	s_Object.m_fAnglePitch = simdjson::from_json_float32(p_Document["m_fAnglePitch"]);

	*reinterpret_cast<S3rdPersonCameraSaveData*>(p_Target) = s_Object;
}

void S3rdPersonCameraSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);

}

bool S3rdPersonCameraSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool S3rdPersonCameraSaveData::operator==(const S3rdPersonCameraSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<S3rdPersonCameraSaveData>)
		return false;

	if (m_fAngleYaw != p_Other.m_fAngleYaw) return false;
	if (m_fAnglePitch != p_Other.m_fAnglePitch) return false;

	return true;
}

void S3rdPersonCameraSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<S3rdPersonCameraSaveData*>(p_Object);
	s_Object->~S3rdPersonCameraSaveData();
}

ZHMTypeInfo ZGameTime::TypeInfo = ZHMTypeInfo("ZGameTime", sizeof(ZGameTime), alignof(ZGameTime), ZGameTime::WriteSimpleJson, ZGameTime::FromSimpleJson, ZGameTime::Serialize, ZGameTime::Equals, ZGameTime::Destroy);

void ZGameTime::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nTicks") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTicks);

	p_Stream << "}";
}

void ZGameTime::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGameTime s_Object {};

	s_Object.m_nTicks = simdjson::from_json_int64(p_Document["m_nTicks"]);

	*reinterpret_cast<ZGameTime*>(p_Target) = s_Object;
}

void ZGameTime::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);

}

bool ZGameTime::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGameTime*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGameTime*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGameTime::operator==(const ZGameTime& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGameTime>)
		return false;

	if (m_nTicks != p_Other.m_nTicks) return false;

	return true;
}

void ZGameTime::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGameTime*>(p_Object);
	s_Object->~ZGameTime();
}

ZHMTypeInfo SAIEventSaveData::TypeInfo = ZHMTypeInfo("SAIEventSaveData", sizeof(SAIEventSaveData), alignof(SAIEventSaveData), SAIEventSaveData::WriteSimpleJson, SAIEventSaveData::FromSimpleJson, SAIEventSaveData::Serialize, SAIEventSaveData::Equals, SAIEventSaveData::Destroy);

void SAIEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHandled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHandled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nEnd, p_Stream);

	p_Stream << "}";
}

void SAIEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIEventSaveData s_Object {};

	s_Object.m_eType = static_cast<EAIEventType>(ZHMEnums::GetEnumValueByName("EAIEventType", std::string_view(p_Document["m_eType"])));

	s_Object.m_bHandled = simdjson::from_json_bool(p_Document["m_bHandled"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nStart"], &s_Item);
		s_Object.m_nStart = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nEnd"], &s_Item);
		s_Object.m_nEnd = s_Item;
	}

	*reinterpret_cast<SAIEventSaveData*>(p_Target) = s_Object;
}

void SAIEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_nStart, p_Serializer, p_OwnOffset + offsetof(SAIEventSaveData, m_nStart));
	ZGameTime::Serialize(&s_Object->m_nEnd, p_Serializer, p_OwnOffset + offsetof(SAIEventSaveData, m_nEnd));
}

bool SAIEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIEventSaveData::operator==(const SAIEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIEventSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_bHandled != p_Other.m_bHandled) return false;
	if (m_nStart != p_Other.m_nStart) return false;
	if (m_nEnd != p_Other.m_nEnd) return false;

	return true;
}

void SAIEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIEventSaveData*>(p_Object);
	s_Object->~SAIEventSaveData();
}

ZHMTypeInfo SAIModifierServiceActorSaveData::TypeInfo = ZHMTypeInfo("SAIModifierServiceActorSaveData", sizeof(SAIModifierServiceActorSaveData), alignof(SAIModifierServiceActorSaveData), SAIModifierServiceActorSaveData::WriteSimpleJson, SAIModifierServiceActorSaveData::FromSimpleJson, SAIModifierServiceActorSaveData::Serialize, SAIModifierServiceActorSaveData::Equals, SAIModifierServiceActorSaveData::Destroy);

void SAIModifierServiceActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActorRef") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActorRef);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedsVolumeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedsVolumeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedsKnowledgeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedsKnowledgeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModVolume") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModVolume);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModRole") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModRole);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModOutfit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModOutfit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModOverride") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModOverride);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uiModStatus") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uiModStatus);

	p_Stream << "}";
}

void SAIModifierServiceActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIModifierServiceActorSaveData s_Object {};

	s_Object.m_rActorRef = simdjson::from_json_uint32(p_Document["m_rActorRef"]);

	s_Object.m_bNeedsVolumeUpdate = simdjson::from_json_bool(p_Document["m_bNeedsVolumeUpdate"]);

	s_Object.m_bNeedsKnowledgeUpdate = simdjson::from_json_bool(p_Document["m_bNeedsKnowledgeUpdate"]);

	s_Object.m_uiModVolume = simdjson::from_json_uint32(p_Document["m_uiModVolume"]);

	s_Object.m_uiModBehavior = simdjson::from_json_uint32(p_Document["m_uiModBehavior"]);

	s_Object.m_uiModRole = simdjson::from_json_uint32(p_Document["m_uiModRole"]);

	s_Object.m_uiModItem = simdjson::from_json_uint32(p_Document["m_uiModItem"]);

	s_Object.m_uiModSituation = simdjson::from_json_uint32(p_Document["m_uiModSituation"]);

	s_Object.m_uiModOutfit = simdjson::from_json_uint32(p_Document["m_uiModOutfit"]);

	s_Object.m_uiModOverride = simdjson::from_json_uint32(p_Document["m_uiModOverride"]);

	s_Object.m_uiModStatus = simdjson::from_json_uint32(p_Document["m_uiModStatus"]);

	*reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Target) = s_Object;
}

void SAIModifierServiceActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);

}

bool SAIModifierServiceActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIModifierServiceActorSaveData::operator==(const SAIModifierServiceActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIModifierServiceActorSaveData>)
		return false;

	if (m_rActorRef != p_Other.m_rActorRef) return false;
	if (m_bNeedsVolumeUpdate != p_Other.m_bNeedsVolumeUpdate) return false;
	if (m_bNeedsKnowledgeUpdate != p_Other.m_bNeedsKnowledgeUpdate) return false;
	if (m_uiModVolume != p_Other.m_uiModVolume) return false;
	if (m_uiModBehavior != p_Other.m_uiModBehavior) return false;
	if (m_uiModRole != p_Other.m_uiModRole) return false;
	if (m_uiModItem != p_Other.m_uiModItem) return false;
	if (m_uiModSituation != p_Other.m_uiModSituation) return false;
	if (m_uiModOutfit != p_Other.m_uiModOutfit) return false;
	if (m_uiModOverride != p_Other.m_uiModOverride) return false;
	if (m_uiModStatus != p_Other.m_uiModStatus) return false;

	return true;
}

void SAIModifierServiceActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceActorSaveData*>(p_Object);
	s_Object->~SAIModifierServiceActorSaveData();
}

ZHMTypeInfo SAIModifierServiceSaveData::TypeInfo = ZHMTypeInfo("SAIModifierServiceSaveData", sizeof(SAIModifierServiceSaveData), alignof(SAIModifierServiceSaveData), SAIModifierServiceSaveData::WriteSimpleJson, SAIModifierServiceSaveData::FromSimpleJson, SAIModifierServiceSaveData::Serialize, SAIModifierServiceSaveData::Equals, SAIModifierServiceSaveData::Destroy);

void SAIModifierServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bFullVolumeUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFullVolumeUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		SAIModifierServiceActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAIModifierServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIModifierServiceSaveData s_Object {};

	s_Object.m_bFullVolumeUpdate = simdjson::from_json_bool(p_Document["m_bFullVolumeUpdate"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActors"];
	s_Object.m_aActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAIModifierServiceActorSaveData s_ArrayItem0;
		SAIModifierServiceActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActors[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SAIModifierServiceSaveData*>(p_Target) = s_Object;
}

void SAIModifierServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);

	TArray<SAIModifierServiceActorSaveData>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SAIModifierServiceSaveData, m_aActors));
}

bool SAIModifierServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIModifierServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIModifierServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIModifierServiceSaveData::operator==(const SAIModifierServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIModifierServiceSaveData>)
		return false;

	if (m_bFullVolumeUpdate != p_Other.m_bFullVolumeUpdate) return false;
	if (m_aActors != p_Other.m_aActors) return false;

	return true;
}

void SAIModifierServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIModifierServiceSaveData*>(p_Object);
	s_Object->~SAIModifierServiceSaveData();
}

ZHMTypeInfo SAIPerceptibleEntitySaveData::TypeInfo = ZHMTypeInfo("SAIPerceptibleEntitySaveData", sizeof(SAIPerceptibleEntitySaveData), alignof(SAIPerceptibleEntitySaveData), SAIPerceptibleEntitySaveData::WriteSimpleJson, SAIPerceptibleEntitySaveData::FromSimpleJson, SAIPerceptibleEntitySaveData::Serialize, SAIPerceptibleEntitySaveData::Equals, SAIPerceptibleEntitySaveData::Destroy);

void SAIPerceptibleEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPerceptibleEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPerceptibleEnabled);

	p_Stream << "}";
}

void SAIPerceptibleEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIPerceptibleEntitySaveData s_Object {};

	s_Object.m_bPerceptibleEnabled = simdjson::from_json_bool(p_Document["m_bPerceptibleEnabled"]);

	*reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Target) = s_Object;
}

void SAIPerceptibleEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);

}

bool SAIPerceptibleEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIPerceptibleEntitySaveData::operator==(const SAIPerceptibleEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIPerceptibleEntitySaveData>)
		return false;

	if (m_bPerceptibleEnabled != p_Other.m_bPerceptibleEnabled) return false;

	return true;
}

void SAIPerceptibleEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIPerceptibleEntitySaveData*>(p_Object);
	s_Object->~SAIPerceptibleEntitySaveData();
}

ZHMTypeInfo SAIVisionBlockerSaveData::TypeInfo = ZHMTypeInfo("SAIVisionBlockerSaveData", sizeof(SAIVisionBlockerSaveData), alignof(SAIVisionBlockerSaveData), SAIVisionBlockerSaveData::WriteSimpleJson, SAIVisionBlockerSaveData::FromSimpleJson, SAIVisionBlockerSaveData::Serialize, SAIVisionBlockerSaveData::Equals, SAIVisionBlockerSaveData::Destroy);

void SAIVisionBlockerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SAIVisionBlockerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAIVisionBlockerSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SAIVisionBlockerSaveData*>(p_Target) = s_Object;
}

void SAIVisionBlockerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);

}

bool SAIVisionBlockerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAIVisionBlockerSaveData::operator==(const SAIVisionBlockerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAIVisionBlockerSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SAIVisionBlockerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAIVisionBlockerSaveData*>(p_Object);
	s_Object->~SAIVisionBlockerSaveData();
}

ZHMTypeInfo SAccessoryItemSaveData::TypeInfo = ZHMTypeInfo("SAccessoryItemSaveData", sizeof(SAccessoryItemSaveData), alignof(SAccessoryItemSaveData), SAccessoryItemSaveData::WriteSimpleJson, SAccessoryItemSaveData::FromSimpleJson, SAccessoryItemSaveData::Serialize, SAccessoryItemSaveData::Equals, SAccessoryItemSaveData::Destroy);

void SAccessoryItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBoneId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBoneId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SAccessoryItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAccessoryItemSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_nBoneId = simdjson::from_json_uint32(p_Document["m_nBoneId"]);

	s_Object.m_bAttached = simdjson::from_json_bool(p_Document["m_bAttached"]);

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	*reinterpret_cast<SAccessoryItemSaveData*>(p_Target) = s_Object;
}

void SAccessoryItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);

}

bool SAccessoryItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAccessoryItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAccessoryItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAccessoryItemSaveData::operator==(const SAccessoryItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAccessoryItemSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_nBoneId != p_Other.m_nBoneId) return false;
	if (m_bAttached != p_Other.m_bAttached) return false;
	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

void SAccessoryItemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAccessoryItemSaveData*>(p_Object);
	s_Object->~SAccessoryItemSaveData();
}

ZHMTypeInfo SAccidentObserversGroupSaveData::TypeInfo = ZHMTypeInfo("SAccidentObserversGroupSaveData", sizeof(SAccidentObserversGroupSaveData), alignof(SAccidentObserversGroupSaveData), SAccidentObserversGroupSaveData::WriteSimpleJson, SAccidentObserversGroupSaveData::FromSimpleJson, SAccidentObserversGroupSaveData::Serialize, SAccidentObserversGroupSaveData::Equals, SAccidentObserversGroupSaveData::Destroy);

void SAccidentObserversGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAccidentObserversGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingObservers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingObservers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingObservers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aWaitingObservers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_accidentScaleContext") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAccidentScaleContext", static_cast<int>(s_Object->m_accidentScaleContext)));

	p_Stream << "}";
}

void SAccidentObserversGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAccidentObserversGroupSaveData s_Object {};

	s_Object.m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aWaitingObservers"];
	s_Object.m_aWaitingObservers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aWaitingObservers[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_accidentScaleContext = static_cast<EAccidentScaleContext>(ZHMEnums::GetEnumValueByName("EAccidentScaleContext", std::string_view(p_Document["m_accidentScaleContext"])));

	*reinterpret_cast<SAccidentObserversGroupSaveData*>(p_Target) = s_Object;
}

void SAccidentObserversGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAccidentObserversGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aWaitingObservers, p_Serializer, p_OwnOffset + offsetof(SAccidentObserversGroupSaveData, m_aWaitingObservers));
}

bool SAccidentObserversGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAccidentObserversGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAccidentObserversGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAccidentObserversGroupSaveData::operator==(const SAccidentObserversGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAccidentObserversGroupSaveData>)
		return false;

	if (m_target != p_Other.m_target) return false;
	if (m_aWaitingObservers != p_Other.m_aWaitingObservers) return false;
	if (m_accidentScaleContext != p_Other.m_accidentScaleContext) return false;

	return true;
}

void SAccidentObserversGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAccidentObserversGroupSaveData*>(p_Object);
	s_Object->~SAccidentObserversGroupSaveData();
}

ZHMTypeInfo SActBehaviorEntitySaveData::TypeInfo = ZHMTypeInfo("SActBehaviorEntitySaveData", sizeof(SActBehaviorEntitySaveData), alignof(SActBehaviorEntitySaveData), SActBehaviorEntitySaveData::WriteSimpleJson, SActBehaviorEntitySaveData::FromSimpleJson, SActBehaviorEntitySaveData::Serialize, SActBehaviorEntitySaveData::Equals, SActBehaviorEntitySaveData::Destroy);

void SActBehaviorEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStartedSignalSent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedSignalSent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReachedSignalSent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReachedSignalSent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_ActStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceTimeout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceTimeout);

	p_Stream << "}";
}

void SActBehaviorEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActBehaviorEntitySaveData s_Object {};

	s_Object.m_bStartedSignalSent = simdjson::from_json_bool(p_Document["m_bStartedSignalSent"]);

	s_Object.m_bReachedSignalSent = simdjson::from_json_bool(p_Document["m_bReachedSignalSent"]);

	s_Object.m_nState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_nState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_ActStartTime"], &s_Item);
		s_Object.m_ActStartTime = s_Item;
	}

	s_Object.m_bForceTimeout = simdjson::from_json_bool(p_Document["m_bForceTimeout"]);

	*reinterpret_cast<SActBehaviorEntitySaveData*>(p_Target) = s_Object;
}

void SActBehaviorEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_ActStartTime, p_Serializer, p_OwnOffset + offsetof(SActBehaviorEntitySaveData, m_ActStartTime));
}

bool SActBehaviorEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActBehaviorEntitySaveData::operator==(const SActBehaviorEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActBehaviorEntitySaveData>)
		return false;

	if (m_bStartedSignalSent != p_Other.m_bStartedSignalSent) return false;
	if (m_bReachedSignalSent != p_Other.m_bReachedSignalSent) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_ActStartTime != p_Other.m_ActStartTime) return false;
	if (m_bForceTimeout != p_Other.m_bForceTimeout) return false;

	return true;
}

void SActBehaviorEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActBehaviorEntitySaveData*>(p_Object);
	s_Object->~SActBehaviorEntitySaveData();
}

ZHMTypeInfo float4::TypeInfo = ZHMTypeInfo("float4", sizeof(float4), alignof(float4), float4::WriteSimpleJson, float4::FromSimpleJson, float4::Serialize, float4::Equals, float4::Destroy);

void float4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void float4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	float4 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	s_Object.w = simdjson::from_json_float32(p_Document["w"]);

	*reinterpret_cast<float4*>(p_Target) = s_Object;
}

void float4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);

}

bool float4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<float4*>(p_Left);
	auto* s_Right = reinterpret_cast<float4*>(p_Right);

	return *s_Left == *s_Right;
}

bool float4::operator==(const float4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<float4>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;
	if (w != p_Other.w) return false;

	return true;
}

void float4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<float4*>(p_Object);
	s_Object->~float4();
}

ZHMTypeInfo SActOrderSaveData::TypeInfo = ZHMTypeInfo("SActOrderSaveData", sizeof(SActOrderSaveData), alignof(SActOrderSaveData), SActOrderSaveData::WriteSimpleJson, SActOrderSaveData::FromSimpleJson, SActOrderSaveData::Serialize, SActOrderSaveData::Equals, SActOrderSaveData::Destroy);

void SActOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_faceTarget") << ":";
	float4::WriteSimpleJson(&s_Object->m_faceTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlendOutImmediatelyUponTimeout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlendOutImmediatelyUponTimeout);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropCarriedItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropCarriedItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopCurrentActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopCurrentActFast);

	p_Stream << "}";
}

void SActOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActOrderSaveData s_Object {};

	s_Object.m_sAct = std::string_view(p_Document["m_sAct"]);

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object.m_rChildNetworkEntity = simdjson::from_json_uint32(p_Document["m_rChildNetworkEntity"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_faceTarget"], &s_Item);
		s_Object.m_faceTarget = s_Item;
	}

	s_Object.m_bBlendOutImmediatelyUponTimeout = simdjson::from_json_bool(p_Document["m_bBlendOutImmediatelyUponTimeout"]);

	s_Object.m_bDropCarriedItems = simdjson::from_json_bool(p_Document["m_bDropCarriedItems"]);

	s_Object.m_bStopCurrentActFast = simdjson::from_json_bool(p_Document["m_bStopCurrentActFast"]);

	*reinterpret_cast<SActOrderSaveData*>(p_Target) = s_Object;
}

void SActOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sAct, p_Serializer, p_OwnOffset + offsetof(SActOrderSaveData, m_sAct));
	float4::Serialize(&s_Object->m_faceTarget, p_Serializer, p_OwnOffset + offsetof(SActOrderSaveData, m_faceTarget));
}

bool SActOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActOrderSaveData::operator==(const SActOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActOrderSaveData>)
		return false;

	if (m_sAct != p_Other.m_sAct) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_rChildNetworkEntity != p_Other.m_rChildNetworkEntity) return false;
	if (m_faceTarget != p_Other.m_faceTarget) return false;
	if (m_bBlendOutImmediatelyUponTimeout != p_Other.m_bBlendOutImmediatelyUponTimeout) return false;
	if (m_bDropCarriedItems != p_Other.m_bDropCarriedItems) return false;
	if (m_bStopCurrentActFast != p_Other.m_bStopCurrentActFast) return false;

	return true;
}

void SActOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActOrderSaveData*>(p_Object);
	s_Object->~SActOrderSaveData();
}

ZHMTypeInfo SActionRadialArcDisplayInfo::TypeInfo = ZHMTypeInfo("SActionRadialArcDisplayInfo", sizeof(SActionRadialArcDisplayInfo), alignof(SActionRadialArcDisplayInfo), SActionRadialArcDisplayInfo::WriteSimpleJson, SActionRadialArcDisplayInfo::FromSimpleJson, SActionRadialArcDisplayInfo::Serialize, SActionRadialArcDisplayInfo::Equals, SActionRadialArcDisplayInfo::Destroy);

void SActionRadialArcDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("hidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->hidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("locked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->locked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("illegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->illegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);

	p_Stream << "}";
}

void SActionRadialArcDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActionRadialArcDisplayInfo s_Object {};

	s_Object.hidden = simdjson::from_json_bool(p_Document["hidden"]);

	s_Object.locked = simdjson::from_json_bool(p_Document["locked"]);

	s_Object.active = simdjson::from_json_bool(p_Document["active"]);

	s_Object.illegal = simdjson::from_json_bool(p_Document["illegal"]);

	s_Object.icon = simdjson::from_json_int32(p_Document["icon"]);

	s_Object.label = std::string_view(p_Document["label"]);

	*reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Target) = s_Object;
}

void SActionRadialArcDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SActionRadialArcDisplayInfo, label));
}

bool SActionRadialArcDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActionRadialArcDisplayInfo::operator==(const SActionRadialArcDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActionRadialArcDisplayInfo>)
		return false;

	if (hidden != p_Other.hidden) return false;
	if (locked != p_Other.locked) return false;
	if (active != p_Other.active) return false;
	if (illegal != p_Other.illegal) return false;
	if (icon != p_Other.icon) return false;
	if (label != p_Other.label) return false;

	return true;
}

void SActionRadialArcDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfo*>(p_Object);
	s_Object->~SActionRadialArcDisplayInfo();
}

ZHMTypeInfo SActionRadialArcDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SActionRadialArcDisplayInfoArray_dummy", sizeof(SActionRadialArcDisplayInfoArray_dummy), alignof(SActionRadialArcDisplayInfoArray_dummy), SActionRadialArcDisplayInfoArray_dummy::WriteSimpleJson, SActionRadialArcDisplayInfoArray_dummy::FromSimpleJson, SActionRadialArcDisplayInfoArray_dummy::Serialize, SActionRadialArcDisplayInfoArray_dummy::Equals, SActionRadialArcDisplayInfoArray_dummy::Destroy);

void SActionRadialArcDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SActionRadialArcDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActionRadialArcDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActionRadialArcDisplayInfoArray_dummy s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object.dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActionRadialArcDisplayInfo s_ArrayItem0;
		SActionRadialArcDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Target) = s_Object;
}

void SActionRadialArcDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);

	TArray<SActionRadialArcDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SActionRadialArcDisplayInfoArray_dummy, dummy));
}

bool SActionRadialArcDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActionRadialArcDisplayInfoArray_dummy::operator==(const SActionRadialArcDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActionRadialArcDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SActionRadialArcDisplayInfoArray_dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActionRadialArcDisplayInfoArray_dummy*>(p_Object);
	s_Object->~SActionRadialArcDisplayInfoArray_dummy();
}

ZHMTypeInfo SActivity::TypeInfo = ZHMTypeInfo("SActivity", sizeof(SActivity), alignof(SActivity), SActivity::WriteSimpleJson, SActivity::FromSimpleJson, SActivity::Serialize, SActivity::Equals, SActivity::Destroy);

void SActivity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActivity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("id") << ":";
	ZGuid::WriteSimpleJson(&s_Object->id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("activityId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->activityId);

	p_Stream << "}";
}

void SActivity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActivity s_Object {};

	{
		ZGuid s_Item {};
		ZGuid::FromSimpleJson(p_Document["id"], &s_Item);
		s_Object.id = s_Item;
	}

	s_Object.activityId = std::string_view(p_Document["activityId"]);

	*reinterpret_cast<SActivity*>(p_Target) = s_Object;
}

void SActivity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActivity*>(p_Object);

	ZGuid::Serialize(&s_Object->id, p_Serializer, p_OwnOffset + offsetof(SActivity, id));
	ZString::Serialize(&s_Object->activityId, p_Serializer, p_OwnOffset + offsetof(SActivity, activityId));
}

bool SActivity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActivity*>(p_Left);
	auto* s_Right = reinterpret_cast<SActivity*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActivity::operator==(const SActivity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActivity>)
		return false;

	if (id != p_Other.id) return false;
	if (activityId != p_Other.activityId) return false;

	return true;
}

void SActivity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActivity*>(p_Object);
	s_Object->~SActivity();
}

ZHMTypeInfo SActivityExits::TypeInfo = ZHMTypeInfo("SActivityExits", sizeof(SActivityExits), alignof(SActivityExits), SActivityExits::WriteSimpleJson, SActivityExits::FromSimpleJson, SActivityExits::Serialize, SActivityExits::Equals, SActivityExits::Destroy);

void SActivityExits::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActivityExits*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("activity") << ":";
	SActivity::WriteSimpleJson(&s_Object->activity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exits") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exits.size(); ++i)
	{
		auto& s_Item0 = s_Object->exits[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->exits.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActivityExits::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActivityExits s_Object {};

	{
		SActivity s_Item {};
		SActivity::FromSimpleJson(p_Document["activity"], &s_Item);
		s_Object.activity = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["exits"];
	s_Object.exits.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.exits[s_Index0++] = std::string_view(s_Item0);
	}
	}

	*reinterpret_cast<SActivityExits*>(p_Target) = s_Object;
}

void SActivityExits::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActivityExits*>(p_Object);

	SActivity::Serialize(&s_Object->activity, p_Serializer, p_OwnOffset + offsetof(SActivityExits, activity));
	TArray<ZString>::Serialize(&s_Object->exits, p_Serializer, p_OwnOffset + offsetof(SActivityExits, exits));
}

bool SActivityExits::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActivityExits*>(p_Left);
	auto* s_Right = reinterpret_cast<SActivityExits*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActivityExits::operator==(const SActivityExits& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActivityExits>)
		return false;

	if (activity != p_Other.activity) return false;
	if (exits != p_Other.exits) return false;

	return true;
}

void SActivityExits::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActivityExits*>(p_Object);
	s_Object->~SActivityExits();
}

ZHMTypeInfo SActivityObjective::TypeInfo = ZHMTypeInfo("SActivityObjective", sizeof(SActivityObjective), alignof(SActivityObjective), SActivityObjective::WriteSimpleJson, SActivityObjective::FromSimpleJson, SActivityObjective::Serialize, SActivityObjective::Equals, SActivityObjective::Destroy);

void SActivityObjective::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActivityObjective*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("activity") << ":";
	SActivity::WriteSimpleJson(&s_Object->activity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("opportunities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->opportunities.size(); ++i)
	{
		auto& s_Item0 = s_Object->opportunities[i];
		SActivity::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->opportunities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActivityObjective::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActivityObjective s_Object {};

	{
		SActivity s_Item {};
		SActivity::FromSimpleJson(p_Document["activity"], &s_Item);
		s_Object.activity = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["opportunities"];
	s_Object.opportunities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActivity s_ArrayItem0;
		SActivity::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.opportunities[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActivityObjective*>(p_Target) = s_Object;
}

void SActivityObjective::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActivityObjective*>(p_Object);

	SActivity::Serialize(&s_Object->activity, p_Serializer, p_OwnOffset + offsetof(SActivityObjective, activity));
	TArray<SActivity>::Serialize(&s_Object->opportunities, p_Serializer, p_OwnOffset + offsetof(SActivityObjective, opportunities));
}

bool SActivityObjective::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActivityObjective*>(p_Left);
	auto* s_Right = reinterpret_cast<SActivityObjective*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActivityObjective::operator==(const SActivityObjective& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActivityObjective>)
		return false;

	if (activity != p_Other.activity) return false;
	if (opportunities != p_Other.opportunities) return false;

	return true;
}

void SActivityObjective::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActivityObjective*>(p_Object);
	s_Object->~SActivityObjective();
}

ZHMTypeInfo SActivityDefinition::TypeInfo = ZHMTypeInfo("SActivityDefinition", sizeof(SActivityDefinition), alignof(SActivityDefinition), SActivityDefinition::WriteSimpleJson, SActivityDefinition::FromSimpleJson, SActivityDefinition::Serialize, SActivityDefinition::Equals, SActivityDefinition::Destroy);

void SActivityDefinition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActivityDefinition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("activity") << ":";
	SActivity::WriteSimpleJson(&s_Object->activity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectives") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->objectives.size(); ++i)
	{
		auto& s_Item0 = s_Object->objectives[i];
		SActivityObjective::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->objectives.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exits") << ":";
	SActivityExits::WriteSimpleJson(&s_Object->exits, p_Stream);

	p_Stream << "}";
}

void SActivityDefinition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActivityDefinition s_Object {};

	{
		SActivity s_Item {};
		SActivity::FromSimpleJson(p_Document["activity"], &s_Item);
		s_Object.activity = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["objectives"];
	s_Object.objectives.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActivityObjective s_ArrayItem0;
		SActivityObjective::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.objectives[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		SActivityExits s_Item {};
		SActivityExits::FromSimpleJson(p_Document["exits"], &s_Item);
		s_Object.exits = s_Item;
	}

	*reinterpret_cast<SActivityDefinition*>(p_Target) = s_Object;
}

void SActivityDefinition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActivityDefinition*>(p_Object);

	SActivity::Serialize(&s_Object->activity, p_Serializer, p_OwnOffset + offsetof(SActivityDefinition, activity));
	TArray<SActivityObjective>::Serialize(&s_Object->objectives, p_Serializer, p_OwnOffset + offsetof(SActivityDefinition, objectives));
	SActivityExits::Serialize(&s_Object->exits, p_Serializer, p_OwnOffset + offsetof(SActivityDefinition, exits));
}

bool SActivityDefinition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActivityDefinition*>(p_Left);
	auto* s_Right = reinterpret_cast<SActivityDefinition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActivityDefinition::operator==(const SActivityDefinition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActivityDefinition>)
		return false;

	if (activity != p_Other.activity) return false;
	if (objectives != p_Other.objectives) return false;
	if (exits != p_Other.exits) return false;

	return true;
}

void SActivityDefinition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActivityDefinition*>(p_Object);
	s_Object->~SActivityDefinition();
}

ZHMTypeInfo SActivities::TypeInfo = ZHMTypeInfo("SActivities", sizeof(SActivities), alignof(SActivities), SActivities::WriteSimpleJson, SActivities::FromSimpleJson, SActivities::Serialize, SActivities::Equals, SActivities::Destroy);

void SActivities::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActivities*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Activities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Activities.size(); ++i)
	{
		auto& s_Item0 = s_Object->Activities[i];
		SActivityDefinition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->Activities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActivities::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActivities s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["Activities"];
	s_Object.Activities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActivityDefinition s_ArrayItem0;
		SActivityDefinition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.Activities[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActivities*>(p_Target) = s_Object;
}

void SActivities::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActivities*>(p_Object);

	TArray<SActivityDefinition>::Serialize(&s_Object->Activities, p_Serializer, p_OwnOffset + offsetof(SActivities, Activities));
}

bool SActivities::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActivities*>(p_Left);
	auto* s_Right = reinterpret_cast<SActivities*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActivities::operator==(const SActivities& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActivities>)
		return false;

	if (Activities != p_Other.Activities) return false;

	return true;
}

void SActivities::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActivities*>(p_Object);
	s_Object->~SActivities();
}

ZHMTypeInfo SActorAccessoryItemActionSaveData::TypeInfo = ZHMTypeInfo("SActorAccessoryItemActionSaveData", sizeof(SActorAccessoryItemActionSaveData), alignof(SActorAccessoryItemActionSaveData), SActorAccessoryItemActionSaveData::WriteSimpleJson, SActorAccessoryItemActionSaveData::FromSimpleJson, SActorAccessoryItemActionSaveData::Serialize, SActorAccessoryItemActionSaveData::Equals, SActorAccessoryItemActionSaveData::Destroy);

void SActorAccessoryItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorAccessoryItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorAccessoryItemActionSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Target) = s_Object;
}

void SActorAccessoryItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);

}

bool SActorAccessoryItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorAccessoryItemActionSaveData::operator==(const SActorAccessoryItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorAccessoryItemActionSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorAccessoryItemActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorAccessoryItemActionSaveData*>(p_Object);
	s_Object->~SActorAccessoryItemActionSaveData();
}

ZHMTypeInfo SActorAliveConditionSaveData::TypeInfo = ZHMTypeInfo("SActorAliveConditionSaveData", sizeof(SActorAliveConditionSaveData), alignof(SActorAliveConditionSaveData), SActorAliveConditionSaveData::WriteSimpleJson, SActorAliveConditionSaveData::FromSimpleJson, SActorAliveConditionSaveData::Serialize, SActorAliveConditionSaveData::Equals, SActorAliveConditionSaveData::Destroy);

void SActorAliveConditionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAliveConditionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorAliveConditionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorAliveConditionSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorAliveConditionSaveData*>(p_Target) = s_Object;
}

void SActorAliveConditionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorAliveConditionSaveData*>(p_Object);

}

bool SActorAliveConditionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorAliveConditionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorAliveConditionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorAliveConditionSaveData::operator==(const SActorAliveConditionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorAliveConditionSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorAliveConditionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorAliveConditionSaveData*>(p_Object);
	s_Object->~SActorAliveConditionSaveData();
}

ZHMTypeInfo SActorAnimSetVariationIndexSaveData::TypeInfo = ZHMTypeInfo("SActorAnimSetVariationIndexSaveData", sizeof(SActorAnimSetVariationIndexSaveData), alignof(SActorAnimSetVariationIndexSaveData), SActorAnimSetVariationIndexSaveData::WriteSimpleJson, SActorAnimSetVariationIndexSaveData::FromSimpleJson, SActorAnimSetVariationIndexSaveData::Serialize, SActorAnimSetVariationIndexSaveData::Equals, SActorAnimSetVariationIndexSaveData::Destroy);

void SActorAnimSetVariationIndexSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetVariationIndexSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rAnimationSetDefinition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAnimationSetDefinition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);

	p_Stream << "}";
}

void SActorAnimSetVariationIndexSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorAnimSetVariationIndexSaveData s_Object {};

	s_Object.m_rAnimationSetDefinition = simdjson::from_json_uint32(p_Document["m_rAnimationSetDefinition"]);

	s_Object.m_nIndex = simdjson::from_json_int32(p_Document["m_nIndex"]);

	*reinterpret_cast<SActorAnimSetVariationIndexSaveData*>(p_Target) = s_Object;
}

void SActorAnimSetVariationIndexSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetVariationIndexSaveData*>(p_Object);

}

bool SActorAnimSetVariationIndexSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorAnimSetVariationIndexSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorAnimSetVariationIndexSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorAnimSetVariationIndexSaveData::operator==(const SActorAnimSetVariationIndexSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorAnimSetVariationIndexSaveData>)
		return false;

	if (m_rAnimationSetDefinition != p_Other.m_rAnimationSetDefinition) return false;
	if (m_nIndex != p_Other.m_nIndex) return false;

	return true;
}

void SActorAnimSetVariationIndexSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetVariationIndexSaveData*>(p_Object);
	s_Object->~SActorAnimSetVariationIndexSaveData();
}

ZHMTypeInfo SActorAnimSetSaveData::TypeInfo = ZHMTypeInfo("SActorAnimSetSaveData", sizeof(SActorAnimSetSaveData), alignof(SActorAnimSetSaveData), SActorAnimSetSaveData::WriteSimpleJson, SActorAnimSetSaveData::FromSimpleJson, SActorAnimSetSaveData::Serialize, SActorAnimSetSaveData::Equals, SActorAnimSetSaveData::Destroy);

void SActorAnimSetSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eAnimSet") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetType", static_cast<int>(s_Object->m_eAnimSet)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCustomAnimationSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCustomAnimationSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eVariationResourceMaxTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eVariationResourceMaxTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eVariationResourceMaxEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eVariationResourceMaxEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAnimSetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetState", static_cast<int>(s_Object->m_eAnimSetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePreCustomAnimSet") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAnimSetType", static_cast<int>(s_Object->m_ePreCustomAnimSet)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aLocoVariationIndecies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aLocoVariationIndecies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aLocoVariationIndecies[i];
		SActorAnimSetVariationIndexSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aLocoVariationIndecies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aReactVariationIndecies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aReactVariationIndecies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aReactVariationIndecies[i];
		SActorAnimSetVariationIndexSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aReactVariationIndecies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorAnimSetSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorAnimSetSaveData s_Object {};

	s_Object.m_eAnimSet = static_cast<EAnimSetType>(ZHMEnums::GetEnumValueByName("EAnimSetType", std::string_view(p_Document["m_eAnimSet"])));

	s_Object.m_rCustomAnimationSet = simdjson::from_json_uint32(p_Document["m_rCustomAnimationSet"]);

	s_Object.m_eVariationResourceMaxTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eVariationResourceMaxTension"])));

	s_Object.m_eVariationResourceMaxEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eVariationResourceMaxEmotionState"])));

	s_Object.m_eAnimSetEmotionState = static_cast<EAnimSetState>(ZHMEnums::GetEnumValueByName("EAnimSetState", std::string_view(p_Document["m_eAnimSetEmotionState"])));

	s_Object.m_ePreCustomAnimSet = static_cast<EAnimSetType>(ZHMEnums::GetEnumValueByName("EAnimSetType", std::string_view(p_Document["m_ePreCustomAnimSet"])));

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aLocoVariationIndecies"];
	s_Object.m_aLocoVariationIndecies.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorAnimSetVariationIndexSaveData s_ArrayItem0;
		SActorAnimSetVariationIndexSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aLocoVariationIndecies[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aReactVariationIndecies"];
	s_Object.m_aReactVariationIndecies.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorAnimSetVariationIndexSaveData s_ArrayItem0;
		SActorAnimSetVariationIndexSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aReactVariationIndecies[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActorAnimSetSaveData*>(p_Target) = s_Object;
}

void SActorAnimSetSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);

	TArray<SActorAnimSetVariationIndexSaveData>::Serialize(&s_Object->m_aLocoVariationIndecies, p_Serializer, p_OwnOffset + offsetof(SActorAnimSetSaveData, m_aLocoVariationIndecies));
	TArray<SActorAnimSetVariationIndexSaveData>::Serialize(&s_Object->m_aReactVariationIndecies, p_Serializer, p_OwnOffset + offsetof(SActorAnimSetSaveData, m_aReactVariationIndecies));
}

bool SActorAnimSetSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorAnimSetSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorAnimSetSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorAnimSetSaveData::operator==(const SActorAnimSetSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorAnimSetSaveData>)
		return false;

	if (m_eAnimSet != p_Other.m_eAnimSet) return false;
	if (m_rCustomAnimationSet != p_Other.m_rCustomAnimationSet) return false;
	if (m_eVariationResourceMaxTension != p_Other.m_eVariationResourceMaxTension) return false;
	if (m_eVariationResourceMaxEmotionState != p_Other.m_eVariationResourceMaxEmotionState) return false;
	if (m_eAnimSetEmotionState != p_Other.m_eAnimSetEmotionState) return false;
	if (m_ePreCustomAnimSet != p_Other.m_ePreCustomAnimSet) return false;
	if (m_aLocoVariationIndecies != p_Other.m_aLocoVariationIndecies) return false;
	if (m_aReactVariationIndecies != p_Other.m_aReactVariationIndecies) return false;

	return true;
}

void SActorAnimSetSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorAnimSetSaveData*>(p_Object);
	s_Object->~SActorAnimSetSaveData();
}

ZHMTypeInfo SActorBoneAttachSaveData::TypeInfo = ZHMTypeInfo("SActorBoneAttachSaveData", sizeof(SActorBoneAttachSaveData), alignof(SActorBoneAttachSaveData), SActorBoneAttachSaveData::WriteSimpleJson, SActorBoneAttachSaveData::FromSimpleJson, SActorBoneAttachSaveData::Serialize, SActorBoneAttachSaveData::Equals, SActorBoneAttachSaveData::Destroy);

void SActorBoneAttachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rAttachmentTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAttachmentTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAttached);

	p_Stream << "}";
}

void SActorBoneAttachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorBoneAttachSaveData s_Object {};

	s_Object.m_rAttachmentTarget = simdjson::from_json_uint32(p_Document["m_rAttachmentTarget"]);

	s_Object.m_bIsAttached = simdjson::from_json_bool(p_Document["m_bIsAttached"]);

	*reinterpret_cast<SActorBoneAttachSaveData*>(p_Target) = s_Object;
}

void SActorBoneAttachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);

}

bool SActorBoneAttachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneAttachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneAttachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneAttachSaveData::operator==(const SActorBoneAttachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneAttachSaveData>)
		return false;

	if (m_rAttachmentTarget != p_Other.m_rAttachmentTarget) return false;
	if (m_bIsAttached != p_Other.m_bIsAttached) return false;

	return true;
}

void SActorBoneAttachSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachSaveData*>(p_Object);
	s_Object->~SActorBoneAttachSaveData();
}

ZHMTypeInfo SActorBoneAttachmentsSaveData::TypeInfo = ZHMTypeInfo("SActorBoneAttachmentsSaveData", sizeof(SActorBoneAttachmentsSaveData), alignof(SActorBoneAttachmentsSaveData), SActorBoneAttachmentsSaveData::WriteSimpleJson, SActorBoneAttachmentsSaveData::FromSimpleJson, SActorBoneAttachmentsSaveData::Serialize, SActorBoneAttachmentsSaveData::Equals, SActorBoneAttachmentsSaveData::Destroy);

void SActorBoneAttachmentsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorBoneAttachSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorBoneAttachmentsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorBoneAttachmentsSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorBoneAttachSaveData s_ArrayItem0;
		SActorBoneAttachSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Target) = s_Object;
}

void SActorBoneAttachmentsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorBoneAttachmentsSaveData, m_aEntities));
	TArray<SActorBoneAttachSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorBoneAttachmentsSaveData, m_aData));
}

bool SActorBoneAttachmentsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneAttachmentsSaveData::operator==(const SActorBoneAttachmentsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneAttachmentsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SActorBoneAttachmentsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorBoneAttachmentsSaveData*>(p_Object);
	s_Object->~SActorBoneAttachmentsSaveData();
}

ZHMTypeInfo SVector4::TypeInfo = ZHMTypeInfo("SVector4", sizeof(SVector4), alignof(SVector4), SVector4::WriteSimpleJson, SVector4::FromSimpleJson, SVector4::Serialize, SVector4::Equals, SVector4::Destroy);

void SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector4 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	s_Object.w = simdjson::from_json_float32(p_Document["w"]);

	*reinterpret_cast<SVector4*>(p_Target) = s_Object;
}

void SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);

}

bool SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector4::operator==(const SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector4>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;
	if (w != p_Other.w) return false;

	return true;
}

void SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVector4*>(p_Object);
	s_Object->~SVector4();
}

ZHMTypeInfo SActorBoneSaveData::TypeInfo = ZHMTypeInfo("SActorBoneSaveData", sizeof(SActorBoneSaveData), alignof(SActorBoneSaveData), SActorBoneSaveData::WriteSimpleJson, SActorBoneSaveData::FromSimpleJson, SActorBoneSaveData::Serialize, SActorBoneSaveData::Equals, SActorBoneSaveData::Destroy);

void SActorBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SActorBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorBoneSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Item);
		s_Object.mQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Item);
		s_Object.mTranslation = s_Item;
	}

	*reinterpret_cast<SActorBoneSaveData*>(p_Target) = s_Object;
}

void SActorBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SActorBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SActorBoneSaveData, mTranslation));
}

bool SActorBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorBoneSaveData::operator==(const SActorBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

void SActorBoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorBoneSaveData*>(p_Object);
	s_Object->~SActorBoneSaveData();
}

ZHMTypeInfo SActorDamageControlSaveData::TypeInfo = ZHMTypeInfo("SActorDamageControlSaveData", sizeof(SActorDamageControlSaveData), alignof(SActorDamageControlSaveData), SActorDamageControlSaveData::WriteSimpleJson, SActorDamageControlSaveData::FromSimpleJson, SActorDamageControlSaveData::Serialize, SActorDamageControlSaveData::Equals, SActorDamageControlSaveData::Destroy);

void SActorDamageControlSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDamageControlSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("bExplosive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bExplosive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bProjectile") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bProjectile);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHeadshot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHeadshot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSniperShot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSniperShot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bThroughWall") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bThroughWall);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bKillByAccident") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bKillByAccident);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bWeaponSilenced") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bWeaponSilenced);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bLongRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bLongRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fTotalDamage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fTotalDamage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fPacifyDamage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fPacifyDamage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nImpactBodyPart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nImpactBodyPart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("maxDeathType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathType", static_cast<int>(s_Object->maxDeathType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("maxDeathContext") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathContext", static_cast<int>(s_Object->maxDeathContext)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rAccidentSetup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rAccidentSetup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bFirearmPacifiesTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bFirearmPacifiesTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bBulletCausesHitReaction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bBulletCausesHitReaction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fHitsNumberTimeout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fHitsNumberTimeout);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fHealthPercentTimeout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fHealthPercentTimeout);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rCharacter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rCharacter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rSource") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rSource);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_accuseUnconsciousOutfit") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_accuseUnconsciousOutfit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidAccuseUnconsciousOutfit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidAccuseUnconsciousOutfit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eDeathSpeak") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorSoundDefs", static_cast<int>(s_Object->eDeathSpeak)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDefaultDeathSound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDefaultDeathSound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iEvents") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iEvents);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAgilityElementUncosciousTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAgilityElementUncosciousTime);

	p_Stream << "}";
}

void SActorDamageControlSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorDamageControlSaveData s_Object {};

	s_Object.bExplosive = simdjson::from_json_bool(p_Document["bExplosive"]);

	s_Object.bProjectile = simdjson::from_json_bool(p_Document["bProjectile"]);

	s_Object.bHeadshot = simdjson::from_json_bool(p_Document["bHeadshot"]);

	s_Object.bSniperShot = simdjson::from_json_bool(p_Document["bSniperShot"]);

	s_Object.bThroughWall = simdjson::from_json_bool(p_Document["bThroughWall"]);

	s_Object.bKillByAccident = simdjson::from_json_bool(p_Document["bKillByAccident"]);

	s_Object.bWeaponSilenced = simdjson::from_json_bool(p_Document["bWeaponSilenced"]);

	s_Object.bLongRange = simdjson::from_json_bool(p_Document["bLongRange"]);

	s_Object.fTotalDamage = simdjson::from_json_float32(p_Document["fTotalDamage"]);

	s_Object.fPacifyDamage = simdjson::from_json_float32(p_Document["fPacifyDamage"]);

	s_Object.nImpactBodyPart = simdjson::from_json_int32(p_Document["nImpactBodyPart"]);

	s_Object.maxDeathType = static_cast<EDeathType>(ZHMEnums::GetEnumValueByName("EDeathType", std::string_view(p_Document["maxDeathType"])));

	s_Object.maxDeathContext = static_cast<EDeathContext>(ZHMEnums::GetEnumValueByName("EDeathContext", std::string_view(p_Document["maxDeathContext"])));

	s_Object.rAccidentSetup = simdjson::from_json_uint32(p_Document["rAccidentSetup"]);

	s_Object.bFirearmPacifiesTarget = simdjson::from_json_bool(p_Document["bFirearmPacifiesTarget"]);

	s_Object.bBulletCausesHitReaction = simdjson::from_json_bool(p_Document["bBulletCausesHitReaction"]);

	s_Object.fHitsNumberTimeout = simdjson::from_json_float32(p_Document["fHitsNumberTimeout"]);

	s_Object.fHealthPercentTimeout = simdjson::from_json_float32(p_Document["fHealthPercentTimeout"]);

	s_Object.rCharacter = simdjson::from_json_uint32(p_Document["rCharacter"]);

	s_Object.rSource = simdjson::from_json_uint32(p_Document["rSource"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_accuseUnconsciousOutfit"], &s_Item);
		s_Object.m_accuseUnconsciousOutfit = s_Item;
	}

	s_Object.m_bValidAccuseUnconsciousOutfit = simdjson::from_json_bool(p_Document["m_bValidAccuseUnconsciousOutfit"]);

	s_Object.eDeathSpeak = static_cast<EActorSoundDefs>(ZHMEnums::GetEnumValueByName("EActorSoundDefs", std::string_view(p_Document["eDeathSpeak"])));

	s_Object.bDefaultDeathSound = simdjson::from_json_bool(p_Document["bDefaultDeathSound"]);

	s_Object.iEvents = simdjson::from_json_int32(p_Document["iEvents"]);

	s_Object.fAgilityElementUncosciousTime = simdjson::from_json_float32(p_Document["fAgilityElementUncosciousTime"]);

	*reinterpret_cast<SActorDamageControlSaveData*>(p_Target) = s_Object;
}

void SActorDamageControlSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDamageControlSaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_accuseUnconsciousOutfit, p_Serializer, p_OwnOffset + offsetof(SActorDamageControlSaveData, m_accuseUnconsciousOutfit));
}

bool SActorDamageControlSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDamageControlSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDamageControlSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDamageControlSaveData::operator==(const SActorDamageControlSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDamageControlSaveData>)
		return false;

	if (bExplosive != p_Other.bExplosive) return false;
	if (bProjectile != p_Other.bProjectile) return false;
	if (bHeadshot != p_Other.bHeadshot) return false;
	if (bSniperShot != p_Other.bSniperShot) return false;
	if (bThroughWall != p_Other.bThroughWall) return false;
	if (bKillByAccident != p_Other.bKillByAccident) return false;
	if (bWeaponSilenced != p_Other.bWeaponSilenced) return false;
	if (bLongRange != p_Other.bLongRange) return false;
	if (fTotalDamage != p_Other.fTotalDamage) return false;
	if (fPacifyDamage != p_Other.fPacifyDamage) return false;
	if (nImpactBodyPart != p_Other.nImpactBodyPart) return false;
	if (maxDeathType != p_Other.maxDeathType) return false;
	if (maxDeathContext != p_Other.maxDeathContext) return false;
	if (rAccidentSetup != p_Other.rAccidentSetup) return false;
	if (bFirearmPacifiesTarget != p_Other.bFirearmPacifiesTarget) return false;
	if (bBulletCausesHitReaction != p_Other.bBulletCausesHitReaction) return false;
	if (fHitsNumberTimeout != p_Other.fHitsNumberTimeout) return false;
	if (fHealthPercentTimeout != p_Other.fHealthPercentTimeout) return false;
	if (rCharacter != p_Other.rCharacter) return false;
	if (rSource != p_Other.rSource) return false;
	if (m_accuseUnconsciousOutfit != p_Other.m_accuseUnconsciousOutfit) return false;
	if (m_bValidAccuseUnconsciousOutfit != p_Other.m_bValidAccuseUnconsciousOutfit) return false;
	if (eDeathSpeak != p_Other.eDeathSpeak) return false;
	if (bDefaultDeathSound != p_Other.bDefaultDeathSound) return false;
	if (iEvents != p_Other.iEvents) return false;
	if (fAgilityElementUncosciousTime != p_Other.fAgilityElementUncosciousTime) return false;

	return true;
}

void SActorDamageControlSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorDamageControlSaveData*>(p_Object);
	s_Object->~SActorDamageControlSaveData();
}

ZHMTypeInfo SActorDynamicTemplateHandlerSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateHandlerSaveData", sizeof(SActorDynamicTemplateHandlerSaveData), alignof(SActorDynamicTemplateHandlerSaveData), SActorDynamicTemplateHandlerSaveData::WriteSimpleJson, SActorDynamicTemplateHandlerSaveData::FromSimpleJson, SActorDynamicTemplateHandlerSaveData::Serialize, SActorDynamicTemplateHandlerSaveData::Equals, SActorDynamicTemplateHandlerSaveData::Destroy);

void SActorDynamicTemplateHandlerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSetpiece") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSetpiece);

	p_Stream << "}";
}

void SActorDynamicTemplateHandlerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorDynamicTemplateHandlerSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	s_Object.m_rSetpiece = simdjson::from_json_uint32(p_Document["m_rSetpiece"]);

	*reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Target) = s_Object;
}

void SActorDynamicTemplateHandlerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);

}

bool SActorDynamicTemplateHandlerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateHandlerSaveData::operator==(const SActorDynamicTemplateHandlerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateHandlerSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rItem != p_Other.m_rItem) return false;
	if (m_rSetpiece != p_Other.m_rSetpiece) return false;

	return true;
}

void SActorDynamicTemplateHandlerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateHandlerSaveData*>(p_Object);
	s_Object->~SActorDynamicTemplateHandlerSaveData();
}

ZHMTypeInfo SActorDynamicTemplateManipulatorSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateManipulatorSaveData", sizeof(SActorDynamicTemplateManipulatorSaveData), alignof(SActorDynamicTemplateManipulatorSaveData), SActorDynamicTemplateManipulatorSaveData::WriteSimpleJson, SActorDynamicTemplateManipulatorSaveData::FromSimpleJson, SActorDynamicTemplateManipulatorSaveData::Serialize, SActorDynamicTemplateManipulatorSaveData::Equals, SActorDynamicTemplateManipulatorSaveData::Destroy);

void SActorDynamicTemplateManipulatorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorDynamicTemplateManipulatorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorDynamicTemplateManipulatorSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Target) = s_Object;
}

void SActorDynamicTemplateManipulatorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);

}

bool SActorDynamicTemplateManipulatorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateManipulatorSaveData::operator==(const SActorDynamicTemplateManipulatorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateManipulatorSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorDynamicTemplateManipulatorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateManipulatorSaveData*>(p_Object);
	s_Object->~SActorDynamicTemplateManipulatorSaveData();
}

ZHMTypeInfo SActorDynamicTemplateSaveData::TypeInfo = ZHMTypeInfo("SActorDynamicTemplateSaveData", sizeof(SActorDynamicTemplateSaveData), alignof(SActorDynamicTemplateSaveData), SActorDynamicTemplateSaveData::WriteSimpleJson, SActorDynamicTemplateSaveData::FromSimpleJson, SActorDynamicTemplateSaveData::Serialize, SActorDynamicTemplateSaveData::Equals, SActorDynamicTemplateSaveData::Destroy);

void SActorDynamicTemplateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTensionLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eTensionLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeLimit") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nTimeLimit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTensionRemoveLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eTensionRemoveLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionRemoveLimit") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionRemoveLimit)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeRemoveLimit") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nTimeRemoveLimit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_resourceID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_resourceID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInstance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInstance);

	p_Stream << "}";
}

void SActorDynamicTemplateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorDynamicTemplateSaveData s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	s_Object.m_eTensionLimit = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eTensionLimit"])));

	s_Object.m_eEmotionLimit = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eEmotionLimit"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nTimeLimit"], &s_Item);
		s_Object.m_nTimeLimit = s_Item;
	}

	s_Object.m_eTensionRemoveLimit = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eTensionRemoveLimit"])));

	s_Object.m_eEmotionRemoveLimit = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eEmotionRemoveLimit"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nTimeRemoveLimit"], &s_Item);
		s_Object.m_nTimeRemoveLimit = s_Item;
	}

	s_Object.m_resourceID = simdjson::from_json_int64(p_Document["m_resourceID"]);

	s_Object.m_rInstance = simdjson::from_json_uint32(p_Document["m_rInstance"]);

	*reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Target) = s_Object;
}

void SActorDynamicTemplateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_sName));
	ZGameTime::Serialize(&s_Object->m_nTimeLimit, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_nTimeLimit));
	ZGameTime::Serialize(&s_Object->m_nTimeRemoveLimit, p_Serializer, p_OwnOffset + offsetof(SActorDynamicTemplateSaveData, m_nTimeRemoveLimit));
}

bool SActorDynamicTemplateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorDynamicTemplateSaveData::operator==(const SActorDynamicTemplateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorDynamicTemplateSaveData>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_eTensionLimit != p_Other.m_eTensionLimit) return false;
	if (m_eEmotionLimit != p_Other.m_eEmotionLimit) return false;
	if (m_nTimeLimit != p_Other.m_nTimeLimit) return false;
	if (m_eTensionRemoveLimit != p_Other.m_eTensionRemoveLimit) return false;
	if (m_eEmotionRemoveLimit != p_Other.m_eEmotionRemoveLimit) return false;
	if (m_nTimeRemoveLimit != p_Other.m_nTimeRemoveLimit) return false;
	if (m_resourceID != p_Other.m_resourceID) return false;
	if (m_rInstance != p_Other.m_rInstance) return false;

	return true;
}

void SActorDynamicTemplateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorDynamicTemplateSaveData*>(p_Object);
	s_Object->~SActorDynamicTemplateSaveData();
}

ZHMTypeInfo SActorGoalSaveData::TypeInfo = ZHMTypeInfo("SActorGoalSaveData", sizeof(SActorGoalSaveData), alignof(SActorGoalSaveData), SActorGoalSaveData::WriteSimpleJson, SActorGoalSaveData::FromSimpleJson, SActorGoalSaveData::Serialize, SActorGoalSaveData::Equals, SActorGoalSaveData::Destroy);

void SActorGoalSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aHandled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHandled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHandled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aHandled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIsCurrent") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIsCurrent.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIsCurrent[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIsCurrent.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fExpiredTime") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_fExpiredTime.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_fExpiredTime[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_fExpiredTime.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorGoalSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorGoalSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aHandled"];
	s_Object.m_aHandled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aHandled[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIsCurrent"];
	s_Object.m_aIsCurrent.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aIsCurrent[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_fExpiredTime"];
	s_Object.m_fExpiredTime.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_fExpiredTime[s_Index0++] = simdjson::from_json_float32(s_Item0);
	}
	}

	*reinterpret_cast<SActorGoalSaveData*>(p_Target) = s_Object;
}

void SActorGoalSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aEntities));
	TArray<bool>::Serialize(&s_Object->m_aHandled, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aHandled));
	TArray<bool>::Serialize(&s_Object->m_aIsCurrent, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_aIsCurrent));
	TArray<float32>::Serialize(&s_Object->m_fExpiredTime, p_Serializer, p_OwnOffset + offsetof(SActorGoalSaveData, m_fExpiredTime));
}

bool SActorGoalSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorGoalSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorGoalSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorGoalSaveData::operator==(const SActorGoalSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorGoalSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aHandled != p_Other.m_aHandled) return false;
	if (m_aIsCurrent != p_Other.m_aIsCurrent) return false;
	if (m_fExpiredTime != p_Other.m_fExpiredTime) return false;

	return true;
}

void SActorGoalSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorGoalSaveData*>(p_Object);
	s_Object->~SActorGoalSaveData();
}

ZHMTypeInfo SActorIKControllerSaveData::TypeInfo = ZHMTypeInfo("SActorIKControllerSaveData", sizeof(SActorIKControllerSaveData), alignof(SActorIKControllerSaveData), SActorIKControllerSaveData::WriteSimpleJson, SActorIKControllerSaveData::FromSimpleJson, SActorIKControllerSaveData::Serialize, SActorIKControllerSaveData::Equals, SActorIKControllerSaveData::Destroy);

void SActorIKControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorIKControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fRightHandWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRightHandWeight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLeftHandWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLeftHandWeight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRightHandTargetWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRightHandTargetWeight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLeftHandTargetWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLeftHandTargetWeight);

	p_Stream << "}";
}

void SActorIKControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorIKControllerSaveData s_Object {};

	s_Object.m_fRightHandWeight = simdjson::from_json_float32(p_Document["m_fRightHandWeight"]);

	s_Object.m_fLeftHandWeight = simdjson::from_json_float32(p_Document["m_fLeftHandWeight"]);

	s_Object.m_fRightHandTargetWeight = simdjson::from_json_float32(p_Document["m_fRightHandTargetWeight"]);

	s_Object.m_fLeftHandTargetWeight = simdjson::from_json_float32(p_Document["m_fLeftHandTargetWeight"]);

	*reinterpret_cast<SActorIKControllerSaveData*>(p_Target) = s_Object;
}

void SActorIKControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorIKControllerSaveData*>(p_Object);

}

bool SActorIKControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorIKControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorIKControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorIKControllerSaveData::operator==(const SActorIKControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorIKControllerSaveData>)
		return false;

	if (m_fRightHandWeight != p_Other.m_fRightHandWeight) return false;
	if (m_fLeftHandWeight != p_Other.m_fLeftHandWeight) return false;
	if (m_fRightHandTargetWeight != p_Other.m_fRightHandTargetWeight) return false;
	if (m_fLeftHandTargetWeight != p_Other.m_fLeftHandTargetWeight) return false;

	return true;
}

void SActorIKControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorIKControllerSaveData*>(p_Object);
	s_Object->~SActorIKControllerSaveData();
}

ZHMTypeInfo SActorInventoryItemSaveData::TypeInfo = ZHMTypeInfo("SActorInventoryItemSaveData", sizeof(SActorInventoryItemSaveData), alignof(SActorInventoryItemSaveData), SActorInventoryItemSaveData::WriteSimpleJson, SActorInventoryItemSaveData::FromSimpleJson, SActorInventoryItemSaveData::Serialize, SActorInventoryItemSaveData::Equals, SActorInventoryItemSaveData::Destroy);

void SActorInventoryItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAttachLocation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAttachLocation", static_cast<int>(s_Object->m_eAttachLocation)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMaxTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eMaxTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeftHand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeftHand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeapon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeapon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGrenade") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGrenade);

	p_Stream << "}";
}

void SActorInventoryItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorInventoryItemSaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	s_Object.m_eAttachLocation = static_cast<EAttachLocation>(ZHMEnums::GetEnumValueByName("EAttachLocation", std::string_view(p_Document["m_eAttachLocation"])));

	s_Object.m_eMaxTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eMaxTension"])));

	s_Object.m_bLeftHand = simdjson::from_json_bool(p_Document["m_bLeftHand"]);

	s_Object.m_bWeapon = simdjson::from_json_bool(p_Document["m_bWeapon"]);

	s_Object.m_bGrenade = simdjson::from_json_bool(p_Document["m_bGrenade"]);

	*reinterpret_cast<SActorInventoryItemSaveData*>(p_Target) = s_Object;
}

void SActorInventoryItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);

}

bool SActorInventoryItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorInventoryItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorInventoryItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorInventoryItemSaveData::operator==(const SActorInventoryItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorInventoryItemSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;
	if (m_eAttachLocation != p_Other.m_eAttachLocation) return false;
	if (m_eMaxTension != p_Other.m_eMaxTension) return false;
	if (m_bLeftHand != p_Other.m_bLeftHand) return false;
	if (m_bWeapon != p_Other.m_bWeapon) return false;
	if (m_bGrenade != p_Other.m_bGrenade) return false;

	return true;
}

void SActorInventoryItemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorInventoryItemSaveData*>(p_Object);
	s_Object->~SActorInventoryItemSaveData();
}

ZHMTypeInfo SActorInventorySaveData::TypeInfo = ZHMTypeInfo("SActorInventorySaveData", sizeof(SActorInventorySaveData), alignof(SActorInventorySaveData), SActorInventorySaveData::WriteSimpleJson, SActorInventorySaveData::FromSimpleJson, SActorInventorySaveData::Serialize, SActorInventorySaveData::Equals, SActorInventorySaveData::Destroy);

void SActorInventorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		SActorInventoryItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorInventorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorInventorySaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aItems"];
	s_Object.m_aItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorInventoryItemSaveData s_ArrayItem0;
		SActorInventoryItemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItems[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActorInventorySaveData*>(p_Target) = s_Object;
}

void SActorInventorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);

	TArray<SActorInventoryItemSaveData>::Serialize(&s_Object->m_aItems, p_Serializer, p_OwnOffset + offsetof(SActorInventorySaveData, m_aItems));
}

bool SActorInventorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorInventorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorInventorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorInventorySaveData::operator==(const SActorInventorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorInventorySaveData>)
		return false;

	if (m_aItems != p_Other.m_aItems) return false;

	return true;
}

void SActorInventorySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorInventorySaveData*>(p_Object);
	s_Object->~SActorInventorySaveData();
}

ZHMTypeInfo SActorItemActionSaveData::TypeInfo = ZHMTypeInfo("SActorItemActionSaveData", sizeof(SActorItemActionSaveData), alignof(SActorItemActionSaveData), SActorItemActionSaveData::WriteSimpleJson, SActorItemActionSaveData::FromSimpleJson, SActorItemActionSaveData::Serialize, SActorItemActionSaveData::Equals, SActorItemActionSaveData::Destroy);

void SActorItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SActorItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorItemActionSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SActorItemActionSaveData*>(p_Target) = s_Object;
}

void SActorItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);

}

bool SActorItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorItemActionSaveData::operator==(const SActorItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorItemActionSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SActorItemActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorItemActionSaveData*>(p_Object);
	s_Object->~SActorItemActionSaveData();
}

ZHMTypeInfo SActorKeywordProxySaveData::TypeInfo = ZHMTypeInfo("SActorKeywordProxySaveData", sizeof(SActorKeywordProxySaveData), alignof(SActorKeywordProxySaveData), SActorKeywordProxySaveData::WriteSimpleJson, SActorKeywordProxySaveData::FromSimpleJson, SActorKeywordProxySaveData::Serialize, SActorKeywordProxySaveData::Equals, SActorKeywordProxySaveData::Destroy);

void SActorKeywordProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorKeywordProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorKeywordProxySaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorKeywordProxySaveData*>(p_Target) = s_Object;
}

void SActorKeywordProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);

}

bool SActorKeywordProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorKeywordProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorKeywordProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorKeywordProxySaveData::operator==(const SActorKeywordProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorKeywordProxySaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorKeywordProxySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxySaveData*>(p_Object);
	s_Object->~SActorKeywordProxySaveData();
}

ZHMTypeInfo SActorKeywordProxiesSaveData::TypeInfo = ZHMTypeInfo("SActorKeywordProxiesSaveData", sizeof(SActorKeywordProxiesSaveData), alignof(SActorKeywordProxiesSaveData), SActorKeywordProxiesSaveData::WriteSimpleJson, SActorKeywordProxiesSaveData::FromSimpleJson, SActorKeywordProxiesSaveData::Serialize, SActorKeywordProxiesSaveData::Equals, SActorKeywordProxiesSaveData::Destroy);

void SActorKeywordProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorKeywordProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorKeywordProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorKeywordProxiesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorKeywordProxySaveData s_ArrayItem0;
		SActorKeywordProxySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Target) = s_Object;
}

void SActorKeywordProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorKeywordProxiesSaveData, m_aEntities));
	TArray<SActorKeywordProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorKeywordProxiesSaveData, m_aData));
}

bool SActorKeywordProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorKeywordProxiesSaveData::operator==(const SActorKeywordProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorKeywordProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SActorKeywordProxiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorKeywordProxiesSaveData*>(p_Object);
	s_Object->~SActorKeywordProxiesSaveData();
}

ZHMTypeInfo SActorManagerReferencableData::TypeInfo = ZHMTypeInfo("SActorManagerReferencableData", sizeof(SActorManagerReferencableData), alignof(SActorManagerReferencableData), SActorManagerReferencableData::WriteSimpleJson, SActorManagerReferencableData::FromSimpleJson, SActorManagerReferencableData::Serialize, SActorManagerReferencableData::Equals, SActorManagerReferencableData::Destroy);

void SActorManagerReferencableData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSituationTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSituationTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSituationTypes[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationType", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aSituationTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorManagerReferencableData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorManagerReferencableData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSituationTypes"];
	s_Object.m_aSituationTypes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aSituationTypes[s_Index0++] = static_cast<ESituationType>(ZHMEnums::GetEnumValueByName("ESituationType", std::string_view(s_Item0)));
	}
	}

	*reinterpret_cast<SActorManagerReferencableData*>(p_Target) = s_Object;
}

void SActorManagerReferencableData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);

	TArray<ESituationType>::Serialize(&s_Object->m_aSituationTypes, p_Serializer, p_OwnOffset + offsetof(SActorManagerReferencableData, m_aSituationTypes));
}

bool SActorManagerReferencableData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorManagerReferencableData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorManagerReferencableData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorManagerReferencableData::operator==(const SActorManagerReferencableData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorManagerReferencableData>)
		return false;

	if (m_aSituationTypes != p_Other.m_aSituationTypes) return false;

	return true;
}

void SActorManagerReferencableData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorManagerReferencableData*>(p_Object);
	s_Object->~SActorManagerReferencableData();
}

ZHMTypeInfo SActorProviderApproachSaveData::TypeInfo = ZHMTypeInfo("SActorProviderApproachSaveData", sizeof(SActorProviderApproachSaveData), alignof(SActorProviderApproachSaveData), SActorProviderApproachSaveData::WriteSimpleJson, SActorProviderApproachSaveData::FromSimpleJson, SActorProviderApproachSaveData::Serialize, SActorProviderApproachSaveData::Equals, SActorProviderApproachSaveData::Destroy);

void SActorProviderApproachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCastActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCastActor);

	p_Stream << "}";
}

void SActorProviderApproachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorProviderApproachSaveData s_Object {};

	s_Object.m_rCastActor = simdjson::from_json_uint32(p_Document["m_rCastActor"]);

	*reinterpret_cast<SActorProviderApproachSaveData*>(p_Target) = s_Object;
}

void SActorProviderApproachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);

}

bool SActorProviderApproachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProviderApproachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProviderApproachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProviderApproachSaveData::operator==(const SActorProviderApproachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProviderApproachSaveData>)
		return false;

	if (m_rCastActor != p_Other.m_rCastActor) return false;

	return true;
}

void SActorProviderApproachSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorProviderApproachSaveData*>(p_Object);
	s_Object->~SActorProviderApproachSaveData();
}

ZHMTypeInfo SActorProviderDirectSaveData::TypeInfo = ZHMTypeInfo("SActorProviderDirectSaveData", sizeof(SActorProviderDirectSaveData), alignof(SActorProviderDirectSaveData), SActorProviderDirectSaveData::WriteSimpleJson, SActorProviderDirectSaveData::FromSimpleJson, SActorProviderDirectSaveData::Serialize, SActorProviderDirectSaveData::Equals, SActorProviderDirectSaveData::Destroy);

void SActorProviderDirectSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunning);

	p_Stream << "}";
}

void SActorProviderDirectSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorProviderDirectSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActors"];
	s_Object.m_aActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aActors[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_bRunning = simdjson::from_json_bool(p_Document["m_bRunning"]);

	*reinterpret_cast<SActorProviderDirectSaveData*>(p_Target) = s_Object;
}

void SActorProviderDirectSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SActorProviderDirectSaveData, m_aActors));
}

bool SActorProviderDirectSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProviderDirectSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProviderDirectSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProviderDirectSaveData::operator==(const SActorProviderDirectSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProviderDirectSaveData>)
		return false;

	if (m_aActors != p_Other.m_aActors) return false;
	if (m_bRunning != p_Other.m_bRunning) return false;

	return true;
}

void SActorProviderDirectSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorProviderDirectSaveData*>(p_Object);
	s_Object->~SActorProviderDirectSaveData();
}

ZHMTypeInfo SVector3::TypeInfo = ZHMTypeInfo("SVector3", sizeof(SVector3), alignof(SVector3), SVector3::WriteSimpleJson, SVector3::FromSimpleJson, SVector3::Serialize, SVector3::Equals, SVector3::Destroy);

void SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("z") << ":";
	p_Stream << simdjson::as_json_string(s_Object->z);

	p_Stream << "}";
}

void SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector3 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	s_Object.z = simdjson::from_json_float32(p_Document["z"]);

	*reinterpret_cast<SVector3*>(p_Target) = s_Object;
}

void SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);

}

bool SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector3::operator==(const SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector3>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (z != p_Other.z) return false;

	return true;
}

void SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVector3*>(p_Object);
	s_Object->~SVector3();
}

ZHMTypeInfo SActorRagdollPoseSaveData::TypeInfo = ZHMTypeInfo("SActorRagdollPoseSaveData", sizeof(SActorRagdollPoseSaveData), alignof(SActorRagdollPoseSaveData), SActorRagdollPoseSaveData::WriteSimpleJson, SActorRagdollPoseSaveData::FromSimpleJson, SActorRagdollPoseSaveData::Serialize, SActorRagdollPoseSaveData::Equals, SActorRagdollPoseSaveData::Destroy);

void SActorRagdollPoseSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vBodyVelocity") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vBodyVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SActorBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBoneIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorRagdollPoseSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorRagdollPoseSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vBodyVelocity"], &s_Item);
		s_Object.m_vBodyVelocity = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBones"];
	s_Object.m_aBones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorBoneSaveData s_ArrayItem0;
		SActorBoneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBones[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneIndices"];
	s_Object.m_aBoneIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aBoneIndices[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SActorRagdollPoseSaveData*>(p_Target) = s_Object;
}

void SActorRagdollPoseSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vBodyVelocity, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_vBodyVelocity));
	TArray<SActorBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_aBones));
	TArray<uint32>::Serialize(&s_Object->m_aBoneIndices, p_Serializer, p_OwnOffset + offsetof(SActorRagdollPoseSaveData, m_aBoneIndices));
}

bool SActorRagdollPoseSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorRagdollPoseSaveData::operator==(const SActorRagdollPoseSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorRagdollPoseSaveData>)
		return false;

	if (m_vBodyVelocity != p_Other.m_vBodyVelocity) return false;
	if (m_aBones != p_Other.m_aBones) return false;
	if (m_aBoneIndices != p_Other.m_aBoneIndices) return false;

	return true;
}

void SActorRagdollPoseSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorRagdollPoseSaveData*>(p_Object);
	s_Object->~SActorRagdollPoseSaveData();
}

ZHMTypeInfo SActorThrowSaveData::TypeInfo = ZHMTypeInfo("SActorThrowSaveData", sizeof(SActorThrowSaveData), alignof(SActorThrowSaveData), SActorThrowSaveData::WriteSimpleJson, SActorThrowSaveData::FromSimpleJson, SActorThrowSaveData::Serialize, SActorThrowSaveData::Equals, SActorThrowSaveData::Destroy);

void SActorThrowSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorThrowSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vStartPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStartPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vEndPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vEndPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vItemVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_vItemVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistance);

	p_Stream << "}";
}

void SActorThrowSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorThrowSaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStartPosition"], &s_Item);
		s_Object.m_vStartPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vEndPosition"], &s_Item);
		s_Object.m_vEndPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vItemVelocity"], &s_Item);
		s_Object.m_vItemVelocity = s_Item;
	}

	s_Object.m_fDistance = simdjson::from_json_float32(p_Document["m_fDistance"]);

	*reinterpret_cast<SActorThrowSaveData*>(p_Target) = s_Object;
}

void SActorThrowSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorThrowSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStartPosition, p_Serializer, p_OwnOffset + offsetof(SActorThrowSaveData, m_vStartPosition));
	float4::Serialize(&s_Object->m_vEndPosition, p_Serializer, p_OwnOffset + offsetof(SActorThrowSaveData, m_vEndPosition));
	float4::Serialize(&s_Object->m_vItemVelocity, p_Serializer, p_OwnOffset + offsetof(SActorThrowSaveData, m_vItemVelocity));
}

bool SActorThrowSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorThrowSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorThrowSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorThrowSaveData::operator==(const SActorThrowSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorThrowSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;
	if (m_vStartPosition != p_Other.m_vStartPosition) return false;
	if (m_vEndPosition != p_Other.m_vEndPosition) return false;
	if (m_vItemVelocity != p_Other.m_vItemVelocity) return false;
	if (m_fDistance != p_Other.m_fDistance) return false;

	return true;
}

void SActorThrowSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorThrowSaveData*>(p_Object);
	s_Object->~SActorThrowSaveData();
}

ZHMTypeInfo SEventHistorySaveData::TypeInfo = ZHMTypeInfo("SEventHistorySaveData", sizeof(SEventHistorySaveData), alignof(SEventHistorySaveData), SEventHistorySaveData::WriteSimpleJson, SEventHistorySaveData::FromSimpleJson, SEventHistorySaveData::Serialize, SEventHistorySaveData::Equals, SEventHistorySaveData::Destroy);

void SEventHistorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aOccurences") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aOccurences.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aOccurences[i];
		ZGameTime::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aOccurences.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEventHistorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEventHistorySaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aOccurences"];
	s_Object.m_aOccurences.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZGameTime s_ArrayItem0;
		ZGameTime::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aOccurences[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SEventHistorySaveData*>(p_Target) = s_Object;
}

void SEventHistorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);

	TArray<ZGameTime>::Serialize(&s_Object->m_aOccurences, p_Serializer, p_OwnOffset + offsetof(SEventHistorySaveData, m_aOccurences));
}

bool SEventHistorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventHistorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventHistorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventHistorySaveData::operator==(const SEventHistorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventHistorySaveData>)
		return false;

	if (m_aOccurences != p_Other.m_aOccurences) return false;

	return true;
}

void SEventHistorySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEventHistorySaveData*>(p_Object);
	s_Object->~SEventHistorySaveData();
}

ZHMTypeInfo SMatrix::TypeInfo = ZHMTypeInfo("SMatrix", sizeof(SMatrix), alignof(SMatrix), SMatrix::WriteSimpleJson, SMatrix::FromSimpleJson, SMatrix::Serialize, SMatrix::Equals, SMatrix::Destroy);

void SMatrix::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	float4::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	float4::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	float4::WriteSimpleJson(&s_Object->ZAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	float4::WriteSimpleJson(&s_Object->Trans, p_Stream);

	p_Stream << "}";
}

void SMatrix::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["Trans"], &s_Item);
		s_Object.Trans = s_Item;
	}

	*reinterpret_cast<SMatrix*>(p_Target) = s_Object;
}

void SMatrix::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);

	float4::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, XAxis));
	float4::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, YAxis));
	float4::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix, ZAxis));
	float4::Serialize(&s_Object->Trans, p_Serializer, p_OwnOffset + offsetof(SMatrix, Trans));
}

bool SMatrix::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix::operator==(const SMatrix& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;
	if (Trans != p_Other.Trans) return false;

	return true;
}

void SMatrix::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMatrix*>(p_Object);
	s_Object->~SMatrix();
}

ZHMTypeInfo SKnownEntitySaveData::TypeInfo = ZHMTypeInfo("SKnownEntitySaveData", sizeof(SKnownEntitySaveData), alignof(SKnownEntitySaveData), SKnownEntitySaveData::WriteSimpleJson, SKnownEntitySaveData::FromSimpleJson, SKnownEntitySaveData::Serialize, SKnownEntitySaveData::Equals, SKnownEntitySaveData::Destroy);

void SKnownEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nSharedIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSharedIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEvents[i];
		SAIEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBooleanEvents") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBooleanEvents);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBooleanEventsHandled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBooleanEventsHandled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_knownWorldMatrix") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_knownWorldMatrix, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWorldMatrixUpdate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastWorldMatrixUpdate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGoals") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGoals);

	p_Stream << "}";
}

void SKnownEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SKnownEntitySaveData s_Object {};

	s_Object.m_nSharedIndex = simdjson::from_json_int32(p_Document["m_nSharedIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEvents"];
	s_Object.m_aEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAIEventSaveData s_ArrayItem0;
		SAIEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEvents[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_nBooleanEvents = simdjson::from_json_uint32(p_Document["m_nBooleanEvents"]);

	s_Object.m_nBooleanEventsHandled = simdjson::from_json_uint32(p_Document["m_nBooleanEventsHandled"]);

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_knownWorldMatrix"], &s_Item);
		s_Object.m_knownWorldMatrix = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastWorldMatrixUpdate"], &s_Item);
		s_Object.m_tLastWorldMatrixUpdate = s_Item;
	}

	s_Object.m_nGoals = simdjson::from_json_uint16(p_Document["m_nGoals"]);

	*reinterpret_cast<SKnownEntitySaveData*>(p_Target) = s_Object;
}

void SKnownEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);

	TArray<SAIEventSaveData>::Serialize(&s_Object->m_aEvents, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_aEvents));
	SMatrix::Serialize(&s_Object->m_knownWorldMatrix, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_knownWorldMatrix));
	ZGameTime::Serialize(&s_Object->m_tLastWorldMatrixUpdate, p_Serializer, p_OwnOffset + offsetof(SKnownEntitySaveData, m_tLastWorldMatrixUpdate));
}

bool SKnownEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKnownEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKnownEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKnownEntitySaveData::operator==(const SKnownEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKnownEntitySaveData>)
		return false;

	if (m_nSharedIndex != p_Other.m_nSharedIndex) return false;
	if (m_aEvents != p_Other.m_aEvents) return false;
	if (m_nBooleanEvents != p_Other.m_nBooleanEvents) return false;
	if (m_nBooleanEventsHandled != p_Other.m_nBooleanEventsHandled) return false;
	if (m_knownWorldMatrix != p_Other.m_knownWorldMatrix) return false;
	if (m_tLastWorldMatrixUpdate != p_Other.m_tLastWorldMatrixUpdate) return false;
	if (m_nGoals != p_Other.m_nGoals) return false;

	return true;
}

void SKnownEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SKnownEntitySaveData*>(p_Object);
	s_Object->~SKnownEntitySaveData();
}

ZHMTypeInfo SKnowledgeSaveData::TypeInfo = ZHMTypeInfo("SKnowledgeSaveData", sizeof(SKnowledgeSaveData), alignof(SKnowledgeSaveData), SKnowledgeSaveData::WriteSimpleJson, SKnowledgeSaveData::FromSimpleJson, SKnowledgeSaveData::Serialize, SKnowledgeSaveData::Equals, SKnowledgeSaveData::Destroy);

void SKnowledgeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKnownEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKnownEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKnownEntities[i];
		SKnownEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aKnownEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGoalKeys") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGoalKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGoalKeys[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAIGoal", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aGoalKeys.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGoals") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGoals.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGoals[i];
		SActorGoalSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGoals.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMAttentionLastUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMAttentionLastUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMDisguiseAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMDisguiseAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMTrespassingAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMTrespassingAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMLastTrespassingAttentionMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMLastTrespassingAttentionMax);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTrespassingAttentionGain") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTrespassingAttentionGain, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastAttentionEvaluate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastAttentionEvaluate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMWeaponAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMWeaponAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHMWeaponAttentionChange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHMWeaponAttentionChange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGameTension") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGameTension", static_cast<int>(s_Object->m_eGameTension)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAmbientStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAmbientStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tExpiredAIModifierSuppressSocialGreeting") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiredAIModifierSuppressSocialGreeting, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_behaviorModifiers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_behaviorModifiers);

	p_Stream << "}";
}

void SKnowledgeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SKnowledgeSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKnownEntities"];
	s_Object.m_aKnownEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SKnownEntitySaveData s_ArrayItem0;
		SKnownEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aKnownEntities[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGoalKeys"];
	s_Object.m_aGoalKeys.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aGoalKeys[s_Index0++] = static_cast<EAIGoal>(ZHMEnums::GetEnumValueByName("EAIGoal", std::string_view(s_Item0)));
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGoals"];
	s_Object.m_aGoals.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorGoalSaveData s_ArrayItem0;
		SActorGoalSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGoals[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_fHMAttention = simdjson::from_json_float32(p_Document["m_fHMAttention"]);

	s_Object.m_fHMAttentionLastUpdate = simdjson::from_json_float32(p_Document["m_fHMAttentionLastUpdate"]);

	s_Object.m_fHMDisguiseAttention = simdjson::from_json_float32(p_Document["m_fHMDisguiseAttention"]);

	s_Object.m_fHMTrespassingAttention = simdjson::from_json_float32(p_Document["m_fHMTrespassingAttention"]);

	s_Object.m_fHMLastTrespassingAttentionMax = simdjson::from_json_float32(p_Document["m_fHMLastTrespassingAttentionMax"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTrespassingAttentionGain"], &s_Item);
		s_Object.m_tLastTrespassingAttentionGain = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastAttentionEvaluate"], &s_Item);
		s_Object.m_tLastAttentionEvaluate = s_Item;
	}

	s_Object.m_fHMWeaponAttention = simdjson::from_json_float32(p_Document["m_fHMWeaponAttention"]);

	s_Object.m_fHMWeaponAttentionChange = simdjson::from_json_float32(p_Document["m_fHMWeaponAttentionChange"]);

	s_Object.m_eGameTension = static_cast<EGameTension>(ZHMEnums::GetEnumValueByName("EGameTension", std::string_view(p_Document["m_eGameTension"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tAmbientStartTime"], &s_Item);
		s_Object.m_tAmbientStartTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tExpiredAIModifierSuppressSocialGreeting"], &s_Item);
		s_Object.m_tExpiredAIModifierSuppressSocialGreeting = s_Item;
	}

	s_Object.m_behaviorModifiers = simdjson::from_json_uint32(p_Document["m_behaviorModifiers"]);

	*reinterpret_cast<SKnowledgeSaveData*>(p_Target) = s_Object;
}

void SKnowledgeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);

	TArray<SKnownEntitySaveData>::Serialize(&s_Object->m_aKnownEntities, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aKnownEntities));
	TArray<EAIGoal>::Serialize(&s_Object->m_aGoalKeys, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aGoalKeys));
	TArray<SActorGoalSaveData>::Serialize(&s_Object->m_aGoals, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_aGoals));
	ZGameTime::Serialize(&s_Object->m_tLastTrespassingAttentionGain, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tLastTrespassingAttentionGain));
	ZGameTime::Serialize(&s_Object->m_tLastAttentionEvaluate, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tLastAttentionEvaluate));
	ZGameTime::Serialize(&s_Object->m_tAmbientStartTime, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tAmbientStartTime));
	ZGameTime::Serialize(&s_Object->m_tExpiredAIModifierSuppressSocialGreeting, p_Serializer, p_OwnOffset + offsetof(SKnowledgeSaveData, m_tExpiredAIModifierSuppressSocialGreeting));
}

bool SKnowledgeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKnowledgeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKnowledgeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKnowledgeSaveData::operator==(const SKnowledgeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKnowledgeSaveData>)
		return false;

	if (m_aKnownEntities != p_Other.m_aKnownEntities) return false;
	if (m_aGoalKeys != p_Other.m_aGoalKeys) return false;
	if (m_aGoals != p_Other.m_aGoals) return false;
	if (m_fHMAttention != p_Other.m_fHMAttention) return false;
	if (m_fHMAttentionLastUpdate != p_Other.m_fHMAttentionLastUpdate) return false;
	if (m_fHMDisguiseAttention != p_Other.m_fHMDisguiseAttention) return false;
	if (m_fHMTrespassingAttention != p_Other.m_fHMTrespassingAttention) return false;
	if (m_fHMLastTrespassingAttentionMax != p_Other.m_fHMLastTrespassingAttentionMax) return false;
	if (m_tLastTrespassingAttentionGain != p_Other.m_tLastTrespassingAttentionGain) return false;
	if (m_tLastAttentionEvaluate != p_Other.m_tLastAttentionEvaluate) return false;
	if (m_fHMWeaponAttention != p_Other.m_fHMWeaponAttention) return false;
	if (m_fHMWeaponAttentionChange != p_Other.m_fHMWeaponAttentionChange) return false;
	if (m_eGameTension != p_Other.m_eGameTension) return false;
	if (m_tAmbientStartTime != p_Other.m_tAmbientStartTime) return false;
	if (m_tExpiredAIModifierSuppressSocialGreeting != p_Other.m_tExpiredAIModifierSuppressSocialGreeting) return false;
	if (m_behaviorModifiers != p_Other.m_behaviorModifiers) return false;

	return true;
}

void SKnowledgeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SKnowledgeSaveData*>(p_Object);
	s_Object->~SKnowledgeSaveData();
}

ZHMTypeInfo SLongTermMemorySaveData::TypeInfo = ZHMTypeInfo("SLongTermMemorySaveData", sizeof(SLongTermMemorySaveData), alignof(SLongTermMemorySaveData), SLongTermMemorySaveData::WriteSimpleJson, SLongTermMemorySaveData::FromSimpleJson, SLongTermMemorySaveData::Serialize, SLongTermMemorySaveData::Equals, SLongTermMemorySaveData::Destroy);

void SLongTermMemorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLongTermMemorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sOutfit") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_sOutfit, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Memory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_Memory);

	p_Stream << "}";
}

void SLongTermMemorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLongTermMemorySaveData s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_sOutfit"], &s_Item);
		s_Object.m_sOutfit = s_Item;
	}

	s_Object.m_Memory = simdjson::from_json_uint8(p_Document["m_Memory"]);

	*reinterpret_cast<SLongTermMemorySaveData*>(p_Target) = s_Object;
}

void SLongTermMemorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLongTermMemorySaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_sOutfit, p_Serializer, p_OwnOffset + offsetof(SLongTermMemorySaveData, m_sOutfit));
}

bool SLongTermMemorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLongTermMemorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLongTermMemorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLongTermMemorySaveData::operator==(const SLongTermMemorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLongTermMemorySaveData>)
		return false;

	if (m_sOutfit != p_Other.m_sOutfit) return false;
	if (m_Memory != p_Other.m_Memory) return false;

	return true;
}

void SLongTermMemorySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLongTermMemorySaveData*>(p_Object);
	s_Object->~SLongTermMemorySaveData();
}

ZHMTypeInfo SActorSaveData::TypeInfo = ZHMTypeInfo("SActorSaveData", sizeof(SActorSaveData), alignof(SActorSaveData), SActorSaveData::WriteSimpleJson, SActorSaveData::FromSimpleJson, SActorSaveData::Serialize, SActorSaveData::Equals, SActorSaveData::Destroy);

void SActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternion") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vQuaternion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Inventory") << ":";
	SActorInventorySaveData::WriteSimpleJson(&s_Object->m_Inventory, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AnimSet") << ":";
	SActorAnimSetSaveData::WriteSimpleJson(&s_Object->m_AnimSet, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ThrowHandler") << ":";
	SActorThrowSaveData::WriteSimpleJson(&s_Object->m_ThrowHandler, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentBehaviorType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentBehaviorType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CurrentBehaviorState") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CurrentBehaviorState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCurrentBehaviorEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCurrentBehaviorEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCurrentBehaviorEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCurrentBehaviorEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBehaviorEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBehaviorEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBehaviorEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBehaviorEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_KnowledgeData") << ":";
	SKnowledgeSaveData::WriteSimpleJson(&s_Object->m_KnowledgeData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitRepositoryId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_OutfitRepositoryId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSequenceEndTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tSequenceEndTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBodyContainerEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBodyContainerEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBodyContainerSlot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBodyContainerSlot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCorpseBodybagEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCorpseBodybagEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDragBodybagEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDragBodybagEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AccidentContext") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_AccidentContext);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorDamageControlData") << ":";
	SActorDamageControlSaveData::WriteSimpleJson(&s_Object->m_ActorDamageControlData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AnimatedActorOrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_AnimatedActorOrderData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStepsFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStepsFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fZBeforeEnteringStairs") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fZBeforeEnteringStairs);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fZError") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fZError);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicTemplates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicTemplates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicTemplates[i];
		SActorDynamicTemplateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aDynamicTemplates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sEndOrientation") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_sEndOrientation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eOverrideSensorState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorAIState", static_cast<int>(s_Object->m_eOverrideSensorState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDeathBehavior") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathBehavior", static_cast<int>(s_Object->m_eDeathBehavior)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bumpsHistory") << ":";
	SEventHistorySaveData::WriteSimpleJson(&s_Object->m_bumpsHistory, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RagdollPose") << ":";
	SActorRagdollPoseSaveData::WriteSimpleJson(&s_Object->m_RagdollPose, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aLongTermMemorySaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aLongTermMemorySaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aLongTermMemorySaveData[i];
		SLongTermMemorySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aLongTermMemorySaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_AgentData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_AgentData);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_KnockdownsWhileConscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_KnockdownsWhileConscious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SecondaryAIIconState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_SecondaryAIIconState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SituationAvailabilityValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_SituationAvailabilityValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HadValidAgent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_HadValidAgent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNude") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNude);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActiveEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActiveEnforcer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPotentialEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPotentialEnforcer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDynamicEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDynamicEnforcer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCrowdCharacter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCrowdCharacter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsWoozy") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsWoozy);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlendingOrientation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlendingOrientation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMakeMainWeaponUndroppable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMakeMainWeaponUndroppable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFinalizePendingSpawnGrenade") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFinalizePendingSpawnGrenade);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponIsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponIsHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegisteredForLT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegisteredForLT);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKeepOverrideSensorStateAfterBeingUnconscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKeepOverrideSensorStateAfterBeingUnconscious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponReady") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponReady);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDynamicWeaponUnholstered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDynamicWeaponUnholstered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceInteractionGlow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceInteractionGlow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOutfitRuined") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOutfitRuined);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BehaviorSelectDisabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_BehaviorSelectDisabled);

	p_Stream << "}";
}

void SActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vQuaternion"], &s_Item);
		s_Object.m_vQuaternion = s_Item;
	}

	{
		SActorInventorySaveData s_Item {};
		SActorInventorySaveData::FromSimpleJson(p_Document["m_Inventory"], &s_Item);
		s_Object.m_Inventory = s_Item;
	}

	{
		SActorAnimSetSaveData s_Item {};
		SActorAnimSetSaveData::FromSimpleJson(p_Document["m_AnimSet"], &s_Item);
		s_Object.m_AnimSet = s_Item;
	}

	{
		SActorThrowSaveData s_Item {};
		SActorThrowSaveData::FromSimpleJson(p_Document["m_ThrowHandler"], &s_Item);
		s_Object.m_ThrowHandler = s_Item;
	}

	s_Object.m_nCurrentBehaviorType = simdjson::from_json_int32(p_Document["m_nCurrentBehaviorType"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CurrentBehaviorState"], &s_Item);
		s_Object.m_CurrentBehaviorState = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCurrentBehaviorEntities"];
	s_Object.m_aCurrentBehaviorEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aCurrentBehaviorEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBehaviorEntities"];
	s_Object.m_aBehaviorEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aBehaviorEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
		SKnowledgeSaveData s_Item {};
		SKnowledgeSaveData::FromSimpleJson(p_Document["m_KnowledgeData"], &s_Item);
		s_Object.m_KnowledgeData = s_Item;
	}

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_OutfitRepositoryId"], &s_Item);
		s_Object.m_OutfitRepositoryId = s_Item;
	}

	s_Object.m_nOutfitCharset = simdjson::from_json_int32(p_Document["m_nOutfitCharset"]);

	s_Object.m_nOutfitVariation = simdjson::from_json_int32(p_Document["m_nOutfitVariation"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tSequenceEndTime"], &s_Item);
		s_Object.m_tSequenceEndTime = s_Item;
	}

	s_Object.m_nState = static_cast<EActorState>(ZHMEnums::GetEnumValueByName("EActorState", std::string_view(p_Document["m_nState"])));

	s_Object.m_rBodyContainerEntity = simdjson::from_json_uint32(p_Document["m_rBodyContainerEntity"]);

	s_Object.m_nBodyContainerSlot = simdjson::from_json_int32(p_Document["m_nBodyContainerSlot"]);

	s_Object.m_eEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eEmotionState"])));

	s_Object.m_rCorpseBodybagEntity = simdjson::from_json_uint32(p_Document["m_rCorpseBodybagEntity"]);

	s_Object.m_rDragBodybagEntity = simdjson::from_json_uint32(p_Document["m_rDragBodybagEntity"]);

	s_Object.m_AccidentContext = simdjson::from_json_uint32(p_Document["m_AccidentContext"]);

	{
		SActorDamageControlSaveData s_Item {};
		SActorDamageControlSaveData::FromSimpleJson(p_Document["m_ActorDamageControlData"], &s_Item);
		s_Object.m_ActorDamageControlData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_AnimatedActorOrderData"], &s_Item);
		s_Object.m_AnimatedActorOrderData = s_Item;
	}

	s_Object.m_fStepsFraction = simdjson::from_json_float32(p_Document["m_fStepsFraction"]);

	s_Object.m_fZBeforeEnteringStairs = simdjson::from_json_float32(p_Document["m_fZBeforeEnteringStairs"]);

	s_Object.m_fZError = simdjson::from_json_float32(p_Document["m_fZError"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDynamicTemplates"];
	s_Object.m_aDynamicTemplates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorDynamicTemplateSaveData s_ArrayItem0;
		SActorDynamicTemplateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aDynamicTemplates[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_sEndOrientation"], &s_Item);
		s_Object.m_sEndOrientation = s_Item;
	}

	s_Object.m_eOverrideSensorState = static_cast<EActorAIState>(ZHMEnums::GetEnumValueByName("EActorAIState", std::string_view(p_Document["m_eOverrideSensorState"])));

	s_Object.m_eDeathBehavior = static_cast<EDeathBehavior>(ZHMEnums::GetEnumValueByName("EDeathBehavior", std::string_view(p_Document["m_eDeathBehavior"])));

	{
		SEventHistorySaveData s_Item {};
		SEventHistorySaveData::FromSimpleJson(p_Document["m_bumpsHistory"], &s_Item);
		s_Object.m_bumpsHistory = s_Item;
	}

	{
		SActorRagdollPoseSaveData s_Item {};
		SActorRagdollPoseSaveData::FromSimpleJson(p_Document["m_RagdollPose"], &s_Item);
		s_Object.m_RagdollPose = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aLongTermMemorySaveData"];
	s_Object.m_aLongTermMemorySaveData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLongTermMemorySaveData s_ArrayItem0;
		SLongTermMemorySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aLongTermMemorySaveData[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_AgentData = simdjson::from_json_uint32(p_Document["m_AgentData"]);

	s_Object.m_KnockdownsWhileConscious = simdjson::from_json_uint32(p_Document["m_KnockdownsWhileConscious"]);

	s_Object.m_SecondaryAIIconState = simdjson::from_json_uint32(p_Document["m_SecondaryAIIconState"]);

	s_Object.m_SituationAvailabilityValue = simdjson::from_json_int32(p_Document["m_SituationAvailabilityValue"]);

	s_Object.m_HadValidAgent = simdjson::from_json_bool(p_Document["m_HadValidAgent"]);

	s_Object.m_bNude = simdjson::from_json_bool(p_Document["m_bNude"]);

	s_Object.m_bActiveEnforcer = simdjson::from_json_bool(p_Document["m_bActiveEnforcer"]);

	s_Object.m_bIsPotentialEnforcer = simdjson::from_json_bool(p_Document["m_bIsPotentialEnforcer"]);

	s_Object.m_bDynamicEnforcer = simdjson::from_json_bool(p_Document["m_bDynamicEnforcer"]);

	s_Object.m_bIsCrowdCharacter = simdjson::from_json_bool(p_Document["m_bIsCrowdCharacter"]);

	s_Object.m_bIsWoozy = simdjson::from_json_bool(p_Document["m_bIsWoozy"]);

	s_Object.m_bBlendingOrientation = simdjson::from_json_bool(p_Document["m_bBlendingOrientation"]);

	s_Object.m_bMakeMainWeaponUndroppable = simdjson::from_json_bool(p_Document["m_bMakeMainWeaponUndroppable"]);

	s_Object.m_bFinalizePendingSpawnGrenade = simdjson::from_json_bool(p_Document["m_bFinalizePendingSpawnGrenade"]);

	s_Object.m_bWeaponIsHidden = simdjson::from_json_bool(p_Document["m_bWeaponIsHidden"]);

	s_Object.m_bRegisteredForLT = simdjson::from_json_bool(p_Document["m_bRegisteredForLT"]);

	s_Object.m_bKeepOverrideSensorStateAfterBeingUnconscious = simdjson::from_json_bool(p_Document["m_bKeepOverrideSensorStateAfterBeingUnconscious"]);

	s_Object.m_bWeaponReady = simdjson::from_json_bool(p_Document["m_bWeaponReady"]);

	s_Object.m_bDynamicWeaponUnholstered = simdjson::from_json_bool(p_Document["m_bDynamicWeaponUnholstered"]);

	s_Object.m_bForceInteractionGlow = simdjson::from_json_bool(p_Document["m_bForceInteractionGlow"]);

	s_Object.m_bIsOutfitRuined = simdjson::from_json_bool(p_Document["m_bIsOutfitRuined"]);

	s_Object.m_BehaviorSelectDisabled = simdjson::from_json_bool(p_Document["m_BehaviorSelectDisabled"]);

	*reinterpret_cast<SActorSaveData*>(p_Target) = s_Object;
}

void SActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vQuaternion, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_vQuaternion));
	SActorInventorySaveData::Serialize(&s_Object->m_Inventory, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_Inventory));
	SActorAnimSetSaveData::Serialize(&s_Object->m_AnimSet, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_AnimSet));
	SActorThrowSaveData::Serialize(&s_Object->m_ThrowHandler, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_ThrowHandler));
	ZVariant::Serialize(&s_Object->m_CurrentBehaviorState, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_CurrentBehaviorState));
	TArray<uint32>::Serialize(&s_Object->m_aCurrentBehaviorEntities, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_aCurrentBehaviorEntities));
	TArray<uint32>::Serialize(&s_Object->m_aBehaviorEntities, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_aBehaviorEntities));
	SKnowledgeSaveData::Serialize(&s_Object->m_KnowledgeData, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_KnowledgeData));
	ZRepositoryID::Serialize(&s_Object->m_OutfitRepositoryId, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_OutfitRepositoryId));
	ZGameTime::Serialize(&s_Object->m_tSequenceEndTime, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_tSequenceEndTime));
	SActorDamageControlSaveData::Serialize(&s_Object->m_ActorDamageControlData, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_ActorDamageControlData));
	ZVariant::Serialize(&s_Object->m_AnimatedActorOrderData, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_AnimatedActorOrderData));
	TArray<SActorDynamicTemplateSaveData>::Serialize(&s_Object->m_aDynamicTemplates, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_aDynamicTemplates));
	SMatrix::Serialize(&s_Object->m_sEndOrientation, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_sEndOrientation));
	SEventHistorySaveData::Serialize(&s_Object->m_bumpsHistory, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_bumpsHistory));
	SActorRagdollPoseSaveData::Serialize(&s_Object->m_RagdollPose, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_RagdollPose));
	TArray<SLongTermMemorySaveData>::Serialize(&s_Object->m_aLongTermMemorySaveData, p_Serializer, p_OwnOffset + offsetof(SActorSaveData, m_aLongTermMemorySaveData));
}

bool SActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSaveData::operator==(const SActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSaveData>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vQuaternion != p_Other.m_vQuaternion) return false;
	if (m_Inventory != p_Other.m_Inventory) return false;
	if (m_AnimSet != p_Other.m_AnimSet) return false;
	if (m_ThrowHandler != p_Other.m_ThrowHandler) return false;
	if (m_nCurrentBehaviorType != p_Other.m_nCurrentBehaviorType) return false;
	if (m_CurrentBehaviorState != p_Other.m_CurrentBehaviorState) return false;
	if (m_aCurrentBehaviorEntities != p_Other.m_aCurrentBehaviorEntities) return false;
	if (m_aBehaviorEntities != p_Other.m_aBehaviorEntities) return false;
	if (m_KnowledgeData != p_Other.m_KnowledgeData) return false;
	if (m_OutfitRepositoryId != p_Other.m_OutfitRepositoryId) return false;
	if (m_nOutfitCharset != p_Other.m_nOutfitCharset) return false;
	if (m_nOutfitVariation != p_Other.m_nOutfitVariation) return false;
	if (m_tSequenceEndTime != p_Other.m_tSequenceEndTime) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_rBodyContainerEntity != p_Other.m_rBodyContainerEntity) return false;
	if (m_nBodyContainerSlot != p_Other.m_nBodyContainerSlot) return false;
	if (m_eEmotionState != p_Other.m_eEmotionState) return false;
	if (m_rCorpseBodybagEntity != p_Other.m_rCorpseBodybagEntity) return false;
	if (m_rDragBodybagEntity != p_Other.m_rDragBodybagEntity) return false;
	if (m_AccidentContext != p_Other.m_AccidentContext) return false;
	if (m_ActorDamageControlData != p_Other.m_ActorDamageControlData) return false;
	if (m_AnimatedActorOrderData != p_Other.m_AnimatedActorOrderData) return false;
	if (m_fStepsFraction != p_Other.m_fStepsFraction) return false;
	if (m_fZBeforeEnteringStairs != p_Other.m_fZBeforeEnteringStairs) return false;
	if (m_fZError != p_Other.m_fZError) return false;
	if (m_aDynamicTemplates != p_Other.m_aDynamicTemplates) return false;
	if (m_sEndOrientation != p_Other.m_sEndOrientation) return false;
	if (m_eOverrideSensorState != p_Other.m_eOverrideSensorState) return false;
	if (m_eDeathBehavior != p_Other.m_eDeathBehavior) return false;
	if (m_bumpsHistory != p_Other.m_bumpsHistory) return false;
	if (m_RagdollPose != p_Other.m_RagdollPose) return false;
	if (m_aLongTermMemorySaveData != p_Other.m_aLongTermMemorySaveData) return false;
	if (m_AgentData != p_Other.m_AgentData) return false;
	if (m_KnockdownsWhileConscious != p_Other.m_KnockdownsWhileConscious) return false;
	if (m_SecondaryAIIconState != p_Other.m_SecondaryAIIconState) return false;
	if (m_SituationAvailabilityValue != p_Other.m_SituationAvailabilityValue) return false;
	if (m_HadValidAgent != p_Other.m_HadValidAgent) return false;
	if (m_bNude != p_Other.m_bNude) return false;
	if (m_bActiveEnforcer != p_Other.m_bActiveEnforcer) return false;
	if (m_bIsPotentialEnforcer != p_Other.m_bIsPotentialEnforcer) return false;
	if (m_bDynamicEnforcer != p_Other.m_bDynamicEnforcer) return false;
	if (m_bIsCrowdCharacter != p_Other.m_bIsCrowdCharacter) return false;
	if (m_bIsWoozy != p_Other.m_bIsWoozy) return false;
	if (m_bBlendingOrientation != p_Other.m_bBlendingOrientation) return false;
	if (m_bMakeMainWeaponUndroppable != p_Other.m_bMakeMainWeaponUndroppable) return false;
	if (m_bFinalizePendingSpawnGrenade != p_Other.m_bFinalizePendingSpawnGrenade) return false;
	if (m_bWeaponIsHidden != p_Other.m_bWeaponIsHidden) return false;
	if (m_bRegisteredForLT != p_Other.m_bRegisteredForLT) return false;
	if (m_bKeepOverrideSensorStateAfterBeingUnconscious != p_Other.m_bKeepOverrideSensorStateAfterBeingUnconscious) return false;
	if (m_bWeaponReady != p_Other.m_bWeaponReady) return false;
	if (m_bDynamicWeaponUnholstered != p_Other.m_bDynamicWeaponUnholstered) return false;
	if (m_bForceInteractionGlow != p_Other.m_bForceInteractionGlow) return false;
	if (m_bIsOutfitRuined != p_Other.m_bIsOutfitRuined) return false;
	if (m_BehaviorSelectDisabled != p_Other.m_BehaviorSelectDisabled) return false;

	return true;
}

void SActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSaveData*>(p_Object);
	s_Object->~SActorSaveData();
}

ZHMTypeInfo SCombatMetricsSaveData::TypeInfo = ZHMTypeInfo("SCombatMetricsSaveData", sizeof(SCombatMetricsSaveData), alignof(SCombatMetricsSaveData), SCombatMetricsSaveData::WriteSimpleJson, SCombatMetricsSaveData::FromSimpleJson, SCombatMetricsSaveData::Serialize, SCombatMetricsSaveData::Equals, SCombatMetricsSaveData::Destroy);

void SCombatMetricsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatMetricsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CombatProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CombatProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DeadVIPsOrContractTargets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_DeadVIPsOrContractTargets.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_DeadVIPsOrContractTargets[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_DeadVIPsOrContractTargets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DiscoveredVIPOrContractTargetBodies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_DiscoveredVIPOrContractTargetBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_DiscoveredVIPOrContractTargetBodies[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_DiscoveredVIPOrContractTargetBodies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCombatMetricsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCombatMetricsSaveData s_Object {};

	s_Object.m_CombatProgress = simdjson::from_json_float32(p_Document["m_CombatProgress"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_DeadVIPsOrContractTargets"];
	s_Object.m_DeadVIPsOrContractTargets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_DeadVIPsOrContractTargets[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_DiscoveredVIPOrContractTargetBodies"];
	s_Object.m_DiscoveredVIPOrContractTargetBodies.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_DiscoveredVIPOrContractTargetBodies[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SCombatMetricsSaveData*>(p_Target) = s_Object;
}

void SCombatMetricsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatMetricsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_DeadVIPsOrContractTargets, p_Serializer, p_OwnOffset + offsetof(SCombatMetricsSaveData, m_DeadVIPsOrContractTargets));
	TArray<uint32>::Serialize(&s_Object->m_DiscoveredVIPOrContractTargetBodies, p_Serializer, p_OwnOffset + offsetof(SCombatMetricsSaveData, m_DiscoveredVIPOrContractTargetBodies));
}

bool SCombatMetricsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatMetricsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatMetricsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatMetricsSaveData::operator==(const SCombatMetricsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatMetricsSaveData>)
		return false;

	if (m_CombatProgress != p_Other.m_CombatProgress) return false;
	if (m_DeadVIPsOrContractTargets != p_Other.m_DeadVIPsOrContractTargets) return false;
	if (m_DiscoveredVIPOrContractTargetBodies != p_Other.m_DiscoveredVIPOrContractTargetBodies) return false;

	return true;
}

void SCombatMetricsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCombatMetricsSaveData*>(p_Object);
	s_Object->~SCombatMetricsSaveData();
}

ZHMTypeInfo SEventSaveData::TypeInfo = ZHMTypeInfo("SEventSaveData", sizeof(SEventSaveData), alignof(SEventSaveData), SEventSaveData::WriteSimpleJson, SEventSaveData::FromSimpleJson, SEventSaveData::Serialize, SEventSaveData::Equals, SEventSaveData::Destroy);

void SEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_nType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_nEnd, p_Stream);

	p_Stream << "}";
}

void SEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEventSaveData s_Object {};

	s_Object.m_nType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_nType"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nStart"], &s_Item);
		s_Object.m_nStart = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_nEnd"], &s_Item);
		s_Object.m_nEnd = s_Item;
	}

	*reinterpret_cast<SEventSaveData*>(p_Target) = s_Object;
}

void SEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_nStart, p_Serializer, p_OwnOffset + offsetof(SEventSaveData, m_nStart));
	ZGameTime::Serialize(&s_Object->m_nEnd, p_Serializer, p_OwnOffset + offsetof(SEventSaveData, m_nEnd));
}

bool SEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventSaveData::operator==(const SEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventSaveData>)
		return false;

	if (m_nType != p_Other.m_nType) return false;
	if (m_nStart != p_Other.m_nStart) return false;
	if (m_nEnd != p_Other.m_nEnd) return false;

	return true;
}

void SEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEventSaveData*>(p_Object);
	s_Object->~SEventSaveData();
}

ZHMTypeInfo SSharedKnowledgeSaveData::TypeInfo = ZHMTypeInfo("SSharedKnowledgeSaveData", sizeof(SSharedKnowledgeSaveData), alignof(SSharedKnowledgeSaveData), SSharedKnowledgeSaveData::WriteSimpleJson, SSharedKnowledgeSaveData::FromSimpleJson, SSharedKnowledgeSaveData::Serialize, SSharedKnowledgeSaveData::Equals, SSharedKnowledgeSaveData::Destroy);

void SSharedKnowledgeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_OutfitId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActualMatrix") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_ActualMatrix, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEvents[i];
		SEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSharedKnowledgeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSharedKnowledgeSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_OutfitId"], &s_Item);
		s_Object.m_OutfitId = s_Item;
	}

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_ActualMatrix"], &s_Item);
		s_Object.m_ActualMatrix = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEvents"];
	s_Object.m_aEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEventSaveData s_ArrayItem0;
		SEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEvents[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SSharedKnowledgeSaveData*>(p_Target) = s_Object;
}

void SSharedKnowledgeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_OutfitId, p_Serializer, p_OwnOffset + offsetof(SSharedKnowledgeSaveData, m_OutfitId));
	SMatrix::Serialize(&s_Object->m_ActualMatrix, p_Serializer, p_OwnOffset + offsetof(SSharedKnowledgeSaveData, m_ActualMatrix));
	TArray<SEventSaveData>::Serialize(&s_Object->m_aEvents, p_Serializer, p_OwnOffset + offsetof(SSharedKnowledgeSaveData, m_aEvents));
}

bool SSharedKnowledgeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSharedKnowledgeSaveData::operator==(const SSharedKnowledgeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSharedKnowledgeSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_OutfitId != p_Other.m_OutfitId) return false;
	if (m_ActualMatrix != p_Other.m_ActualMatrix) return false;
	if (m_aEvents != p_Other.m_aEvents) return false;

	return true;
}

void SSharedKnowledgeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSharedKnowledgeSaveData*>(p_Object);
	s_Object->~SSharedKnowledgeSaveData();
}

ZHMTypeInfo SSituationGroupSaveData::TypeInfo = ZHMTypeInfo("SSituationGroupSaveData", sizeof(SSituationGroupSaveData), alignof(SSituationGroupSaveData), SSituationGroupSaveData::WriteSimpleJson, SSituationGroupSaveData::FromSimpleJson, SSituationGroupSaveData::Serialize, SSituationGroupSaveData::Equals, SSituationGroupSaveData::Destroy);

void SSituationGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sClassTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sClassTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationGroupSaveData s_Object {};

	s_Object.m_sClassTypeName = std::string_view(p_Document["m_sClassTypeName"]);

	s_Object.m_nSituation = simdjson::from_json_uint32(p_Document["m_nSituation"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActors"];
	s_Object.m_aActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aActors[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_nGroupID = simdjson::from_json_int32(p_Document["m_nGroupID"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Item);
		s_Object.m_CustomData = s_Item;
	}

	*reinterpret_cast<SSituationGroupSaveData*>(p_Target) = s_Object;
}

void SSituationGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sClassTypeName, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_sClassTypeName));
	TArray<uint32>::Serialize(&s_Object->m_aActors, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_aActors));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationGroupSaveData, m_CustomData));
}

bool SSituationGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationGroupSaveData::operator==(const SSituationGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationGroupSaveData>)
		return false;

	if (m_sClassTypeName != p_Other.m_sClassTypeName) return false;
	if (m_nSituation != p_Other.m_nSituation) return false;
	if (m_aActors != p_Other.m_aActors) return false;
	if (m_nGroupID != p_Other.m_nGroupID) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

void SSituationGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationGroupSaveData*>(p_Object);
	s_Object->~SSituationGroupSaveData();
}

ZHMTypeInfo SSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SSituationMemberSaveData", sizeof(SSituationMemberSaveData), alignof(SSituationMemberSaveData), SSituationMemberSaveData::WriteSimpleJson, SSituationMemberSaveData::FromSimpleJson, SSituationMemberSaveData::Serialize, SSituationMemberSaveData::Equals, SSituationMemberSaveData::Destroy);

void SSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eJoinReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationJoinReason", static_cast<int>(s_Object->m_eJoinReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOrderValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOrderValid);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_OrderData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PendingOrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_PendingOrderData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDramaRole") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDramaRole);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationMemberSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_eJoinReason = static_cast<ESituationJoinReason>(ZHMEnums::GetEnumValueByName("ESituationJoinReason", std::string_view(p_Document["m_eJoinReason"])));

	s_Object.m_bIsOrderValid = simdjson::from_json_bool(p_Document["m_bIsOrderValid"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_OrderData"], &s_Item);
		s_Object.m_OrderData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_PendingOrderData"], &s_Item);
		s_Object.m_PendingOrderData = s_Item;
	}

	s_Object.m_rDramaRole = simdjson::from_json_uint32(p_Document["m_rDramaRole"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Item);
		s_Object.m_CustomData = s_Item;
	}

	*reinterpret_cast<SSituationMemberSaveData*>(p_Target) = s_Object;
}

void SSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_OrderData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_OrderData));
	ZVariant::Serialize(&s_Object->m_PendingOrderData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_PendingOrderData));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationMemberSaveData, m_CustomData));
}

bool SSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationMemberSaveData::operator==(const SSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationMemberSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_eJoinReason != p_Other.m_eJoinReason) return false;
	if (m_bIsOrderValid != p_Other.m_bIsOrderValid) return false;
	if (m_OrderData != p_Other.m_OrderData) return false;
	if (m_PendingOrderData != p_Other.m_PendingOrderData) return false;
	if (m_rDramaRole != p_Other.m_rDramaRole) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

void SSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationMemberSaveData*>(p_Object);
	s_Object->~SSituationMemberSaveData();
}

ZHMTypeInfo SSituationSaveData::TypeInfo = ZHMTypeInfo("SSituationSaveData", sizeof(SSituationSaveData), alignof(SSituationSaveData), SSituationSaveData::WriteSimpleJson, SSituationSaveData::FromSimpleJson, SSituationSaveData::Serialize, SSituationSaveData::Equals, SSituationSaveData::Destroy);

void SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESituationType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetSharedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetSharedEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMemberData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMemberData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMemberData[i];
		SSituationMemberSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aMemberData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGroupData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGroupData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGroupData[i];
		SSituationGroupSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGroupData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNextGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNextGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_situationStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_situationStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationEnded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationEnded);

	p_Stream << "}";
}

void SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationSaveData s_Object {};

	s_Object.m_rSituation = simdjson::from_json_uint32(p_Document["m_rSituation"]);

	s_Object.m_eType = static_cast<ESituationType>(ZHMEnums::GetEnumValueByName("ESituationType", std::string_view(p_Document["m_eType"])));

	s_Object.m_nTargetSharedEntity = simdjson::from_json_int32(p_Document["m_nTargetSharedEntity"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Item);
		s_Object.m_Data = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aMemberData"];
	s_Object.m_aMemberData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSituationMemberSaveData s_ArrayItem0;
		SSituationMemberSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aMemberData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGroupData"];
	s_Object.m_aGroupData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSituationGroupSaveData s_ArrayItem0;
		SSituationGroupSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGroupData[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_nNextGroupID = simdjson::from_json_int32(p_Document["m_nNextGroupID"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_situationStartTime"], &s_Item);
		s_Object.m_situationStartTime = s_Item;
	}

	s_Object.m_bSituationEnded = simdjson::from_json_bool(p_Document["m_bSituationEnded"]);

	*reinterpret_cast<SSituationSaveData*>(p_Target) = s_Object;
}

void SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_Data));
	TArray<SSituationMemberSaveData>::Serialize(&s_Object->m_aMemberData, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_aMemberData));
	TArray<SSituationGroupSaveData>::Serialize(&s_Object->m_aGroupData, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_aGroupData));
	ZGameTime::Serialize(&s_Object->m_situationStartTime, p_Serializer, p_OwnOffset + offsetof(SSituationSaveData, m_situationStartTime));
}

bool SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationSaveData::operator==(const SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationSaveData>)
		return false;

	if (m_rSituation != p_Other.m_rSituation) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_nTargetSharedEntity != p_Other.m_nTargetSharedEntity) return false;
	if (m_Data != p_Other.m_Data) return false;
	if (m_aMemberData != p_Other.m_aMemberData) return false;
	if (m_aGroupData != p_Other.m_aGroupData) return false;
	if (m_nNextGroupID != p_Other.m_nNextGroupID) return false;
	if (m_situationStartTime != p_Other.m_situationStartTime) return false;
	if (m_bSituationEnded != p_Other.m_bSituationEnded) return false;

	return true;
}

void SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationSaveData*>(p_Object);
	s_Object->~SSituationSaveData();
}

ZHMTypeInfo SActorProxySaveData::TypeInfo = ZHMTypeInfo("SActorProxySaveData", sizeof(SActorProxySaveData), alignof(SActorProxySaveData), SActorProxySaveData::WriteSimpleJson, SActorProxySaveData::FromSimpleJson, SActorProxySaveData::Serialize, SActorProxySaveData::Equals, SActorProxySaveData::Destroy);

void SActorProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorProxySaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorProxySaveData*>(p_Target) = s_Object;
}

void SActorProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);

}

bool SActorProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProxySaveData::operator==(const SActorProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProxySaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorProxySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorProxySaveData*>(p_Object);
	s_Object->~SActorProxySaveData();
}

ZHMTypeInfo SActorProxiesSaveData::TypeInfo = ZHMTypeInfo("SActorProxiesSaveData", sizeof(SActorProxiesSaveData), alignof(SActorProxiesSaveData), SActorProxiesSaveData::WriteSimpleJson, SActorProxiesSaveData::FromSimpleJson, SActorProxiesSaveData::Serialize, SActorProxiesSaveData::Equals, SActorProxiesSaveData::Destroy);

void SActorProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorProxiesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorProxySaveData s_ArrayItem0;
		SActorProxySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActorProxiesSaveData*>(p_Target) = s_Object;
}

void SActorProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorProxiesSaveData, m_aEntities));
	TArray<SActorProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorProxiesSaveData, m_aData));
}

bool SActorProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorProxiesSaveData::operator==(const SActorProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SActorProxiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorProxiesSaveData*>(p_Object);
	s_Object->~SActorProxiesSaveData();
}

ZHMTypeInfo SActorSoundDefs::TypeInfo = ZHMTypeInfo("SActorSoundDefs", sizeof(SActorSoundDefs), alignof(SActorSoundDefs), SActorSoundDefs::WriteSimpleJson, SActorSoundDefs::FromSimpleJson, SActorSoundDefs::Serialize, SActorSoundDefs::Equals, SActorSoundDefs::Destroy);

void SActorSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SActorSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSoundDefs s_Object {};

	*reinterpret_cast<SActorSoundDefs*>(p_Target) = s_Object;
}

void SActorSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);

}

bool SActorSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSoundDefs::operator==(const SActorSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSoundDefs>)
		return false;


	return true;
}

void SActorSoundDefs::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSoundDefs*>(p_Object);
	s_Object->~SActorSoundDefs();
}

ZHMTypeInfo SActorSpreadControllerCandidateSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadControllerCandidateSaveData", sizeof(SActorSpreadControllerCandidateSaveData), alignof(SActorSpreadControllerCandidateSaveData), SActorSpreadControllerCandidateSaveData::WriteSimpleJson, SActorSpreadControllerCandidateSaveData::FromSimpleJson, SActorSpreadControllerCandidateSaveData::Serialize, SActorSpreadControllerCandidateSaveData::Equals, SActorSpreadControllerCandidateSaveData::Destroy);

void SActorSpreadControllerCandidateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CandidateActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CandidateActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CandidateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_CandidateTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidCandidate);

	p_Stream << "}";
}

void SActorSpreadControllerCandidateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSpreadControllerCandidateSaveData s_Object {};

	s_Object.m_CandidateActor = simdjson::from_json_uint32(p_Document["m_CandidateActor"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_CandidateTime"], &s_Item);
		s_Object.m_CandidateTime = s_Item;
	}

	s_Object.m_bValidCandidate = simdjson::from_json_bool(p_Document["m_bValidCandidate"]);

	*reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Target) = s_Object;
}

void SActorSpreadControllerCandidateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_CandidateTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerCandidateSaveData, m_CandidateTime));
}

bool SActorSpreadControllerCandidateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadControllerCandidateSaveData::operator==(const SActorSpreadControllerCandidateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadControllerCandidateSaveData>)
		return false;

	if (m_CandidateActor != p_Other.m_CandidateActor) return false;
	if (m_CandidateTime != p_Other.m_CandidateTime) return false;
	if (m_bValidCandidate != p_Other.m_bValidCandidate) return false;

	return true;
}

void SActorSpreadControllerCandidateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerCandidateSaveData*>(p_Object);
	s_Object->~SActorSpreadControllerCandidateSaveData();
}

ZHMTypeInfo SActorSpreadControllerSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadControllerSaveData", sizeof(SActorSpreadControllerSaveData), alignof(SActorSpreadControllerSaveData), SActorSpreadControllerSaveData::WriteSimpleJson, SActorSpreadControllerSaveData::FromSimpleJson, SActorSpreadControllerSaveData::Serialize, SActorSpreadControllerSaveData::Equals, SActorSpreadControllerSaveData::Destroy);

void SActorSpreadControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aSpreadingActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpreadingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpreadingActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSpreadingActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDeadSpreadingActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDeadSpreadingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDeadSpreadingActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDeadSpreadingActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSpreadingActorsAddedTime") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSpreadingActorsAddedTime.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSpreadingActorsAddedTime[i];
		ZGameTime::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSpreadingActorsAddedTime.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aNewCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aNewCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aNewCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aNewCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		SActorSpreadControllerCandidateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpreadingActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpreadingActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentActorIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerCheckEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerCheckEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerSpreading") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerSpreading);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerIsValidCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerIsValidCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayerIsCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayerIsCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PlayerCandidateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_PlayerCandidateTime, p_Stream);

	p_Stream << "}";
}

void SActorSpreadControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSpreadControllerSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSpreadingActors"];
	s_Object.m_aSpreadingActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aSpreadingActors[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDeadSpreadingActors"];
	s_Object.m_aDeadSpreadingActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aDeadSpreadingActors[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSpreadingActorsAddedTime"];
	s_Object.m_aSpreadingActorsAddedTime.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZGameTime s_ArrayItem0;
		ZGameTime::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSpreadingActorsAddedTime[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aNewCandidates"];
	s_Object.m_aNewCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aNewCandidates[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCandidates"];
	s_Object.m_aCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorSpreadControllerCandidateSaveData s_ArrayItem0;
		SActorSpreadControllerCandidateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aCandidates[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_rCurrentSpreadingActor = simdjson::from_json_uint32(p_Document["m_rCurrentSpreadingActor"]);

	s_Object.m_nCurrentActorIndex = simdjson::from_json_uint32(p_Document["m_nCurrentActorIndex"]);

	s_Object.m_bPlayerCheckEnabled = simdjson::from_json_bool(p_Document["m_bPlayerCheckEnabled"]);

	s_Object.m_bPlayerSpreading = simdjson::from_json_bool(p_Document["m_bPlayerSpreading"]);

	s_Object.m_bPlayerIsValidCandidate = simdjson::from_json_bool(p_Document["m_bPlayerIsValidCandidate"]);

	s_Object.m_bPlayerIsCandidate = simdjson::from_json_bool(p_Document["m_bPlayerIsCandidate"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_PlayerCandidateTime"], &s_Item);
		s_Object.m_PlayerCandidateTime = s_Item;
	}

	*reinterpret_cast<SActorSpreadControllerSaveData*>(p_Target) = s_Object;
}

void SActorSpreadControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aSpreadingActors, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aSpreadingActors));
	TArray<uint32>::Serialize(&s_Object->m_aDeadSpreadingActors, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aDeadSpreadingActors));
	TArray<ZGameTime>::Serialize(&s_Object->m_aSpreadingActorsAddedTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aSpreadingActorsAddedTime));
	TArray<uint32>::Serialize(&s_Object->m_aNewCandidates, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aNewCandidates));
	TArray<SActorSpreadControllerCandidateSaveData>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_aCandidates));
	ZGameTime::Serialize(&s_Object->m_PlayerCandidateTime, p_Serializer, p_OwnOffset + offsetof(SActorSpreadControllerSaveData, m_PlayerCandidateTime));
}

bool SActorSpreadControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadControllerSaveData::operator==(const SActorSpreadControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadControllerSaveData>)
		return false;

	if (m_aSpreadingActors != p_Other.m_aSpreadingActors) return false;
	if (m_aDeadSpreadingActors != p_Other.m_aDeadSpreadingActors) return false;
	if (m_aSpreadingActorsAddedTime != p_Other.m_aSpreadingActorsAddedTime) return false;
	if (m_aNewCandidates != p_Other.m_aNewCandidates) return false;
	if (m_aCandidates != p_Other.m_aCandidates) return false;
	if (m_rCurrentSpreadingActor != p_Other.m_rCurrentSpreadingActor) return false;
	if (m_nCurrentActorIndex != p_Other.m_nCurrentActorIndex) return false;
	if (m_bPlayerCheckEnabled != p_Other.m_bPlayerCheckEnabled) return false;
	if (m_bPlayerSpreading != p_Other.m_bPlayerSpreading) return false;
	if (m_bPlayerIsValidCandidate != p_Other.m_bPlayerIsValidCandidate) return false;
	if (m_bPlayerIsCandidate != p_Other.m_bPlayerIsCandidate) return false;
	if (m_PlayerCandidateTime != p_Other.m_PlayerCandidateTime) return false;

	return true;
}

void SActorSpreadControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSpreadControllerSaveData*>(p_Object);
	s_Object->~SActorSpreadControllerSaveData();
}

ZHMTypeInfo SActorSpreadTransitionOperatorMaterialActorSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadTransitionOperatorMaterialActorSaveData", sizeof(SActorSpreadTransitionOperatorMaterialActorSaveData), alignof(SActorSpreadTransitionOperatorMaterialActorSaveData), SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson, SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson, SActorSpreadTransitionOperatorMaterialActorSaveData::Serialize, SActorSpreadTransitionOperatorMaterialActorSaveData::Equals, SActorSpreadTransitionOperatorMaterialActorSaveData::Destroy);

void SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Actor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_Actor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpacity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpacity);

	p_Stream << "}";
}

void SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSpreadTransitionOperatorMaterialActorSaveData s_Object {};

	s_Object.m_Actor = simdjson::from_json_uint32(p_Document["m_Actor"]);

	s_Object.m_fOpacity = simdjson::from_json_float32(p_Document["m_fOpacity"]);

	*reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Target) = s_Object;
}

void SActorSpreadTransitionOperatorMaterialActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);

}

bool SActorSpreadTransitionOperatorMaterialActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadTransitionOperatorMaterialActorSaveData::operator==(const SActorSpreadTransitionOperatorMaterialActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadTransitionOperatorMaterialActorSaveData>)
		return false;

	if (m_Actor != p_Other.m_Actor) return false;
	if (m_fOpacity != p_Other.m_fOpacity) return false;

	return true;
}

void SActorSpreadTransitionOperatorMaterialActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialActorSaveData*>(p_Object);
	s_Object->~SActorSpreadTransitionOperatorMaterialActorSaveData();
}

ZHMTypeInfo SActorSpreadTransitionOperatorMaterialSaveData::TypeInfo = ZHMTypeInfo("SActorSpreadTransitionOperatorMaterialSaveData", sizeof(SActorSpreadTransitionOperatorMaterialSaveData), alignof(SActorSpreadTransitionOperatorMaterialSaveData), SActorSpreadTransitionOperatorMaterialSaveData::WriteSimpleJson, SActorSpreadTransitionOperatorMaterialSaveData::FromSimpleJson, SActorSpreadTransitionOperatorMaterialSaveData::Serialize, SActorSpreadTransitionOperatorMaterialSaveData::Equals, SActorSpreadTransitionOperatorMaterialSaveData::Destroy);

void SActorSpreadTransitionOperatorMaterialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aActorMaterialOverrides") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorMaterialOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorMaterialOverrides[i];
		SActorSpreadTransitionOperatorMaterialActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorMaterialOverrides.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorSpreadTransitionOperatorMaterialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorSpreadTransitionOperatorMaterialSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActorMaterialOverrides"];
	s_Object.m_aActorMaterialOverrides.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorSpreadTransitionOperatorMaterialActorSaveData s_ArrayItem0;
		SActorSpreadTransitionOperatorMaterialActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorMaterialOverrides[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Target) = s_Object;
}

void SActorSpreadTransitionOperatorMaterialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);

	TArray<SActorSpreadTransitionOperatorMaterialActorSaveData>::Serialize(&s_Object->m_aActorMaterialOverrides, p_Serializer, p_OwnOffset + offsetof(SActorSpreadTransitionOperatorMaterialSaveData, m_aActorMaterialOverrides));
}

bool SActorSpreadTransitionOperatorMaterialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorSpreadTransitionOperatorMaterialSaveData::operator==(const SActorSpreadTransitionOperatorMaterialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorSpreadTransitionOperatorMaterialSaveData>)
		return false;

	if (m_aActorMaterialOverrides != p_Other.m_aActorMaterialOverrides) return false;

	return true;
}

void SActorSpreadTransitionOperatorMaterialSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorSpreadTransitionOperatorMaterialSaveData*>(p_Object);
	s_Object->~SActorSpreadTransitionOperatorMaterialSaveData();
}

ZHMTypeInfo SActorStandInSaveData::TypeInfo = ZHMTypeInfo("SActorStandInSaveData", sizeof(SActorStandInSaveData), alignof(SActorStandInSaveData), SActorStandInSaveData::WriteSimpleJson, SActorStandInSaveData::FromSimpleJson, SActorStandInSaveData::Serialize, SActorStandInSaveData::Equals, SActorStandInSaveData::Destroy);

void SActorStandInSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SActorStandInSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorStandInSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SActorStandInSaveData*>(p_Target) = s_Object;
}

void SActorStandInSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);

}

bool SActorStandInSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorStandInSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorStandInSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorStandInSaveData::operator==(const SActorStandInSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorStandInSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SActorStandInSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorStandInSaveData*>(p_Object);
	s_Object->~SActorStandInSaveData();
}

ZHMTypeInfo SActorStandInEntitiesSaveData::TypeInfo = ZHMTypeInfo("SActorStandInEntitiesSaveData", sizeof(SActorStandInEntitiesSaveData), alignof(SActorStandInEntitiesSaveData), SActorStandInEntitiesSaveData::WriteSimpleJson, SActorStandInEntitiesSaveData::FromSimpleJson, SActorStandInEntitiesSaveData::Serialize, SActorStandInEntitiesSaveData::Equals, SActorStandInEntitiesSaveData::Destroy);

void SActorStandInEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SActorStandInSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorStandInEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorStandInEntitiesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorStandInSaveData s_ArrayItem0;
		SActorStandInSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Target) = s_Object;
}

void SActorStandInEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SActorStandInEntitiesSaveData, m_aEntities));
	TArray<SActorStandInSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SActorStandInEntitiesSaveData, m_aData));
}

bool SActorStandInEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorStandInEntitiesSaveData::operator==(const SActorStandInEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorStandInEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SActorStandInEntitiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorStandInEntitiesSaveData*>(p_Object);
	s_Object->~SActorStandInEntitiesSaveData();
}

ZHMTypeInfo SActorTagSaveData::TypeInfo = ZHMTypeInfo("SActorTagSaveData", sizeof(SActorTagSaveData), alignof(SActorTagSaveData), SActorTagSaveData::WriteSimpleJson, SActorTagSaveData::FromSimpleJson, SActorTagSaveData::Serialize, SActorTagSaveData::Equals, SActorTagSaveData::Destroy);

void SActorTagSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSeen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSeen);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTagged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTagged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rActorRef") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActorRef);

	p_Stream << "}";
}

void SActorTagSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorTagSaveData s_Object {};

	s_Object.m_bSeen = simdjson::from_json_bool(p_Document["m_bSeen"]);

	s_Object.m_bTagged = simdjson::from_json_bool(p_Document["m_bTagged"]);

	s_Object.m_rActorRef = simdjson::from_json_uint32(p_Document["m_rActorRef"]);

	*reinterpret_cast<SActorTagSaveData*>(p_Target) = s_Object;
}

void SActorTagSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);

}

bool SActorTagSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorTagSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorTagSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorTagSaveData::operator==(const SActorTagSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorTagSaveData>)
		return false;

	if (m_bSeen != p_Other.m_bSeen) return false;
	if (m_bTagged != p_Other.m_bTagged) return false;
	if (m_rActorRef != p_Other.m_rActorRef) return false;

	return true;
}

void SActorTagSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorTagSaveData*>(p_Object);
	s_Object->~SActorTagSaveData();
}

ZHMTypeInfo SActorTagManagerSaveData::TypeInfo = ZHMTypeInfo("SActorTagManagerSaveData", sizeof(SActorTagManagerSaveData), alignof(SActorTagManagerSaveData), SActorTagManagerSaveData::WriteSimpleJson, SActorTagManagerSaveData::FromSimpleJson, SActorTagManagerSaveData::Serialize, SActorTagManagerSaveData::Equals, SActorTagManagerSaveData::Destroy);

void SActorTagManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bContractsCreationMode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContractsCreationMode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTagCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTagCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxTagCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxTagCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTaggingEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTaggingEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorTagData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorTagData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorTagData[i];
		SActorTagSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorTagData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SActorTagManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorTagManagerSaveData s_Object {};

	s_Object.m_bContractsCreationMode = simdjson::from_json_bool(p_Document["m_bContractsCreationMode"]);

	s_Object.m_nTagCount = simdjson::from_json_int32(p_Document["m_nTagCount"]);

	s_Object.m_nMaxTagCount = simdjson::from_json_int32(p_Document["m_nMaxTagCount"]);

	s_Object.m_bTaggingEnabled = simdjson::from_json_bool(p_Document["m_bTaggingEnabled"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActorTagData"];
	s_Object.m_aActorTagData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SActorTagSaveData s_ArrayItem0;
		SActorTagSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorTagData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SActorTagManagerSaveData*>(p_Target) = s_Object;
}

void SActorTagManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);

	TArray<SActorTagSaveData>::Serialize(&s_Object->m_aActorTagData, p_Serializer, p_OwnOffset + offsetof(SActorTagManagerSaveData, m_aActorTagData));
}

bool SActorTagManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorTagManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorTagManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorTagManagerSaveData::operator==(const SActorTagManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorTagManagerSaveData>)
		return false;

	if (m_bContractsCreationMode != p_Other.m_bContractsCreationMode) return false;
	if (m_nTagCount != p_Other.m_nTagCount) return false;
	if (m_nMaxTagCount != p_Other.m_nMaxTagCount) return false;
	if (m_bTaggingEnabled != p_Other.m_bTaggingEnabled) return false;
	if (m_aActorTagData != p_Other.m_aActorTagData) return false;

	return true;
}

void SActorTagManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorTagManagerSaveData*>(p_Object);
	s_Object->~SActorTagManagerSaveData();
}

ZHMTypeInfo SActorVisibilityConditionSaveData::TypeInfo = ZHMTypeInfo("SActorVisibilityConditionSaveData", sizeof(SActorVisibilityConditionSaveData), alignof(SActorVisibilityConditionSaveData), SActorVisibilityConditionSaveData::WriteSimpleJson, SActorVisibilityConditionSaveData::FromSimpleJson, SActorVisibilityConditionSaveData::Serialize, SActorVisibilityConditionSaveData::Equals, SActorVisibilityConditionSaveData::Destroy);

void SActorVisibilityConditionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SActorVisibilityConditionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pActor);

	p_Stream << "}";
}

void SActorVisibilityConditionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SActorVisibilityConditionSaveData s_Object {};

	s_Object.m_pActor = simdjson::from_json_uint32(p_Document["m_pActor"]);

	*reinterpret_cast<SActorVisibilityConditionSaveData*>(p_Target) = s_Object;
}

void SActorVisibilityConditionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SActorVisibilityConditionSaveData*>(p_Object);

}

bool SActorVisibilityConditionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SActorVisibilityConditionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SActorVisibilityConditionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SActorVisibilityConditionSaveData::operator==(const SActorVisibilityConditionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SActorVisibilityConditionSaveData>)
		return false;

	if (m_pActor != p_Other.m_pActor) return false;

	return true;
}

void SActorVisibilityConditionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SActorVisibilityConditionSaveData*>(p_Object);
	s_Object->~SActorVisibilityConditionSaveData();
}

ZHMTypeInfo SAgencyPickupInfo::TypeInfo = ZHMTypeInfo("SAgencyPickupInfo", sizeof(SAgencyPickupInfo), alignof(SAgencyPickupInfo), SAgencyPickupInfo::WriteSimpleJson, SAgencyPickupInfo::FromSimpleJson, SAgencyPickupInfo::Serialize, SAgencyPickupInfo::Equals, SAgencyPickupInfo::Destroy);

void SAgencyPickupInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAgencyPickupInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_AgencyPickupId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_AgencyPickupId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aItemIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItemIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aModifierIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aModifierIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aModifierIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAgencyPickupInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAgencyPickupInfo s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_AgencyPickupId"], &s_Item);
		s_Object.m_AgencyPickupId = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aItemIds"];
	s_Object.m_aItemIds.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItemIds[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aModifierIds"];
	s_Object.m_aModifierIds.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aModifierIds[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SAgencyPickupInfo*>(p_Target) = s_Object;
}

void SAgencyPickupInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAgencyPickupInfo*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_AgencyPickupId, p_Serializer, p_OwnOffset + offsetof(SAgencyPickupInfo, m_AgencyPickupId));
	TArray<ZRepositoryID>::Serialize(&s_Object->m_aItemIds, p_Serializer, p_OwnOffset + offsetof(SAgencyPickupInfo, m_aItemIds));
	TArray<ZRepositoryID>::Serialize(&s_Object->m_aModifierIds, p_Serializer, p_OwnOffset + offsetof(SAgencyPickupInfo, m_aModifierIds));
}

bool SAgencyPickupInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAgencyPickupInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SAgencyPickupInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAgencyPickupInfo::operator==(const SAgencyPickupInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAgencyPickupInfo>)
		return false;

	if (m_AgencyPickupId != p_Other.m_AgencyPickupId) return false;
	if (m_aItemIds != p_Other.m_aItemIds) return false;
	if (m_aModifierIds != p_Other.m_aModifierIds) return false;

	return true;
}

void SAgencyPickupInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAgencyPickupInfo*>(p_Object);
	s_Object->~SAgencyPickupInfo();
}

ZHMTypeInfo SAgitatedBystanderOrderSaveData::TypeInfo = ZHMTypeInfo("SAgitatedBystanderOrderSaveData", sizeof(SAgitatedBystanderOrderSaveData), alignof(SAgitatedBystanderOrderSaveData), SAgitatedBystanderOrderSaveData::WriteSimpleJson, SAgitatedBystanderOrderSaveData::FromSimpleJson, SAgitatedBystanderOrderSaveData::Serialize, SAgitatedBystanderOrderSaveData::Equals, SAgitatedBystanderOrderSaveData::Destroy);

void SAgitatedBystanderOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rBystanderPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBystanderPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCover") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCover, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCoverDir") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCoverDir, p_Stream);

	p_Stream << "}";
}

void SAgitatedBystanderOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAgitatedBystanderOrderSaveData s_Object {};

	s_Object.m_rBystanderPoint = simdjson::from_json_uint32(p_Document["m_rBystanderPoint"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vCover"], &s_Item);
		s_Object.m_vCover = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vCoverDir"], &s_Item);
		s_Object.m_vCoverDir = s_Item;
	}

	*reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Target) = s_Object;
}

void SAgitatedBystanderOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vCover, p_Serializer, p_OwnOffset + offsetof(SAgitatedBystanderOrderSaveData, m_vCover));
	float4::Serialize(&s_Object->m_vCoverDir, p_Serializer, p_OwnOffset + offsetof(SAgitatedBystanderOrderSaveData, m_vCoverDir));
}

bool SAgitatedBystanderOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAgitatedBystanderOrderSaveData::operator==(const SAgitatedBystanderOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAgitatedBystanderOrderSaveData>)
		return false;

	if (m_rBystanderPoint != p_Other.m_rBystanderPoint) return false;
	if (m_vCover != p_Other.m_vCover) return false;
	if (m_vCoverDir != p_Other.m_vCoverDir) return false;

	return true;
}

void SAgitatedBystanderOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAgitatedBystanderOrderSaveData*>(p_Object);
	s_Object->~SAgitatedBystanderOrderSaveData();
}

ZHMTypeInfo SAimAssistObjectSaveData::TypeInfo = ZHMTypeInfo("SAimAssistObjectSaveData", sizeof(SAimAssistObjectSaveData), alignof(SAimAssistObjectSaveData), SAimAssistObjectSaveData::WriteSimpleJson, SAimAssistObjectSaveData::FromSimpleJson, SAimAssistObjectSaveData::Serialize, SAimAssistObjectSaveData::Equals, SAimAssistObjectSaveData::Destroy);

void SAimAssistObjectSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAimAssistObjectSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bHasBeenStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasBeenStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasAimAssistActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasAimAssistActivated);

	p_Stream << "}";
}

void SAimAssistObjectSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAimAssistObjectSaveData s_Object {};

	s_Object.m_bHasBeenStarted = simdjson::from_json_bool(p_Document["m_bHasBeenStarted"]);

	s_Object.m_bWasAimAssistActivated = simdjson::from_json_bool(p_Document["m_bWasAimAssistActivated"]);

	*reinterpret_cast<SAimAssistObjectSaveData*>(p_Target) = s_Object;
}

void SAimAssistObjectSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAimAssistObjectSaveData*>(p_Object);

}

bool SAimAssistObjectSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAimAssistObjectSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAimAssistObjectSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAimAssistObjectSaveData::operator==(const SAimAssistObjectSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAimAssistObjectSaveData>)
		return false;

	if (m_bHasBeenStarted != p_Other.m_bHasBeenStarted) return false;
	if (m_bWasAimAssistActivated != p_Other.m_bWasAimAssistActivated) return false;

	return true;
}

void SAimAssistObjectSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAimAssistObjectSaveData*>(p_Object);
	s_Object->~SAimAssistObjectSaveData();
}

ZHMTypeInfo SBoneTransformSaveData::TypeInfo = ZHMTypeInfo("SBoneTransformSaveData", sizeof(SBoneTransformSaveData), alignof(SBoneTransformSaveData), SBoneTransformSaveData::WriteSimpleJson, SBoneTransformSaveData::FromSimpleJson, SBoneTransformSaveData::Serialize, SBoneTransformSaveData::Equals, SBoneTransformSaveData::Destroy);

void SBoneTransformSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SBoneTransformSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBoneTransformSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Item);
		s_Object.mQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Item);
		s_Object.mTranslation = s_Item;
	}

	*reinterpret_cast<SBoneTransformSaveData*>(p_Target) = s_Object;
}

void SBoneTransformSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SBoneTransformSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SBoneTransformSaveData, mTranslation));
}

bool SBoneTransformSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneTransformSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneTransformSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneTransformSaveData::operator==(const SBoneTransformSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneTransformSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

void SBoneTransformSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBoneTransformSaveData*>(p_Object);
	s_Object->~SBoneTransformSaveData();
}

ZHMTypeInfo SAnimPlayerSaveData::TypeInfo = ZHMTypeInfo("SAnimPlayerSaveData", sizeof(SAnimPlayerSaveData), alignof(SAnimPlayerSaveData), SAnimPlayerSaveData::WriteSimpleJson, SAnimPlayerSaveData::FromSimpleJson, SAnimPlayerSaveData::Serialize, SAnimPlayerSaveData::Equals, SAnimPlayerSaveData::Destroy);

void SAnimPlayerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mTrajectoryQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTrajectoryQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTrajectoryTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTrajectoryTranslation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SBoneTransformSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAnimPlayerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimPlayerSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTrajectoryQuaterion"], &s_Item);
		s_Object.mTrajectoryQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTrajectoryTranslation"], &s_Item);
		s_Object.mTrajectoryTranslation = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBones"];
	s_Object.m_aBones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBoneTransformSaveData s_ArrayItem0;
		SBoneTransformSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBones[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SAnimPlayerSaveData*>(p_Target) = s_Object;
}

void SAnimPlayerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mTrajectoryQuaterion, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, mTrajectoryQuaterion));
	SVector4::Serialize(&s_Object->mTrajectoryTranslation, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, mTrajectoryTranslation));
	TArray<SBoneTransformSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SAnimPlayerSaveData, m_aBones));
}

bool SAnimPlayerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimPlayerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimPlayerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimPlayerSaveData::operator==(const SAnimPlayerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimPlayerSaveData>)
		return false;

	if (mTrajectoryQuaterion != p_Other.mTrajectoryQuaterion) return false;
	if (mTrajectoryTranslation != p_Other.mTrajectoryTranslation) return false;
	if (m_aBones != p_Other.m_aBones) return false;

	return true;
}

void SAnimPlayerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimPlayerSaveData*>(p_Object);
	s_Object->~SAnimPlayerSaveData();
}

ZHMTypeInfo SAnimatedActorActOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorActOrderSaveData", sizeof(SAnimatedActorActOrderSaveData), alignof(SAnimatedActorActOrderSaveData), SAnimatedActorActOrderSaveData::WriteSimpleJson, SAnimatedActorActOrderSaveData::FromSimpleJson, SAnimatedActorActOrderSaveData::Serialize, SAnimatedActorActOrderSaveData::Equals, SAnimatedActorActOrderSaveData::Destroy);

void SAnimatedActorActOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bOverrideExistingAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOverrideExistingAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nForcedAnimationNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nForcedAnimationNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkAct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rListener") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rListener);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vOriginPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginQuaternion") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vOriginQuaternion, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorActOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorActOrderSaveData s_Object {};

	s_Object.m_bOverrideExistingAct = simdjson::from_json_bool(p_Document["m_bOverrideExistingAct"]);

	s_Object.m_nForcedAnimationNode = simdjson::from_json_uint32(p_Document["m_nForcedAnimationNode"]);

	s_Object.m_rChildNetworkAct = simdjson::from_json_uint32(p_Document["m_rChildNetworkAct"]);

	s_Object.m_rListener = simdjson::from_json_uint32(p_Document["m_rListener"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vOriginPosition"], &s_Item);
		s_Object.m_vOriginPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vOriginQuaternion"], &s_Item);
		s_Object.m_vOriginQuaternion = s_Item;
	}

	*reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorActOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vOriginPosition, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorActOrderSaveData, m_vOriginPosition));
	SVector4::Serialize(&s_Object->m_vOriginQuaternion, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorActOrderSaveData, m_vOriginQuaternion));
}

bool SAnimatedActorActOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorActOrderSaveData::operator==(const SAnimatedActorActOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorActOrderSaveData>)
		return false;

	if (m_bOverrideExistingAct != p_Other.m_bOverrideExistingAct) return false;
	if (m_nForcedAnimationNode != p_Other.m_nForcedAnimationNode) return false;
	if (m_rChildNetworkAct != p_Other.m_rChildNetworkAct) return false;
	if (m_rListener != p_Other.m_rListener) return false;
	if (m_vOriginPosition != p_Other.m_vOriginPosition) return false;
	if (m_vOriginQuaternion != p_Other.m_vOriginQuaternion) return false;

	return true;
}

void SAnimatedActorActOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorActOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorActOrderSaveData();
}

ZHMTypeInfo SAnimatedActorMoveOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorMoveOrderSaveData", sizeof(SAnimatedActorMoveOrderSaveData), alignof(SAnimatedActorMoveOrderSaveData), SAnimatedActorMoveOrderSaveData::WriteSimpleJson, SAnimatedActorMoveOrderSaveData::FromSimpleJson, SAnimatedActorMoveOrderSaveData::Serialize, SAnimatedActorMoveOrderSaveData::Equals, SAnimatedActorMoveOrderSaveData::Destroy);

void SAnimatedActorMoveOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPrecisePositioning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPrecisePositioning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPreciseOrientation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPreciseOrientation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreEndCollision") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreEndCollision);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForcedEnpointSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForcedEnpointSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStopMoveDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStopMoveDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vWaypoint") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vWaypoint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vForcedEndpoint") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vForcedEndpoint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vFacingDirection") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFacingDirection, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorMoveOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorMoveOrderSaveData s_Object {};

	s_Object.m_bPrecisePositioning = simdjson::from_json_bool(p_Document["m_bPrecisePositioning"]);

	s_Object.m_bPreciseOrientation = simdjson::from_json_bool(p_Document["m_bPreciseOrientation"]);

	s_Object.m_bIgnoreEndCollision = simdjson::from_json_bool(p_Document["m_bIgnoreEndCollision"]);

	s_Object.m_bForcedEnpointSet = simdjson::from_json_bool(p_Document["m_bForcedEnpointSet"]);

	s_Object.m_fStopMoveDistance = simdjson::from_json_float32(p_Document["m_fStopMoveDistance"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vWaypoint"], &s_Item);
		s_Object.m_vWaypoint = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vForcedEndpoint"], &s_Item);
		s_Object.m_vForcedEndpoint = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vFacingDirection"], &s_Item);
		s_Object.m_vFacingDirection = s_Item;
	}

	*reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorMoveOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vWaypoint, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorMoveOrderSaveData, m_vWaypoint));
	SVector3::Serialize(&s_Object->m_vForcedEndpoint, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorMoveOrderSaveData, m_vForcedEndpoint));
	SVector3::Serialize(&s_Object->m_vFacingDirection, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorMoveOrderSaveData, m_vFacingDirection));
}

bool SAnimatedActorMoveOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorMoveOrderSaveData::operator==(const SAnimatedActorMoveOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorMoveOrderSaveData>)
		return false;

	if (m_bPrecisePositioning != p_Other.m_bPrecisePositioning) return false;
	if (m_bPreciseOrientation != p_Other.m_bPreciseOrientation) return false;
	if (m_bIgnoreEndCollision != p_Other.m_bIgnoreEndCollision) return false;
	if (m_bForcedEnpointSet != p_Other.m_bForcedEnpointSet) return false;
	if (m_fStopMoveDistance != p_Other.m_fStopMoveDistance) return false;
	if (m_vWaypoint != p_Other.m_vWaypoint) return false;
	if (m_vForcedEndpoint != p_Other.m_vForcedEndpoint) return false;
	if (m_vFacingDirection != p_Other.m_vFacingDirection) return false;

	return true;
}

void SAnimatedActorMoveOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorMoveOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorMoveOrderSaveData();
}

ZHMTypeInfo SAnimatedActorOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorOrderSaveData", sizeof(SAnimatedActorOrderSaveData), alignof(SAnimatedActorOrderSaveData), SAnimatedActorOrderSaveData::WriteSimpleJson, SAnimatedActorOrderSaveData::FromSimpleJson, SAnimatedActorOrderSaveData::Serialize, SAnimatedActorOrderSaveData::Equals, SAnimatedActorOrderSaveData::Destroy);

void SAnimatedActorOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eOrderType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorAnimationOrder", static_cast<int>(s_Object->m_eOrderType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OrderData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_OrderData, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorOrderSaveData s_Object {};

	s_Object.m_eOrderType = static_cast<EActorAnimationOrder>(ZHMEnums::GetEnumValueByName("EActorAnimationOrder", std::string_view(p_Document["m_eOrderType"])));

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_OrderData"], &s_Item);
		s_Object.m_OrderData = s_Item;
	}

	*reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_OrderData, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorOrderSaveData, m_OrderData));
}

bool SAnimatedActorOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorOrderSaveData::operator==(const SAnimatedActorOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorOrderSaveData>)
		return false;

	if (m_eOrderType != p_Other.m_eOrderType) return false;
	if (m_OrderData != p_Other.m_OrderData) return false;

	return true;
}

void SAnimatedActorOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorOrderSaveData();
}

ZHMTypeInfo SAnimatedActorReactOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorReactOrderSaveData", sizeof(SAnimatedActorReactOrderSaveData), alignof(SAnimatedActorReactOrderSaveData), SAnimatedActorReactOrderSaveData::WriteSimpleJson, SAnimatedActorReactOrderSaveData::FromSimpleJson, SAnimatedActorReactOrderSaveData::Serialize, SAnimatedActorReactOrderSaveData::Equals, SAnimatedActorReactOrderSaveData::Destroy);

void SAnimatedActorReactOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vFaceTarget") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFaceTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLookAtTarget") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLookAtTarget, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rChildNetworkEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rChildNetworkEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_targetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadbody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadbody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bExplosion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bExplosion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropCarriedItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropCarriedItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFaceTargetSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFaceTargetSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLookAtTargetSet") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAtTargetSet);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sAct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sAct);

	p_Stream << "}";
}

void SAnimatedActorReactOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorReactOrderSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vFaceTarget"], &s_Item);
		s_Object.m_vFaceTarget = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLookAtTarget"], &s_Item);
		s_Object.m_vLookAtTarget = s_Item;
	}

	s_Object.m_rChildNetworkEntity = simdjson::from_json_uint32(p_Document["m_rChildNetworkEntity"]);

	s_Object.m_targetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_targetEmotionState"])));

	s_Object.m_bDeadbody = simdjson::from_json_bool(p_Document["m_bDeadbody"]);

	s_Object.m_bExplosion = simdjson::from_json_bool(p_Document["m_bExplosion"]);

	s_Object.m_bTrespassing = simdjson::from_json_bool(p_Document["m_bTrespassing"]);

	s_Object.m_bDropCarriedItems = simdjson::from_json_bool(p_Document["m_bDropCarriedItems"]);

	s_Object.m_bFaceTargetSet = simdjson::from_json_bool(p_Document["m_bFaceTargetSet"]);

	s_Object.m_bLookAtTargetSet = simdjson::from_json_bool(p_Document["m_bLookAtTargetSet"]);

	s_Object.m_sAct = std::string_view(p_Document["m_sAct"]);

	*reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorReactOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vFaceTarget, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_vFaceTarget));
	SVector3::Serialize(&s_Object->m_vLookAtTarget, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_vLookAtTarget));
	ZString::Serialize(&s_Object->m_sAct, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorReactOrderSaveData, m_sAct));
}

bool SAnimatedActorReactOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorReactOrderSaveData::operator==(const SAnimatedActorReactOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorReactOrderSaveData>)
		return false;

	if (m_vFaceTarget != p_Other.m_vFaceTarget) return false;
	if (m_vLookAtTarget != p_Other.m_vLookAtTarget) return false;
	if (m_rChildNetworkEntity != p_Other.m_rChildNetworkEntity) return false;
	if (m_targetEmotionState != p_Other.m_targetEmotionState) return false;
	if (m_bDeadbody != p_Other.m_bDeadbody) return false;
	if (m_bExplosion != p_Other.m_bExplosion) return false;
	if (m_bTrespassing != p_Other.m_bTrespassing) return false;
	if (m_bDropCarriedItems != p_Other.m_bDropCarriedItems) return false;
	if (m_bFaceTargetSet != p_Other.m_bFaceTargetSet) return false;
	if (m_bLookAtTargetSet != p_Other.m_bLookAtTargetSet) return false;
	if (m_sAct != p_Other.m_sAct) return false;

	return true;
}

void SAnimatedActorReactOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorReactOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorReactOrderSaveData();
}

ZHMTypeInfo SAnimatedActorStandOrderSaveData::TypeInfo = ZHMTypeInfo("SAnimatedActorStandOrderSaveData", sizeof(SAnimatedActorStandOrderSaveData), alignof(SAnimatedActorStandOrderSaveData), SAnimatedActorStandOrderSaveData::WriteSimpleJson, SAnimatedActorStandOrderSaveData::FromSimpleJson, SAnimatedActorStandOrderSaveData::Serialize, SAnimatedActorStandOrderSaveData::Equals, SAnimatedActorStandOrderSaveData::Destroy);

void SAnimatedActorStandOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vFacingDirection") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vFacingDirection, p_Stream);

	p_Stream << "}";
}

void SAnimatedActorStandOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAnimatedActorStandOrderSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vFacingDirection"], &s_Item);
		s_Object.m_vFacingDirection = s_Item;
	}

	*reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Target) = s_Object;
}

void SAnimatedActorStandOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vFacingDirection, p_Serializer, p_OwnOffset + offsetof(SAnimatedActorStandOrderSaveData, m_vFacingDirection));
}

bool SAnimatedActorStandOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAnimatedActorStandOrderSaveData::operator==(const SAnimatedActorStandOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAnimatedActorStandOrderSaveData>)
		return false;

	if (m_vFacingDirection != p_Other.m_vFacingDirection) return false;

	return true;
}

void SAnimatedActorStandOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAnimatedActorStandOrderSaveData*>(p_Object);
	s_Object->~SAnimatedActorStandOrderSaveData();
}

ZHMTypeInfo SAttentionHUDUIElement::TypeInfo = ZHMTypeInfo("SAttentionHUDUIElement", sizeof(SAttentionHUDUIElement), alignof(SAttentionHUDUIElement), SAttentionHUDUIElement::WriteSimpleJson, SAttentionHUDUIElement::FromSimpleJson, SAttentionHUDUIElement::Serialize, SAttentionHUDUIElement::Equals, SAttentionHUDUIElement::Destroy);

void SAttentionHUDUIElement::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAttention") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAttention);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fRadius);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nColor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColor);

	p_Stream << "}";
}

void SAttentionHUDUIElement::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAttentionHUDUIElement s_Object {};

	s_Object.fAngle = simdjson::from_json_float32(p_Document["fAngle"]);

	s_Object.fAttention = simdjson::from_json_float32(p_Document["fAttention"]);

	s_Object.fAlpha = simdjson::from_json_float32(p_Document["fAlpha"]);

	s_Object.fRadius = simdjson::from_json_float32(p_Document["fRadius"]);

	s_Object.nColor = simdjson::from_json_int32(p_Document["nColor"]);

	*reinterpret_cast<SAttentionHUDUIElement*>(p_Target) = s_Object;
}

void SAttentionHUDUIElement::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);

}

bool SAttentionHUDUIElement::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAttentionHUDUIElement*>(p_Left);
	auto* s_Right = reinterpret_cast<SAttentionHUDUIElement*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAttentionHUDUIElement::operator==(const SAttentionHUDUIElement& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAttentionHUDUIElement>)
		return false;

	if (fAngle != p_Other.fAngle) return false;
	if (fAttention != p_Other.fAttention) return false;
	if (fAlpha != p_Other.fAlpha) return false;
	if (fRadius != p_Other.fRadius) return false;
	if (nColor != p_Other.nColor) return false;

	return true;
}

void SAttentionHUDUIElement::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElement*>(p_Object);
	s_Object->~SAttentionHUDUIElement();
}

ZHMTypeInfo SAttentionHUDUIElementArray_Dummy::TypeInfo = ZHMTypeInfo("SAttentionHUDUIElementArray_Dummy", sizeof(SAttentionHUDUIElementArray_Dummy), alignof(SAttentionHUDUIElementArray_Dummy), SAttentionHUDUIElementArray_Dummy::WriteSimpleJson, SAttentionHUDUIElementArray_Dummy::FromSimpleJson, SAttentionHUDUIElementArray_Dummy::Serialize, SAttentionHUDUIElementArray_Dummy::Equals, SAttentionHUDUIElementArray_Dummy::Destroy);

void SAttentionHUDUIElementArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SAttentionHUDUIElement::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAttentionHUDUIElementArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAttentionHUDUIElementArray_Dummy s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object.dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAttentionHUDUIElement s_ArrayItem0;
		SAttentionHUDUIElement::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Target) = s_Object;
}

void SAttentionHUDUIElementArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);

	TArray<SAttentionHUDUIElement>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SAttentionHUDUIElementArray_Dummy, dummy));
}

bool SAttentionHUDUIElementArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAttentionHUDUIElementArray_Dummy::operator==(const SAttentionHUDUIElementArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAttentionHUDUIElementArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SAttentionHUDUIElementArray_Dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAttentionHUDUIElementArray_Dummy*>(p_Object);
	s_Object->~SAttentionHUDUIElementArray_Dummy();
}

ZHMTypeInfo SAudioEmitterEventSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterEventSaveData", sizeof(SAudioEmitterEventSaveData), alignof(SAudioEmitterEventSaveData), SAudioEmitterEventSaveData::WriteSimpleJson, SAudioEmitterEventSaveData::FromSimpleJson, SAudioEmitterEventSaveData::Serialize, SAudioEmitterEventSaveData::Equals, SAudioEmitterEventSaveData::Destroy);

void SAudioEmitterEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEventSender") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEventSender);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSeekPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPlayState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPlayState);

	p_Stream << "}";
}

void SAudioEmitterEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterEventSaveData s_Object {};

	s_Object.m_nEventId = simdjson::from_json_uint32(p_Document["m_nEventId"]);

	s_Object.m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	s_Object.m_nFlags = simdjson::from_json_uint32(p_Document["m_nFlags"]);

	s_Object.m_rEventSender = simdjson::from_json_uint32(p_Document["m_rEventSender"]);

	s_Object.m_nSeekPosition = simdjson::from_json_int32(p_Document["m_nSeekPosition"]);

	s_Object.m_nPlayState = simdjson::from_json_uint8(p_Document["m_nPlayState"]);

	*reinterpret_cast<SAudioEmitterEventSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);

}

bool SAudioEmitterEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterEventSaveData::operator==(const SAudioEmitterEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterEventSaveData>)
		return false;

	if (m_nEventId != p_Other.m_nEventId) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;
	if (m_nFlags != p_Other.m_nFlags) return false;
	if (m_rEventSender != p_Other.m_rEventSender) return false;
	if (m_nSeekPosition != p_Other.m_nSeekPosition) return false;
	if (m_nPlayState != p_Other.m_nPlayState) return false;

	return true;
}

void SAudioEmitterEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterEventSaveData*>(p_Object);
	s_Object->~SAudioEmitterEventSaveData();
}

ZHMTypeInfo SAudioEmitterRTPCSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterRTPCSaveData", sizeof(SAudioEmitterRTPCSaveData), alignof(SAudioEmitterRTPCSaveData), SAudioEmitterRTPCSaveData::WriteSimpleJson, SAudioEmitterRTPCSaveData::FromSimpleJson, SAudioEmitterRTPCSaveData::Serialize, SAudioEmitterRTPCSaveData::Equals, SAudioEmitterRTPCSaveData::Destroy);

void SAudioEmitterRTPCSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nParamId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nParamId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fValue);

	p_Stream << "}";
}

void SAudioEmitterRTPCSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterRTPCSaveData s_Object {};

	s_Object.m_nParamId = simdjson::from_json_uint32(p_Document["m_nParamId"]);

	s_Object.m_fValue = simdjson::from_json_float32(p_Document["m_fValue"]);

	*reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterRTPCSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);

}

bool SAudioEmitterRTPCSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterRTPCSaveData::operator==(const SAudioEmitterRTPCSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterRTPCSaveData>)
		return false;

	if (m_nParamId != p_Other.m_nParamId) return false;
	if (m_fValue != p_Other.m_fValue) return false;

	return true;
}

void SAudioEmitterRTPCSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterRTPCSaveData*>(p_Object);
	s_Object->~SAudioEmitterRTPCSaveData();
}

ZHMTypeInfo SAudioEmitterSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterSaveData", sizeof(SAudioEmitterSaveData), alignof(SAudioEmitterSaveData), SAudioEmitterSaveData::WriteSimpleJson, SAudioEmitterSaveData::FromSimpleJson, SAudioEmitterSaveData::Serialize, SAudioEmitterSaveData::Equals, SAudioEmitterSaveData::Destroy);

void SAudioEmitterSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEmitter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEmitter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfEvents") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfEvents);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfRTPCs") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfRTPCs);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfSwitches") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfSwitches);

	p_Stream << "}";
}

void SAudioEmitterSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterSaveData s_Object {};

	s_Object.m_rEmitter = simdjson::from_json_uint32(p_Document["m_rEmitter"]);

	s_Object.m_nNumberOfEvents = simdjson::from_json_uint32(p_Document["m_nNumberOfEvents"]);

	s_Object.m_nNumberOfRTPCs = simdjson::from_json_uint32(p_Document["m_nNumberOfRTPCs"]);

	s_Object.m_nNumberOfSwitches = simdjson::from_json_uint32(p_Document["m_nNumberOfSwitches"]);

	*reinterpret_cast<SAudioEmitterSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);

}

bool SAudioEmitterSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterSaveData::operator==(const SAudioEmitterSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterSaveData>)
		return false;

	if (m_rEmitter != p_Other.m_rEmitter) return false;
	if (m_nNumberOfEvents != p_Other.m_nNumberOfEvents) return false;
	if (m_nNumberOfRTPCs != p_Other.m_nNumberOfRTPCs) return false;
	if (m_nNumberOfSwitches != p_Other.m_nNumberOfSwitches) return false;

	return true;
}

void SAudioEmitterSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSaveData*>(p_Object);
	s_Object->~SAudioEmitterSaveData();
}

ZHMTypeInfo SAudioEmitterStateSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterStateSaveData", sizeof(SAudioEmitterStateSaveData), alignof(SAudioEmitterStateSaveData), SAudioEmitterStateSaveData::WriteSimpleJson, SAudioEmitterStateSaveData::FromSimpleJson, SAudioEmitterStateSaveData::Serialize, SAudioEmitterStateSaveData::Equals, SAudioEmitterStateSaveData::Destroy);

void SAudioEmitterStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nGroupId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStateId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStateId);

	p_Stream << "}";
}

void SAudioEmitterStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterStateSaveData s_Object {};

	s_Object.m_nGroupId = simdjson::from_json_uint32(p_Document["m_nGroupId"]);

	s_Object.m_nStateId = simdjson::from_json_uint32(p_Document["m_nStateId"]);

	*reinterpret_cast<SAudioEmitterStateSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);

}

bool SAudioEmitterStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterStateSaveData::operator==(const SAudioEmitterStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterStateSaveData>)
		return false;

	if (m_nGroupId != p_Other.m_nGroupId) return false;
	if (m_nStateId != p_Other.m_nStateId) return false;

	return true;
}

void SAudioEmitterStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterStateSaveData*>(p_Object);
	s_Object->~SAudioEmitterStateSaveData();
}

ZHMTypeInfo SAudioEmitterSwitchSaveData::TypeInfo = ZHMTypeInfo("SAudioEmitterSwitchSaveData", sizeof(SAudioEmitterSwitchSaveData), alignof(SAudioEmitterSwitchSaveData), SAudioEmitterSwitchSaveData::WriteSimpleJson, SAudioEmitterSwitchSaveData::FromSimpleJson, SAudioEmitterSwitchSaveData::Serialize, SAudioEmitterSwitchSaveData::Equals, SAudioEmitterSwitchSaveData::Destroy);

void SAudioEmitterSwitchSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nGroupId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStateId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStateId);

	p_Stream << "}";
}

void SAudioEmitterSwitchSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioEmitterSwitchSaveData s_Object {};

	s_Object.m_nGroupId = simdjson::from_json_uint32(p_Document["m_nGroupId"]);

	s_Object.m_nStateId = simdjson::from_json_uint32(p_Document["m_nStateId"]);

	*reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Target) = s_Object;
}

void SAudioEmitterSwitchSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);

}

bool SAudioEmitterSwitchSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioEmitterSwitchSaveData::operator==(const SAudioEmitterSwitchSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioEmitterSwitchSaveData>)
		return false;

	if (m_nGroupId != p_Other.m_nGroupId) return false;
	if (m_nStateId != p_Other.m_nStateId) return false;

	return true;
}

void SAudioEmitterSwitchSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioEmitterSwitchSaveData*>(p_Object);
	s_Object->~SAudioEmitterSwitchSaveData();
}

ZHMTypeInfo ZResourceID::TypeInfo = ZHMTypeInfo("ZResourceID", sizeof(ZResourceID), alignof(ZResourceID), ZResourceID::WriteSimpleJson, ZResourceID::FromSimpleJson, ZResourceID::Serialize, ZResourceID::Equals, ZResourceID::Destroy);

void ZResourceID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_uri") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uri);

	p_Stream << "}";
}

void ZResourceID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZResourceID s_Object {};

	s_Object.m_uri = std::string_view(p_Document["m_uri"]);

	*reinterpret_cast<ZResourceID*>(p_Target) = s_Object;
}

void ZResourceID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);

	ZString::Serialize(&s_Object->m_uri, p_Serializer, p_OwnOffset + offsetof(ZResourceID, m_uri));
}

bool ZResourceID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZResourceID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZResourceID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZResourceID::operator==(const ZResourceID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZResourceID>)
		return false;

	if (m_uri != p_Other.m_uri) return false;

	return true;
}

void ZResourceID::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZResourceID*>(p_Object);
	s_Object->~ZResourceID();
}

ZHMTypeInfo SAudioMemoryMonitorEntry::TypeInfo = ZHMTypeInfo("SAudioMemoryMonitorEntry", sizeof(SAudioMemoryMonitorEntry), alignof(SAudioMemoryMonitorEntry), SAudioMemoryMonitorEntry::WriteSimpleJson, SAudioMemoryMonitorEntry::FromSimpleJson, SAudioMemoryMonitorEntry::Serialize, SAudioMemoryMonitorEntry::Equals, SAudioMemoryMonitorEntry::Destroy);

void SAudioMemoryMonitorEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioMemoryMonitorEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("shortId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->shortId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("size") << ":";
	p_Stream << simdjson::as_json_string(s_Object->size);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("references") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->references.size(); ++i)
	{
		auto& s_Item0 = s_Object->references[i];
		ZResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->references.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAudioMemoryMonitorEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioMemoryMonitorEntry s_Object {};

	s_Object.shortId = simdjson::from_json_uint32(p_Document["shortId"]);

	s_Object.size = simdjson::from_json_uint32(p_Document["size"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["references"];
	s_Object.references.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZResourceID s_ArrayItem0;
		ZResourceID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.references[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SAudioMemoryMonitorEntry*>(p_Target) = s_Object;
}

void SAudioMemoryMonitorEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioMemoryMonitorEntry*>(p_Object);

	TArray<ZResourceID>::Serialize(&s_Object->references, p_Serializer, p_OwnOffset + offsetof(SAudioMemoryMonitorEntry, references));
}

bool SAudioMemoryMonitorEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioMemoryMonitorEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioMemoryMonitorEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioMemoryMonitorEntry::operator==(const SAudioMemoryMonitorEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioMemoryMonitorEntry>)
		return false;

	if (shortId != p_Other.shortId) return false;
	if (size != p_Other.size) return false;
	if (references != p_Other.references) return false;

	return true;
}

void SAudioMemoryMonitorEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioMemoryMonitorEntry*>(p_Object);
	s_Object->~SAudioMemoryMonitorEntry();
}

ZHMTypeInfo SAudioSaveData::TypeInfo = ZHMTypeInfo("SAudioSaveData", sizeof(SAudioSaveData), alignof(SAudioSaveData), SAudioSaveData::WriteSimpleJson, SAudioSaveData::FromSimpleJson, SAudioSaveData::Serialize, SAudioSaveData::Equals, SAudioSaveData::Destroy);

void SAudioSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEmitters") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitters.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitters[i];
		SAudioEmitterSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitters.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterEvents[i];
		SAudioEmitterEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterRTPCs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterRTPCs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterRTPCs[i];
		SAudioEmitterRTPCSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterRTPCs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEmitterSwitches") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEmitterSwitches.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEmitterSwitches[i];
		SAudioEmitterSwitchSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEmitterSwitches.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGlobalStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGlobalStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGlobalStates[i];
		SAudioEmitterStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGlobalStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGlobalRTPCs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGlobalRTPCs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGlobalRTPCs[i];
		SAudioEmitterRTPCSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGlobalRTPCs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEventsEnabledAfterInit") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEventsEnabledAfterInit.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEventsEnabledAfterInit[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEventsEnabledAfterInit.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SAudioSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAudioSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEmitters"];
	s_Object.m_aEmitters.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterSaveData s_ArrayItem0;
		SAudioEmitterSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEmitters[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEmitterEvents"];
	s_Object.m_aEmitterEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterEventSaveData s_ArrayItem0;
		SAudioEmitterEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEmitterEvents[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEmitterRTPCs"];
	s_Object.m_aEmitterRTPCs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterRTPCSaveData s_ArrayItem0;
		SAudioEmitterRTPCSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEmitterRTPCs[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEmitterSwitches"];
	s_Object.m_aEmitterSwitches.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterSwitchSaveData s_ArrayItem0;
		SAudioEmitterSwitchSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEmitterSwitches[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGlobalStates"];
	s_Object.m_aGlobalStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterStateSaveData s_ArrayItem0;
		SAudioEmitterStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGlobalStates[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGlobalRTPCs"];
	s_Object.m_aGlobalRTPCs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SAudioEmitterRTPCSaveData s_ArrayItem0;
		SAudioEmitterRTPCSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGlobalRTPCs[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEventsEnabledAfterInit"];
	s_Object.m_aEventsEnabledAfterInit.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEventsEnabledAfterInit[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SAudioSaveData*>(p_Target) = s_Object;
}

void SAudioSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);

	TArray<SAudioEmitterSaveData>::Serialize(&s_Object->m_aEmitters, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitters));
	TArray<SAudioEmitterEventSaveData>::Serialize(&s_Object->m_aEmitterEvents, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterEvents));
	TArray<SAudioEmitterRTPCSaveData>::Serialize(&s_Object->m_aEmitterRTPCs, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterRTPCs));
	TArray<SAudioEmitterSwitchSaveData>::Serialize(&s_Object->m_aEmitterSwitches, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEmitterSwitches));
	TArray<SAudioEmitterStateSaveData>::Serialize(&s_Object->m_aGlobalStates, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aGlobalStates));
	TArray<SAudioEmitterRTPCSaveData>::Serialize(&s_Object->m_aGlobalRTPCs, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aGlobalRTPCs));
	TArray<uint32>::Serialize(&s_Object->m_aEventsEnabledAfterInit, p_Serializer, p_OwnOffset + offsetof(SAudioSaveData, m_aEventsEnabledAfterInit));
}

bool SAudioSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAudioSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAudioSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAudioSaveData::operator==(const SAudioSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAudioSaveData>)
		return false;

	if (m_aEmitters != p_Other.m_aEmitters) return false;
	if (m_aEmitterEvents != p_Other.m_aEmitterEvents) return false;
	if (m_aEmitterRTPCs != p_Other.m_aEmitterRTPCs) return false;
	if (m_aEmitterSwitches != p_Other.m_aEmitterSwitches) return false;
	if (m_aGlobalStates != p_Other.m_aGlobalStates) return false;
	if (m_aGlobalRTPCs != p_Other.m_aGlobalRTPCs) return false;
	if (m_aEventsEnabledAfterInit != p_Other.m_aEventsEnabledAfterInit) return false;

	return true;
}

void SAudioSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAudioSaveData*>(p_Object);
	s_Object->~SAudioSaveData();
}

ZHMTypeInfo SFSMSaveData::TypeInfo = ZHMTypeInfo("SFSMSaveData", sizeof(SFSMSaveData), alignof(SFSMSaveData), SFSMSaveData::WriteSimpleJson, SFSMSaveData::FromSimpleJson, SFSMSaveData::Serialize, SFSMSaveData::Equals, SFSMSaveData::Destroy);

void SFSMSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eStateStatus") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EFSMStateStatus", static_cast<int>(s_Object->m_eStateStatus)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_state);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_prevState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_prevState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tCurrentStateEnterTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tCurrentStateEnterTime, p_Stream);

	p_Stream << "}";
}

void SFSMSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFSMSaveData s_Object {};

	s_Object.m_eStateStatus = static_cast<EFSMStateStatus>(ZHMEnums::GetEnumValueByName("EFSMStateStatus", std::string_view(p_Document["m_eStateStatus"])));

	s_Object.m_state = simdjson::from_json_int32(p_Document["m_state"]);

	s_Object.m_prevState = simdjson::from_json_int32(p_Document["m_prevState"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tCurrentStateEnterTime"], &s_Item);
		s_Object.m_tCurrentStateEnterTime = s_Item;
	}

	*reinterpret_cast<SFSMSaveData*>(p_Target) = s_Object;
}

void SFSMSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tCurrentStateEnterTime, p_Serializer, p_OwnOffset + offsetof(SFSMSaveData, m_tCurrentStateEnterTime));
}

bool SFSMSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFSMSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFSMSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFSMSaveData::operator==(const SFSMSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFSMSaveData>)
		return false;

	if (m_eStateStatus != p_Other.m_eStateStatus) return false;
	if (m_state != p_Other.m_state) return false;
	if (m_prevState != p_Other.m_prevState) return false;
	if (m_tCurrentStateEnterTime != p_Other.m_tCurrentStateEnterTime) return false;

	return true;
}

void SFSMSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFSMSaveData*>(p_Object);
	s_Object->~SFSMSaveData();
}

ZHMTypeInfo SAvoidDangerousAreaGroupSaveData::TypeInfo = ZHMTypeInfo("SAvoidDangerousAreaGroupSaveData", sizeof(SAvoidDangerousAreaGroupSaveData), alignof(SAvoidDangerousAreaGroupSaveData), SAvoidDangerousAreaGroupSaveData::WriteSimpleJson, SAvoidDangerousAreaGroupSaveData::FromSimpleJson, SAvoidDangerousAreaGroupSaveData::Serialize, SAvoidDangerousAreaGroupSaveData::Equals, SAvoidDangerousAreaGroupSaveData::Destroy);

void SAvoidDangerousAreaGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDangerousArea") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDangerousArea);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDestinationPoint") << ":";
	float4::WriteSimpleJson(&s_Object->m_vDestinationPoint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iGridId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iGridId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitUntilDangerEnds") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitUntilDangerEnds);

	p_Stream << "}";
}

void SAvoidDangerousAreaGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SAvoidDangerousAreaGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_rDangerousArea = simdjson::from_json_uint32(p_Document["m_rDangerousArea"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vDestinationPoint"], &s_Item);
		s_Object.m_vDestinationPoint = s_Item;
	}

	s_Object.m_iGridId = simdjson::from_json_int32(p_Document["m_iGridId"]);

	s_Object.m_bWaitUntilDangerEnds = simdjson::from_json_bool(p_Document["m_bWaitUntilDangerEnds"]);

	*reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Target) = s_Object;
}

void SAvoidDangerousAreaGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SAvoidDangerousAreaGroupSaveData, m_fsmState));
	float4::Serialize(&s_Object->m_vDestinationPoint, p_Serializer, p_OwnOffset + offsetof(SAvoidDangerousAreaGroupSaveData, m_vDestinationPoint));
}

bool SAvoidDangerousAreaGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SAvoidDangerousAreaGroupSaveData::operator==(const SAvoidDangerousAreaGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SAvoidDangerousAreaGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rDangerousArea != p_Other.m_rDangerousArea) return false;
	if (m_vDestinationPoint != p_Other.m_vDestinationPoint) return false;
	if (m_iGridId != p_Other.m_iGridId) return false;
	if (m_bWaitUntilDangerEnds != p_Other.m_bWaitUntilDangerEnds) return false;

	return true;
}

void SAvoidDangerousAreaGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SAvoidDangerousAreaGroupSaveData*>(p_Object);
	s_Object->~SAvoidDangerousAreaGroupSaveData();
}

ZHMTypeInfo SBehaviorTreeEntityReference::TypeInfo = ZHMTypeInfo("SBehaviorTreeEntityReference", sizeof(SBehaviorTreeEntityReference), alignof(SBehaviorTreeEntityReference), SBehaviorTreeEntityReference::WriteSimpleJson, SBehaviorTreeEntityReference::FromSimpleJson, SBehaviorTreeEntityReference::Serialize, SBehaviorTreeEntityReference::Equals, SBehaviorTreeEntityReference::Destroy);

void SBehaviorTreeEntityReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bList") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bList);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);

	p_Stream << "}";
}

void SBehaviorTreeEntityReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEntityReference s_Object {};

	s_Object.m_bList = simdjson::from_json_bool(p_Document["m_bList"]);

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	*reinterpret_cast<SBehaviorTreeEntityReference*>(p_Target) = s_Object;
}

void SBehaviorTreeEntityReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEntityReference, m_sName));
}

bool SBehaviorTreeEntityReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEntityReference::operator==(const SBehaviorTreeEntityReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEntityReference>)
		return false;

	if (m_bList != p_Other.m_bList) return false;
	if (m_sName != p_Other.m_sName) return false;

	return true;
}

void SBehaviorTreeEntityReference::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEntityReference*>(p_Object);
	s_Object->~SBehaviorTreeEntityReference();
}

ZHMTypeInfo SBehaviorTreeEvaluationLogEntry::TypeInfo = ZHMTypeInfo("SBehaviorTreeEvaluationLogEntry", sizeof(SBehaviorTreeEvaluationLogEntry), alignof(SBehaviorTreeEvaluationLogEntry), SBehaviorTreeEvaluationLogEntry::WriteSimpleJson, SBehaviorTreeEvaluationLogEntry::FromSimpleJson, SBehaviorTreeEvaluationLogEntry::Serialize, SBehaviorTreeEvaluationLogEntry::Equals, SBehaviorTreeEvaluationLogEntry::Destroy);

void SBehaviorTreeEvaluationLogEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nBehaviorTreeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBehaviorTreeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nConditionOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nConditionOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bResult") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bResult);

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLogEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEvaluationLogEntry s_Object {};

	s_Object.m_nBehaviorTreeIndex = simdjson::from_json_uint32(p_Document["m_nBehaviorTreeIndex"]);

	s_Object.m_nConditionOffset = simdjson::from_json_uint64(p_Document["m_nConditionOffset"]);

	s_Object.m_bResult = simdjson::from_json_bool(p_Document["m_bResult"]);

	*reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Target) = s_Object;
}

void SBehaviorTreeEvaluationLogEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);

}

bool SBehaviorTreeEvaluationLogEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEvaluationLogEntry::operator==(const SBehaviorTreeEvaluationLogEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEvaluationLogEntry>)
		return false;

	if (m_nBehaviorTreeIndex != p_Other.m_nBehaviorTreeIndex) return false;
	if (m_nConditionOffset != p_Other.m_nConditionOffset) return false;
	if (m_bResult != p_Other.m_bResult) return false;

	return true;
}

void SBehaviorTreeEvaluationLogEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLogEntry*>(p_Object);
	s_Object->~SBehaviorTreeEvaluationLogEntry();
}

ZHMTypeInfo SBehaviorTreeEvaluationLog::TypeInfo = ZHMTypeInfo("SBehaviorTreeEvaluationLog", sizeof(SBehaviorTreeEvaluationLog), alignof(SBehaviorTreeEvaluationLog), SBehaviorTreeEvaluationLog::WriteSimpleJson, SBehaviorTreeEvaluationLog::FromSimpleJson, SBehaviorTreeEvaluationLog::Serialize, SBehaviorTreeEvaluationLog::Equals, SBehaviorTreeEvaluationLog::Destroy);

void SBehaviorTreeEvaluationLog::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_BehaviorTrees") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_BehaviorTrees.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_BehaviorTrees[i];
		ZResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_BehaviorTrees.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Entries") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Entries.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Entries[i];
		SBehaviorTreeEvaluationLogEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_Entries.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBehaviorTreeEvaluationLog::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeEvaluationLog s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_BehaviorTrees"];
	s_Object.m_BehaviorTrees.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZResourceID s_ArrayItem0;
		ZResourceID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_BehaviorTrees[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_Entries"];
	s_Object.m_Entries.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeEvaluationLogEntry s_ArrayItem0;
		SBehaviorTreeEvaluationLogEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_Entries[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Target) = s_Object;
}

void SBehaviorTreeEvaluationLog::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);

	TArray<ZResourceID>::Serialize(&s_Object->m_BehaviorTrees, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEvaluationLog, m_BehaviorTrees));
	TArray<SBehaviorTreeEvaluationLogEntry>::Serialize(&s_Object->m_Entries, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeEvaluationLog, m_Entries));
}

bool SBehaviorTreeEvaluationLog::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeEvaluationLog::operator==(const SBehaviorTreeEvaluationLog& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeEvaluationLog>)
		return false;

	if (m_BehaviorTrees != p_Other.m_BehaviorTrees) return false;
	if (m_Entries != p_Other.m_Entries) return false;

	return true;
}

void SBehaviorTreeEvaluationLog::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeEvaluationLog*>(p_Object);
	s_Object->~SBehaviorTreeEvaluationLog();
}

ZHMTypeInfo SBehaviorTreeInputPinCondition::TypeInfo = ZHMTypeInfo("SBehaviorTreeInputPinCondition", sizeof(SBehaviorTreeInputPinCondition), alignof(SBehaviorTreeInputPinCondition), SBehaviorTreeInputPinCondition::WriteSimpleJson, SBehaviorTreeInputPinCondition::FromSimpleJson, SBehaviorTreeInputPinCondition::Serialize, SBehaviorTreeInputPinCondition::Equals, SBehaviorTreeInputPinCondition::Destroy);

void SBehaviorTreeInputPinCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);

	p_Stream << "}";
}

void SBehaviorTreeInputPinCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeInputPinCondition s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	*reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Target) = s_Object;
}

void SBehaviorTreeInputPinCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInputPinCondition, m_sName));
}

bool SBehaviorTreeInputPinCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeInputPinCondition::operator==(const SBehaviorTreeInputPinCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeInputPinCondition>)
		return false;

	if (m_sName != p_Other.m_sName) return false;

	return true;
}

void SBehaviorTreeInputPinCondition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInputPinCondition*>(p_Object);
	s_Object->~SBehaviorTreeInputPinCondition();
}

ZHMTypeInfo SBehaviorTreeInfo::TypeInfo = ZHMTypeInfo("SBehaviorTreeInfo", sizeof(SBehaviorTreeInfo), alignof(SBehaviorTreeInfo), SBehaviorTreeInfo::WriteSimpleJson, SBehaviorTreeInfo::FromSimpleJson, SBehaviorTreeInfo::Serialize, SBehaviorTreeInfo::Equals, SBehaviorTreeInfo::Destroy);

void SBehaviorTreeInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_references") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_references.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_references[i];
		SBehaviorTreeEntityReference::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_references.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_inputPinConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_inputPinConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_inputPinConditions[i];
		SBehaviorTreeInputPinCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_inputPinConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBehaviorTreeInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBehaviorTreeInfo s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_references"];
	s_Object.m_references.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeEntityReference s_ArrayItem0;
		SBehaviorTreeEntityReference::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_references[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_inputPinConditions"];
	s_Object.m_inputPinConditions.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBehaviorTreeInputPinCondition s_ArrayItem0;
		SBehaviorTreeInputPinCondition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_inputPinConditions[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SBehaviorTreeInfo*>(p_Target) = s_Object;
}

void SBehaviorTreeInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);

	TArray<SBehaviorTreeEntityReference>::Serialize(&s_Object->m_references, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInfo, m_references));
	TArray<SBehaviorTreeInputPinCondition>::Serialize(&s_Object->m_inputPinConditions, p_Serializer, p_OwnOffset + offsetof(SBehaviorTreeInfo, m_inputPinConditions));
}

bool SBehaviorTreeInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBehaviorTreeInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SBehaviorTreeInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBehaviorTreeInfo::operator==(const SBehaviorTreeInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBehaviorTreeInfo>)
		return false;

	if (m_references != p_Other.m_references) return false;
	if (m_inputPinConditions != p_Other.m_inputPinConditions) return false;

	return true;
}

void SBehaviorTreeInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBehaviorTreeInfo*>(p_Object);
	s_Object->~SBehaviorTreeInfo();
}

ZHMTypeInfo SBlobsConfigResourceEntry::TypeInfo = ZHMTypeInfo("SBlobsConfigResourceEntry", sizeof(SBlobsConfigResourceEntry), alignof(SBlobsConfigResourceEntry), SBlobsConfigResourceEntry::WriteSimpleJson, SBlobsConfigResourceEntry::FromSimpleJson, SBlobsConfigResourceEntry::Serialize, SBlobsConfigResourceEntry::Equals, SBlobsConfigResourceEntry::Destroy);

void SBlobsConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("BlobRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->BlobRid, p_Stream);

	p_Stream << "}";
}

void SBlobsConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBlobsConfigResourceEntry s_Object {};

	s_Object.Id = std::string_view(p_Document["Id"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["BlobRid"], &s_Item);
		s_Object.BlobRid = s_Item;
	}

	*reinterpret_cast<SBlobsConfigResourceEntry*>(p_Target) = s_Object;
}

void SBlobsConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Id, p_Serializer, p_OwnOffset + offsetof(SBlobsConfigResourceEntry, Id));
	ZRuntimeResourceID::Serialize(&s_Object->BlobRid, p_Serializer, p_OwnOffset + offsetof(SBlobsConfigResourceEntry, BlobRid));
}

bool SBlobsConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBlobsConfigResourceEntry::operator==(const SBlobsConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBlobsConfigResourceEntry>)
		return false;

	if (Id != p_Other.Id) return false;
	if (BlobRid != p_Other.BlobRid) return false;

	return true;
}

void SBlobsConfigResourceEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBlobsConfigResourceEntry*>(p_Object);
	s_Object->~SBlobsConfigResourceEntry();
}

ZHMTypeInfo SBodyContainerSaveData::TypeInfo = ZHMTypeInfo("SBodyContainerSaveData", sizeof(SBodyContainerSaveData), alignof(SBodyContainerSaveData), SBodyContainerSaveData::WriteSimpleJson, SBodyContainerSaveData::FromSimpleJson, SBodyContainerSaveData::Serialize, SBodyContainerSaveData::Equals, SBodyContainerSaveData::Destroy);

void SBodyContainerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eBCState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5BodyContainer.EBCState", static_cast<int>(s_Object->m_eBCState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLidAutoCloseTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLidAutoCloseTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLidOpenFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLidOpenFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrameUpdateActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrameUpdateActive);

	p_Stream << "}";
}

void SBodyContainerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodyContainerSaveData s_Object {};

	s_Object.m_eBCState = static_cast<ZHM5BodyContainer_EBCState>(ZHMEnums::GetEnumValueByName("ZHM5BodyContainer.EBCState", std::string_view(p_Document["m_eBCState"])));

	s_Object.m_fLidAutoCloseTime = simdjson::from_json_float32(p_Document["m_fLidAutoCloseTime"]);

	s_Object.m_fLidOpenFraction = simdjson::from_json_float32(p_Document["m_fLidOpenFraction"]);

	s_Object.m_bFrameUpdateActive = simdjson::from_json_bool(p_Document["m_bFrameUpdateActive"]);

	*reinterpret_cast<SBodyContainerSaveData*>(p_Target) = s_Object;
}

void SBodyContainerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);

}

bool SBodyContainerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyContainerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyContainerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyContainerSaveData::operator==(const SBodyContainerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyContainerSaveData>)
		return false;

	if (m_eBCState != p_Other.m_eBCState) return false;
	if (m_fLidAutoCloseTime != p_Other.m_fLidAutoCloseTime) return false;
	if (m_fLidOpenFraction != p_Other.m_fLidOpenFraction) return false;
	if (m_bFrameUpdateActive != p_Other.m_bFrameUpdateActive) return false;

	return true;
}

void SBodyContainerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodyContainerSaveData*>(p_Object);
	s_Object->~SBodyContainerSaveData();
}

ZHMTypeInfo SBodyContainersSaveData::TypeInfo = ZHMTypeInfo("SBodyContainersSaveData", sizeof(SBodyContainersSaveData), alignof(SBodyContainersSaveData), SBodyContainersSaveData::WriteSimpleJson, SBodyContainersSaveData::FromSimpleJson, SBodyContainersSaveData::Serialize, SBodyContainersSaveData::Equals, SBodyContainersSaveData::Destroy);

void SBodyContainersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SBodyContainerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBodyContainersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodyContainersSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBodyContainerSaveData s_ArrayItem0;
		SBodyContainerSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SBodyContainersSaveData*>(p_Target) = s_Object;
}

void SBodyContainersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SBodyContainersSaveData, m_aEntities));
	TArray<SBodyContainerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SBodyContainersSaveData, m_aData));
}

bool SBodyContainersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyContainersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyContainersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyContainersSaveData::operator==(const SBodyContainersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyContainersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SBodyContainersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodyContainersSaveData*>(p_Object);
	s_Object->~SBodyContainersSaveData();
}

ZHMTypeInfo SBodyPartDamageMultipliers::TypeInfo = ZHMTypeInfo("SBodyPartDamageMultipliers", sizeof(SBodyPartDamageMultipliers), alignof(SBodyPartDamageMultipliers), SBodyPartDamageMultipliers::WriteSimpleJson, SBodyPartDamageMultipliers::FromSimpleJson, SBodyPartDamageMultipliers::Serialize, SBodyPartDamageMultipliers::Equals, SBodyPartDamageMultipliers::Destroy);

void SBodyPartDamageMultipliers::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fHeadDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeadDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fArmDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fArmDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLArmDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLArmDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRArmDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRArmDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHandDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHandDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLHandDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLHandDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRHandDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRHandDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLegDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLegDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLLegDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLLegDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRLegDamageScalar") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRLegDamageScalar);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTorsoDamageMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTorsoDamageMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bApplyLeftRightScalars") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bApplyLeftRightScalars);

	p_Stream << "}";
}

void SBodyPartDamageMultipliers::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodyPartDamageMultipliers s_Object {};

	s_Object.m_fHeadDamageMultiplier = simdjson::from_json_float32(p_Document["m_fHeadDamageMultiplier"]);

	s_Object.m_fFaceDamageMultiplier = simdjson::from_json_float32(p_Document["m_fFaceDamageMultiplier"]);

	s_Object.m_fArmDamageMultiplier = simdjson::from_json_float32(p_Document["m_fArmDamageMultiplier"]);

	s_Object.m_fLArmDamageScalar = simdjson::from_json_float32(p_Document["m_fLArmDamageScalar"]);

	s_Object.m_fRArmDamageScalar = simdjson::from_json_float32(p_Document["m_fRArmDamageScalar"]);

	s_Object.m_fHandDamageMultiplier = simdjson::from_json_float32(p_Document["m_fHandDamageMultiplier"]);

	s_Object.m_fLHandDamageScalar = simdjson::from_json_float32(p_Document["m_fLHandDamageScalar"]);

	s_Object.m_fRHandDamageScalar = simdjson::from_json_float32(p_Document["m_fRHandDamageScalar"]);

	s_Object.m_fLegDamageMultiplier = simdjson::from_json_float32(p_Document["m_fLegDamageMultiplier"]);

	s_Object.m_fLLegDamageScalar = simdjson::from_json_float32(p_Document["m_fLLegDamageScalar"]);

	s_Object.m_fRLegDamageScalar = simdjson::from_json_float32(p_Document["m_fRLegDamageScalar"]);

	s_Object.m_fTorsoDamageMultiplier = simdjson::from_json_float32(p_Document["m_fTorsoDamageMultiplier"]);

	s_Object.m_bApplyLeftRightScalars = simdjson::from_json_bool(p_Document["m_bApplyLeftRightScalars"]);

	*reinterpret_cast<SBodyPartDamageMultipliers*>(p_Target) = s_Object;
}

void SBodyPartDamageMultipliers::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);

}

bool SBodyPartDamageMultipliers::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodyPartDamageMultipliers::operator==(const SBodyPartDamageMultipliers& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodyPartDamageMultipliers>)
		return false;

	if (m_fHeadDamageMultiplier != p_Other.m_fHeadDamageMultiplier) return false;
	if (m_fFaceDamageMultiplier != p_Other.m_fFaceDamageMultiplier) return false;
	if (m_fArmDamageMultiplier != p_Other.m_fArmDamageMultiplier) return false;
	if (m_fLArmDamageScalar != p_Other.m_fLArmDamageScalar) return false;
	if (m_fRArmDamageScalar != p_Other.m_fRArmDamageScalar) return false;
	if (m_fHandDamageMultiplier != p_Other.m_fHandDamageMultiplier) return false;
	if (m_fLHandDamageScalar != p_Other.m_fLHandDamageScalar) return false;
	if (m_fRHandDamageScalar != p_Other.m_fRHandDamageScalar) return false;
	if (m_fLegDamageMultiplier != p_Other.m_fLegDamageMultiplier) return false;
	if (m_fLLegDamageScalar != p_Other.m_fLLegDamageScalar) return false;
	if (m_fRLegDamageScalar != p_Other.m_fRLegDamageScalar) return false;
	if (m_fTorsoDamageMultiplier != p_Other.m_fTorsoDamageMultiplier) return false;
	if (m_bApplyLeftRightScalars != p_Other.m_bApplyLeftRightScalars) return false;

	return true;
}

void SBodyPartDamageMultipliers::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodyPartDamageMultipliers*>(p_Object);
	s_Object->~SBodyPartDamageMultipliers();
}

ZHMTypeInfo SBodybagBoneSaveData::TypeInfo = ZHMTypeInfo("SBodybagBoneSaveData", sizeof(SBodybagBoneSaveData), alignof(SBodybagBoneSaveData), SBodybagBoneSaveData::WriteSimpleJson, SBodybagBoneSaveData::FromSimpleJson, SBodybagBoneSaveData::Serialize, SBodybagBoneSaveData::Equals, SBodybagBoneSaveData::Destroy);

void SBodybagBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SBodybagBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodybagBoneSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Item);
		s_Object.mQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Item);
		s_Object.mTranslation = s_Item;
	}

	*reinterpret_cast<SBodybagBoneSaveData*>(p_Target) = s_Object;
}

void SBodybagBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SBodybagBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SBodybagBoneSaveData, mTranslation));
}

bool SBodybagBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodybagBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodybagBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodybagBoneSaveData::operator==(const SBodybagBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodybagBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

void SBodybagBoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodybagBoneSaveData*>(p_Object);
	s_Object->~SBodybagBoneSaveData();
}

ZHMTypeInfo SBodybagSaveData::TypeInfo = ZHMTypeInfo("SBodybagSaveData", sizeof(SBodybagSaveData), alignof(SBodybagSaveData), SBodybagSaveData::WriteSimpleJson, SBodybagSaveData::FromSimpleJson, SBodybagSaveData::Serialize, SBodybagSaveData::Equals, SBodybagSaveData::Destroy);

void SBodybagSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vLinkedPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLinkedPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLinkedQuaternionRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vLinkedQuaternionRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SBodybagBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBoneIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDeadActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDeadActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IsInMorgue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IsInMorgue);

	p_Stream << "}";
}

void SBodybagSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBodybagSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLinkedPosition"], &s_Item);
		s_Object.m_vLinkedPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vLinkedQuaternionRotation"], &s_Item);
		s_Object.m_vLinkedQuaternionRotation = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBones"];
	s_Object.m_aBones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBodybagBoneSaveData s_ArrayItem0;
		SBodybagBoneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBones[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneIndices"];
	s_Object.m_aBoneIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aBoneIndices[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_rDeadActor = simdjson::from_json_uint32(p_Document["m_rDeadActor"]);

	s_Object.m_IsInMorgue = simdjson::from_json_bool(p_Document["m_IsInMorgue"]);

	*reinterpret_cast<SBodybagSaveData*>(p_Target) = s_Object;
}

void SBodybagSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLinkedPosition, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_vLinkedPosition));
	SVector4::Serialize(&s_Object->m_vLinkedQuaternionRotation, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_vLinkedQuaternionRotation));
	TArray<SBodybagBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_aBones));
	TArray<uint32>::Serialize(&s_Object->m_aBoneIndices, p_Serializer, p_OwnOffset + offsetof(SBodybagSaveData, m_aBoneIndices));
}

bool SBodybagSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBodybagSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBodybagSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBodybagSaveData::operator==(const SBodybagSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBodybagSaveData>)
		return false;

	if (m_vLinkedPosition != p_Other.m_vLinkedPosition) return false;
	if (m_vLinkedQuaternionRotation != p_Other.m_vLinkedQuaternionRotation) return false;
	if (m_aBones != p_Other.m_aBones) return false;
	if (m_aBoneIndices != p_Other.m_aBoneIndices) return false;
	if (m_rDeadActor != p_Other.m_rDeadActor) return false;
	if (m_IsInMorgue != p_Other.m_IsInMorgue) return false;

	return true;
}

void SBodybagSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBodybagSaveData*>(p_Object);
	s_Object->~SBodybagSaveData();
}

ZHMTypeInfo SBoneAttachSaveData::TypeInfo = ZHMTypeInfo("SBoneAttachSaveData", sizeof(SBoneAttachSaveData), alignof(SBoneAttachSaveData), SBoneAttachSaveData::WriteSimpleJson, SBoneAttachSaveData::FromSimpleJson, SBoneAttachSaveData::Serialize, SBoneAttachSaveData::Equals, SBoneAttachSaveData::Destroy);

void SBoneAttachSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAttached);

	p_Stream << "}";
}

void SBoneAttachSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBoneAttachSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_bIsAttached = simdjson::from_json_bool(p_Document["m_bIsAttached"]);

	*reinterpret_cast<SBoneAttachSaveData*>(p_Target) = s_Object;
}

void SBoneAttachSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);

}

bool SBoneAttachSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneAttachSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneAttachSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneAttachSaveData::operator==(const SBoneAttachSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneAttachSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsAttached != p_Other.m_bIsAttached) return false;

	return true;
}

void SBoneAttachSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBoneAttachSaveData*>(p_Object);
	s_Object->~SBoneAttachSaveData();
}

ZHMTypeInfo SBoneScalesList::TypeInfo = ZHMTypeInfo("SBoneScalesList", sizeof(SBoneScalesList), alignof(SBoneScalesList), SBoneScalesList::WriteSimpleJson, SBoneScalesList::FromSimpleJson, SBoneScalesList::Serialize, SBoneScalesList::Equals, SBoneScalesList::Destroy);

void SBoneScalesList::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBoneScales") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneScales.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneScales[i];
		SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBoneScales.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SBoneScalesList::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SBoneScalesList s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneScales"];
	s_Object.m_aBoneScales.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVector3 s_ArrayItem0;
		SVector3::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBoneScales[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SBoneScalesList*>(p_Target) = s_Object;
}

void SBoneScalesList::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);

	TArray<SVector3>::Serialize(&s_Object->m_aBoneScales, p_Serializer, p_OwnOffset + offsetof(SBoneScalesList, m_aBoneScales));
}

bool SBoneScalesList::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SBoneScalesList*>(p_Left);
	auto* s_Right = reinterpret_cast<SBoneScalesList*>(p_Right);

	return *s_Left == *s_Right;
}

bool SBoneScalesList::operator==(const SBoneScalesList& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SBoneScalesList>)
		return false;

	if (m_aBoneScales != p_Other.m_aBoneScales) return false;

	return true;
}

void SBoneScalesList::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SBoneScalesList*>(p_Object);
	s_Object->~SBoneScalesList();
}

ZHMTypeInfo SCCEffectSet::TypeInfo = ZHMTypeInfo("SCCEffectSet", sizeof(SCCEffectSet), alignof(SCCEffectSet), SCCEffectSet::WriteSimpleJson, SCCEffectSet::FromSimpleJson, SCCEffectSet::Serialize, SCCEffectSet::Equals, SCCEffectSet::Destroy);

void SCCEffectSet::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCCEffectSet*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eDecalEffect") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECCDecalEffect", static_cast<int>(s_Object->m_eDecalEffect)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEmitterEffect") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECCEmitterEffect", static_cast<int>(s_Object->m_eEmitterEffect)));

	p_Stream << "}";
}

void SCCEffectSet::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCCEffectSet s_Object {};

	s_Object.m_eDecalEffect = static_cast<ECCDecalEffect>(ZHMEnums::GetEnumValueByName("ECCDecalEffect", std::string_view(p_Document["m_eDecalEffect"])));

	s_Object.m_eEmitterEffect = static_cast<ECCEmitterEffect>(ZHMEnums::GetEnumValueByName("ECCEmitterEffect", std::string_view(p_Document["m_eEmitterEffect"])));

	*reinterpret_cast<SCCEffectSet*>(p_Target) = s_Object;
}

void SCCEffectSet::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCCEffectSet*>(p_Object);

}

bool SCCEffectSet::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCCEffectSet*>(p_Left);
	auto* s_Right = reinterpret_cast<SCCEffectSet*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCCEffectSet::operator==(const SCCEffectSet& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCCEffectSet>)
		return false;

	if (m_eDecalEffect != p_Other.m_eDecalEffect) return false;
	if (m_eEmitterEffect != p_Other.m_eEmitterEffect) return false;

	return true;
}

void SCCEffectSet::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCCEffectSet*>(p_Object);
	s_Object->~SCCEffectSet();
}

ZHMTypeInfo SCamBone::TypeInfo = ZHMTypeInfo("SCamBone", sizeof(SCamBone), alignof(SCamBone), SCamBone::WriteSimpleJson, SCamBone::FromSimpleJson, SCamBone::Serialize, SCamBone::Equals, SCamBone::Destroy);

void SCamBone::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eBoneId") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("BoneId.Enum", static_cast<int>(s_Object->m_eBoneId)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWeight);

	p_Stream << "}";
}

void SCamBone::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCamBone s_Object {};

	s_Object.m_eBoneId = static_cast<BoneId_Enum>(ZHMEnums::GetEnumValueByName("BoneId.Enum", std::string_view(p_Document["m_eBoneId"])));

	s_Object.m_fWeight = simdjson::from_json_float32(p_Document["m_fWeight"]);

	*reinterpret_cast<SCamBone*>(p_Target) = s_Object;
}

void SCamBone::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);

}

bool SCamBone::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCamBone*>(p_Left);
	auto* s_Right = reinterpret_cast<SCamBone*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCamBone::operator==(const SCamBone& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCamBone>)
		return false;

	if (m_eBoneId != p_Other.m_eBoneId) return false;
	if (m_fWeight != p_Other.m_fWeight) return false;

	return true;
}

void SCamBone::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCamBone*>(p_Object);
	s_Object->~SCamBone();
}

ZHMTypeInfo SCautiousBackupGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousBackupGroupSaveData", sizeof(SCautiousBackupGroupSaveData), alignof(SCautiousBackupGroupSaveData), SCautiousBackupGroupSaveData::WriteSimpleJson, SCautiousBackupGroupSaveData::FromSimpleJson, SCautiousBackupGroupSaveData::Serialize, SCautiousBackupGroupSaveData::Equals, SCautiousBackupGroupSaveData::Destroy);

void SCautiousBackupGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eGroupState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousBackupGroup.EGroupState", static_cast<int>(s_Object->m_eGroupState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aReservedApproachNodeIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aReservedApproachNodeIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aReservedApproachNodeIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aReservedApproachNodeIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);

	p_Stream << "}";
}

void SCautiousBackupGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousBackupGroupSaveData s_Object {};

	s_Object.m_eGroupState = static_cast<ZCautiousBackupGroup_EGroupState>(ZHMEnums::GetEnumValueByName("ZCautiousBackupGroup.EGroupState", std::string_view(p_Document["m_eGroupState"])));

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_nTargetNodeIndex = simdjson::from_json_uint16(p_Document["m_nTargetNodeIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCandidates"];
	s_Object.m_aCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aCandidates[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_pCandidate = simdjson::from_json_uint32(p_Document["m_pCandidate"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aReservedApproachNodeIndices"];
	s_Object.m_aReservedApproachNodeIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aReservedApproachNodeIndices[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Item);
		s_Object.m_tStart = s_Item;
	}

	*reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Target) = s_Object;
}

void SCautiousBackupGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_aCandidates));
	TArray<uint16>::Serialize(&s_Object->m_aReservedApproachNodeIndices, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_aReservedApproachNodeIndices));
	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SCautiousBackupGroupSaveData, m_tStart));
}

bool SCautiousBackupGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousBackupGroupSaveData::operator==(const SCautiousBackupGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousBackupGroupSaveData>)
		return false;

	if (m_eGroupState != p_Other.m_eGroupState) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_nTargetNodeIndex != p_Other.m_nTargetNodeIndex) return false;
	if (m_aCandidates != p_Other.m_aCandidates) return false;
	if (m_pCandidate != p_Other.m_pCandidate) return false;
	if (m_aReservedApproachNodeIndices != p_Other.m_aReservedApproachNodeIndices) return false;
	if (m_tStart != p_Other.m_tStart) return false;

	return true;
}

void SCautiousBackupGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousBackupGroupSaveData*>(p_Object);
	s_Object->~SCautiousBackupGroupSaveData();
}

ZHMTypeInfo SCautiousHuntSaveData::TypeInfo = ZHMTypeInfo("SCautiousHuntSaveData", sizeof(SCautiousHuntSaveData), alignof(SCautiousHuntSaveData), SCautiousHuntSaveData::WriteSimpleJson, SCautiousHuntSaveData::FromSimpleJson, SCautiousHuntSaveData::Serialize, SCautiousHuntSaveData::Equals, SCautiousHuntSaveData::Destroy);

void SCautiousHuntSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAnnounceHuntCoolDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAnnounceHuntCoolDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tAnnouncedHunt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tAnnouncedHunt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tShareHuntTargetCoolDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tShareHuntTargetCoolDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnounceHunt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnounceHunt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnouncedHunt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnouncedHunt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlayAnnouncementDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlayAnnouncementDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHuntTargetKnownKiller") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHuntTargetKnownKiller);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSharedHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSharedHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetBlamed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetBlamed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRuleActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRuleActive);

	p_Stream << "}";
}

void SCautiousHuntSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousHuntSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tAnnounceHuntCoolDown"], &s_Item);
		s_Object.m_tAnnounceHuntCoolDown = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tAnnouncedHunt"], &s_Item);
		s_Object.m_tAnnouncedHunt = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tShareHuntTargetCoolDown"], &s_Item);
		s_Object.m_tShareHuntTargetCoolDown = s_Item;
	}

	s_Object.m_bAnnounceHunt = simdjson::from_json_bool(p_Document["m_bAnnounceHunt"]);

	s_Object.m_bAnnouncedHunt = simdjson::from_json_bool(p_Document["m_bAnnouncedHunt"]);

	s_Object.m_bPlayAnnouncementDialog = simdjson::from_json_bool(p_Document["m_bPlayAnnouncementDialog"]);

	s_Object.m_bHuntTargetKnownKiller = simdjson::from_json_bool(p_Document["m_bHuntTargetKnownKiller"]);

	s_Object.m_bSharedHuntTarget = simdjson::from_json_bool(p_Document["m_bSharedHuntTarget"]);

	s_Object.m_bTargetBlamed = simdjson::from_json_bool(p_Document["m_bTargetBlamed"]);

	s_Object.m_bRuleActive = simdjson::from_json_bool(p_Document["m_bRuleActive"]);

	*reinterpret_cast<SCautiousHuntSaveData*>(p_Target) = s_Object;
}

void SCautiousHuntSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tAnnounceHuntCoolDown, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tAnnounceHuntCoolDown));
	ZGameTime::Serialize(&s_Object->m_tAnnouncedHunt, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tAnnouncedHunt));
	ZGameTime::Serialize(&s_Object->m_tShareHuntTargetCoolDown, p_Serializer, p_OwnOffset + offsetof(SCautiousHuntSaveData, m_tShareHuntTargetCoolDown));
}

bool SCautiousHuntSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousHuntSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousHuntSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousHuntSaveData::operator==(const SCautiousHuntSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousHuntSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tAnnounceHuntCoolDown != p_Other.m_tAnnounceHuntCoolDown) return false;
	if (m_tAnnouncedHunt != p_Other.m_tAnnouncedHunt) return false;
	if (m_tShareHuntTargetCoolDown != p_Other.m_tShareHuntTargetCoolDown) return false;
	if (m_bAnnounceHunt != p_Other.m_bAnnounceHunt) return false;
	if (m_bAnnouncedHunt != p_Other.m_bAnnouncedHunt) return false;
	if (m_bPlayAnnouncementDialog != p_Other.m_bPlayAnnouncementDialog) return false;
	if (m_bHuntTargetKnownKiller != p_Other.m_bHuntTargetKnownKiller) return false;
	if (m_bSharedHuntTarget != p_Other.m_bSharedHuntTarget) return false;
	if (m_bTargetBlamed != p_Other.m_bTargetBlamed) return false;
	if (m_bRuleActive != p_Other.m_bRuleActive) return false;

	return true;
}

void SCautiousHuntSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousHuntSaveData*>(p_Object);
	s_Object->~SCautiousHuntSaveData();
}

ZHMTypeInfo SExactCompressedGridFloatField::TypeInfo = ZHMTypeInfo("SExactCompressedGridFloatField", sizeof(SExactCompressedGridFloatField), alignof(SExactCompressedGridFloatField), SExactCompressedGridFloatField::WriteSimpleJson, SExactCompressedGridFloatField::FromSimpleJson, SExactCompressedGridFloatField::Serialize, SExactCompressedGridFloatField::Equals, SExactCompressedGridFloatField::Destroy);

void SExactCompressedGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFieldSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFieldSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCRC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCRC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SExactCompressedGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExactCompressedGridFloatField s_Object {};

	s_Object.m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	s_Object.m_nFieldSize = simdjson::from_json_uint32(p_Document["m_nFieldSize"]);

	s_Object.m_nGridCRC = simdjson::from_json_uint32(p_Document["m_nGridCRC"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIndices"];
	s_Object.m_aIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aIndices[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aValues"];
	s_Object.m_aValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aValues[s_Index0++] = simdjson::from_json_float32(s_Item0);
	}
	}

	*reinterpret_cast<SExactCompressedGridFloatField*>(p_Target) = s_Object;
}

void SExactCompressedGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_aIndices, p_Serializer, p_OwnOffset + offsetof(SExactCompressedGridFloatField, m_aIndices));
	TArray<float32>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SExactCompressedGridFloatField, m_aValues));
}

bool SExactCompressedGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExactCompressedGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<SExactCompressedGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExactCompressedGridFloatField::operator==(const SExactCompressedGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExactCompressedGridFloatField>)
		return false;

	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_nFieldSize != p_Other.m_nFieldSize) return false;
	if (m_nGridCRC != p_Other.m_nGridCRC) return false;
	if (m_aIndices != p_Other.m_aIndices) return false;
	if (m_aValues != p_Other.m_aValues) return false;

	return true;
}

void SExactCompressedGridFloatField::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExactCompressedGridFloatField*>(p_Object);
	s_Object->~SExactCompressedGridFloatField();
}

ZHMTypeInfo SCautiousInvestigateGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousInvestigateGroupSaveData", sizeof(SCautiousInvestigateGroupSaveData), alignof(SCautiousInvestigateGroupSaveData), SCautiousInvestigateGroupSaveData::WriteSimpleJson, SCautiousInvestigateGroupSaveData::FromSimpleJson, SCautiousInvestigateGroupSaveData::Serialize, SCautiousInvestigateGroupSaveData::Equals, SCautiousInvestigateGroupSaveData::Destroy);

void SCautiousInvestigateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tGroupStarted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGroupStarted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLeaderApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLeaderApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAssistantApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAssistantApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eApproachOrderState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousInvestigateGroup.EApproachOrderState", static_cast<int>(s_Object->m_eApproachOrderState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmAssistantState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmAssistantState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUsingRecurringDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUsingRecurringDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStartedInvestigateDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedInvestigateDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDelayInvestigateDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDelayInvestigateDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReservedOccupancy") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReservedOccupancy);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSilentInvestigation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSilentInvestigation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInvestigateDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInvestigateDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMultipleBodies") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMultipleBodies);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCheckSuspects") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCheckSuspects);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_investigateArea") << ":";
	float4::WriteSimpleJson(&s_Object->m_investigateArea, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetDistanceField") << ":";
	SExactCompressedGridFloatField::WriteSimpleJson(&s_Object->m_targetDistanceField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_targetLOSField") << ":";
	SExactCompressedGridFloatField::WriteSimpleJson(&s_Object->m_targetLOSField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidTargetDistanceField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidTargetDistanceField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidTargetLOSField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidTargetLOSField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceAcknowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceAcknowledge);

	p_Stream << "}";
}

void SCautiousInvestigateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousInvestigateGroupSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tGroupStarted"], &s_Item);
		s_Object.m_tGroupStarted = s_Item;
	}

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object.m_nLeaderApproachNode = simdjson::from_json_int32(p_Document["m_nLeaderApproachNode"]);

	s_Object.m_nAssistantApproachNode = simdjson::from_json_int32(p_Document["m_nAssistantApproachNode"]);

	s_Object.m_eApproachOrderState = static_cast<ZCautiousInvestigateGroup_EApproachOrderState>(ZHMEnums::GetEnumValueByName("ZCautiousInvestigateGroup.EApproachOrderState", std::string_view(p_Document["m_eApproachOrderState"])));

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmAssistantState"], &s_Item);
		s_Object.m_fsmAssistantState = s_Item;
	}

	s_Object.m_bUsingRecurringDialog = simdjson::from_json_bool(p_Document["m_bUsingRecurringDialog"]);

	s_Object.m_bStartedInvestigateDialog = simdjson::from_json_bool(p_Document["m_bStartedInvestigateDialog"]);

	s_Object.m_bDelayInvestigateDialog = simdjson::from_json_bool(p_Document["m_bDelayInvestigateDialog"]);

	s_Object.m_bReservedOccupancy = simdjson::from_json_bool(p_Document["m_bReservedOccupancy"]);

	s_Object.m_bSilentInvestigation = simdjson::from_json_bool(p_Document["m_bSilentInvestigation"]);

	s_Object.m_bInvestigateDeadBody = simdjson::from_json_bool(p_Document["m_bInvestigateDeadBody"]);

	s_Object.m_bMultipleBodies = simdjson::from_json_bool(p_Document["m_bMultipleBodies"]);

	s_Object.m_bCheckSuspects = simdjson::from_json_bool(p_Document["m_bCheckSuspects"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_investigateArea"], &s_Item);
		s_Object.m_investigateArea = s_Item;
	}

	{
		SExactCompressedGridFloatField s_Item {};
		SExactCompressedGridFloatField::FromSimpleJson(p_Document["m_targetDistanceField"], &s_Item);
		s_Object.m_targetDistanceField = s_Item;
	}

	{
		SExactCompressedGridFloatField s_Item {};
		SExactCompressedGridFloatField::FromSimpleJson(p_Document["m_targetLOSField"], &s_Item);
		s_Object.m_targetLOSField = s_Item;
	}

	s_Object.m_bValidTargetDistanceField = simdjson::from_json_bool(p_Document["m_bValidTargetDistanceField"]);

	s_Object.m_bValidTargetLOSField = simdjson::from_json_bool(p_Document["m_bValidTargetLOSField"]);

	s_Object.m_bForceAcknowledge = simdjson::from_json_bool(p_Document["m_bForceAcknowledge"]);

	*reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Target) = s_Object;
}

void SCautiousInvestigateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGroupStarted, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_tGroupStarted));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_fsmState));
	SFSMSaveData::Serialize(&s_Object->m_fsmAssistantState, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_fsmAssistantState));
	float4::Serialize(&s_Object->m_investigateArea, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_investigateArea));
	SExactCompressedGridFloatField::Serialize(&s_Object->m_targetDistanceField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_targetDistanceField));
	SExactCompressedGridFloatField::Serialize(&s_Object->m_targetLOSField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateGroupSaveData, m_targetLOSField));
}

bool SCautiousInvestigateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousInvestigateGroupSaveData::operator==(const SCautiousInvestigateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousInvestigateGroupSaveData>)
		return false;

	if (m_tGroupStarted != p_Other.m_tGroupStarted) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_nLeaderApproachNode != p_Other.m_nLeaderApproachNode) return false;
	if (m_nAssistantApproachNode != p_Other.m_nAssistantApproachNode) return false;
	if (m_eApproachOrderState != p_Other.m_eApproachOrderState) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_fsmAssistantState != p_Other.m_fsmAssistantState) return false;
	if (m_bUsingRecurringDialog != p_Other.m_bUsingRecurringDialog) return false;
	if (m_bStartedInvestigateDialog != p_Other.m_bStartedInvestigateDialog) return false;
	if (m_bDelayInvestigateDialog != p_Other.m_bDelayInvestigateDialog) return false;
	if (m_bReservedOccupancy != p_Other.m_bReservedOccupancy) return false;
	if (m_bSilentInvestigation != p_Other.m_bSilentInvestigation) return false;
	if (m_bInvestigateDeadBody != p_Other.m_bInvestigateDeadBody) return false;
	if (m_bMultipleBodies != p_Other.m_bMultipleBodies) return false;
	if (m_bCheckSuspects != p_Other.m_bCheckSuspects) return false;
	if (m_investigateArea != p_Other.m_investigateArea) return false;
	if (m_targetDistanceField != p_Other.m_targetDistanceField) return false;
	if (m_targetLOSField != p_Other.m_targetLOSField) return false;
	if (m_bValidTargetDistanceField != p_Other.m_bValidTargetDistanceField) return false;
	if (m_bValidTargetLOSField != p_Other.m_bValidTargetLOSField) return false;
	if (m_bForceAcknowledge != p_Other.m_bForceAcknowledge) return false;

	return true;
}

void SCautiousInvestigateGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateGroupSaveData*>(p_Object);
	s_Object->~SCautiousInvestigateGroupSaveData();
}

ZHMTypeInfo SCompressedGridFloatField::TypeInfo = ZHMTypeInfo("SCompressedGridFloatField", sizeof(SCompressedGridFloatField), alignof(SCompressedGridFloatField), SCompressedGridFloatField::WriteSimpleJson, SCompressedGridFloatField::FromSimpleJson, SCompressedGridFloatField::Serialize, SCompressedGridFloatField::Equals, SCompressedGridFloatField::Destroy);

void SCompressedGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsSparse") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSparse);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFieldSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFieldSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCRC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCRC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCompressedGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCompressedGridFloatField s_Object {};

	s_Object.m_bIsSparse = simdjson::from_json_bool(p_Document["m_bIsSparse"]);

	s_Object.m_nFieldSize = simdjson::from_json_uint32(p_Document["m_nFieldSize"]);

	s_Object.m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	s_Object.m_nGridCRC = simdjson::from_json_uint32(p_Document["m_nGridCRC"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIndices"];
	s_Object.m_aIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aIndices[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aValues"];
	s_Object.m_aValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aValues[s_Index0++] = simdjson::from_json_uint8(s_Item0);
	}
	}

	*reinterpret_cast<SCompressedGridFloatField*>(p_Target) = s_Object;
}

void SCompressedGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_aIndices, p_Serializer, p_OwnOffset + offsetof(SCompressedGridFloatField, m_aIndices));
	TArray<uint8>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SCompressedGridFloatField, m_aValues));
}

bool SCompressedGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCompressedGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<SCompressedGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCompressedGridFloatField::operator==(const SCompressedGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCompressedGridFloatField>)
		return false;

	if (m_bIsSparse != p_Other.m_bIsSparse) return false;
	if (m_nFieldSize != p_Other.m_nFieldSize) return false;
	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_nGridCRC != p_Other.m_nGridCRC) return false;
	if (m_aIndices != p_Other.m_aIndices) return false;
	if (m_aValues != p_Other.m_aValues) return false;

	return true;
}

void SCompressedGridFloatField::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCompressedGridFloatField*>(p_Object);
	s_Object->~SCompressedGridFloatField();
}

ZHMTypeInfo SDisturbanceSaveData::TypeInfo = ZHMTypeInfo("SDisturbanceSaveData", sizeof(SDisturbanceSaveData), alignof(SDisturbanceSaveData), SDisturbanceSaveData::WriteSimpleJson, SDisturbanceSaveData::FromSimpleJson, SDisturbanceSaveData::Serialize, SDisturbanceSaveData::Equals, SDisturbanceSaveData::Destroy);

void SDisturbanceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_object") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_object);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECautiousDisturbanceState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_started") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_started, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockOnHitmanPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockOnHitmanPosition);

	p_Stream << "}";
}

void SDisturbanceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDisturbanceSaveData s_Object {};

	s_Object.m_object = simdjson::from_json_int32(p_Document["m_object"]);

	s_Object.m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object.m_state = static_cast<ECautiousDisturbanceState>(ZHMEnums::GetEnumValueByName("ECautiousDisturbanceState", std::string_view(p_Document["m_state"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_started"], &s_Item);
		s_Object.m_started = s_Item;
	}

	s_Object.m_pInvestigateGroup = simdjson::from_json_int32(p_Document["m_pInvestigateGroup"]);

	s_Object.m_bLockOnHitmanPosition = simdjson::from_json_bool(p_Document["m_bLockOnHitmanPosition"]);

	*reinterpret_cast<SDisturbanceSaveData*>(p_Target) = s_Object;
}

void SDisturbanceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_started, p_Serializer, p_OwnOffset + offsetof(SDisturbanceSaveData, m_started));
}

bool SDisturbanceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDisturbanceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDisturbanceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDisturbanceSaveData::operator==(const SDisturbanceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDisturbanceSaveData>)
		return false;

	if (m_object != p_Other.m_object) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_state != p_Other.m_state) return false;
	if (m_started != p_Other.m_started) return false;
	if (m_pInvestigateGroup != p_Other.m_pInvestigateGroup) return false;
	if (m_bLockOnHitmanPosition != p_Other.m_bLockOnHitmanPosition) return false;

	return true;
}

void SDisturbanceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDisturbanceSaveData*>(p_Object);
	s_Object->~SDisturbanceSaveData();
}

ZHMTypeInfo ZInvestigateCautiousSituation_SStateData::TypeInfo = ZHMTypeInfo("ZInvestigateCautiousSituation.SStateData", sizeof(ZInvestigateCautiousSituation_SStateData), alignof(ZInvestigateCautiousSituation_SStateData), ZInvestigateCautiousSituation_SStateData::WriteSimpleJson, ZInvestigateCautiousSituation_SStateData::FromSimpleJson, ZInvestigateCautiousSituation_SStateData::Serialize, ZInvestigateCautiousSituation_SStateData::Equals, ZInvestigateCautiousSituation_SStateData::Destroy);

void ZInvestigateCautiousSituation_SStateData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateCautiousSituation.ESituationState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eBystanderState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateCautiousSituation.EBystanderState", static_cast<int>(s_Object->m_eBystanderState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInvestigationEnded") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInvestigationEnded, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastApproachOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastApproachOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastBackupGroupEnded") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastBackupGroupEnded, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastHunt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastHunt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHuntTargetLastUpdate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tHuntTargetLastUpdate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNewHuntTargetTimer") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNewHuntTargetTimer, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastPropagate") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastPropagate, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCombatAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCombatAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownZoneDisturbanceAdded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownZoneDisturbanceAdded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownFalseAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownFalseAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownGracePeriod") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownGracePeriod);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHMInGuardDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHMInGuardDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrisked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrisked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnnouncedFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnnouncedFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReasonToFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReasonToFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneHasBeenInCombat") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneHasBeenInCombat);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInvestigationGroupActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInvestigationGroupActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandDownGuards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandDownGuards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStandDownDelay") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStandDownDelay, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMostSevereDisturbance") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eMostSevereDisturbance)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDiscoveredDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDiscoveredDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDiscoveredPacifiedBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDiscoveredPacifiedBody);

	p_Stream << "}";
}

void ZInvestigateCautiousSituation_SStateData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInvestigateCautiousSituation_SStateData s_Object {};

	s_Object.m_state = static_cast<ZInvestigateCautiousSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZInvestigateCautiousSituation.ESituationState", std::string_view(p_Document["m_state"])));

	s_Object.m_eBystanderState = static_cast<ZInvestigateCautiousSituation_EBystanderState>(ZHMEnums::GetEnumValueByName("ZInvestigateCautiousSituation.EBystanderState", std::string_view(p_Document["m_eBystanderState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastInvestigationEnded"], &s_Item);
		s_Object.m_tLastInvestigationEnded = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastApproachOrder"], &s_Item);
		s_Object.m_tLastApproachOrder = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastBackupGroupEnded"], &s_Item);
		s_Object.m_tLastBackupGroupEnded = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastHunt"], &s_Item);
		s_Object.m_tLastHunt = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tHuntTargetLastUpdate"], &s_Item);
		s_Object.m_tHuntTargetLastUpdate = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tNewHuntTargetTimer"], &s_Item);
		s_Object.m_tNewHuntTargetTimer = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastPropagate"], &s_Item);
		s_Object.m_tLastPropagate = s_Item;
	}

	s_Object.m_fCombatAge = simdjson::from_json_float32(p_Document["m_fCombatAge"]);

	s_Object.m_bLockdownZoneDisturbanceAdded = simdjson::from_json_bool(p_Document["m_bLockdownZoneDisturbanceAdded"]);

	s_Object.m_bLockdownSituation = simdjson::from_json_bool(p_Document["m_bLockdownSituation"]);

	s_Object.m_bLockdownFalseAlarm = simdjson::from_json_bool(p_Document["m_bLockdownFalseAlarm"]);

	s_Object.m_bLockdownGracePeriod = simdjson::from_json_bool(p_Document["m_bLockdownGracePeriod"]);

	s_Object.m_bHMInGuardDisguise = simdjson::from_json_bool(p_Document["m_bHMInGuardDisguise"]);

	s_Object.m_bFrisked = simdjson::from_json_bool(p_Document["m_bFrisked"]);

	s_Object.m_bAnnouncedFrisk = simdjson::from_json_bool(p_Document["m_bAnnouncedFrisk"]);

	s_Object.m_bReasonToFrisk = simdjson::from_json_bool(p_Document["m_bReasonToFrisk"]);

	s_Object.m_bSomeoneHasBeenInCombat = simdjson::from_json_bool(p_Document["m_bSomeoneHasBeenInCombat"]);

	s_Object.m_bInvestigationGroupActive = simdjson::from_json_bool(p_Document["m_bInvestigationGroupActive"]);

	s_Object.m_bStandDownGuards = simdjson::from_json_bool(p_Document["m_bStandDownGuards"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStandDownDelay"], &s_Item);
		s_Object.m_tStandDownDelay = s_Item;
	}

	s_Object.m_eMostSevereDisturbance = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eMostSevereDisturbance"])));

	s_Object.m_bDiscoveredDeadBody = simdjson::from_json_bool(p_Document["m_bDiscoveredDeadBody"]);

	s_Object.m_bDiscoveredPacifiedBody = simdjson::from_json_bool(p_Document["m_bDiscoveredPacifiedBody"]);

	*reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Target) = s_Object;
}

void ZInvestigateCautiousSituation_SStateData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastInvestigationEnded, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastInvestigationEnded));
	ZGameTime::Serialize(&s_Object->m_tLastApproachOrder, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastApproachOrder));
	ZGameTime::Serialize(&s_Object->m_tLastBackupGroupEnded, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastBackupGroupEnded));
	ZGameTime::Serialize(&s_Object->m_tLastHunt, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastHunt));
	ZGameTime::Serialize(&s_Object->m_tHuntTargetLastUpdate, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tHuntTargetLastUpdate));
	ZGameTime::Serialize(&s_Object->m_tNewHuntTargetTimer, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tNewHuntTargetTimer));
	ZGameTime::Serialize(&s_Object->m_tLastPropagate, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tLastPropagate));
	ZGameTime::Serialize(&s_Object->m_tStandDownDelay, p_Serializer, p_OwnOffset + offsetof(ZInvestigateCautiousSituation_SStateData, m_tStandDownDelay));
}

bool ZInvestigateCautiousSituation_SStateData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateCautiousSituation_SStateData::operator==(const ZInvestigateCautiousSituation_SStateData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateCautiousSituation_SStateData>)
		return false;

	if (m_state != p_Other.m_state) return false;
	if (m_eBystanderState != p_Other.m_eBystanderState) return false;
	if (m_tLastInvestigationEnded != p_Other.m_tLastInvestigationEnded) return false;
	if (m_tLastApproachOrder != p_Other.m_tLastApproachOrder) return false;
	if (m_tLastBackupGroupEnded != p_Other.m_tLastBackupGroupEnded) return false;
	if (m_tLastHunt != p_Other.m_tLastHunt) return false;
	if (m_tHuntTargetLastUpdate != p_Other.m_tHuntTargetLastUpdate) return false;
	if (m_tNewHuntTargetTimer != p_Other.m_tNewHuntTargetTimer) return false;
	if (m_tLastPropagate != p_Other.m_tLastPropagate) return false;
	if (m_fCombatAge != p_Other.m_fCombatAge) return false;
	if (m_bLockdownZoneDisturbanceAdded != p_Other.m_bLockdownZoneDisturbanceAdded) return false;
	if (m_bLockdownSituation != p_Other.m_bLockdownSituation) return false;
	if (m_bLockdownFalseAlarm != p_Other.m_bLockdownFalseAlarm) return false;
	if (m_bLockdownGracePeriod != p_Other.m_bLockdownGracePeriod) return false;
	if (m_bHMInGuardDisguise != p_Other.m_bHMInGuardDisguise) return false;
	if (m_bFrisked != p_Other.m_bFrisked) return false;
	if (m_bAnnouncedFrisk != p_Other.m_bAnnouncedFrisk) return false;
	if (m_bReasonToFrisk != p_Other.m_bReasonToFrisk) return false;
	if (m_bSomeoneHasBeenInCombat != p_Other.m_bSomeoneHasBeenInCombat) return false;
	if (m_bInvestigationGroupActive != p_Other.m_bInvestigationGroupActive) return false;
	if (m_bStandDownGuards != p_Other.m_bStandDownGuards) return false;
	if (m_tStandDownDelay != p_Other.m_tStandDownDelay) return false;
	if (m_eMostSevereDisturbance != p_Other.m_eMostSevereDisturbance) return false;
	if (m_bDiscoveredDeadBody != p_Other.m_bDiscoveredDeadBody) return false;
	if (m_bDiscoveredPacifiedBody != p_Other.m_bDiscoveredPacifiedBody) return false;

	return true;
}

void ZInvestigateCautiousSituation_SStateData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInvestigateCautiousSituation_SStateData*>(p_Object);
	s_Object->~ZInvestigateCautiousSituation_SStateData();
}

ZHMTypeInfo SCautiousInvestigateSituationSaveData::TypeInfo = ZHMTypeInfo("SCautiousInvestigateSituationSaveData", sizeof(SCautiousInvestigateSituationSaveData), alignof(SCautiousInvestigateSituationSaveData), SCautiousInvestigateSituationSaveData::WriteSimpleJson, SCautiousInvestigateSituationSaveData::FromSimpleJson, SCautiousInvestigateSituationSaveData::Serialize, SCautiousInvestigateSituationSaveData::Equals, SCautiousInvestigateSituationSaveData::Destroy);

void SCautiousInvestigateSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_StateData") << ":";
	ZInvestigateCautiousSituation_SStateData::WriteSimpleJson(&s_Object->m_StateData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pBackupGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pBackupGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rTriggerAlarmGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTriggerAlarmGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_cautiousVIPGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cautiousVIPGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cautiousVIPGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_cautiousVIPGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_friskGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_friskGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_friskGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_friskGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tFriskCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tFriskCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tFriskGroupEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tFriskGroupEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tRecoverUnconsciousGroupEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tRecoverUnconsciousGroupEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGuardMembers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGuardMembers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGuardMembers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aGuardMembers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_disturbances") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_disturbances.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_disturbances[i];
		SDisturbanceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_disturbances.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValidDisturbanceField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValidDisturbanceField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_disturbanceField") << ":";
	SCompressedGridFloatField::WriteSimpleJson(&s_Object->m_disturbanceField, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_recoverUnconsciousGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_recoverUnconsciousGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspendSearchOnInitialGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspendSearchOnInitialGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastStaticArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastStaticArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_lastStaticCombatReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_lastStaticCombatReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAnyGunshotDisturbance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAnyGunshotDisturbance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadBodyMassiveReported") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadBodyMassiveReported);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadBodiesDiscovered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadBodiesDiscovered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadCrowdBodiesDiscovered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_deadCrowdBodiesDiscovered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicEnforceEventsForSearchers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicEnforceEventsForSearchers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicEnforceEventsForSearchers[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aDynamicEnforceEventsForSearchers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastIdleStanddown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastIdleStanddown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_cautiousHuntData") << ":";
	SCautiousHuntSaveData::WriteSimpleJson(&s_Object->m_cautiousHuntData, p_Stream);

	p_Stream << "}";
}

void SCautiousInvestigateSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousInvestigateSituationSaveData s_Object {};

	{
		ZInvestigateCautiousSituation_SStateData s_Item {};
		ZInvestigateCautiousSituation_SStateData::FromSimpleJson(p_Document["m_StateData"], &s_Item);
		s_Object.m_StateData = s_Item;
	}

	s_Object.m_pGetHelpGroup = simdjson::from_json_int32(p_Document["m_pGetHelpGroup"]);

	s_Object.m_pBackupGroup = simdjson::from_json_int32(p_Document["m_pBackupGroup"]);

	s_Object.m_rTriggerAlarmGroup = simdjson::from_json_int32(p_Document["m_rTriggerAlarmGroup"]);

	s_Object.m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_cautiousVIPGroups"];
	s_Object.m_cautiousVIPGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_cautiousVIPGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_friskGroups"];
	s_Object.m_friskGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_friskGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tFriskCooldown"], &s_Item);
		s_Object.m_tFriskCooldown = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tFriskGroupEnd"], &s_Item);
		s_Object.m_tFriskGroupEnd = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tRecoverUnconsciousGroupEnd"], &s_Item);
		s_Object.m_tRecoverUnconsciousGroupEnd = s_Item;
	}

	s_Object.m_nHuntTarget = simdjson::from_json_int32(p_Document["m_nHuntTarget"]);

	s_Object.m_rZone = simdjson::from_json_uint32(p_Document["m_rZone"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGuardMembers"];
	s_Object.m_aGuardMembers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aGuardMembers[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_disturbances"];
	s_Object.m_disturbances.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDisturbanceSaveData s_ArrayItem0;
		SDisturbanceSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_disturbances[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_bValidDisturbanceField = simdjson::from_json_bool(p_Document["m_bValidDisturbanceField"]);

	{
		SCompressedGridFloatField s_Item {};
		SCompressedGridFloatField::FromSimpleJson(p_Document["m_disturbanceField"], &s_Item);
		s_Object.m_disturbanceField = s_Item;
	}

	s_Object.m_recoverUnconsciousGroup = simdjson::from_json_int32(p_Document["m_recoverUnconsciousGroup"]);

	s_Object.m_bSuspendSearchOnInitialGetHelpGroup = simdjson::from_json_bool(p_Document["m_bSuspendSearchOnInitialGetHelpGroup"]);

	s_Object.m_lastArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastArrestReason"])));

	s_Object.m_lastStaticArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastStaticArrestReason"])));

	s_Object.m_lastStaticCombatReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_lastStaticCombatReason"])));

	s_Object.m_bAnyGunshotDisturbance = simdjson::from_json_bool(p_Document["m_bAnyGunshotDisturbance"]);

	s_Object.m_deadBodyMassiveReported = simdjson::from_json_bool(p_Document["m_deadBodyMassiveReported"]);

	s_Object.m_deadBodiesDiscovered = simdjson::from_json_int32(p_Document["m_deadBodiesDiscovered"]);

	s_Object.m_deadCrowdBodiesDiscovered = simdjson::from_json_int32(p_Document["m_deadCrowdBodiesDiscovered"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDynamicEnforceEventsForSearchers"];
	s_Object.m_aDynamicEnforceEventsForSearchers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aDynamicEnforceEventsForSearchers[s_Index0++] = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(s_Item0)));
	}
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastIdleStanddown"], &s_Item);
		s_Object.m_tLastIdleStanddown = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAvoidDangerGroups"];
	s_Object.m_aAvoidDangerGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aAvoidDangerGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
		SCautiousHuntSaveData s_Item {};
		SCautiousHuntSaveData::FromSimpleJson(p_Document["m_cautiousHuntData"], &s_Item);
		s_Object.m_cautiousHuntData = s_Item;
	}

	*reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Target) = s_Object;
}

void SCautiousInvestigateSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);

	ZInvestigateCautiousSituation_SStateData::Serialize(&s_Object->m_StateData, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_StateData));
	TArray<int32>::Serialize(&s_Object->m_cautiousVIPGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_cautiousVIPGroups));
	TArray<int32>::Serialize(&s_Object->m_friskGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_friskGroups));
	ZGameTime::Serialize(&s_Object->m_tFriskCooldown, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tFriskCooldown));
	ZGameTime::Serialize(&s_Object->m_tFriskGroupEnd, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tFriskGroupEnd));
	ZGameTime::Serialize(&s_Object->m_tRecoverUnconsciousGroupEnd, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tRecoverUnconsciousGroupEnd));
	TArray<uint32>::Serialize(&s_Object->m_aGuardMembers, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aGuardMembers));
	TArray<SDisturbanceSaveData>::Serialize(&s_Object->m_disturbances, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_disturbances));
	SCompressedGridFloatField::Serialize(&s_Object->m_disturbanceField, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_disturbanceField));
	TArray<EAISharedEventType>::Serialize(&s_Object->m_aDynamicEnforceEventsForSearchers, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aDynamicEnforceEventsForSearchers));
	ZGameTime::Serialize(&s_Object->m_tLastIdleStanddown, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_tLastIdleStanddown));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_aAvoidDangerGroups));
	SCautiousHuntSaveData::Serialize(&s_Object->m_cautiousHuntData, p_Serializer, p_OwnOffset + offsetof(SCautiousInvestigateSituationSaveData, m_cautiousHuntData));
}

bool SCautiousInvestigateSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousInvestigateSituationSaveData::operator==(const SCautiousInvestigateSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousInvestigateSituationSaveData>)
		return false;

	if (m_StateData != p_Other.m_StateData) return false;
	if (m_pGetHelpGroup != p_Other.m_pGetHelpGroup) return false;
	if (m_pBackupGroup != p_Other.m_pBackupGroup) return false;
	if (m_rTriggerAlarmGroup != p_Other.m_rTriggerAlarmGroup) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_cautiousVIPGroups != p_Other.m_cautiousVIPGroups) return false;
	if (m_friskGroups != p_Other.m_friskGroups) return false;
	if (m_tFriskCooldown != p_Other.m_tFriskCooldown) return false;
	if (m_tFriskGroupEnd != p_Other.m_tFriskGroupEnd) return false;
	if (m_tRecoverUnconsciousGroupEnd != p_Other.m_tRecoverUnconsciousGroupEnd) return false;
	if (m_nHuntTarget != p_Other.m_nHuntTarget) return false;
	if (m_rZone != p_Other.m_rZone) return false;
	if (m_aGuardMembers != p_Other.m_aGuardMembers) return false;
	if (m_disturbances != p_Other.m_disturbances) return false;
	if (m_bValidDisturbanceField != p_Other.m_bValidDisturbanceField) return false;
	if (m_disturbanceField != p_Other.m_disturbanceField) return false;
	if (m_recoverUnconsciousGroup != p_Other.m_recoverUnconsciousGroup) return false;
	if (m_bSuspendSearchOnInitialGetHelpGroup != p_Other.m_bSuspendSearchOnInitialGetHelpGroup) return false;
	if (m_lastArrestReason != p_Other.m_lastArrestReason) return false;
	if (m_lastStaticArrestReason != p_Other.m_lastStaticArrestReason) return false;
	if (m_lastStaticCombatReason != p_Other.m_lastStaticCombatReason) return false;
	if (m_bAnyGunshotDisturbance != p_Other.m_bAnyGunshotDisturbance) return false;
	if (m_deadBodyMassiveReported != p_Other.m_deadBodyMassiveReported) return false;
	if (m_deadBodiesDiscovered != p_Other.m_deadBodiesDiscovered) return false;
	if (m_deadCrowdBodiesDiscovered != p_Other.m_deadCrowdBodiesDiscovered) return false;
	if (m_aDynamicEnforceEventsForSearchers != p_Other.m_aDynamicEnforceEventsForSearchers) return false;
	if (m_tLastIdleStanddown != p_Other.m_tLastIdleStanddown) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;
	if (m_cautiousHuntData != p_Other.m_cautiousHuntData) return false;

	return true;
}

void SCautiousInvestigateSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousInvestigateSituationSaveData*>(p_Object);
	s_Object->~SCautiousInvestigateSituationSaveData();
}

ZHMTypeInfo SCautiousSearchGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousSearchGroupSaveData", sizeof(SCautiousSearchGroupSaveData), alignof(SCautiousSearchGroupSaveData), SCautiousSearchGroupSaveData::WriteSimpleJson, SCautiousSearchGroupSaveData::FromSimpleJson, SCautiousSearchGroupSaveData::Serialize, SCautiousSearchGroupSaveData::Equals, SCautiousSearchGroupSaveData::Destroy);

void SCautiousSearchGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_searchNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_searchNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assistantApproachNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_assistantApproachNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGroupState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousSearchGroup.ESearchGroupState", static_cast<int>(s_Object->m_eGroupState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAssistantState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZCautiousSearchGroup.EAssistantState", static_cast<int>(s_Object->m_eAssistantState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);

	p_Stream << "}";
}

void SCautiousSearchGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousSearchGroupSaveData s_Object {};

	s_Object.m_searchNode = simdjson::from_json_uint16(p_Document["m_searchNode"]);

	s_Object.m_assistantApproachNode = simdjson::from_json_uint16(p_Document["m_assistantApproachNode"]);

	s_Object.m_eGroupState = static_cast<ZCautiousSearchGroup_ESearchGroupState>(ZHMEnums::GetEnumValueByName("ZCautiousSearchGroup.ESearchGroupState", std::string_view(p_Document["m_eGroupState"])));

	s_Object.m_eAssistantState = static_cast<ZCautiousSearchGroup_EAssistantState>(ZHMEnums::GetEnumValueByName("ZCautiousSearchGroup.EAssistantState", std::string_view(p_Document["m_eAssistantState"])));

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	*reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Target) = s_Object;
}

void SCautiousSearchGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);

}

bool SCautiousSearchGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousSearchGroupSaveData::operator==(const SCautiousSearchGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousSearchGroupSaveData>)
		return false;

	if (m_searchNode != p_Other.m_searchNode) return false;
	if (m_assistantApproachNode != p_Other.m_assistantApproachNode) return false;
	if (m_eGroupState != p_Other.m_eGroupState) return false;
	if (m_eAssistantState != p_Other.m_eAssistantState) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;

	return true;
}

void SCautiousSearchGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousSearchGroupSaveData*>(p_Object);
	s_Object->~SCautiousSearchGroupSaveData();
}

ZHMTypeInfo SCautiousSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SCautiousSituationMemberSaveData", sizeof(SCautiousSituationMemberSaveData), alignof(SCautiousSituationMemberSaveData), SCautiousSituationMemberSaveData::WriteSimpleJson, SCautiousSituationMemberSaveData::FromSimpleJson, SCautiousSituationMemberSaveData::Serialize, SCautiousSituationMemberSaveData::Equals, SCautiousSituationMemberSaveData::Destroy);

void SCautiousSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tLastDisturbance") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastDisturbance, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSearchCalc") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSearchCalc, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInfluenceCalc") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInfluenceCalc, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSearchCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSearchCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastInvestigationCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastInvestigationCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTimeIdling") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tTimeIdling, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGuardDutyPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuardDutyPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBulletImpactsHeard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBulletImpactsHeard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointSubIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointSubIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBanterCandidate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBanterCandidate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCivOccupant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCivOccupant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRecievingNewHuntTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRecievingNewHuntTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLockdownEnforcer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLockdownEnforcer);

	p_Stream << "}";
}

void SCautiousSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousSituationMemberSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastDisturbance"], &s_Item);
		s_Object.m_tLastDisturbance = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastSearchCalc"], &s_Item);
		s_Object.m_tLastSearchCalc = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastInfluenceCalc"], &s_Item);
		s_Object.m_tLastInfluenceCalc = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastSearchCompleted"], &s_Item);
		s_Object.m_tLastSearchCompleted = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastInvestigationCompleted"], &s_Item);
		s_Object.m_tLastInvestigationCompleted = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tTimeIdling"], &s_Item);
		s_Object.m_tTimeIdling = s_Item;
	}

	s_Object.m_pGuardDutyPoint = simdjson::from_json_uint32(p_Document["m_pGuardDutyPoint"]);

	s_Object.m_nBulletImpactsHeard = simdjson::from_json_int32(p_Document["m_nBulletImpactsHeard"]);

	s_Object.m_nPatrolWaypointIndex = simdjson::from_json_int32(p_Document["m_nPatrolWaypointIndex"]);

	s_Object.m_nPatrolWaypointSubIndex = simdjson::from_json_uint32(p_Document["m_nPatrolWaypointSubIndex"]);

	s_Object.m_bBanterCandidate = simdjson::from_json_bool(p_Document["m_bBanterCandidate"]);

	s_Object.m_bCivOccupant = simdjson::from_json_bool(p_Document["m_bCivOccupant"]);

	s_Object.m_bRecievingNewHuntTarget = simdjson::from_json_bool(p_Document["m_bRecievingNewHuntTarget"]);

	s_Object.m_bLockdownEnforcer = simdjson::from_json_bool(p_Document["m_bLockdownEnforcer"]);

	*reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Target) = s_Object;
}

void SCautiousSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastDisturbance, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastDisturbance));
	ZGameTime::Serialize(&s_Object->m_tLastSearchCalc, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastSearchCalc));
	ZGameTime::Serialize(&s_Object->m_tLastInfluenceCalc, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastInfluenceCalc));
	ZGameTime::Serialize(&s_Object->m_tLastSearchCompleted, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastSearchCompleted));
	ZGameTime::Serialize(&s_Object->m_tLastInvestigationCompleted, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tLastInvestigationCompleted));
	ZGameTime::Serialize(&s_Object->m_tTimeIdling, p_Serializer, p_OwnOffset + offsetof(SCautiousSituationMemberSaveData, m_tTimeIdling));
}

bool SCautiousSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousSituationMemberSaveData::operator==(const SCautiousSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousSituationMemberSaveData>)
		return false;

	if (m_tLastDisturbance != p_Other.m_tLastDisturbance) return false;
	if (m_tLastSearchCalc != p_Other.m_tLastSearchCalc) return false;
	if (m_tLastInfluenceCalc != p_Other.m_tLastInfluenceCalc) return false;
	if (m_tLastSearchCompleted != p_Other.m_tLastSearchCompleted) return false;
	if (m_tLastInvestigationCompleted != p_Other.m_tLastInvestigationCompleted) return false;
	if (m_tTimeIdling != p_Other.m_tTimeIdling) return false;
	if (m_pGuardDutyPoint != p_Other.m_pGuardDutyPoint) return false;
	if (m_nBulletImpactsHeard != p_Other.m_nBulletImpactsHeard) return false;
	if (m_nPatrolWaypointIndex != p_Other.m_nPatrolWaypointIndex) return false;
	if (m_nPatrolWaypointSubIndex != p_Other.m_nPatrolWaypointSubIndex) return false;
	if (m_bBanterCandidate != p_Other.m_bBanterCandidate) return false;
	if (m_bCivOccupant != p_Other.m_bCivOccupant) return false;
	if (m_bRecievingNewHuntTarget != p_Other.m_bRecievingNewHuntTarget) return false;
	if (m_bLockdownEnforcer != p_Other.m_bLockdownEnforcer) return false;

	return true;
}

void SCautiousSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousSituationMemberSaveData*>(p_Object);
	s_Object->~SCautiousSituationMemberSaveData();
}

ZHMTypeInfo SCautiousVIPGroupState::TypeInfo = ZHMTypeInfo("SCautiousVIPGroupState", sizeof(SCautiousVIPGroupState), alignof(SCautiousVIPGroupState), SCautiousVIPGroupState::WriteSimpleJson, SCautiousVIPGroupState::FromSimpleJson, SCautiousVIPGroupState::Serialize, SCautiousVIPGroupState::Equals, SCautiousVIPGroupState::Destroy);

void SCautiousVIPGroupState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tMove") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tMove, p_Stream);

	p_Stream << "}";
}

void SCautiousVIPGroupState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousVIPGroupState s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tMove"], &s_Item);
		s_Object.m_tMove = s_Item;
	}

	*reinterpret_cast<SCautiousVIPGroupState*>(p_Target) = s_Object;
}

void SCautiousVIPGroupState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tMove, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupState, m_tMove));
}

bool SCautiousVIPGroupState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousVIPGroupState*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousVIPGroupState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousVIPGroupState::operator==(const SCautiousVIPGroupState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousVIPGroupState>)
		return false;

	if (m_tMove != p_Other.m_tMove) return false;

	return true;
}

void SCautiousVIPGroupState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupState*>(p_Object);
	s_Object->~SCautiousVIPGroupState();
}

ZHMTypeInfo SCautiousVIPGroupSaveData::TypeInfo = ZHMTypeInfo("SCautiousVIPGroupSaveData", sizeof(SCautiousVIPGroupSaveData), alignof(SCautiousVIPGroupSaveData), SCautiousVIPGroupSaveData::WriteSimpleJson, SCautiousVIPGroupSaveData::FromSimpleJson, SCautiousVIPGroupSaveData::Serialize, SCautiousVIPGroupSaveData::Equals, SCautiousVIPGroupSaveData::Destroy);

void SCautiousVIPGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_vip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_stateData") << ":";
	SCautiousVIPGroupState::WriteSimpleJson(&s_Object->m_stateData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vipTargetNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_vipTargetNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_occupancyNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_occupancyNode);

	p_Stream << "}";
}

void SCautiousVIPGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCautiousVIPGroupSaveData s_Object {};

	s_Object.m_vip = simdjson::from_json_uint32(p_Document["m_vip"]);

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		SCautiousVIPGroupState s_Item {};
		SCautiousVIPGroupState::FromSimpleJson(p_Document["m_stateData"], &s_Item);
		s_Object.m_stateData = s_Item;
	}

	s_Object.m_vipTargetNode = simdjson::from_json_int32(p_Document["m_vipTargetNode"]);

	s_Object.m_occupancyNode = simdjson::from_json_int32(p_Document["m_occupancyNode"]);

	*reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Target) = s_Object;
}

void SCautiousVIPGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupSaveData, m_fsmState));
	SCautiousVIPGroupState::Serialize(&s_Object->m_stateData, p_Serializer, p_OwnOffset + offsetof(SCautiousVIPGroupSaveData, m_stateData));
}

bool SCautiousVIPGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCautiousVIPGroupSaveData::operator==(const SCautiousVIPGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCautiousVIPGroupSaveData>)
		return false;

	if (m_vip != p_Other.m_vip) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_stateData != p_Other.m_stateData) return false;
	if (m_vipTargetNode != p_Other.m_vipTargetNode) return false;
	if (m_occupancyNode != p_Other.m_occupancyNode) return false;

	return true;
}

void SCautiousVIPGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCautiousVIPGroupSaveData*>(p_Object);
	s_Object->~SCautiousVIPGroupSaveData();
}

ZHMTypeInfo SChairSaveData::TypeInfo = ZHMTypeInfo("SChairSaveData", sizeof(SChairSaveData), alignof(SChairSaveData), SChairSaveData::WriteSimpleJson, SChairSaveData::FromSimpleJson, SChairSaveData::Serialize, SChairSaveData::Equals, SChairSaveData::Destroy);

void SChairSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttached);

	p_Stream << "}";
}

void SChairSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SChairSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_bAttached = simdjson::from_json_bool(p_Document["m_bAttached"]);

	*reinterpret_cast<SChairSaveData*>(p_Target) = s_Object;
}

void SChairSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);

}

bool SChairSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChairSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChairSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChairSaveData::operator==(const SChairSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChairSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_bAttached != p_Other.m_bAttached) return false;

	return true;
}

void SChairSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SChairSaveData*>(p_Object);
	s_Object->~SChairSaveData();
}

ZHMTypeInfo SChallengeSaveData::TypeInfo = ZHMTypeInfo("SChallengeSaveData", sizeof(SChallengeSaveData), alignof(SChallengeSaveData), SChallengeSaveData::WriteSimpleJson, SChallengeSaveData::FromSimpleJson, SChallengeSaveData::Serialize, SChallengeSaveData::Equals, SChallengeSaveData::Destroy);

void SChallengeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_State, p_Stream);

	p_Stream << "}";
}

void SChallengeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SChallengeSaveData s_Object {};

	s_Object.m_sId = std::string_view(p_Document["m_sId"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	*reinterpret_cast<SChallengeSaveData*>(p_Target) = s_Object;
}

void SChallengeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sId, p_Serializer, p_OwnOffset + offsetof(SChallengeSaveData, m_sId));
	ZDynamicObject::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(SChallengeSaveData, m_State));
}

bool SChallengeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChallengeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChallengeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChallengeSaveData::operator==(const SChallengeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChallengeSaveData>)
		return false;

	if (m_sId != p_Other.m_sId) return false;
	if (m_State != p_Other.m_State) return false;

	return true;
}

void SChallengeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SChallengeSaveData*>(p_Object);
	s_Object->~SChallengeSaveData();
}

ZHMTypeInfo SChallengesSaveData::TypeInfo = ZHMTypeInfo("SChallengesSaveData", sizeof(SChallengesSaveData), alignof(SChallengesSaveData), SChallengesSaveData::WriteSimpleJson, SChallengesSaveData::FromSimpleJson, SChallengesSaveData::Serialize, SChallengesSaveData::Equals, SChallengesSaveData::Destroy);

void SChallengesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_mChallengeStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_mChallengeStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_mChallengeStates[i];
		SChallengeSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_mChallengeStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SChallengesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SChallengesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_mChallengeStates"];
	s_Object.m_mChallengeStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SChallengeSaveData s_ArrayItem0;
		SChallengeSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_mChallengeStates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SChallengesSaveData*>(p_Target) = s_Object;
}

void SChallengesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);

	TArray<SChallengeSaveData>::Serialize(&s_Object->m_mChallengeStates, p_Serializer, p_OwnOffset + offsetof(SChallengesSaveData, m_mChallengeStates));
}

bool SChallengesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SChallengesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SChallengesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SChallengesSaveData::operator==(const SChallengesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SChallengesSaveData>)
		return false;

	if (m_mChallengeStates != p_Other.m_mChallengeStates) return false;

	return true;
}

void SChallengesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SChallengesSaveData*>(p_Object);
	s_Object->~SChallengesSaveData();
}

ZHMTypeInfo SCharacterSpeakEntitySaveData::TypeInfo = ZHMTypeInfo("SCharacterSpeakEntitySaveData", sizeof(SCharacterSpeakEntitySaveData), alignof(SCharacterSpeakEntitySaveData), SCharacterSpeakEntitySaveData::WriteSimpleJson, SCharacterSpeakEntitySaveData::FromSimpleJson, SCharacterSpeakEntitySaveData::Serialize, SCharacterSpeakEntitySaveData::Equals, SCharacterSpeakEntitySaveData::Destroy);

void SCharacterSpeakEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSeekPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRandomSelectionSeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRandomSelectionSeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWereSubtitlesSeen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWereSubtitlesSeen);

	p_Stream << "}";
}

void SCharacterSpeakEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCharacterSpeakEntitySaveData s_Object {};

	s_Object.m_fSeekPosition = simdjson::from_json_float32(p_Document["m_fSeekPosition"]);

	s_Object.m_nRandomSelectionSeed = simdjson::from_json_uint32(p_Document["m_nRandomSelectionSeed"]);

	s_Object.m_bWereSubtitlesSeen = simdjson::from_json_bool(p_Document["m_bWereSubtitlesSeen"]);

	*reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Target) = s_Object;
}

void SCharacterSpeakEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);

}

bool SCharacterSpeakEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCharacterSpeakEntitySaveData::operator==(const SCharacterSpeakEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCharacterSpeakEntitySaveData>)
		return false;

	if (m_fSeekPosition != p_Other.m_fSeekPosition) return false;
	if (m_nRandomSelectionSeed != p_Other.m_nRandomSelectionSeed) return false;
	if (m_bWereSubtitlesSeen != p_Other.m_bWereSubtitlesSeen) return false;

	return true;
}

void SCharacterSpeakEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCharacterSpeakEntitySaveData*>(p_Object);
	s_Object->~SCharacterSpeakEntitySaveData();
}

ZHMTypeInfo SCheckLastPositionGroupSaveData::TypeInfo = ZHMTypeInfo("SCheckLastPositionGroupSaveData", sizeof(SCheckLastPositionGroupSaveData), alignof(SCheckLastPositionGroupSaveData), SCheckLastPositionGroupSaveData::WriteSimpleJson, SCheckLastPositionGroupSaveData::FromSimpleJson, SCheckLastPositionGroupSaveData::Serialize, SCheckLastPositionGroupSaveData::Equals, SCheckLastPositionGroupSaveData::Destroy);

void SCheckLastPositionGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLeaderTargetNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLeaderTargetNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAssistantOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAssistantOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSearchCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchCompleted);

	p_Stream << "}";
}

void SCheckLastPositionGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCheckLastPositionGroupSaveData s_Object {};

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object.m_nLeaderTargetNodeIndex = simdjson::from_json_uint16(p_Document["m_nLeaderTargetNodeIndex"]);

	s_Object.m_bLeaderOrderAssigned = simdjson::from_json_bool(p_Document["m_bLeaderOrderAssigned"]);

	s_Object.m_bAssistantOrderAssigned = simdjson::from_json_bool(p_Document["m_bAssistantOrderAssigned"]);

	s_Object.m_bSearchCompleted = simdjson::from_json_bool(p_Document["m_bSearchCompleted"]);

	*reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Target) = s_Object;
}

void SCheckLastPositionGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);

}

bool SCheckLastPositionGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCheckLastPositionGroupSaveData::operator==(const SCheckLastPositionGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCheckLastPositionGroupSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_nLeaderTargetNodeIndex != p_Other.m_nLeaderTargetNodeIndex) return false;
	if (m_bLeaderOrderAssigned != p_Other.m_bLeaderOrderAssigned) return false;
	if (m_bAssistantOrderAssigned != p_Other.m_bAssistantOrderAssigned) return false;
	if (m_bSearchCompleted != p_Other.m_bSearchCompleted) return false;

	return true;
}

void SCheckLastPositionGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCheckLastPositionGroupSaveData*>(p_Object);
	s_Object->~SCheckLastPositionGroupSaveData();
}

ZHMTypeInfo SClothBundleSaveData::TypeInfo = ZHMTypeInfo("SClothBundleSaveData", sizeof(SClothBundleSaveData), alignof(SClothBundleSaveData), SClothBundleSaveData::WriteSimpleJson, SClothBundleSaveData::FromSimpleJson, SClothBundleSaveData::Serialize, SClothBundleSaveData::Equals, SClothBundleSaveData::Destroy);

void SClothBundleSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothBundleSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternion") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vQuaternion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OutfitID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_OutfitID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSpawnedByHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSpawnedByHitman);

	p_Stream << "}";
}

void SClothBundleSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SClothBundleSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vQuaternion"], &s_Item);
		s_Object.m_vQuaternion = s_Item;
	}

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_OutfitID"], &s_Item);
		s_Object.m_OutfitID = s_Item;
	}

	s_Object.m_nOutfitVariation = simdjson::from_json_int32(p_Document["m_nOutfitVariation"]);

	s_Object.m_nOutfitCharset = simdjson::from_json_int32(p_Document["m_nOutfitCharset"]);

	s_Object.bSpawnedByHitman = simdjson::from_json_bool(p_Document["bSpawnedByHitman"]);

	*reinterpret_cast<SClothBundleSaveData*>(p_Target) = s_Object;
}

void SClothBundleSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothBundleSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SClothBundleSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vQuaternion, p_Serializer, p_OwnOffset + offsetof(SClothBundleSaveData, m_vQuaternion));
	ZRepositoryID::Serialize(&s_Object->m_OutfitID, p_Serializer, p_OwnOffset + offsetof(SClothBundleSaveData, m_OutfitID));
}

bool SClothBundleSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothBundleSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothBundleSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothBundleSaveData::operator==(const SClothBundleSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothBundleSaveData>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vQuaternion != p_Other.m_vQuaternion) return false;
	if (m_OutfitID != p_Other.m_OutfitID) return false;
	if (m_nOutfitVariation != p_Other.m_nOutfitVariation) return false;
	if (m_nOutfitCharset != p_Other.m_nOutfitCharset) return false;
	if (bSpawnedByHitman != p_Other.bSpawnedByHitman) return false;

	return true;
}

void SClothBundleSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SClothBundleSaveData*>(p_Object);
	s_Object->~SClothBundleSaveData();
}

ZHMTypeInfo SClothBundleSpawnSaveData::TypeInfo = ZHMTypeInfo("SClothBundleSpawnSaveData", sizeof(SClothBundleSpawnSaveData), alignof(SClothBundleSpawnSaveData), SClothBundleSpawnSaveData::WriteSimpleJson, SClothBundleSpawnSaveData::FromSimpleJson, SClothBundleSpawnSaveData::Serialize, SClothBundleSpawnSaveData::Equals, SClothBundleSpawnSaveData::Destroy);

void SClothBundleSpawnSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rClothbundle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rClothbundle);

	p_Stream << "}";
}

void SClothBundleSpawnSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SClothBundleSpawnSaveData s_Object {};

	s_Object.m_rClothbundle = simdjson::from_json_uint32(p_Document["m_rClothbundle"]);

	*reinterpret_cast<SClothBundleSpawnSaveData*>(p_Target) = s_Object;
}

void SClothBundleSpawnSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);

}

bool SClothBundleSpawnSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothBundleSpawnSaveData::operator==(const SClothBundleSpawnSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothBundleSpawnSaveData>)
		return false;

	if (m_rClothbundle != p_Other.m_rClothbundle) return false;

	return true;
}

void SClothBundleSpawnSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SClothBundleSpawnSaveData*>(p_Object);
	s_Object->~SClothBundleSpawnSaveData();
}

ZHMTypeInfo SClothVertex::TypeInfo = ZHMTypeInfo("SClothVertex", sizeof(SClothVertex), alignof(SClothVertex), SClothVertex::WriteSimpleJson, SClothVertex::FromSimpleJson, SClothVertex::Serialize, SClothVertex::Equals, SClothVertex::Destroy);

void SClothVertex::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nColumn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColumn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRow);

	p_Stream << "}";
}

void SClothVertex::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SClothVertex s_Object {};

	s_Object.m_nColumn = simdjson::from_json_uint16(p_Document["m_nColumn"]);

	s_Object.m_nRow = simdjson::from_json_uint16(p_Document["m_nRow"]);

	*reinterpret_cast<SClothVertex*>(p_Target) = s_Object;
}

void SClothVertex::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);

}

bool SClothVertex::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothVertex*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothVertex*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothVertex::operator==(const SClothVertex& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothVertex>)
		return false;

	if (m_nColumn != p_Other.m_nColumn) return false;
	if (m_nRow != p_Other.m_nRow) return false;

	return true;
}

void SClothVertex::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SClothVertex*>(p_Object);
	s_Object->~SClothVertex();
}

ZHMTypeInfo SClothWireEntitySaveData::TypeInfo = ZHMTypeInfo("SClothWireEntitySaveData", sizeof(SClothWireEntitySaveData), alignof(SClothWireEntitySaveData), SClothWireEntitySaveData::WriteSimpleJson, SClothWireEntitySaveData::FromSimpleJson, SClothWireEntitySaveData::Serialize, SClothWireEntitySaveData::Equals, SClothWireEntitySaveData::Destroy);

void SClothWireEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fWireLength") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWireLength);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAttachToAnchorTransform") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAttachToAnchorTransform);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSimulationEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSimulationEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SClothWireEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SClothWireEntitySaveData s_Object {};

	s_Object.m_fWireLength = simdjson::from_json_float32(p_Document["m_fWireLength"]);

	s_Object.m_bAttachToAnchorTransform = simdjson::from_json_bool(p_Document["m_bAttachToAnchorTransform"]);

	s_Object.m_bSimulationEnabled = simdjson::from_json_bool(p_Document["m_bSimulationEnabled"]);

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	*reinterpret_cast<SClothWireEntitySaveData*>(p_Target) = s_Object;
}

void SClothWireEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);

}

bool SClothWireEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SClothWireEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SClothWireEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SClothWireEntitySaveData::operator==(const SClothWireEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SClothWireEntitySaveData>)
		return false;

	if (m_fWireLength != p_Other.m_fWireLength) return false;
	if (m_bAttachToAnchorTransform != p_Other.m_bAttachToAnchorTransform) return false;
	if (m_bSimulationEnabled != p_Other.m_bSimulationEnabled) return false;
	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

void SClothWireEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SClothWireEntitySaveData*>(p_Object);
	s_Object->~SClothWireEntitySaveData();
}

ZHMTypeInfo SCollidingParticle::TypeInfo = ZHMTypeInfo("SCollidingParticle", sizeof(SCollidingParticle), alignof(SCollidingParticle), SCollidingParticle::WriteSimpleJson, SCollidingParticle::FromSimpleJson, SCollidingParticle::Serialize, SCollidingParticle::Equals, SCollidingParticle::Destroy);

void SCollidingParticle::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vNewVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_vNewVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nColor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nColor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSize);

	p_Stream << "}";
}

void SCollidingParticle::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCollidingParticle s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vVelocity"], &s_Item);
		s_Object.m_vVelocity = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vNewVelocity"], &s_Item);
		s_Object.m_vNewVelocity = s_Item;
	}

	s_Object.m_nColor = simdjson::from_json_uint32(p_Document["m_nColor"]);

	s_Object.m_fSize = simdjson::from_json_float32(p_Document["m_fSize"]);

	*reinterpret_cast<SCollidingParticle*>(p_Target) = s_Object;
}

void SCollidingParticle::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vPosition));
	float4::Serialize(&s_Object->m_vVelocity, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vVelocity));
	float4::Serialize(&s_Object->m_vNewVelocity, p_Serializer, p_OwnOffset + offsetof(SCollidingParticle, m_vNewVelocity));
}

bool SCollidingParticle::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollidingParticle*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollidingParticle*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollidingParticle::operator==(const SCollidingParticle& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollidingParticle>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vVelocity != p_Other.m_vVelocity) return false;
	if (m_vNewVelocity != p_Other.m_vNewVelocity) return false;
	if (m_nColor != p_Other.m_nColor) return false;
	if (m_fSize != p_Other.m_fSize) return false;

	return true;
}

void SCollidingParticle::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCollidingParticle*>(p_Object);
	s_Object->~SCollidingParticle();
}

ZHMTypeInfo SCollisionControllerAspectSaveData::TypeInfo = ZHMTypeInfo("SCollisionControllerAspectSaveData", sizeof(SCollisionControllerAspectSaveData), alignof(SCollisionControllerAspectSaveData), SCollisionControllerAspectSaveData::WriteSimpleJson, SCollisionControllerAspectSaveData::FromSimpleJson, SCollisionControllerAspectSaveData::Serialize, SCollisionControllerAspectSaveData::Equals, SCollisionControllerAspectSaveData::Destroy);

void SCollisionControllerAspectSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bCollideHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollideHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCollideCamera") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollideCamera);

	p_Stream << "}";
}

void SCollisionControllerAspectSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCollisionControllerAspectSaveData s_Object {};

	s_Object.m_bCollideHitman = simdjson::from_json_bool(p_Document["m_bCollideHitman"]);

	s_Object.m_bCollideCamera = simdjson::from_json_bool(p_Document["m_bCollideCamera"]);

	*reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Target) = s_Object;
}

void SCollisionControllerAspectSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);

}

bool SCollisionControllerAspectSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollisionControllerAspectSaveData::operator==(const SCollisionControllerAspectSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollisionControllerAspectSaveData>)
		return false;

	if (m_bCollideHitman != p_Other.m_bCollideHitman) return false;
	if (m_bCollideCamera != p_Other.m_bCollideCamera) return false;

	return true;
}

void SCollisionControllerAspectSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectSaveData*>(p_Object);
	s_Object->~SCollisionControllerAspectSaveData();
}

ZHMTypeInfo SCollisionControllerAspectsSaveData::TypeInfo = ZHMTypeInfo("SCollisionControllerAspectsSaveData", sizeof(SCollisionControllerAspectsSaveData), alignof(SCollisionControllerAspectsSaveData), SCollisionControllerAspectsSaveData::WriteSimpleJson, SCollisionControllerAspectsSaveData::FromSimpleJson, SCollisionControllerAspectsSaveData::Serialize, SCollisionControllerAspectsSaveData::Equals, SCollisionControllerAspectsSaveData::Destroy);

void SCollisionControllerAspectsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SCollisionControllerAspectSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCollisionControllerAspectsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCollisionControllerAspectsSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCollisionControllerAspectSaveData s_ArrayItem0;
		SCollisionControllerAspectSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Target) = s_Object;
}

void SCollisionControllerAspectsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SCollisionControllerAspectsSaveData, m_aEntities));
	TArray<SCollisionControllerAspectSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SCollisionControllerAspectsSaveData, m_aData));
}

bool SCollisionControllerAspectsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCollisionControllerAspectsSaveData::operator==(const SCollisionControllerAspectsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCollisionControllerAspectsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SCollisionControllerAspectsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCollisionControllerAspectsSaveData*>(p_Object);
	s_Object->~SCollisionControllerAspectsSaveData();
}

ZHMTypeInfo SColorRGB::TypeInfo = ZHMTypeInfo("SColorRGB", sizeof(SColorRGB), alignof(SColorRGB), SColorRGB::WriteSimpleJson, SColorRGB::FromSimpleJson, SColorRGB::Serialize, SColorRGB::Equals, SColorRGB::Destroy);

void SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->b);

	p_Stream << "}";
}

void SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SColorRGB s_Object {};

	s_Object.r = simdjson::from_json_float32(p_Document["r"]);

	s_Object.g = simdjson::from_json_float32(p_Document["g"]);

	s_Object.b = simdjson::from_json_float32(p_Document["b"]);

	*reinterpret_cast<SColorRGB*>(p_Target) = s_Object;
}

void SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);

}

bool SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGB::operator==(const SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGB>)
		return false;

	if (r != p_Other.r) return false;
	if (g != p_Other.g) return false;
	if (b != p_Other.b) return false;

	return true;
}

void SColorRGB::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SColorRGB*>(p_Object);
	s_Object->~SColorRGB();
}

ZHMTypeInfo SColorRGBA::TypeInfo = ZHMTypeInfo("SColorRGBA", sizeof(SColorRGBA), alignof(SColorRGBA), SColorRGBA::WriteSimpleJson, SColorRGBA::FromSimpleJson, SColorRGBA::Serialize, SColorRGBA::Equals, SColorRGBA::Destroy);

void SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("r") << ":";
	p_Stream << simdjson::as_json_string(s_Object->r);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("g") << ":";
	p_Stream << simdjson::as_json_string(s_Object->g);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("b") << ":";
	p_Stream << simdjson::as_json_string(s_Object->b);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("a") << ":";
	p_Stream << simdjson::as_json_string(s_Object->a);

	p_Stream << "}";
}

void SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SColorRGBA s_Object {};

	s_Object.r = simdjson::from_json_float32(p_Document["r"]);

	s_Object.g = simdjson::from_json_float32(p_Document["g"]);

	s_Object.b = simdjson::from_json_float32(p_Document["b"]);

	s_Object.a = simdjson::from_json_float32(p_Document["a"]);

	*reinterpret_cast<SColorRGBA*>(p_Target) = s_Object;
}

void SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);

}

bool SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGBA::operator==(const SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGBA>)
		return false;

	if (r != p_Other.r) return false;
	if (g != p_Other.g) return false;
	if (b != p_Other.b) return false;
	if (a != p_Other.a) return false;

	return true;
}

void SColorRGBA::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SColorRGBA*>(p_Object);
	s_Object->~SColorRGBA();
}

ZHMTypeInfo SColorRGBSaveData::TypeInfo = ZHMTypeInfo("SColorRGBSaveData", sizeof(SColorRGBSaveData), alignof(SColorRGBSaveData), SColorRGBSaveData::WriteSimpleJson, SColorRGBSaveData::FromSimpleJson, SColorRGBSaveData::Serialize, SColorRGBSaveData::Equals, SColorRGBSaveData::Destroy);

void SColorRGBSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SColorRGB::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SColorRGBSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SColorRGBSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SColorRGB s_ArrayItem0;
		SColorRGB::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SColorRGBSaveData*>(p_Target) = s_Object;
}

void SColorRGBSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SColorRGBSaveData, m_aEntities));
	TArray<SColorRGB>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SColorRGBSaveData, m_aData));
}

bool SColorRGBSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SColorRGBSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SColorRGBSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SColorRGBSaveData::operator==(const SColorRGBSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SColorRGBSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SColorRGBSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SColorRGBSaveData*>(p_Object);
	s_Object->~SColorRGBSaveData();
}

ZHMTypeInfo SCombatOrderSaveData::TypeInfo = ZHMTypeInfo("SCombatOrderSaveData", sizeof(SCombatOrderSaveData), alignof(SCombatOrderSaveData), SCombatOrderSaveData::WriteSimpleJson, SCombatOrderSaveData::FromSimpleJson, SCombatOrderSaveData::Serialize, SCombatOrderSaveData::Equals, SCombatOrderSaveData::Destroy);

void SCombatOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPos") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPos, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_coverPlane") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_coverPlane);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInteraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInteraction);

	p_Stream << "}";
}

void SCombatOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCombatOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPos"], &s_Item);
		s_Object.m_vPos = s_Item;
	}

	s_Object.m_coverPlane = simdjson::from_json_uint32(p_Document["m_coverPlane"]);

	s_Object.m_rInteraction = simdjson::from_json_uint32(p_Document["m_rInteraction"]);

	*reinterpret_cast<SCombatOrderSaveData*>(p_Target) = s_Object;
}

void SCombatOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPos, p_Serializer, p_OwnOffset + offsetof(SCombatOrderSaveData, m_vPos));
}

bool SCombatOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatOrderSaveData::operator==(const SCombatOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatOrderSaveData>)
		return false;

	if (m_vPos != p_Other.m_vPos) return false;
	if (m_coverPlane != p_Other.m_coverPlane) return false;
	if (m_rInteraction != p_Other.m_rInteraction) return false;

	return true;
}

void SCombatOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCombatOrderSaveData*>(p_Object);
	s_Object->~SCombatOrderSaveData();
}

ZHMTypeInfo SCombatSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SCombatSituationMemberSaveData", sizeof(SCombatSituationMemberSaveData), alignof(SCombatSituationMemberSaveData), SCombatSituationMemberSaveData::WriteSimpleJson, SCombatSituationMemberSaveData::FromSimpleJson, SCombatSituationMemberSaveData::Serialize, SCombatSituationMemberSaveData::Equals, SCombatSituationMemberSaveData::Destroy);

void SCombatSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceFieldValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceFieldValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_civilianJoinReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_civilianJoinReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPreferredToFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPreferredToFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDialogPreventShooting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDialogPreventShooting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanFlee") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanFlee);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCantFleeNoPath") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCantFleeNoPath);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReportedToGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReportedToGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandAndShoot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandAndShoot);

	p_Stream << "}";
}

void SCombatSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCombatSituationMemberSaveData s_Object {};

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_fDistanceFieldValue = simdjson::from_json_float32(p_Document["m_fDistanceFieldValue"]);

	s_Object.m_civilianJoinReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_civilianJoinReason"])));

	s_Object.m_bIsPreferredToFire = simdjson::from_json_bool(p_Document["m_bIsPreferredToFire"]);

	s_Object.m_bDialogPreventShooting = simdjson::from_json_bool(p_Document["m_bDialogPreventShooting"]);

	s_Object.m_bCanFlee = simdjson::from_json_bool(p_Document["m_bCanFlee"]);

	s_Object.m_bCantFleeNoPath = simdjson::from_json_bool(p_Document["m_bCantFleeNoPath"]);

	s_Object.m_bReportedToGuard = simdjson::from_json_bool(p_Document["m_bReportedToGuard"]);

	s_Object.m_bStandAndShoot = simdjson::from_json_bool(p_Document["m_bStandAndShoot"]);

	*reinterpret_cast<SCombatSituationMemberSaveData*>(p_Target) = s_Object;
}

void SCombatSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);

}

bool SCombatSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatSituationMemberSaveData::operator==(const SCombatSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatSituationMemberSaveData>)
		return false;

	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_fDistanceFieldValue != p_Other.m_fDistanceFieldValue) return false;
	if (m_civilianJoinReason != p_Other.m_civilianJoinReason) return false;
	if (m_bIsPreferredToFire != p_Other.m_bIsPreferredToFire) return false;
	if (m_bDialogPreventShooting != p_Other.m_bDialogPreventShooting) return false;
	if (m_bCanFlee != p_Other.m_bCanFlee) return false;
	if (m_bCantFleeNoPath != p_Other.m_bCantFleeNoPath) return false;
	if (m_bReportedToGuard != p_Other.m_bReportedToGuard) return false;
	if (m_bStandAndShoot != p_Other.m_bStandAndShoot) return false;

	return true;
}

void SCombatSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCombatSituationMemberSaveData*>(p_Object);
	s_Object->~SCombatSituationMemberSaveData();
}

ZHMTypeInfo SCombatZoneEntitySaveData::TypeInfo = ZHMTypeInfo("SCombatZoneEntitySaveData", sizeof(SCombatZoneEntitySaveData), alignof(SCombatZoneEntitySaveData), SCombatZoneEntitySaveData::WriteSimpleJson, SCombatZoneEntitySaveData::FromSimpleJson, SCombatZoneEntitySaveData::Serialize, SCombatZoneEntitySaveData::Equals, SCombatZoneEntitySaveData::Destroy);

void SCombatZoneEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInLockdown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInLockdown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFalseAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFalseAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECombatZoneState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLockdownTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLockdownTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTriggerTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tTriggerTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEngageTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEngageTime, p_Stream);

	p_Stream << "}";
}

void SCombatZoneEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCombatZoneEntitySaveData s_Object {};

	s_Object.m_bIsInLockdown = simdjson::from_json_bool(p_Document["m_bIsInLockdown"]);

	s_Object.m_bIsFalseAlarm = simdjson::from_json_bool(p_Document["m_bIsFalseAlarm"]);

	s_Object.m_nState = static_cast<ECombatZoneState>(ZHMEnums::GetEnumValueByName("ECombatZoneState", std::string_view(p_Document["m_nState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLockdownTime"], &s_Item);
		s_Object.m_tLockdownTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tTriggerTime"], &s_Item);
		s_Object.m_tTriggerTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tEngageTime"], &s_Item);
		s_Object.m_tEngageTime = s_Item;
	}

	*reinterpret_cast<SCombatZoneEntitySaveData*>(p_Target) = s_Object;
}

void SCombatZoneEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLockdownTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tLockdownTime));
	ZGameTime::Serialize(&s_Object->m_tTriggerTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tTriggerTime));
	ZGameTime::Serialize(&s_Object->m_tEngageTime, p_Serializer, p_OwnOffset + offsetof(SCombatZoneEntitySaveData, m_tEngageTime));
}

bool SCombatZoneEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCombatZoneEntitySaveData::operator==(const SCombatZoneEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCombatZoneEntitySaveData>)
		return false;

	if (m_bIsInLockdown != p_Other.m_bIsInLockdown) return false;
	if (m_bIsFalseAlarm != p_Other.m_bIsFalseAlarm) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_tLockdownTime != p_Other.m_tLockdownTime) return false;
	if (m_tTriggerTime != p_Other.m_tTriggerTime) return false;
	if (m_tEngageTime != p_Other.m_tEngageTime) return false;

	return true;
}

void SCombatZoneEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCombatZoneEntitySaveData*>(p_Object);
	s_Object->~SCombatZoneEntitySaveData();
}

ZHMTypeInfo SComboDeviceBinding::TypeInfo = ZHMTypeInfo("SComboDeviceBinding", sizeof(SComboDeviceBinding), alignof(SComboDeviceBinding), SComboDeviceBinding::WriteSimpleJson, SComboDeviceBinding::FromSimpleJson, SComboDeviceBinding::Serialize, SComboDeviceBinding::Equals, SComboDeviceBinding::Destroy);

void SComboDeviceBinding::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SComboDeviceBinding*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("button") << ":";
	p_Stream << simdjson::as_json_string(s_Object->button);

	p_Stream << "}";
}

void SComboDeviceBinding::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SComboDeviceBinding s_Object {};

	s_Object.type = simdjson::from_json_uint32(p_Document["type"]);

	s_Object.button = simdjson::from_json_uint32(p_Document["button"]);

	*reinterpret_cast<SComboDeviceBinding*>(p_Target) = s_Object;
}

void SComboDeviceBinding::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SComboDeviceBinding*>(p_Object);

}

bool SComboDeviceBinding::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SComboDeviceBinding*>(p_Left);
	auto* s_Right = reinterpret_cast<SComboDeviceBinding*>(p_Right);

	return *s_Left == *s_Right;
}

bool SComboDeviceBinding::operator==(const SComboDeviceBinding& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SComboDeviceBinding>)
		return false;

	if (type != p_Other.type) return false;
	if (button != p_Other.button) return false;

	return true;
}

void SComboDeviceBinding::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SComboDeviceBinding*>(p_Object);
	s_Object->~SComboDeviceBinding();
}

ZHMTypeInfo ZBehaviorTreeVariable::TypeInfo = ZHMTypeInfo("ZBehaviorTreeVariable", sizeof(ZBehaviorTreeVariable), alignof(ZBehaviorTreeVariable), ZBehaviorTreeVariable::WriteSimpleJson, ZBehaviorTreeVariable::FromSimpleJson, ZBehaviorTreeVariable::Serialize, ZBehaviorTreeVariable::Equals, ZBehaviorTreeVariable::Destroy);

void ZBehaviorTreeVariable::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZBehaviorTreeVariable::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZBehaviorTreeVariable s_Object {};

	*reinterpret_cast<ZBehaviorTreeVariable*>(p_Target) = s_Object;
}

void ZBehaviorTreeVariable::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);

}

bool ZBehaviorTreeVariable::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZBehaviorTreeVariable*>(p_Left);
	auto* s_Right = reinterpret_cast<ZBehaviorTreeVariable*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZBehaviorTreeVariable::operator==(const ZBehaviorTreeVariable& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZBehaviorTreeVariable>)
		return false;


	return true;
}

void ZBehaviorTreeVariable::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZBehaviorTreeVariable*>(p_Object);
	s_Object->~ZBehaviorTreeVariable();
}

ZHMTypeInfo SConditionBase::TypeInfo = ZHMTypeInfo("SConditionBase", sizeof(SConditionBase), alignof(SConditionBase), SConditionBase::WriteSimpleJson, SConditionBase::FromSimpleJson, SConditionBase::Serialize, SConditionBase::Equals, SConditionBase::Destroy);

void SConditionBase::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("eConditionType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECompiledConditionType", static_cast<int>(s_Object->eConditionType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nConditionModifiers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nConditionModifiers);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("assignTo") << ":";
	ZBehaviorTreeVariable::WriteSimpleJson(&s_Object->assignTo, p_Stream);

	p_Stream << "}";
}

void SConditionBase::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SConditionBase s_Object {};

	s_Object.eConditionType = static_cast<ECompiledConditionType>(ZHMEnums::GetEnumValueByName("ECompiledConditionType", std::string_view(p_Document["eConditionType"])));

	s_Object.nConditionModifiers = simdjson::from_json_uint32(p_Document["nConditionModifiers"]);

	{
		ZBehaviorTreeVariable s_Item {};
		ZBehaviorTreeVariable::FromSimpleJson(p_Document["assignTo"], &s_Item);
		s_Object.assignTo = s_Item;
	}

	*reinterpret_cast<SConditionBase*>(p_Target) = s_Object;
}

void SConditionBase::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);

	ZBehaviorTreeVariable::Serialize(&s_Object->assignTo, p_Serializer, p_OwnOffset + offsetof(SConditionBase, assignTo));
}

bool SConditionBase::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConditionBase*>(p_Left);
	auto* s_Right = reinterpret_cast<SConditionBase*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConditionBase::operator==(const SConditionBase& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConditionBase>)
		return false;

	if (eConditionType != p_Other.eConditionType) return false;
	if (nConditionModifiers != p_Other.nConditionModifiers) return false;
	if (assignTo != p_Other.assignTo) return false;

	return true;
}

void SConditionBase::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SConditionBase*>(p_Object);
	s_Object->~SConditionBase();
}

ZHMTypeInfo SConditionalTimerEntitySaveData::TypeInfo = ZHMTypeInfo("SConditionalTimerEntitySaveData", sizeof(SConditionalTimerEntitySaveData), alignof(SConditionalTimerEntitySaveData), SConditionalTimerEntitySaveData::WriteSimpleJson, SConditionalTimerEntitySaveData::FromSimpleJson, SConditionalTimerEntitySaveData::Serialize, SConditionalTimerEntitySaveData::Equals, SConditionalTimerEntitySaveData::Destroy);

void SConditionalTimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValue);

	p_Stream << "}";
}

void SConditionalTimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SConditionalTimerEntitySaveData s_Object {};

	s_Object.m_nInterval = simdjson::from_json_int32(p_Document["m_nInterval"]);

	s_Object.m_nRemaining = simdjson::from_json_int32(p_Document["m_nRemaining"]);

	s_Object.m_bActive = simdjson::from_json_bool(p_Document["m_bActive"]);

	s_Object.m_bValue = simdjson::from_json_bool(p_Document["m_bValue"]);

	*reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Target) = s_Object;
}

void SConditionalTimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);

}

bool SConditionalTimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConditionalTimerEntitySaveData::operator==(const SConditionalTimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConditionalTimerEntitySaveData>)
		return false;

	if (m_nInterval != p_Other.m_nInterval) return false;
	if (m_nRemaining != p_Other.m_nRemaining) return false;
	if (m_bActive != p_Other.m_bActive) return false;
	if (m_bValue != p_Other.m_bValue) return false;

	return true;
}

void SConditionalTimerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SConditionalTimerEntitySaveData*>(p_Object);
	s_Object->~SConditionalTimerEntitySaveData();
}

ZHMTypeInfo SInventoryItem::TypeInfo = ZHMTypeInfo("SInventoryItem", sizeof(SInventoryItem), alignof(SInventoryItem), SInventoryItem::WriteSimpleJson, SInventoryItem::FromSimpleJson, SInventoryItem::Serialize, SInventoryItem::Equals, SInventoryItem::Destroy);

void SInventoryItem::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryItem*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sInstanceId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sInstanceId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sUnlockableId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sUnlockableId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repositoryId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->repositoryId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aRepositoryAssetIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aRepositoryAssetIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->aRepositoryAssetIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aRepositoryAssetIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aModifierIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->aModifierIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aModifierIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInventoryItem::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryItem s_Object {};

	s_Object.sInstanceId = std::string_view(p_Document["sInstanceId"]);

	s_Object.sUnlockableId = std::string_view(p_Document["sUnlockableId"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["repositoryId"], &s_Item);
		s_Object.repositoryId = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aRepositoryAssetIds"];
	s_Object.aRepositoryAssetIds.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aRepositoryAssetIds[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aModifierIds"];
	s_Object.aModifierIds.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aModifierIds[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SInventoryItem*>(p_Target) = s_Object;
}

void SInventoryItem::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryItem*>(p_Object);

	ZString::Serialize(&s_Object->sInstanceId, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, sInstanceId));
	ZString::Serialize(&s_Object->sUnlockableId, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, sUnlockableId));
	ZRepositoryID::Serialize(&s_Object->repositoryId, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, repositoryId));
	TArray<ZRepositoryID>::Serialize(&s_Object->aRepositoryAssetIds, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, aRepositoryAssetIds));
	TArray<ZRepositoryID>::Serialize(&s_Object->aModifierIds, p_Serializer, p_OwnOffset + offsetof(SInventoryItem, aModifierIds));
}

bool SInventoryItem::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryItem*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryItem*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryItem::operator==(const SInventoryItem& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryItem>)
		return false;

	if (sInstanceId != p_Other.sInstanceId) return false;
	if (sUnlockableId != p_Other.sUnlockableId) return false;
	if (repositoryId != p_Other.repositoryId) return false;
	if (aRepositoryAssetIds != p_Other.aRepositoryAssetIds) return false;
	if (aModifierIds != p_Other.aModifierIds) return false;

	return true;
}

void SInventoryItem::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryItem*>(p_Object);
	s_Object->~SInventoryItem();
}

ZHMTypeInfo SContainerItemInfo::TypeInfo = ZHMTypeInfo("SContainerItemInfo", sizeof(SContainerItemInfo), alignof(SContainerItemInfo), SContainerItemInfo::WriteSimpleJson, SContainerItemInfo::FromSimpleJson, SContainerItemInfo::Serialize, SContainerItemInfo::Equals, SContainerItemInfo::Destroy);

void SContainerItemInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContainerItemInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sContainerInstanceId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContainerInstanceId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_concealedItem") << ":";
	SInventoryItem::WriteSimpleJson(&s_Object->m_concealedItem, p_Stream);

	p_Stream << "}";
}

void SContainerItemInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContainerItemInfo s_Object {};

	s_Object.m_sContainerInstanceId = std::string_view(p_Document["m_sContainerInstanceId"]);

	{
		SInventoryItem s_Item {};
		SInventoryItem::FromSimpleJson(p_Document["m_concealedItem"], &s_Item);
		s_Object.m_concealedItem = s_Item;
	}

	*reinterpret_cast<SContainerItemInfo*>(p_Target) = s_Object;
}

void SContainerItemInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContainerItemInfo*>(p_Object);

	ZString::Serialize(&s_Object->m_sContainerInstanceId, p_Serializer, p_OwnOffset + offsetof(SContainerItemInfo, m_sContainerInstanceId));
	SInventoryItem::Serialize(&s_Object->m_concealedItem, p_Serializer, p_OwnOffset + offsetof(SContainerItemInfo, m_concealedItem));
}

bool SContainerItemInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContainerItemInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SContainerItemInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContainerItemInfo::operator==(const SContainerItemInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContainerItemInfo>)
		return false;

	if (m_sContainerInstanceId != p_Other.m_sContainerInstanceId) return false;
	if (m_concealedItem != p_Other.m_concealedItem) return false;

	return true;
}

void SContainerItemInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContainerItemInfo*>(p_Object);
	s_Object->~SContainerItemInfo();
}

ZHMTypeInfo SContextActionSaveData::TypeInfo = ZHMTypeInfo("SContextActionSaveData", sizeof(SContextActionSaveData), alignof(SContextActionSaveData), SContextActionSaveData::WriteSimpleJson, SContextActionSaveData::FromSimpleJson, SContextActionSaveData::Serialize, SContextActionSaveData::Equals, SContextActionSaveData::Destroy);

void SContextActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldShow);

	p_Stream << "}";
}

void SContextActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContextActionSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bTriggered = simdjson::from_json_bool(p_Document["m_bTriggered"]);

	s_Object.m_bShouldShow = simdjson::from_json_bool(p_Document["m_bShouldShow"]);

	*reinterpret_cast<SContextActionSaveData*>(p_Target) = s_Object;
}

void SContextActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);

}

bool SContextActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContextActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContextActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContextActionSaveData::operator==(const SContextActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContextActionSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bTriggered != p_Other.m_bTriggered) return false;
	if (m_bShouldShow != p_Other.m_bShouldShow) return false;

	return true;
}

void SContextActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContextActionSaveData*>(p_Object);
	s_Object->~SContextActionSaveData();
}

ZHMTypeInfo SContractConfigResourceEntry::TypeInfo = ZHMTypeInfo("SContractConfigResourceEntry", sizeof(SContractConfigResourceEntry), alignof(SContractConfigResourceEntry), SContractConfigResourceEntry::WriteSimpleJson, SContractConfigResourceEntry::FromSimpleJson, SContractConfigResourceEntry::Serialize, SContractConfigResourceEntry::Equals, SContractConfigResourceEntry::Destroy);

void SContractConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ContractRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->ContractRid, p_Stream);

	p_Stream << "}";
}

void SContractConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractConfigResourceEntry s_Object {};

	s_Object.Id = std::string_view(p_Document["Id"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["ContractRid"], &s_Item);
		s_Object.ContractRid = s_Item;
	}

	*reinterpret_cast<SContractConfigResourceEntry*>(p_Target) = s_Object;
}

void SContractConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Id, p_Serializer, p_OwnOffset + offsetof(SContractConfigResourceEntry, Id));
	ZRuntimeResourceID::Serialize(&s_Object->ContractRid, p_Serializer, p_OwnOffset + offsetof(SContractConfigResourceEntry, ContractRid));
}

bool SContractConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractConfigResourceEntry::operator==(const SContractConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractConfigResourceEntry>)
		return false;

	if (Id != p_Other.Id) return false;
	if (ContractRid != p_Other.ContractRid) return false;

	return true;
}

void SContractConfigResourceEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContractConfigResourceEntry*>(p_Object);
	s_Object->~SContractConfigResourceEntry();
}

ZHMTypeInfo SContractObjectiveHudHintEntitySaveData::TypeInfo = ZHMTypeInfo("SContractObjectiveHudHintEntitySaveData", sizeof(SContractObjectiveHudHintEntitySaveData), alignof(SContractObjectiveHudHintEntitySaveData), SContractObjectiveHudHintEntitySaveData::WriteSimpleJson, SContractObjectiveHudHintEntitySaveData::FromSimpleJson, SContractObjectiveHudHintEntitySaveData::Serialize, SContractObjectiveHudHintEntitySaveData::Equals, SContractObjectiveHudHintEntitySaveData::Destroy);

void SContractObjectiveHudHintEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SContractObjectiveHudHintEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractObjectiveHudHintEntitySaveData s_Object {};

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	*reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Target) = s_Object;
}

void SContractObjectiveHudHintEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);

}

bool SContractObjectiveHudHintEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractObjectiveHudHintEntitySaveData::operator==(const SContractObjectiveHudHintEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractObjectiveHudHintEntitySaveData>)
		return false;

	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

void SContractObjectiveHudHintEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveHudHintEntitySaveData*>(p_Object);
	s_Object->~SContractObjectiveHudHintEntitySaveData();
}

ZHMTypeInfo SContractObjectiveSaveData::TypeInfo = ZHMTypeInfo("SContractObjectiveSaveData", sizeof(SContractObjectiveSaveData), alignof(SContractObjectiveSaveData), SContractObjectiveSaveData::WriteSimpleJson, SContractObjectiveSaveData::FromSimpleJson, SContractObjectiveSaveData::Serialize, SContractObjectiveSaveData::Equals, SContractObjectiveSaveData::Destroy);

void SContractObjectiveSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Id") << ":";
	ZGuid::WriteSimpleJson(&s_Object->m_Id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCategory") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Category", static_cast<int>(s_Object->m_eCategory)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sSuccessEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sSuccessEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SuccessEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_SuccessEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sFailedEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sFailedEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_FailedEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_FailedEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sResetEventName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sResetEventName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ResetEventValues") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_ResetEventValues, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLongBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sLongBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sHUDText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sHUDText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iRepeatSuccess") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iRepeatSuccess);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iRepeatFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iRepeatFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iCurrentSuccess") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCurrentSuccess);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iCurrentFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iCurrentFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationCondition") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_ActivationCondition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_ActivationValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateActivationOnCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateActivationOnCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisplayAsKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisplayAsKill);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreIfInactive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreIfInactive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCombinedDisplayInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCombinedDisplayInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnInactive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnInactive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnActive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnActive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExits") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_aExits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectiveType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectiveType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBriefingName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceShowOnLoadingScreen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceShowOnLoadingScreen);

	p_Stream << "}";
}

void SContractObjectiveSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractObjectiveSaveData s_Object {};

	{
		ZGuid s_Item {};
		ZGuid::FromSimpleJson(p_Document["m_Id"], &s_Item);
		s_Object.m_Id = s_Item;
	}

	s_Object.m_sText = std::string_view(p_Document["m_sText"]);

	s_Object.m_eCategory = static_cast<IContractObjective_Category>(ZHMEnums::GetEnumValueByName("IContractObjective.Category", std::string_view(p_Document["m_eCategory"])));

	s_Object.m_bCompleted = simdjson::from_json_bool(p_Document["m_bCompleted"]);

	s_Object.m_bFailed = simdjson::from_json_bool(p_Document["m_bFailed"]);

	s_Object.m_bIsHidden = simdjson::from_json_bool(p_Document["m_bIsHidden"]);

	s_Object.m_sSuccessEventName = std::string_view(p_Document["m_sSuccessEventName"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_SuccessEventValues"], &s_Item);
		s_Object.m_SuccessEventValues = s_Item;
	}

	s_Object.m_sFailedEventName = std::string_view(p_Document["m_sFailedEventName"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_FailedEventValues"], &s_Item);
		s_Object.m_FailedEventValues = s_Item;
	}

	s_Object.m_sResetEventName = std::string_view(p_Document["m_sResetEventName"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_ResetEventValues"], &s_Item);
		s_Object.m_ResetEventValues = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sBriefingText"], &s_Item);
		s_Object.m_sBriefingText = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sLongBriefingText"], &s_Item);
		s_Object.m_sLongBriefingText = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sHUDText"], &s_Item);
		s_Object.m_sHUDText = s_Item;
	}

	s_Object.m_iRepeatSuccess = simdjson::from_json_int32(p_Document["m_iRepeatSuccess"]);

	s_Object.m_iRepeatFailed = simdjson::from_json_int32(p_Document["m_iRepeatFailed"]);

	s_Object.m_iCurrentSuccess = simdjson::from_json_int32(p_Document["m_iCurrentSuccess"]);

	s_Object.m_iCurrentFailed = simdjson::from_json_int32(p_Document["m_iCurrentFailed"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_ActivationCondition"], &s_Item);
		s_Object.m_ActivationCondition = s_Item;
	}

	s_Object.m_ActivationValue = simdjson::from_json_bool(p_Document["m_ActivationValue"]);

	s_Object.m_bUpdateActivationOnCompleted = simdjson::from_json_bool(p_Document["m_bUpdateActivationOnCompleted"]);

	s_Object.m_bDisplayAsKill = simdjson::from_json_bool(p_Document["m_bDisplayAsKill"]);

	s_Object.m_bIgnoreIfInactive = simdjson::from_json_bool(p_Document["m_bIgnoreIfInactive"]);

	s_Object.m_bShowInHud = simdjson::from_json_bool(p_Document["m_bShowInHud"]);

	s_Object.m_bCombinedDisplayInHud = simdjson::from_json_bool(p_Document["m_bCombinedDisplayInHud"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_OnInactive"], &s_Item);
		s_Object.m_OnInactive = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_OnActive"], &s_Item);
		s_Object.m_OnActive = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_aExits"], &s_Item);
		s_Object.m_aExits = s_Item;
	}

	s_Object.m_sImage = std::string_view(p_Document["m_sImage"]);

	s_Object.m_sObjectiveType = std::string_view(p_Document["m_sObjectiveType"]);

	s_Object.m_sBriefingName = std::string_view(p_Document["m_sBriefingName"]);

	s_Object.m_bForceShowOnLoadingScreen = simdjson::from_json_bool(p_Document["m_bForceShowOnLoadingScreen"]);

	*reinterpret_cast<SContractObjectiveSaveData*>(p_Target) = s_Object;
}

void SContractObjectiveSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);

	ZGuid::Serialize(&s_Object->m_Id, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_Id));
	ZString::Serialize(&s_Object->m_sText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sText));
	ZString::Serialize(&s_Object->m_sSuccessEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sSuccessEventName));
	ZDynamicObject::Serialize(&s_Object->m_SuccessEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_SuccessEventValues));
	ZString::Serialize(&s_Object->m_sFailedEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sFailedEventName));
	ZDynamicObject::Serialize(&s_Object->m_FailedEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_FailedEventValues));
	ZString::Serialize(&s_Object->m_sResetEventName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sResetEventName));
	ZDynamicObject::Serialize(&s_Object->m_ResetEventValues, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_ResetEventValues));
	ZDynamicObject::Serialize(&s_Object->m_sBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_sLongBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sLongBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_sHUDText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sHUDText));
	ZDynamicObject::Serialize(&s_Object->m_ActivationCondition, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_ActivationCondition));
	ZDynamicObject::Serialize(&s_Object->m_OnInactive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_OnInactive));
	ZDynamicObject::Serialize(&s_Object->m_OnActive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_OnActive));
	ZDynamicObject::Serialize(&s_Object->m_aExits, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_aExits));
	ZString::Serialize(&s_Object->m_sImage, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sImage));
	ZString::Serialize(&s_Object->m_sObjectiveType, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sObjectiveType));
	ZString::Serialize(&s_Object->m_sBriefingName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveSaveData, m_sBriefingName));
}

bool SContractObjectiveSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractObjectiveSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractObjectiveSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractObjectiveSaveData::operator==(const SContractObjectiveSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractObjectiveSaveData>)
		return false;

	if (m_Id != p_Other.m_Id) return false;
	if (m_sText != p_Other.m_sText) return false;
	if (m_eCategory != p_Other.m_eCategory) return false;
	if (m_bCompleted != p_Other.m_bCompleted) return false;
	if (m_bFailed != p_Other.m_bFailed) return false;
	if (m_bIsHidden != p_Other.m_bIsHidden) return false;
	if (m_sSuccessEventName != p_Other.m_sSuccessEventName) return false;
	if (m_SuccessEventValues != p_Other.m_SuccessEventValues) return false;
	if (m_sFailedEventName != p_Other.m_sFailedEventName) return false;
	if (m_FailedEventValues != p_Other.m_FailedEventValues) return false;
	if (m_sResetEventName != p_Other.m_sResetEventName) return false;
	if (m_ResetEventValues != p_Other.m_ResetEventValues) return false;
	if (m_sBriefingText != p_Other.m_sBriefingText) return false;
	if (m_sLongBriefingText != p_Other.m_sLongBriefingText) return false;
	if (m_sHUDText != p_Other.m_sHUDText) return false;
	if (m_iRepeatSuccess != p_Other.m_iRepeatSuccess) return false;
	if (m_iRepeatFailed != p_Other.m_iRepeatFailed) return false;
	if (m_iCurrentSuccess != p_Other.m_iCurrentSuccess) return false;
	if (m_iCurrentFailed != p_Other.m_iCurrentFailed) return false;
	if (m_ActivationCondition != p_Other.m_ActivationCondition) return false;
	if (m_ActivationValue != p_Other.m_ActivationValue) return false;
	if (m_bUpdateActivationOnCompleted != p_Other.m_bUpdateActivationOnCompleted) return false;
	if (m_bDisplayAsKill != p_Other.m_bDisplayAsKill) return false;
	if (m_bIgnoreIfInactive != p_Other.m_bIgnoreIfInactive) return false;
	if (m_bShowInHud != p_Other.m_bShowInHud) return false;
	if (m_bCombinedDisplayInHud != p_Other.m_bCombinedDisplayInHud) return false;
	if (m_OnInactive != p_Other.m_OnInactive) return false;
	if (m_OnActive != p_Other.m_OnActive) return false;
	if (m_aExits != p_Other.m_aExits) return false;
	if (m_sImage != p_Other.m_sImage) return false;
	if (m_sObjectiveType != p_Other.m_sObjectiveType) return false;
	if (m_sBriefingName != p_Other.m_sBriefingName) return false;
	if (m_bForceShowOnLoadingScreen != p_Other.m_bForceShowOnLoadingScreen) return false;

	return true;
}

void SContractObjectiveSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveSaveData*>(p_Object);
	s_Object->~SContractObjectiveSaveData();
}

ZHMTypeInfo SContractObjectiveStateMachineSaveData::TypeInfo = ZHMTypeInfo("SContractObjectiveStateMachineSaveData", sizeof(SContractObjectiveStateMachineSaveData), alignof(SContractObjectiveStateMachineSaveData), SContractObjectiveStateMachineSaveData::WriteSimpleJson, SContractObjectiveStateMachineSaveData::FromSimpleJson, SContractObjectiveStateMachineSaveData::Serialize, SContractObjectiveStateMachineSaveData::Equals, SContractObjectiveStateMachineSaveData::Destroy);

void SContractObjectiveStateMachineSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Id") << ":";
	ZGuid::WriteSimpleJson(&s_Object->m_Id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCategory") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Category", static_cast<int>(s_Object->m_eCategory)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLongBriefingText") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_sLongBriefingText, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Definition") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_Definition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTargets") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_aTargets, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAllies") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_aAllies, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetsHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HUDTmpl") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_HUDTmpl, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActivationCondition") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_ActivationCondition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivationValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivationValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateActivationOnCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateActivationOnCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnInactive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnInactive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_OnActive") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_OnActive, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aExits") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_aExits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_timerEndTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_timerEndTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTimerHasJustStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTimerHasJustStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTimerHasJustStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTimerHasJustStopped);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsActiveTimerVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsActiveTimerVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisplayAsKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisplayAsKill);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreIfInactive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreIfInactive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCombinedDisplayInHud") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCombinedDisplayInHud);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCounterVisibleInTile") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCounterVisibleInTile);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTargetConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTargetConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTargetConditions[i];
		IContractObjective_STargetCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTargetConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectiveType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectiveType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBriefingName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBriefingName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObjectivesCounterCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObjectivesCounterCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sObjectivesCounterHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sObjectivesCounterHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObjectivesCounterDeactivate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObjectivesCounterDeactivate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_dObjectivesCounterExtraData") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->m_dObjectivesCounterExtraData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTimerHasStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTimerHasStopped);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceShowOnLoadingScreen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceShowOnLoadingScreen);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObjectivesCounterType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObjectivesCounterType);

	p_Stream << "}";
}

void SContractObjectiveStateMachineSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SContractObjectiveStateMachineSaveData s_Object {};

	{
		ZGuid s_Item {};
		ZGuid::FromSimpleJson(p_Document["m_Id"], &s_Item);
		s_Object.m_Id = s_Item;
	}

	s_Object.m_eCategory = static_cast<IContractObjective_Category>(ZHMEnums::GetEnumValueByName("IContractObjective.Category", std::string_view(p_Document["m_eCategory"])));

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sBriefingText"], &s_Item);
		s_Object.m_sBriefingText = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_sLongBriefingText"], &s_Item);
		s_Object.m_sLongBriefingText = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_Definition"], &s_Item);
		s_Object.m_Definition = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_aTargets"], &s_Item);
		s_Object.m_aTargets = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_aAllies"], &s_Item);
		s_Object.m_aAllies = s_Item;
	}

	s_Object.m_bTargetsHidden = simdjson::from_json_bool(p_Document["m_bTargetsHidden"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_HUDTmpl"], &s_Item);
		s_Object.m_HUDTmpl = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_ActivationCondition"], &s_Item);
		s_Object.m_ActivationCondition = s_Item;
	}

	s_Object.m_bActivationValue = simdjson::from_json_bool(p_Document["m_bActivationValue"]);

	s_Object.m_bUpdateActivationOnCompleted = simdjson::from_json_bool(p_Document["m_bUpdateActivationOnCompleted"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_OnInactive"], &s_Item);
		s_Object.m_OnInactive = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_OnActive"], &s_Item);
		s_Object.m_OnActive = s_Item;
	}

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_aExits"], &s_Item);
		s_Object.m_aExits = s_Item;
	}

	s_Object.m_timerEndTime = simdjson::from_json_float64(p_Document["m_timerEndTime"]);

	s_Object.m_bTimerHasJustStarted = simdjson::from_json_bool(p_Document["m_bTimerHasJustStarted"]);

	s_Object.m_bTimerHasJustStopped = simdjson::from_json_bool(p_Document["m_bTimerHasJustStopped"]);

	s_Object.m_bIsActiveTimerVisible = simdjson::from_json_bool(p_Document["m_bIsActiveTimerVisible"]);

	s_Object.m_bDisplayAsKill = simdjson::from_json_bool(p_Document["m_bDisplayAsKill"]);

	s_Object.m_bIgnoreIfInactive = simdjson::from_json_bool(p_Document["m_bIgnoreIfInactive"]);

	s_Object.m_bShowInHud = simdjson::from_json_bool(p_Document["m_bShowInHud"]);

	s_Object.m_bCombinedDisplayInHud = simdjson::from_json_bool(p_Document["m_bCombinedDisplayInHud"]);

	s_Object.m_bIsCounterVisibleInTile = simdjson::from_json_bool(p_Document["m_bIsCounterVisibleInTile"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTargetConditions"];
	s_Object.m_aTargetConditions.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		IContractObjective_STargetCondition s_ArrayItem0;
		IContractObjective_STargetCondition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTargetConditions[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_sImage = std::string_view(p_Document["m_sImage"]);

	s_Object.m_sObjectiveType = std::string_view(p_Document["m_sObjectiveType"]);

	s_Object.m_sBriefingName = std::string_view(p_Document["m_sBriefingName"]);

	s_Object.m_nObjectivesCounterCount = simdjson::from_json_int32(p_Document["m_nObjectivesCounterCount"]);

	s_Object.m_sObjectivesCounterHeader = std::string_view(p_Document["m_sObjectivesCounterHeader"]);

	s_Object.m_nObjectivesCounterDeactivate = simdjson::from_json_int32(p_Document["m_nObjectivesCounterDeactivate"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["m_dObjectivesCounterExtraData"], &s_Item);
		s_Object.m_dObjectivesCounterExtraData = s_Item;
	}

	s_Object.m_bTimerHasStopped = simdjson::from_json_bool(p_Document["m_bTimerHasStopped"]);

	s_Object.m_bForceShowOnLoadingScreen = simdjson::from_json_bool(p_Document["m_bForceShowOnLoadingScreen"]);

	s_Object.m_nObjectivesCounterType = simdjson::from_json_uint8(p_Document["m_nObjectivesCounterType"]);

	*reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Target) = s_Object;
}

void SContractObjectiveStateMachineSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Object);

	ZGuid::Serialize(&s_Object->m_Id, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_Id));
	ZDynamicObject::Serialize(&s_Object->m_sBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_sLongBriefingText, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sLongBriefingText));
	ZDynamicObject::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_State));
	ZDynamicObject::Serialize(&s_Object->m_Definition, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_Definition));
	ZDynamicObject::Serialize(&s_Object->m_aTargets, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_aTargets));
	ZDynamicObject::Serialize(&s_Object->m_aAllies, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_aAllies));
	ZDynamicObject::Serialize(&s_Object->m_HUDTmpl, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_HUDTmpl));
	ZDynamicObject::Serialize(&s_Object->m_ActivationCondition, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_ActivationCondition));
	ZDynamicObject::Serialize(&s_Object->m_OnInactive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_OnInactive));
	ZDynamicObject::Serialize(&s_Object->m_OnActive, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_OnActive));
	ZDynamicObject::Serialize(&s_Object->m_aExits, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_aExits));
	TArray<IContractObjective_STargetCondition>::Serialize(&s_Object->m_aTargetConditions, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_aTargetConditions));
	ZString::Serialize(&s_Object->m_sImage, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sImage));
	ZString::Serialize(&s_Object->m_sObjectiveType, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sObjectiveType));
	ZString::Serialize(&s_Object->m_sBriefingName, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sBriefingName));
	ZString::Serialize(&s_Object->m_sObjectivesCounterHeader, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_sObjectivesCounterHeader));
	ZDynamicObject::Serialize(&s_Object->m_dObjectivesCounterExtraData, p_Serializer, p_OwnOffset + offsetof(SContractObjectiveStateMachineSaveData, m_dObjectivesCounterExtraData));
}

bool SContractObjectiveStateMachineSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SContractObjectiveStateMachineSaveData::operator==(const SContractObjectiveStateMachineSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SContractObjectiveStateMachineSaveData>)
		return false;

	if (m_Id != p_Other.m_Id) return false;
	if (m_eCategory != p_Other.m_eCategory) return false;
	if (m_sBriefingText != p_Other.m_sBriefingText) return false;
	if (m_sLongBriefingText != p_Other.m_sLongBriefingText) return false;
	if (m_State != p_Other.m_State) return false;
	if (m_Definition != p_Other.m_Definition) return false;
	if (m_aTargets != p_Other.m_aTargets) return false;
	if (m_aAllies != p_Other.m_aAllies) return false;
	if (m_bTargetsHidden != p_Other.m_bTargetsHidden) return false;
	if (m_HUDTmpl != p_Other.m_HUDTmpl) return false;
	if (m_ActivationCondition != p_Other.m_ActivationCondition) return false;
	if (m_bActivationValue != p_Other.m_bActivationValue) return false;
	if (m_bUpdateActivationOnCompleted != p_Other.m_bUpdateActivationOnCompleted) return false;
	if (m_OnInactive != p_Other.m_OnInactive) return false;
	if (m_OnActive != p_Other.m_OnActive) return false;
	if (m_aExits != p_Other.m_aExits) return false;
	if (m_timerEndTime != p_Other.m_timerEndTime) return false;
	if (m_bTimerHasJustStarted != p_Other.m_bTimerHasJustStarted) return false;
	if (m_bTimerHasJustStopped != p_Other.m_bTimerHasJustStopped) return false;
	if (m_bIsActiveTimerVisible != p_Other.m_bIsActiveTimerVisible) return false;
	if (m_bDisplayAsKill != p_Other.m_bDisplayAsKill) return false;
	if (m_bIgnoreIfInactive != p_Other.m_bIgnoreIfInactive) return false;
	if (m_bShowInHud != p_Other.m_bShowInHud) return false;
	if (m_bCombinedDisplayInHud != p_Other.m_bCombinedDisplayInHud) return false;
	if (m_bIsCounterVisibleInTile != p_Other.m_bIsCounterVisibleInTile) return false;
	if (m_aTargetConditions != p_Other.m_aTargetConditions) return false;
	if (m_sImage != p_Other.m_sImage) return false;
	if (m_sObjectiveType != p_Other.m_sObjectiveType) return false;
	if (m_sBriefingName != p_Other.m_sBriefingName) return false;
	if (m_nObjectivesCounterCount != p_Other.m_nObjectivesCounterCount) return false;
	if (m_sObjectivesCounterHeader != p_Other.m_sObjectivesCounterHeader) return false;
	if (m_nObjectivesCounterDeactivate != p_Other.m_nObjectivesCounterDeactivate) return false;
	if (m_dObjectivesCounterExtraData != p_Other.m_dObjectivesCounterExtraData) return false;
	if (m_bTimerHasStopped != p_Other.m_bTimerHasStopped) return false;
	if (m_bForceShowOnLoadingScreen != p_Other.m_bForceShowOnLoadingScreen) return false;
	if (m_nObjectivesCounterType != p_Other.m_nObjectivesCounterType) return false;

	return true;
}

void SContractObjectiveStateMachineSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SContractObjectiveStateMachineSaveData*>(p_Object);
	s_Object->~SContractObjectiveStateMachineSaveData();
}

ZHMTypeInfo SConversationEntry::TypeInfo = ZHMTypeInfo("SConversationEntry", sizeof(SConversationEntry), alignof(SConversationEntry), SConversationEntry::WriteSimpleJson, SConversationEntry::FromSimpleJson, SConversationEntry::Serialize, SConversationEntry::Equals, SConversationEntry::Destroy);

void SConversationEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConversationEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_role") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EConversationRole", static_cast<int>(s_Object->m_role)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sound") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorSoundDefs", static_cast<int>(s_Object->m_sound)));

	p_Stream << "}";
}

void SConversationEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SConversationEntry s_Object {};

	s_Object.m_role = static_cast<EConversationRole>(ZHMEnums::GetEnumValueByName("EConversationRole", std::string_view(p_Document["m_role"])));

	s_Object.m_sound = static_cast<EActorSoundDefs>(ZHMEnums::GetEnumValueByName("EActorSoundDefs", std::string_view(p_Document["m_sound"])));

	*reinterpret_cast<SConversationEntry*>(p_Target) = s_Object;
}

void SConversationEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConversationEntry*>(p_Object);

}

bool SConversationEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConversationEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SConversationEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConversationEntry::operator==(const SConversationEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConversationEntry>)
		return false;

	if (m_role != p_Other.m_role) return false;
	if (m_sound != p_Other.m_sound) return false;

	return true;
}

void SConversationEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SConversationEntry*>(p_Object);
	s_Object->~SConversationEntry();
}

ZHMTypeInfo SConversationPart::TypeInfo = ZHMTypeInfo("SConversationPart", sizeof(SConversationPart), alignof(SConversationPart), SConversationPart::WriteSimpleJson, SConversationPart::FromSimpleJson, SConversationPart::Serialize, SConversationPart::Equals, SConversationPart::Destroy);

void SConversationPart::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SConversationPart*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_chance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_chance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_entries") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_entries.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_entries[i];
		SConversationEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_entries.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SConversationPart::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SConversationPart s_Object {};

	s_Object.m_chance = simdjson::from_json_float32(p_Document["m_chance"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_entries"];
	s_Object.m_entries.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SConversationEntry s_ArrayItem0;
		SConversationEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_entries[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SConversationPart*>(p_Target) = s_Object;
}

void SConversationPart::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SConversationPart*>(p_Object);

	TArray<SConversationEntry>::Serialize(&s_Object->m_entries, p_Serializer, p_OwnOffset + offsetof(SConversationPart, m_entries));
}

bool SConversationPart::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SConversationPart*>(p_Left);
	auto* s_Right = reinterpret_cast<SConversationPart*>(p_Right);

	return *s_Left == *s_Right;
}

bool SConversationPart::operator==(const SConversationPart& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SConversationPart>)
		return false;

	if (m_chance != p_Other.m_chance) return false;
	if (m_entries != p_Other.m_entries) return false;

	return true;
}

void SConversationPart::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SConversationPart*>(p_Object);
	s_Object->~SConversationPart();
}

ZHMTypeInfo SEntityTemplateProperty::TypeInfo = ZHMTypeInfo("SEntityTemplateProperty", sizeof(SEntityTemplateProperty), alignof(SEntityTemplateProperty), SEntityTemplateProperty::WriteSimpleJson, SEntityTemplateProperty::FromSimpleJson, SEntityTemplateProperty::Serialize, SEntityTemplateProperty::Equals, SEntityTemplateProperty::Destroy);

void SEntityTemplateProperty::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nPropertyID") << ":";
	{
		auto s_PropertyName = ZHMProperties::PropertyToString(s_Object->nPropertyID);

		if (s_PropertyName.size() == 0)
			p_Stream << simdjson::as_json_string(s_Object->nPropertyID);
		else
			p_Stream << simdjson::as_json_string(s_PropertyName);
	}
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->value, p_Stream);

	p_Stream << "}";
}

void SEntityTemplateProperty::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateProperty s_Object {};

	if (p_Document["nPropertyID"].type() == simdjson::ondemand::json_type::string)
		s_Object.nPropertyID = Hash::Crc32(std::string_view(p_Document["nPropertyID"]));
	else
		s_Object.nPropertyID = simdjson::from_json_uint32(p_Document["nPropertyID"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["value"], &s_Item);
		s_Object.value = s_Item;
	}

	*reinterpret_cast<SEntityTemplateProperty*>(p_Target) = s_Object;
}

void SEntityTemplateProperty::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);

	ZVariant::Serialize(&s_Object->value, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateProperty, value));
}

bool SEntityTemplateProperty::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateProperty*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateProperty*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateProperty::operator==(const SEntityTemplateProperty& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateProperty>)
		return false;

	if (nPropertyID != p_Other.nPropertyID) return false;
	if (value != p_Other.value) return false;

	return true;
}

void SEntityTemplateProperty::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateProperty*>(p_Object);
	s_Object->~SEntityTemplateProperty();
}

ZHMTypeInfo SCppEntity::TypeInfo = ZHMTypeInfo("SCppEntity", sizeof(SCppEntity), alignof(SCppEntity), SCppEntity::WriteSimpleJson, SCppEntity::FromSimpleJson, SCppEntity::Serialize, SCppEntity::Equals, SCppEntity::Destroy);

void SCppEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntity s_Object {};

	s_Object.blueprintIndexInResourceHeader = simdjson::from_json_int32(p_Document["blueprintIndexInResourceHeader"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyValues"];
	s_Object.propertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyValues[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCppEntity*>(p_Target) = s_Object;
}

void SCppEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);

	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(SCppEntity, propertyValues));
}

bool SCppEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntity::operator==(const SCppEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntity>)
		return false;

	if (blueprintIndexInResourceHeader != p_Other.blueprintIndexInResourceHeader) return false;
	if (propertyValues != p_Other.propertyValues) return false;

	return true;
}

void SCppEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCppEntity*>(p_Object);
	s_Object->~SCppEntity();
}

ZHMTypeInfo SCppEntitySubsetInfo::TypeInfo = ZHMTypeInfo("SCppEntitySubsetInfo", sizeof(SCppEntitySubsetInfo), alignof(SCppEntitySubsetInfo), SCppEntitySubsetInfo::WriteSimpleJson, SCppEntitySubsetInfo::FromSimpleJson, SCppEntitySubsetInfo::Serialize, SCppEntitySubsetInfo::Equals, SCppEntitySubsetInfo::Destroy);

void SCppEntitySubsetInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("name") << ":";
	p_Stream << simdjson::as_json_string(s_Object->name);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("flags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->flags);

	p_Stream << "}";
}

void SCppEntitySubsetInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntitySubsetInfo s_Object {};

	s_Object.name = std::string_view(p_Document["name"]);

	s_Object.flags = simdjson::from_json_uint32(p_Document["flags"]);

	*reinterpret_cast<SCppEntitySubsetInfo*>(p_Target) = s_Object;
}

void SCppEntitySubsetInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);

	ZString::Serialize(&s_Object->name, p_Serializer, p_OwnOffset + offsetof(SCppEntitySubsetInfo, name));
}

bool SCppEntitySubsetInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntitySubsetInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntitySubsetInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntitySubsetInfo::operator==(const SCppEntitySubsetInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntitySubsetInfo>)
		return false;

	if (name != p_Other.name) return false;
	if (flags != p_Other.flags) return false;

	return true;
}

void SCppEntitySubsetInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCppEntitySubsetInfo*>(p_Object);
	s_Object->~SCppEntitySubsetInfo();
}

ZHMTypeInfo SCppEntityBlueprint::TypeInfo = ZHMTypeInfo("SCppEntityBlueprint", sizeof(SCppEntityBlueprint), alignof(SCppEntityBlueprint), SCppEntityBlueprint::WriteSimpleJson, SCppEntityBlueprint::FromSimpleJson, SCppEntityBlueprint::Serialize, SCppEntityBlueprint::Equals, SCppEntityBlueprint::Destroy);

void SCppEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("typeName") << ":";
	TypeID::WriteSimpleJson(&s_Object->typeName, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("typeFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->typeFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->subsets[i];
		SCppEntitySubsetInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->subsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCppEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCppEntityBlueprint s_Object {};

	{
		TypeID s_Item {};
		TypeID::FromSimpleJson(p_Document["typeName"], &s_Item);
		s_Object.typeName = s_Item;
	}

	s_Object.typeFlags = simdjson::from_json_uint32(p_Document["typeFlags"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["subsets"];
	s_Object.subsets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCppEntitySubsetInfo s_ArrayItem0;
		SCppEntitySubsetInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.subsets[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCppEntityBlueprint*>(p_Target) = s_Object;
}

void SCppEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);

	TypeID::Serialize(&s_Object->typeName, p_Serializer, p_OwnOffset + offsetof(SCppEntityBlueprint, typeName));
	TArray<SCppEntitySubsetInfo>::Serialize(&s_Object->subsets, p_Serializer, p_OwnOffset + offsetof(SCppEntityBlueprint, subsets));
}

bool SCppEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCppEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<SCppEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCppEntityBlueprint::operator==(const SCppEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCppEntityBlueprint>)
		return false;

	if (typeName != p_Other.typeName) return false;
	if (typeFlags != p_Other.typeFlags) return false;
	if (subsets != p_Other.subsets) return false;

	return true;
}

void SCppEntityBlueprint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCppEntityBlueprint*>(p_Object);
	s_Object->~SCppEntityBlueprint();
}

ZHMTypeInfo SRunningCrowdAIEventSaveData::TypeInfo = ZHMTypeInfo("SRunningCrowdAIEventSaveData", sizeof(SRunningCrowdAIEventSaveData), alignof(SRunningCrowdAIEventSaveData), SRunningCrowdAIEventSaveData::WriteSimpleJson, SRunningCrowdAIEventSaveData::FromSimpleJson, SRunningCrowdAIEventSaveData::Serialize, SRunningCrowdAIEventSaveData::Equals, SRunningCrowdAIEventSaveData::Destroy);

void SRunningCrowdAIEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRunningCrowdAIEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ReactionEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_ReactionEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CrowdEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CrowdEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HitmanToBlame") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_HitmanToBlame);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CrowdCoreIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CrowdCoreIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TimeLeft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_TimeLeft);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TimeToPulse") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_TimeToPulse);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Position") << ":";
	float4::WriteSimpleJson(&s_Object->m_Position, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IsInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IsInvestigated);

	p_Stream << "}";
}

void SRunningCrowdAIEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRunningCrowdAIEventSaveData s_Object {};

	s_Object.m_ReactionEntity = simdjson::from_json_uint32(p_Document["m_ReactionEntity"]);

	s_Object.m_CrowdEntity = simdjson::from_json_uint32(p_Document["m_CrowdEntity"]);

	s_Object.m_HitmanToBlame = simdjson::from_json_uint32(p_Document["m_HitmanToBlame"]);

	s_Object.m_CrowdCoreIndex = simdjson::from_json_int32(p_Document["m_CrowdCoreIndex"]);

	s_Object.m_TimeLeft = simdjson::from_json_float32(p_Document["m_TimeLeft"]);

	s_Object.m_TimeToPulse = simdjson::from_json_float32(p_Document["m_TimeToPulse"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_Position"], &s_Item);
		s_Object.m_Position = s_Item;
	}

	s_Object.m_IsInvestigated = simdjson::from_json_bool(p_Document["m_IsInvestigated"]);

	*reinterpret_cast<SRunningCrowdAIEventSaveData*>(p_Target) = s_Object;
}

void SRunningCrowdAIEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRunningCrowdAIEventSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_Position, p_Serializer, p_OwnOffset + offsetof(SRunningCrowdAIEventSaveData, m_Position));
}

bool SRunningCrowdAIEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRunningCrowdAIEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRunningCrowdAIEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRunningCrowdAIEventSaveData::operator==(const SRunningCrowdAIEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRunningCrowdAIEventSaveData>)
		return false;

	if (m_ReactionEntity != p_Other.m_ReactionEntity) return false;
	if (m_CrowdEntity != p_Other.m_CrowdEntity) return false;
	if (m_HitmanToBlame != p_Other.m_HitmanToBlame) return false;
	if (m_CrowdCoreIndex != p_Other.m_CrowdCoreIndex) return false;
	if (m_TimeLeft != p_Other.m_TimeLeft) return false;
	if (m_TimeToPulse != p_Other.m_TimeToPulse) return false;
	if (m_Position != p_Other.m_Position) return false;
	if (m_IsInvestigated != p_Other.m_IsInvestigated) return false;

	return true;
}

void SRunningCrowdAIEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRunningCrowdAIEventSaveData*>(p_Object);
	s_Object->~SRunningCrowdAIEventSaveData();
}

ZHMTypeInfo SCrowdAIEventSaveData::TypeInfo = ZHMTypeInfo("SCrowdAIEventSaveData", sizeof(SCrowdAIEventSaveData), alignof(SCrowdAIEventSaveData), SCrowdAIEventSaveData::WriteSimpleJson, SCrowdAIEventSaveData::FromSimpleJson, SCrowdAIEventSaveData::Serialize, SCrowdAIEventSaveData::Equals, SCrowdAIEventSaveData::Destroy);

void SCrowdAIEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdAIEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_RunningEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_RunningEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_RunningEvents[i];
		SRunningCrowdAIEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_RunningEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdAIEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdAIEventSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_RunningEvents"];
	s_Object.m_RunningEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SRunningCrowdAIEventSaveData s_ArrayItem0;
		SRunningCrowdAIEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_RunningEvents[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCrowdAIEventSaveData*>(p_Target) = s_Object;
}

void SCrowdAIEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdAIEventSaveData*>(p_Object);

	TArray<SRunningCrowdAIEventSaveData>::Serialize(&s_Object->m_RunningEvents, p_Serializer, p_OwnOffset + offsetof(SCrowdAIEventSaveData, m_RunningEvents));
}

bool SCrowdAIEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdAIEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdAIEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdAIEventSaveData::operator==(const SCrowdAIEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdAIEventSaveData>)
		return false;

	if (m_RunningEvents != p_Other.m_RunningEvents) return false;

	return true;
}

void SCrowdAIEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdAIEventSaveData*>(p_Object);
	s_Object->~SCrowdAIEventSaveData();
}

ZHMTypeInfo SCrowdActivitySaveData::TypeInfo = ZHMTypeInfo("SCrowdActivitySaveData", sizeof(SCrowdActivitySaveData), alignof(SCrowdActivitySaveData), SCrowdActivitySaveData::WriteSimpleJson, SCrowdActivitySaveData::FromSimpleJson, SCrowdActivitySaveData::Serialize, SCrowdActivitySaveData::Equals, SCrowdActivitySaveData::Destroy);

void SCrowdActivitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGait") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_eGait)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxEnterDelaySec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxEnterDelaySec);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMaxLeaveDelaySec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMaxLeaveDelaySec);

	p_Stream << "}";
}

void SCrowdActivitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdActivitySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_eGait = static_cast<EGait>(ZHMEnums::GetEnumValueByName("EGait", std::string_view(p_Document["m_eGait"])));

	s_Object.m_nMaxEnterDelaySec = simdjson::from_json_float32(p_Document["m_nMaxEnterDelaySec"]);

	s_Object.m_nMaxLeaveDelaySec = simdjson::from_json_float32(p_Document["m_nMaxLeaveDelaySec"]);

	*reinterpret_cast<SCrowdActivitySaveData*>(p_Target) = s_Object;
}

void SCrowdActivitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);

}

bool SCrowdActivitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdActivitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdActivitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdActivitySaveData::operator==(const SCrowdActivitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdActivitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_eGait != p_Other.m_eGait) return false;
	if (m_nMaxEnterDelaySec != p_Other.m_nMaxEnterDelaySec) return false;
	if (m_nMaxLeaveDelaySec != p_Other.m_nMaxLeaveDelaySec) return false;

	return true;
}

void SCrowdActivitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdActivitySaveData*>(p_Object);
	s_Object->~SCrowdActivitySaveData();
}

ZHMTypeInfo SCrowdActorSaveData::TypeInfo = ZHMTypeInfo("SCrowdActorSaveData", sizeof(SCrowdActorSaveData), alignof(SCrowdActorSaveData), SCrowdActorSaveData::WriteSimpleJson, SCrowdActorSaveData::FromSimpleJson, SCrowdActorSaveData::Serialize, SCrowdActorSaveData::Equals, SCrowdActorSaveData::Destroy);

void SCrowdActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eWantedSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESpeed", static_cast<int>(s_Object->m_eWantedSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eWantedGait") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_eWantedGait)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAnimSourceID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAnimSourceID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAnimSourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAnimSourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vForward") << ":";
	float4::WriteSimpleJson(&s_Object->m_vForward, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMood") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("CrowdUtil.ECrowdActorMood", static_cast<int>(s_Object->m_eMood)));

	p_Stream << "}";
}

void SCrowdActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdActorSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_eWantedSpeed = static_cast<ESpeed>(ZHMEnums::GetEnumValueByName("ESpeed", std::string_view(p_Document["m_eWantedSpeed"])));

	s_Object.m_eWantedGait = static_cast<EGait>(ZHMEnums::GetEnumValueByName("EGait", std::string_view(p_Document["m_eWantedGait"])));

	s_Object.m_nAnimSourceID = simdjson::from_json_uint32(p_Document["m_nAnimSourceID"]);

	s_Object.m_nAnimSourceIndex = simdjson::from_json_uint32(p_Document["m_nAnimSourceIndex"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vForward"], &s_Item);
		s_Object.m_vForward = s_Item;
	}

	s_Object.m_fSpeed = simdjson::from_json_float32(p_Document["m_fSpeed"]);

	s_Object.m_eMood = static_cast<CrowdUtil_ECrowdActorMood>(ZHMEnums::GetEnumValueByName("CrowdUtil.ECrowdActorMood", std::string_view(p_Document["m_eMood"])));

	*reinterpret_cast<SCrowdActorSaveData*>(p_Target) = s_Object;
}

void SCrowdActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SCrowdActorSaveData, m_vPosition));
	float4::Serialize(&s_Object->m_vForward, p_Serializer, p_OwnOffset + offsetof(SCrowdActorSaveData, m_vForward));
}

bool SCrowdActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdActorSaveData::operator==(const SCrowdActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdActorSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_eWantedSpeed != p_Other.m_eWantedSpeed) return false;
	if (m_eWantedGait != p_Other.m_eWantedGait) return false;
	if (m_nAnimSourceID != p_Other.m_nAnimSourceID) return false;
	if (m_nAnimSourceIndex != p_Other.m_nAnimSourceIndex) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vForward != p_Other.m_vForward) return false;
	if (m_fSpeed != p_Other.m_fSpeed) return false;
	if (m_eMood != p_Other.m_eMood) return false;

	return true;
}

void SCrowdActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdActorSaveData*>(p_Object);
	s_Object->~SCrowdActorSaveData();
}

ZHMTypeInfo SCrowdBodySaveData::TypeInfo = ZHMTypeInfo("SCrowdBodySaveData", sizeof(SCrowdBodySaveData), alignof(SCrowdBodySaveData), SCrowdBodySaveData::WriteSimpleJson, SCrowdBodySaveData::FromSimpleJson, SCrowdBodySaveData::Serialize, SCrowdBodySaveData::Equals, SCrowdBodySaveData::Destroy);

void SCrowdBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pCorpseBodybagEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCorpseBodybagEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCrowdEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCrowdEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iActorIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPerceptibleEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPerceptibleEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKnownBy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKnownBy.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKnownBy[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKnownBy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bManaged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bManaged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBagSharedKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBagSharedKnowledge);

	p_Stream << "}";
}

void SCrowdBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdBodySaveData s_Object {};

	s_Object.m_pCorpseBodybagEntity = simdjson::from_json_uint32(p_Document["m_pCorpseBodybagEntity"]);

	s_Object.m_rCrowdEntity = simdjson::from_json_uint32(p_Document["m_rCrowdEntity"]);

	s_Object.m_iActorIndex = simdjson::from_json_uint16(p_Document["m_iActorIndex"]);

	s_Object.m_rPerceptibleEntity = simdjson::from_json_uint32(p_Document["m_rPerceptibleEntity"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKnownBy"];
	s_Object.m_aKnownBy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aKnownBy[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Item);
		s_Object.m_tStart = s_Item;
	}

	s_Object.m_bManaged = simdjson::from_json_bool(p_Document["m_bManaged"]);

	s_Object.m_rBagSharedKnowledge = simdjson::from_json_int32(p_Document["m_rBagSharedKnowledge"]);

	*reinterpret_cast<SCrowdBodySaveData*>(p_Target) = s_Object;
}

void SCrowdBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aKnownBy, p_Serializer, p_OwnOffset + offsetof(SCrowdBodySaveData, m_aKnownBy));
	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SCrowdBodySaveData, m_tStart));
}

bool SCrowdBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdBodySaveData::operator==(const SCrowdBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdBodySaveData>)
		return false;

	if (m_pCorpseBodybagEntity != p_Other.m_pCorpseBodybagEntity) return false;
	if (m_rCrowdEntity != p_Other.m_rCrowdEntity) return false;
	if (m_iActorIndex != p_Other.m_iActorIndex) return false;
	if (m_rPerceptibleEntity != p_Other.m_rPerceptibleEntity) return false;
	if (m_aKnownBy != p_Other.m_aKnownBy) return false;
	if (m_tStart != p_Other.m_tStart) return false;
	if (m_bManaged != p_Other.m_bManaged) return false;
	if (m_rBagSharedKnowledge != p_Other.m_rBagSharedKnowledge) return false;

	return true;
}

void SCrowdBodySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdBodySaveData*>(p_Object);
	s_Object->~SCrowdBodySaveData();
}

ZHMTypeInfo SCrowdCells::TypeInfo = ZHMTypeInfo("SCrowdCells", sizeof(SCrowdCells), alignof(SCrowdCells), SCrowdCells::WriteSimpleJson, SCrowdCells::FromSimpleJson, SCrowdCells::Serialize, SCrowdCells::Equals, SCrowdCells::Destroy);

void SCrowdCells::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_cells") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_cells.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_cells[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_cells.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdCells::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdCells s_Object {};

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["m_cells"])
	{
		s_Object.m_cells[s_Index0] = simdjson::from_json_uint8(s_Item0);
		++s_Index0;
	}
	}

	*reinterpret_cast<SCrowdCells*>(p_Target) = s_Object;
}

void SCrowdCells::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);

	TFixedArray<uint8, 128>::Serialize(&s_Object->m_cells, p_Serializer, p_OwnOffset + offsetof(SCrowdCells, m_cells));
}

bool SCrowdCells::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdCells*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdCells*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdCells::operator==(const SCrowdCells& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdCells>)
		return false;

	if (m_cells != p_Other.m_cells) return false;

	return true;
}

void SCrowdCells::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdCells*>(p_Object);
	s_Object->~SCrowdCells();
}

ZHMTypeInfo SCrowdPoseBoneSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseBoneSaveData", sizeof(SCrowdPoseBoneSaveData), alignof(SCrowdPoseBoneSaveData), SCrowdPoseBoneSaveData::WriteSimpleJson, SCrowdPoseBoneSaveData::FromSimpleJson, SCrowdPoseBoneSaveData::Serialize, SCrowdPoseBoneSaveData::Equals, SCrowdPoseBoneSaveData::Destroy);

void SCrowdPoseBoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mQuaterion") << ":";
	SVector4::WriteSimpleJson(&s_Object->mQuaterion, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mTranslation") << ":";
	SVector4::WriteSimpleJson(&s_Object->mTranslation, p_Stream);

	p_Stream << "}";
}

void SCrowdPoseBoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdPoseBoneSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mQuaterion"], &s_Item);
		s_Object.mQuaterion = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["mTranslation"], &s_Item);
		s_Object.mTranslation = s_Item;
	}

	*reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Target) = s_Object;
}

void SCrowdPoseBoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->mQuaterion, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseBoneSaveData, mQuaterion));
	SVector4::Serialize(&s_Object->mTranslation, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseBoneSaveData, mTranslation));
}

bool SCrowdPoseBoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseBoneSaveData::operator==(const SCrowdPoseBoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseBoneSaveData>)
		return false;

	if (mQuaterion != p_Other.mQuaterion) return false;
	if (mTranslation != p_Other.mTranslation) return false;

	return true;
}

void SCrowdPoseBoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseBoneSaveData*>(p_Object);
	s_Object->~SCrowdPoseBoneSaveData();
}

ZHMTypeInfo SCrowdPoseSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseSaveData", sizeof(SCrowdPoseSaveData), alignof(SCrowdPoseSaveData), SCrowdPoseSaveData::WriteSimpleJson, SCrowdPoseSaveData::FromSimpleJson, SCrowdPoseSaveData::Serialize, SCrowdPoseSaveData::Equals, SCrowdPoseSaveData::Destroy);

void SCrowdPoseSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBones[i];
		SCrowdPoseBoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdPoseSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdPoseSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBones"];
	s_Object.m_aBones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdPoseBoneSaveData s_ArrayItem0;
		SCrowdPoseBoneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBones[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCrowdPoseSaveData*>(p_Target) = s_Object;
}

void SCrowdPoseSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);

	TArray<SCrowdPoseBoneSaveData>::Serialize(&s_Object->m_aBones, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseSaveData, m_aBones));
}

bool SCrowdPoseSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseSaveData::operator==(const SCrowdPoseSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseSaveData>)
		return false;

	if (m_aBones != p_Other.m_aBones) return false;

	return true;
}

void SCrowdPoseSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseSaveData*>(p_Object);
	s_Object->~SCrowdPoseSaveData();
}

ZHMTypeInfo SCrowdPoseCollectionSaveData::TypeInfo = ZHMTypeInfo("SCrowdPoseCollectionSaveData", sizeof(SCrowdPoseCollectionSaveData), alignof(SCrowdPoseCollectionSaveData), SCrowdPoseCollectionSaveData::WriteSimpleJson, SCrowdPoseCollectionSaveData::FromSimpleJson, SCrowdPoseCollectionSaveData::Serialize, SCrowdPoseCollectionSaveData::Equals, SCrowdPoseCollectionSaveData::Destroy);

void SCrowdPoseCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_id") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_id);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPoses") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPoses.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPoses[i];
		SCrowdPoseSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPoses.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdPoseCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdPoseCollectionSaveData s_Object {};

	s_Object.m_id = simdjson::from_json_uint64(p_Document["m_id"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPoses"];
	s_Object.m_aPoses.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdPoseSaveData s_ArrayItem0;
		SCrowdPoseSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aPoses[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Target) = s_Object;
}

void SCrowdPoseCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);

	TArray<SCrowdPoseSaveData>::Serialize(&s_Object->m_aPoses, p_Serializer, p_OwnOffset + offsetof(SCrowdPoseCollectionSaveData, m_aPoses));
}

bool SCrowdPoseCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdPoseCollectionSaveData::operator==(const SCrowdPoseCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdPoseCollectionSaveData>)
		return false;

	if (m_id != p_Other.m_id) return false;
	if (m_aPoses != p_Other.m_aPoses) return false;

	return true;
}

void SCrowdPoseCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdPoseCollectionSaveData*>(p_Object);
	s_Object->~SCrowdPoseCollectionSaveData();
}

ZHMTypeInfo SCrowdDeadPoseRepositorySaveData::TypeInfo = ZHMTypeInfo("SCrowdDeadPoseRepositorySaveData", sizeof(SCrowdDeadPoseRepositorySaveData), alignof(SCrowdDeadPoseRepositorySaveData), SCrowdDeadPoseRepositorySaveData::WriteSimpleJson, SCrowdDeadPoseRepositorySaveData::FromSimpleJson, SCrowdDeadPoseRepositorySaveData::Serialize, SCrowdDeadPoseRepositorySaveData::Equals, SCrowdDeadPoseRepositorySaveData::Destroy);

void SCrowdDeadPoseRepositorySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aPoseCollections") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPoseCollections.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPoseCollections[i];
		SCrowdPoseCollectionSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPoseCollections.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdDeadPoseRepositorySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdDeadPoseRepositorySaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPoseCollections"];
	s_Object.m_aPoseCollections.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdPoseCollectionSaveData s_ArrayItem0;
		SCrowdPoseCollectionSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aPoseCollections[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Target) = s_Object;
}

void SCrowdDeadPoseRepositorySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);

	TArray<SCrowdPoseCollectionSaveData>::Serialize(&s_Object->m_aPoseCollections, p_Serializer, p_OwnOffset + offsetof(SCrowdDeadPoseRepositorySaveData, m_aPoseCollections));
}

bool SCrowdDeadPoseRepositorySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdDeadPoseRepositorySaveData::operator==(const SCrowdDeadPoseRepositorySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdDeadPoseRepositorySaveData>)
		return false;

	if (m_aPoseCollections != p_Other.m_aPoseCollections) return false;

	return true;
}

void SCrowdDeadPoseRepositorySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdDeadPoseRepositorySaveData*>(p_Object);
	s_Object->~SCrowdDeadPoseRepositorySaveData();
}

ZHMTypeInfo SRegionSaveData::TypeInfo = ZHMTypeInfo("SRegionSaveData", sizeof(SRegionSaveData), alignof(SRegionSaveData), SRegionSaveData::WriteSimpleJson, SRegionSaveData::FromSimpleJson, SRegionSaveData::Serialize, SRegionSaveData::Equals, SRegionSaveData::Destroy);

void SRegionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("CrowdRegionType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCenter") << ":";
	float4::WriteSimpleJson(&s_Object->m_vCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDirection") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDirection);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRadius);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLifetime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLifetime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleActorIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleActorIndex);

	p_Stream << "}";
}

void SRegionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRegionSaveData s_Object {};

	s_Object.m_nIndex = simdjson::from_json_uint32(p_Document["m_nIndex"]);

	s_Object.m_eType = static_cast<CrowdRegionType>(ZHMEnums::GetEnumValueByName("CrowdRegionType", std::string_view(p_Document["m_eType"])));

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vCenter"], &s_Item);
		s_Object.m_vCenter = s_Item;
	}

	s_Object.m_nDirection = simdjson::from_json_float32(p_Document["m_nDirection"]);

	s_Object.m_nRadius = simdjson::from_json_float32(p_Document["m_nRadius"]);

	s_Object.m_nAngle = simdjson::from_json_uint32(p_Document["m_nAngle"]);

	s_Object.m_nLifetime = simdjson::from_json_float32(p_Document["m_nLifetime"]);

	s_Object.m_nAge = simdjson::from_json_float32(p_Document["m_nAge"]);

	s_Object.m_nGroupID = simdjson::from_json_uint8(p_Document["m_nGroupID"]);

	s_Object.m_nObstacleActorIndex = simdjson::from_json_int16(p_Document["m_nObstacleActorIndex"]);

	*reinterpret_cast<SRegionSaveData*>(p_Target) = s_Object;
}

void SRegionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vCenter, p_Serializer, p_OwnOffset + offsetof(SRegionSaveData, m_vCenter));
}

bool SRegionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRegionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRegionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRegionSaveData::operator==(const SRegionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRegionSaveData>)
		return false;

	if (m_nIndex != p_Other.m_nIndex) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_vCenter != p_Other.m_vCenter) return false;
	if (m_nDirection != p_Other.m_nDirection) return false;
	if (m_nRadius != p_Other.m_nRadius) return false;
	if (m_nAngle != p_Other.m_nAngle) return false;
	if (m_nLifetime != p_Other.m_nLifetime) return false;
	if (m_nAge != p_Other.m_nAge) return false;
	if (m_nGroupID != p_Other.m_nGroupID) return false;
	if (m_nObstacleActorIndex != p_Other.m_nObstacleActorIndex) return false;

	return true;
}

void SRegionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRegionSaveData*>(p_Object);
	s_Object->~SRegionSaveData();
}

ZHMTypeInfo SCrowdEntitySaveData::TypeInfo = ZHMTypeInfo("SCrowdEntitySaveData", sizeof(SCrowdEntitySaveData), alignof(SCrowdEntitySaveData), SCrowdEntitySaveData::WriteSimpleJson, SCrowdEntitySaveData::FromSimpleJson, SCrowdEntitySaveData::Serialize, SCrowdEntitySaveData::Equals, SCrowdEntitySaveData::Destroy);

void SCrowdEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CrowdActorData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CrowdActorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CrowdActorData[i];
		SCrowdActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CrowdActorData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RegionData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_RegionData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_RegionData[i];
		SRegionSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_RegionData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCrowdAmbient") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCrowdAmbient);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DeadPoseRepository") << ":";
	SCrowdDeadPoseRepositorySaveData::WriteSimpleJson(&s_Object->m_DeadPoseRepository, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCrowdAiPoolActorsMale") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrowdAiPoolActorsMale.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrowdAiPoolActorsMale[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCrowdAiPoolActorsMale.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aCrowdAiPoolActorsFemale") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCrowdAiPoolActorsFemale.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCrowdAiPoolActorsFemale[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aCrowdAiPoolActorsFemale.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdEntitySaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CrowdActorData"];
	s_Object.m_CrowdActorData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdActorSaveData s_ArrayItem0;
		SCrowdActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CrowdActorData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_RegionData"];
	s_Object.m_RegionData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SRegionSaveData s_ArrayItem0;
		SRegionSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_RegionData[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_bIsCrowdAmbient = simdjson::from_json_bool(p_Document["m_bIsCrowdAmbient"]);

	{
		SCrowdDeadPoseRepositorySaveData s_Item {};
		SCrowdDeadPoseRepositorySaveData::FromSimpleJson(p_Document["m_DeadPoseRepository"], &s_Item);
		s_Object.m_DeadPoseRepository = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCrowdAiPoolActorsMale"];
	s_Object.m_aCrowdAiPoolActorsMale.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aCrowdAiPoolActorsMale[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCrowdAiPoolActorsFemale"];
	s_Object.m_aCrowdAiPoolActorsFemale.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aCrowdAiPoolActorsFemale[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SCrowdEntitySaveData*>(p_Target) = s_Object;
}

void SCrowdEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);

	TArray<SCrowdActorSaveData>::Serialize(&s_Object->m_CrowdActorData, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_CrowdActorData));
	TArray<SRegionSaveData>::Serialize(&s_Object->m_RegionData, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_RegionData));
	SCrowdDeadPoseRepositorySaveData::Serialize(&s_Object->m_DeadPoseRepository, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_DeadPoseRepository));
	TArray<uint32>::Serialize(&s_Object->m_aCrowdAiPoolActorsMale, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_aCrowdAiPoolActorsMale));
	TArray<uint32>::Serialize(&s_Object->m_aCrowdAiPoolActorsFemale, p_Serializer, p_OwnOffset + offsetof(SCrowdEntitySaveData, m_aCrowdAiPoolActorsFemale));
}

bool SCrowdEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdEntitySaveData::operator==(const SCrowdEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdEntitySaveData>)
		return false;

	if (m_CrowdActorData != p_Other.m_CrowdActorData) return false;
	if (m_RegionData != p_Other.m_RegionData) return false;
	if (m_bIsCrowdAmbient != p_Other.m_bIsCrowdAmbient) return false;
	if (m_DeadPoseRepository != p_Other.m_DeadPoseRepository) return false;
	if (m_aCrowdAiPoolActorsMale != p_Other.m_aCrowdAiPoolActorsMale) return false;
	if (m_aCrowdAiPoolActorsFemale != p_Other.m_aCrowdAiPoolActorsFemale) return false;

	return true;
}

void SCrowdEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdEntitySaveData*>(p_Object);
	s_Object->~SCrowdEntitySaveData();
}

ZHMTypeInfo SCrowdFlowChannel::TypeInfo = ZHMTypeInfo("SCrowdFlowChannel", sizeof(SCrowdFlowChannel), alignof(SCrowdFlowChannel), SCrowdFlowChannel::WriteSimpleJson, SCrowdFlowChannel::FromSimpleJson, SCrowdFlowChannel::Serialize, SCrowdFlowChannel::Equals, SCrowdFlowChannel::Destroy);

void SCrowdFlowChannel::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aFlowVectorIndex") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowVectorIndex.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowVectorIndex[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFlowVectorIndex.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowCost") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowCost.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowCost[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFlowCost.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdFlowChannel::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdFlowChannel s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowVectorIndex"];
	s_Object.m_aFlowVectorIndex.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aFlowVectorIndex[s_Index0++] = simdjson::from_json_uint8(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowCost"];
	s_Object.m_aFlowCost.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aFlowCost[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	*reinterpret_cast<SCrowdFlowChannel*>(p_Target) = s_Object;
}

void SCrowdFlowChannel::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aFlowVectorIndex, p_Serializer, p_OwnOffset + offsetof(SCrowdFlowChannel, m_aFlowVectorIndex));
	TArray<uint16>::Serialize(&s_Object->m_aFlowCost, p_Serializer, p_OwnOffset + offsetof(SCrowdFlowChannel, m_aFlowCost));
}

bool SCrowdFlowChannel::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdFlowChannel*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdFlowChannel*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdFlowChannel::operator==(const SCrowdFlowChannel& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdFlowChannel>)
		return false;

	if (m_aFlowVectorIndex != p_Other.m_aFlowVectorIndex) return false;
	if (m_aFlowCost != p_Other.m_aFlowCost) return false;

	return true;
}

void SCrowdFlowChannel::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdFlowChannel*>(p_Object);
	s_Object->~SCrowdFlowChannel();
}

ZHMTypeInfo ZCrowdGridPoint::TypeInfo = ZHMTypeInfo("ZCrowdGridPoint", sizeof(ZCrowdGridPoint), alignof(ZCrowdGridPoint), ZCrowdGridPoint::WriteSimpleJson, ZCrowdGridPoint::FromSimpleJson, ZCrowdGridPoint::Serialize, ZCrowdGridPoint::Equals, ZCrowdGridPoint::Destroy);

void ZCrowdGridPoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nHeightOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nHeightOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOnNavGrid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOnNavGrid);

	p_Stream << "}";
}

void ZCrowdGridPoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZCrowdGridPoint s_Object {};

	s_Object.m_nHeightOffset = simdjson::from_json_int16(p_Document["m_nHeightOffset"]);

	s_Object.m_nOnNavGrid = simdjson::from_json_uint8(p_Document["m_nOnNavGrid"]);

	*reinterpret_cast<ZCrowdGridPoint*>(p_Target) = s_Object;
}

void ZCrowdGridPoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);

}

bool ZCrowdGridPoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCrowdGridPoint*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCrowdGridPoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCrowdGridPoint::operator==(const ZCrowdGridPoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCrowdGridPoint>)
		return false;

	if (m_nHeightOffset != p_Other.m_nHeightOffset) return false;
	if (m_nOnNavGrid != p_Other.m_nOnNavGrid) return false;

	return true;
}

void ZCrowdGridPoint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZCrowdGridPoint*>(p_Object);
	s_Object->~ZCrowdGridPoint();
}

ZHMTypeInfo SCrowdMapData::TypeInfo = ZHMTypeInfo("SCrowdMapData", sizeof(SCrowdMapData), alignof(SCrowdMapData), SCrowdMapData::WriteSimpleJson, SCrowdMapData::FromSimpleJson, SCrowdMapData::Serialize, SCrowdMapData::Equals, SCrowdMapData::Destroy);

void SCrowdMapData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vCellConsts") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vCellConsts, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridSizeY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridSizeY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCellSizeY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCellSizeY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GridMap") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_GridMap.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_GridMap[i];
		ZCrowdGridPoint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_GridMap.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridMapHeightOffsetsBias") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridMapHeightOffsetsBias);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellFlags") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellFlags.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellFlags[i];
		SCrowdCells::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CellFlags.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CellGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_CellGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_CellGroups[i];
		SCrowdCells::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_CellGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGroupFlowStartChannel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGroupFlowStartChannel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFlowChannels") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFlowChannels.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFlowChannels[i];
		SCrowdFlowChannel::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aFlowChannels.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridCellSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridCellSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mObjectToWorld") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mObjectToWorld, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vGlobalSize") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vGlobalSize, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridGeneratorOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridGeneratorOffset);

	p_Stream << "}";
}

void SCrowdMapData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdMapData s_Object {};

	s_Object.m_nVersion = simdjson::from_json_uint32(p_Document["m_nVersion"]);

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vCellConsts"], &s_Item);
		s_Object.m_vCellConsts = s_Item;
	}

	s_Object.m_nGridSizeX = simdjson::from_json_uint32(p_Document["m_nGridSizeX"]);

	s_Object.m_nGridSizeY = simdjson::from_json_uint32(p_Document["m_nGridSizeY"]);

	s_Object.m_nCellSizeX = simdjson::from_json_uint32(p_Document["m_nCellSizeX"]);

	s_Object.m_nCellSizeY = simdjson::from_json_uint32(p_Document["m_nCellSizeY"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_GridMap"];
	s_Object.m_GridMap.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZCrowdGridPoint s_ArrayItem0;
		ZCrowdGridPoint::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_GridMap[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_fGridMapHeightOffsetsScale = simdjson::from_json_float32(p_Document["m_fGridMapHeightOffsetsScale"]);

	s_Object.m_fGridMapHeightOffsetsBias = simdjson::from_json_float32(p_Document["m_fGridMapHeightOffsetsBias"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CellFlags"];
	s_Object.m_CellFlags.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdCells s_ArrayItem0;
		SCrowdCells::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CellFlags[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_CellGroups"];
	s_Object.m_CellGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdCells s_ArrayItem0;
		SCrowdCells::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_CellGroups[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_nGroupFlowStartChannel = simdjson::from_json_int32(p_Document["m_nGroupFlowStartChannel"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFlowChannels"];
	s_Object.m_aFlowChannels.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdFlowChannel s_ArrayItem0;
		SCrowdFlowChannel::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aFlowChannels[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_nGridCellSize = simdjson::from_json_float32(p_Document["m_nGridCellSize"]);

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_mObjectToWorld"], &s_Item);
		s_Object.m_mObjectToWorld = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vGlobalSize"], &s_Item);
		s_Object.m_vGlobalSize = s_Item;
	}

	s_Object.m_nGridGeneratorOffset = simdjson::from_json_float32(p_Document["m_nGridGeneratorOffset"]);

	*reinterpret_cast<SCrowdMapData*>(p_Target) = s_Object;
}

void SCrowdMapData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vCellConsts, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_vCellConsts));
	TArray<ZCrowdGridPoint>::Serialize(&s_Object->m_GridMap, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_GridMap));
	TArray<SCrowdCells>::Serialize(&s_Object->m_CellFlags, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_CellFlags));
	TArray<SCrowdCells>::Serialize(&s_Object->m_CellGroups, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_CellGroups));
	TArray<SCrowdFlowChannel>::Serialize(&s_Object->m_aFlowChannels, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_aFlowChannels));
	SMatrix::Serialize(&s_Object->m_mObjectToWorld, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_mObjectToWorld));
	SVector3::Serialize(&s_Object->m_vGlobalSize, p_Serializer, p_OwnOffset + offsetof(SCrowdMapData, m_vGlobalSize));
}

bool SCrowdMapData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdMapData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdMapData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdMapData::operator==(const SCrowdMapData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdMapData>)
		return false;

	if (m_nVersion != p_Other.m_nVersion) return false;
	if (m_vCellConsts != p_Other.m_vCellConsts) return false;
	if (m_nGridSizeX != p_Other.m_nGridSizeX) return false;
	if (m_nGridSizeY != p_Other.m_nGridSizeY) return false;
	if (m_nCellSizeX != p_Other.m_nCellSizeX) return false;
	if (m_nCellSizeY != p_Other.m_nCellSizeY) return false;
	if (m_GridMap != p_Other.m_GridMap) return false;
	if (m_fGridMapHeightOffsetsScale != p_Other.m_fGridMapHeightOffsetsScale) return false;
	if (m_fGridMapHeightOffsetsBias != p_Other.m_fGridMapHeightOffsetsBias) return false;
	if (m_CellFlags != p_Other.m_CellFlags) return false;
	if (m_CellGroups != p_Other.m_CellGroups) return false;
	if (m_nGroupFlowStartChannel != p_Other.m_nGroupFlowStartChannel) return false;
	if (m_aFlowChannels != p_Other.m_aFlowChannels) return false;
	if (m_nGridCellSize != p_Other.m_nGridCellSize) return false;
	if (m_mObjectToWorld != p_Other.m_mObjectToWorld) return false;
	if (m_vGlobalSize != p_Other.m_vGlobalSize) return false;
	if (m_nGridGeneratorOffset != p_Other.m_nGridGeneratorOffset) return false;

	return true;
}

void SCrowdMapData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdMapData*>(p_Object);
	s_Object->~SCrowdMapData();
}

ZHMTypeInfo SCrowdReactionSaveData::TypeInfo = ZHMTypeInfo("SCrowdReactionSaveData", sizeof(SCrowdReactionSaveData), alignof(SCrowdReactionSaveData), SCrowdReactionSaveData::WriteSimpleJson, SCrowdReactionSaveData::FromSimpleJson, SCrowdReactionSaveData::Serialize, SCrowdReactionSaveData::Equals, SCrowdReactionSaveData::Destroy);

void SCrowdReactionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nNumPacify") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumPacify);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumShotsFired") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumShotsFired);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumDeaths") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumDeaths);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumScared") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumScared);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarzoneSpawned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarzoneSpawned);

	p_Stream << "}";
}

void SCrowdReactionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdReactionSaveData s_Object {};

	s_Object.m_nNumPacify = simdjson::from_json_uint32(p_Document["m_nNumPacify"]);

	s_Object.m_nNumShotsFired = simdjson::from_json_uint32(p_Document["m_nNumShotsFired"]);

	s_Object.m_nNumDeaths = simdjson::from_json_uint32(p_Document["m_nNumDeaths"]);

	s_Object.m_nNumScared = simdjson::from_json_uint32(p_Document["m_nNumScared"]);

	s_Object.m_bWarzoneSpawned = simdjson::from_json_bool(p_Document["m_bWarzoneSpawned"]);

	*reinterpret_cast<SCrowdReactionSaveData*>(p_Target) = s_Object;
}

void SCrowdReactionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);

}

bool SCrowdReactionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdReactionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdReactionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdReactionSaveData::operator==(const SCrowdReactionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdReactionSaveData>)
		return false;

	if (m_nNumPacify != p_Other.m_nNumPacify) return false;
	if (m_nNumShotsFired != p_Other.m_nNumShotsFired) return false;
	if (m_nNumDeaths != p_Other.m_nNumDeaths) return false;
	if (m_nNumScared != p_Other.m_nNumScared) return false;
	if (m_bWarzoneSpawned != p_Other.m_bWarzoneSpawned) return false;

	return true;
}

void SCrowdReactionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdReactionSaveData*>(p_Object);
	s_Object->~SCrowdReactionSaveData();
}

ZHMTypeInfo SCrowdServiceSaveData::TypeInfo = ZHMTypeInfo("SCrowdServiceSaveData", sizeof(SCrowdServiceSaveData), alignof(SCrowdServiceSaveData), SCrowdServiceSaveData::WriteSimpleJson, SCrowdServiceSaveData::FromSimpleJson, SCrowdServiceSaveData::Serialize, SCrowdServiceSaveData::Equals, SCrowdServiceSaveData::Destroy);

void SCrowdServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aDeadBodies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDeadBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDeadBodies[i];
		SCrowdBodySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aDeadBodies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPerceptiblePool") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPerceptiblePool.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPerceptiblePool[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aPerceptiblePool.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPerceptibleActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPerceptibleActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPerceptibleActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aPerceptibleActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCrowdServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCrowdServiceSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDeadBodies"];
	s_Object.m_aDeadBodies.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCrowdBodySaveData s_ArrayItem0;
		SCrowdBodySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aDeadBodies[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPerceptiblePool"];
	s_Object.m_aPerceptiblePool.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aPerceptiblePool[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPerceptibleActors"];
	s_Object.m_aPerceptibleActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aPerceptibleActors[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SCrowdServiceSaveData*>(p_Target) = s_Object;
}

void SCrowdServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);

	TArray<SCrowdBodySaveData>::Serialize(&s_Object->m_aDeadBodies, p_Serializer, p_OwnOffset + offsetof(SCrowdServiceSaveData, m_aDeadBodies));
	TArray<uint32>::Serialize(&s_Object->m_aPerceptiblePool, p_Serializer, p_OwnOffset + offsetof(SCrowdServiceSaveData, m_aPerceptiblePool));
	TArray<uint32>::Serialize(&s_Object->m_aPerceptibleActors, p_Serializer, p_OwnOffset + offsetof(SCrowdServiceSaveData, m_aPerceptibleActors));
}

bool SCrowdServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCrowdServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCrowdServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCrowdServiceSaveData::operator==(const SCrowdServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCrowdServiceSaveData>)
		return false;

	if (m_aDeadBodies != p_Other.m_aDeadBodies) return false;
	if (m_aPerceptiblePool != p_Other.m_aPerceptiblePool) return false;
	if (m_aPerceptibleActors != p_Other.m_aPerceptibleActors) return false;

	return true;
}

void SCrowdServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCrowdServiceSaveData*>(p_Object);
	s_Object->~SCrowdServiceSaveData();
}

ZHMTypeInfo SCuriousEventSaveData::TypeInfo = ZHMTypeInfo("SCuriousEventSaveData", sizeof(SCuriousEventSaveData), alignof(SCuriousEventSaveData), SCuriousEventSaveData::WriteSimpleJson, SCuriousEventSaveData::FromSimpleJson, SCuriousEventSaveData::Serialize, SCuriousEventSaveData::Equals, SCuriousEventSaveData::Destroy);

void SCuriousEventSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tExpiresAt") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiresAt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nKnowledgeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nKnowledgeIndex);

	p_Stream << "}";
}

void SCuriousEventSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCuriousEventSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tExpiresAt"], &s_Item);
		s_Object.m_tExpiresAt = s_Item;
	}

	s_Object.m_nKnowledgeIndex = simdjson::from_json_int32(p_Document["m_nKnowledgeIndex"]);

	*reinterpret_cast<SCuriousEventSaveData*>(p_Target) = s_Object;
}

void SCuriousEventSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tExpiresAt, p_Serializer, p_OwnOffset + offsetof(SCuriousEventSaveData, m_tExpiresAt));
}

bool SCuriousEventSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousEventSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousEventSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousEventSaveData::operator==(const SCuriousEventSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousEventSaveData>)
		return false;

	if (m_tExpiresAt != p_Other.m_tExpiresAt) return false;
	if (m_nKnowledgeIndex != p_Other.m_nKnowledgeIndex) return false;

	return true;
}

void SCuriousEventSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCuriousEventSaveData*>(p_Object);
	s_Object->~SCuriousEventSaveData();
}

ZHMTypeInfo SCuriousEventServiceSaveData::TypeInfo = ZHMTypeInfo("SCuriousEventServiceSaveData", sizeof(SCuriousEventServiceSaveData), alignof(SCuriousEventServiceSaveData), SCuriousEventServiceSaveData::WriteSimpleJson, SCuriousEventServiceSaveData::FromSimpleJson, SCuriousEventServiceSaveData::Serialize, SCuriousEventServiceSaveData::Equals, SCuriousEventServiceSaveData::Destroy);

void SCuriousEventServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCuriousEvents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCuriousEvents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCuriousEvents[i];
		SCuriousEventSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCuriousEvents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SCuriousEventServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SCuriousEventServiceSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCuriousEvents"];
	s_Object.m_aCuriousEvents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SCuriousEventSaveData s_ArrayItem0;
		SCuriousEventSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aCuriousEvents[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SCuriousEventServiceSaveData*>(p_Target) = s_Object;
}

void SCuriousEventServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);

	TArray<SCuriousEventSaveData>::Serialize(&s_Object->m_aCuriousEvents, p_Serializer, p_OwnOffset + offsetof(SCuriousEventServiceSaveData, m_aCuriousEvents));
}

bool SCuriousEventServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SCuriousEventServiceSaveData::operator==(const SCuriousEventServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SCuriousEventServiceSaveData>)
		return false;

	if (m_aCuriousEvents != p_Other.m_aCuriousEvents) return false;

	return true;
}

void SCuriousEventServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SCuriousEventServiceSaveData*>(p_Object);
	s_Object->~SCuriousEventServiceSaveData();
}

ZHMTypeInfo SDangerousAreaSaveData::TypeInfo = ZHMTypeInfo("SDangerousAreaSaveData", sizeof(SDangerousAreaSaveData), alignof(SDangerousAreaSaveData), SDangerousAreaSaveData::WriteSimpleJson, SDangerousAreaSaveData::FromSimpleJson, SDangerousAreaSaveData::Serialize, SDangerousAreaSaveData::Equals, SDangerousAreaSaveData::Destroy);

void SDangerousAreaSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bDangerous") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDangerous);

	p_Stream << "}";
}

void SDangerousAreaSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDangerousAreaSaveData s_Object {};

	s_Object.m_bDangerous = simdjson::from_json_bool(p_Document["m_bDangerous"]);

	*reinterpret_cast<SDangerousAreaSaveData*>(p_Target) = s_Object;
}

void SDangerousAreaSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);

}

bool SDangerousAreaSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDangerousAreaSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDangerousAreaSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDangerousAreaSaveData::operator==(const SDangerousAreaSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDangerousAreaSaveData>)
		return false;

	if (m_bDangerous != p_Other.m_bDangerous) return false;

	return true;
}

void SDangerousAreaSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDangerousAreaSaveData*>(p_Object);
	s_Object->~SDangerousAreaSaveData();
}

ZHMTypeInfo SDeadBodyInfoSaveData::TypeInfo = ZHMTypeInfo("SDeadBodyInfoSaveData", sizeof(SDeadBodyInfoSaveData), alignof(SDeadBodyInfoSaveData), SDeadBodyInfoSaveData::WriteSimpleJson, SDeadBodyInfoSaveData::FromSimpleJson, SDeadBodyInfoSaveData::Serialize, SDeadBodyInfoSaveData::Equals, SDeadBodyInfoSaveData::Destroy);

void SDeadBodyInfoSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_knownByActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_knownByActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_knownByActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_knownByActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tKnownSince") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tKnownSince, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tInvestigatedSince") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tInvestigatedSince, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGuarded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGuarded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBodyInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBodyInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHidden);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByAccident") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByAccident);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByUnnoticed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByUnnoticed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanSuspectedInCurrentOutfit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanSuspectedInCurrentOutfit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDeadByExplosion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDeadByExplosion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IsFoundOutsideNavmeshAndIgnored") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IsFoundOutsideNavmeshAndIgnored);

	p_Stream << "}";
}

void SDeadBodyInfoSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDeadBodyInfoSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rGuard = simdjson::from_json_uint32(p_Document["m_rGuard"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_knownByActors"];
	s_Object.m_knownByActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_knownByActors[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tKnownSince"], &s_Item);
		s_Object.m_tKnownSince = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tInvestigatedSince"], &s_Item);
		s_Object.m_tInvestigatedSince = s_Item;
	}

	s_Object.m_bGuarded = simdjson::from_json_bool(p_Document["m_bGuarded"]);

	s_Object.m_bBodyInvestigated = simdjson::from_json_bool(p_Document["m_bBodyInvestigated"]);

	s_Object.m_bHidden = simdjson::from_json_bool(p_Document["m_bHidden"]);

	s_Object.m_bDeadByAccident = simdjson::from_json_bool(p_Document["m_bDeadByAccident"]);

	s_Object.m_bDeadByUnnoticed = simdjson::from_json_bool(p_Document["m_bDeadByUnnoticed"]);

	s_Object.m_bHitmanSuspectedInCurrentOutfit = simdjson::from_json_bool(p_Document["m_bHitmanSuspectedInCurrentOutfit"]);

	s_Object.m_bDeadByExplosion = simdjson::from_json_bool(p_Document["m_bDeadByExplosion"]);

	s_Object.m_IsFoundOutsideNavmeshAndIgnored = simdjson::from_json_bool(p_Document["m_IsFoundOutsideNavmeshAndIgnored"]);

	*reinterpret_cast<SDeadBodyInfoSaveData*>(p_Target) = s_Object;
}

void SDeadBodyInfoSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_knownByActors, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_knownByActors));
	ZGameTime::Serialize(&s_Object->m_tKnownSince, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_tKnownSince));
	ZGameTime::Serialize(&s_Object->m_tInvestigatedSince, p_Serializer, p_OwnOffset + offsetof(SDeadBodyInfoSaveData, m_tInvestigatedSince));
}

bool SDeadBodyInfoSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDeadBodyInfoSaveData::operator==(const SDeadBodyInfoSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDeadBodyInfoSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rGuard != p_Other.m_rGuard) return false;
	if (m_knownByActors != p_Other.m_knownByActors) return false;
	if (m_tKnownSince != p_Other.m_tKnownSince) return false;
	if (m_tInvestigatedSince != p_Other.m_tInvestigatedSince) return false;
	if (m_bGuarded != p_Other.m_bGuarded) return false;
	if (m_bBodyInvestigated != p_Other.m_bBodyInvestigated) return false;
	if (m_bHidden != p_Other.m_bHidden) return false;
	if (m_bDeadByAccident != p_Other.m_bDeadByAccident) return false;
	if (m_bDeadByUnnoticed != p_Other.m_bDeadByUnnoticed) return false;
	if (m_bHitmanSuspectedInCurrentOutfit != p_Other.m_bHitmanSuspectedInCurrentOutfit) return false;
	if (m_bDeadByExplosion != p_Other.m_bDeadByExplosion) return false;
	if (m_IsFoundOutsideNavmeshAndIgnored != p_Other.m_IsFoundOutsideNavmeshAndIgnored) return false;

	return true;
}

void SDeadBodyInfoSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDeadBodyInfoSaveData*>(p_Object);
	s_Object->~SDeadBodyInfoSaveData();
}

ZHMTypeInfo SDeadBodySensorSaveData::TypeInfo = ZHMTypeInfo("SDeadBodySensorSaveData", sizeof(SDeadBodySensorSaveData), alignof(SDeadBodySensorSaveData), SDeadBodySensorSaveData::WriteSimpleJson, SDeadBodySensorSaveData::FromSimpleJson, SDeadBodySensorSaveData::Serialize, SDeadBodySensorSaveData::Equals, SDeadBodySensorSaveData::Destroy);

void SDeadBodySensorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBodies") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBodies.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBodies[i];
		SDeadBodyInfoSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBodies.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBodyIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nBodyIndex);

	p_Stream << "}";
}

void SDeadBodySensorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDeadBodySensorSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBodies"];
	s_Object.m_aBodies.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDeadBodyInfoSaveData s_ArrayItem0;
		SDeadBodyInfoSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBodies[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_nBodyIndex = simdjson::from_json_int32(p_Document["m_nBodyIndex"]);

	*reinterpret_cast<SDeadBodySensorSaveData*>(p_Target) = s_Object;
}

void SDeadBodySensorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);

	TArray<SDeadBodyInfoSaveData>::Serialize(&s_Object->m_aBodies, p_Serializer, p_OwnOffset + offsetof(SDeadBodySensorSaveData, m_aBodies));
}

bool SDeadBodySensorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDeadBodySensorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDeadBodySensorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDeadBodySensorSaveData::operator==(const SDeadBodySensorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDeadBodySensorSaveData>)
		return false;

	if (m_aBodies != p_Other.m_aBodies) return false;
	if (m_nBodyIndex != p_Other.m_nBodyIndex) return false;

	return true;
}

void SDeadBodySensorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDeadBodySensorSaveData*>(p_Object);
	s_Object->~SDeadBodySensorSaveData();
}

ZHMTypeInfo SVector2::TypeInfo = ZHMTypeInfo("SVector2", sizeof(SVector2), alignof(SVector2), SVector2::WriteSimpleJson, SVector2::FromSimpleJson, SVector2::Serialize, SVector2::Equals, SVector2::Destroy);

void SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);

	p_Stream << "}";
}

void SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVector2 s_Object {};

	s_Object.x = simdjson::from_json_float32(p_Document["x"]);

	s_Object.y = simdjson::from_json_float32(p_Document["y"]);

	*reinterpret_cast<SVector2*>(p_Target) = s_Object;
}

void SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);

}

bool SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVector2::operator==(const SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVector2>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;

	return true;
}

void SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVector2*>(p_Object);
	s_Object->~SVector2();
}

ZHMTypeInfo SDecalSpawnSaveData::TypeInfo = ZHMTypeInfo("SDecalSpawnSaveData", sizeof(SDecalSpawnSaveData), alignof(SDecalSpawnSaveData), SDecalSpawnSaveData::WriteSimpleJson, SDecalSpawnSaveData::FromSimpleJson, SDecalSpawnSaveData::Serialize, SDecalSpawnSaveData::Equals, SDecalSpawnSaveData::Destroy);

void SDecalSpawnSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bWasSpawned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasSpawned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vNormal") << ":";
	float4::WriteSimpleJson(&s_Object->m_vNormal, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSize") << ":";
	float4::WriteSimpleJson(&s_Object->m_vSize, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Color") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_Color, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vUVOffset") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vUVOffset, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTiling") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vTiling, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBlockingSpatialEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBlockingSpatialEntity);

	p_Stream << "}";
}

void SDecalSpawnSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDecalSpawnSaveData s_Object {};

	s_Object.m_bWasSpawned = simdjson::from_json_bool(p_Document["m_bWasSpawned"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vNormal"], &s_Item);
		s_Object.m_vNormal = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vDirection"], &s_Item);
		s_Object.m_vDirection = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vSize"], &s_Item);
		s_Object.m_vSize = s_Item;
	}

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_Color"], &s_Item);
		s_Object.m_Color = s_Item;
	}

	s_Object.m_fAlpha = simdjson::from_json_float32(p_Document["m_fAlpha"]);

	s_Object.m_fAngle = simdjson::from_json_float32(p_Document["m_fAngle"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vUVOffset"], &s_Item);
		s_Object.m_vUVOffset = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vTiling"], &s_Item);
		s_Object.m_vTiling = s_Item;
	}

	s_Object.m_rBlockingSpatialEntity = simdjson::from_json_uint32(p_Document["m_rBlockingSpatialEntity"]);

	*reinterpret_cast<SDecalSpawnSaveData*>(p_Target) = s_Object;
}

void SDecalSpawnSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vPosition));
	float4::Serialize(&s_Object->m_vNormal, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vNormal));
	float4::Serialize(&s_Object->m_vDirection, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vDirection));
	float4::Serialize(&s_Object->m_vSize, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vSize));
	SColorRGB::Serialize(&s_Object->m_Color, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_Color));
	SVector2::Serialize(&s_Object->m_vUVOffset, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vUVOffset));
	SVector2::Serialize(&s_Object->m_vTiling, p_Serializer, p_OwnOffset + offsetof(SDecalSpawnSaveData, m_vTiling));
}

bool SDecalSpawnSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDecalSpawnSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDecalSpawnSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDecalSpawnSaveData::operator==(const SDecalSpawnSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDecalSpawnSaveData>)
		return false;

	if (m_bWasSpawned != p_Other.m_bWasSpawned) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vNormal != p_Other.m_vNormal) return false;
	if (m_vDirection != p_Other.m_vDirection) return false;
	if (m_vSize != p_Other.m_vSize) return false;
	if (m_Color != p_Other.m_Color) return false;
	if (m_fAlpha != p_Other.m_fAlpha) return false;
	if (m_fAngle != p_Other.m_fAngle) return false;
	if (m_vUVOffset != p_Other.m_vUVOffset) return false;
	if (m_vTiling != p_Other.m_vTiling) return false;
	if (m_rBlockingSpatialEntity != p_Other.m_rBlockingSpatialEntity) return false;

	return true;
}

void SDecalSpawnSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDecalSpawnSaveData*>(p_Object);
	s_Object->~SDecalSpawnSaveData();
}

ZHMTypeInfo SDestructibleInteractionHandlerData::TypeInfo = ZHMTypeInfo("SDestructibleInteractionHandlerData", sizeof(SDestructibleInteractionHandlerData), alignof(SDestructibleInteractionHandlerData), SDestructibleInteractionHandlerData::WriteSimpleJson, SDestructibleInteractionHandlerData::FromSimpleJson, SDestructibleInteractionHandlerData::Serialize, SDestructibleInteractionHandlerData::Equals, SDestructibleInteractionHandlerData::Destroy);

void SDestructibleInteractionHandlerData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDestructibleInteractionHandlerData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSettleTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSettleTime);

	p_Stream << "}";
}

void SDestructibleInteractionHandlerData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDestructibleInteractionHandlerData s_Object {};

	s_Object.m_fSettleTime = simdjson::from_json_float32(p_Document["m_fSettleTime"]);

	*reinterpret_cast<SDestructibleInteractionHandlerData*>(p_Target) = s_Object;
}

void SDestructibleInteractionHandlerData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDestructibleInteractionHandlerData*>(p_Object);

}

bool SDestructibleInteractionHandlerData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDestructibleInteractionHandlerData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDestructibleInteractionHandlerData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDestructibleInteractionHandlerData::operator==(const SDestructibleInteractionHandlerData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDestructibleInteractionHandlerData>)
		return false;

	if (m_fSettleTime != p_Other.m_fSettleTime) return false;

	return true;
}

void SDestructibleInteractionHandlerData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDestructibleInteractionHandlerData*>(p_Object);
	s_Object->~SDestructibleInteractionHandlerData();
}

ZHMTypeInfo SDestructiblePieceSaveData::TypeInfo = ZHMTypeInfo("SDestructiblePieceSaveData", sizeof(SDestructiblePieceSaveData), alignof(SDestructiblePieceSaveData), SDestructiblePieceSaveData::WriteSimpleJson, SDestructiblePieceSaveData::FromSimpleJson, SDestructiblePieceSaveData::Serialize, SDestructiblePieceSaveData::Equals, SDestructiblePieceSaveData::Destroy);

void SDestructiblePieceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDestructiblePieceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_mTransform") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mTransform, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIndices") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIndices.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIndices[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aIndices.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMass") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMass);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePhysicsType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EPhysicsObjectType", static_cast<int>(s_Object->m_ePhysicsType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsAwake") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsAwake);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLinearVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_fLinearVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAngularVelocity") << ":";
	float4::WriteSimpleJson(&s_Object->m_fAngularVelocity, p_Stream);

	p_Stream << "}";
}

void SDestructiblePieceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDestructiblePieceSaveData s_Object {};

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_mTransform"], &s_Item);
		s_Object.m_mTransform = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIndices"];
	s_Object.m_aIndices.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aIndices[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	s_Object.m_fMass = simdjson::from_json_float32(p_Document["m_fMass"]);

	s_Object.m_ePhysicsType = static_cast<EPhysicsObjectType>(ZHMEnums::GetEnumValueByName("EPhysicsObjectType", std::string_view(p_Document["m_ePhysicsType"])));

	s_Object.m_bIsAwake = simdjson::from_json_bool(p_Document["m_bIsAwake"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_fLinearVelocity"], &s_Item);
		s_Object.m_fLinearVelocity = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_fAngularVelocity"], &s_Item);
		s_Object.m_fAngularVelocity = s_Item;
	}

	*reinterpret_cast<SDestructiblePieceSaveData*>(p_Target) = s_Object;
}

void SDestructiblePieceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDestructiblePieceSaveData*>(p_Object);

	SMatrix::Serialize(&s_Object->m_mTransform, p_Serializer, p_OwnOffset + offsetof(SDestructiblePieceSaveData, m_mTransform));
	TArray<uint16>::Serialize(&s_Object->m_aIndices, p_Serializer, p_OwnOffset + offsetof(SDestructiblePieceSaveData, m_aIndices));
	float4::Serialize(&s_Object->m_fLinearVelocity, p_Serializer, p_OwnOffset + offsetof(SDestructiblePieceSaveData, m_fLinearVelocity));
	float4::Serialize(&s_Object->m_fAngularVelocity, p_Serializer, p_OwnOffset + offsetof(SDestructiblePieceSaveData, m_fAngularVelocity));
}

bool SDestructiblePieceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDestructiblePieceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDestructiblePieceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDestructiblePieceSaveData::operator==(const SDestructiblePieceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDestructiblePieceSaveData>)
		return false;

	if (m_mTransform != p_Other.m_mTransform) return false;
	if (m_aIndices != p_Other.m_aIndices) return false;
	if (m_fMass != p_Other.m_fMass) return false;
	if (m_ePhysicsType != p_Other.m_ePhysicsType) return false;
	if (m_bIsAwake != p_Other.m_bIsAwake) return false;
	if (m_fLinearVelocity != p_Other.m_fLinearVelocity) return false;
	if (m_fAngularVelocity != p_Other.m_fAngularVelocity) return false;

	return true;
}

void SDestructiblePieceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDestructiblePieceSaveData*>(p_Object);
	s_Object->~SDestructiblePieceSaveData();
}

ZHMTypeInfo SDestructibleRuntimeConnnection::TypeInfo = ZHMTypeInfo("SDestructibleRuntimeConnnection", sizeof(SDestructibleRuntimeConnnection), alignof(SDestructibleRuntimeConnnection), SDestructibleRuntimeConnnection::WriteSimpleJson, SDestructibleRuntimeConnnection::FromSimpleJson, SDestructibleRuntimeConnnection::Serialize, SDestructibleRuntimeConnnection::Equals, SDestructibleRuntimeConnnection::Destroy);

void SDestructibleRuntimeConnnection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDestructibleRuntimeConnnection*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nPieceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPieceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aConnections") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aConnections.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aConnections[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aConnections.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDestructibleRuntimeConnnection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDestructibleRuntimeConnnection s_Object {};

	s_Object.m_nPieceIndex = simdjson::from_json_uint16(p_Document["m_nPieceIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aConnections"];
	s_Object.m_aConnections.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aConnections[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	*reinterpret_cast<SDestructibleRuntimeConnnection*>(p_Target) = s_Object;
}

void SDestructibleRuntimeConnnection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDestructibleRuntimeConnnection*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_aConnections, p_Serializer, p_OwnOffset + offsetof(SDestructibleRuntimeConnnection, m_aConnections));
}

bool SDestructibleRuntimeConnnection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDestructibleRuntimeConnnection*>(p_Left);
	auto* s_Right = reinterpret_cast<SDestructibleRuntimeConnnection*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDestructibleRuntimeConnnection::operator==(const SDestructibleRuntimeConnnection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDestructibleRuntimeConnnection>)
		return false;

	if (m_nPieceIndex != p_Other.m_nPieceIndex) return false;
	if (m_aConnections != p_Other.m_aConnections) return false;

	return true;
}

void SDestructibleRuntimeConnnection::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDestructibleRuntimeConnnection*>(p_Object);
	s_Object->~SDestructibleRuntimeConnnection();
}

ZHMTypeInfo SDestructibleRuntimeDamage::TypeInfo = ZHMTypeInfo("SDestructibleRuntimeDamage", sizeof(SDestructibleRuntimeDamage), alignof(SDestructibleRuntimeDamage), SDestructibleRuntimeDamage::WriteSimpleJson, SDestructibleRuntimeDamage::FromSimpleJson, SDestructibleRuntimeDamage::Serialize, SDestructibleRuntimeDamage::Equals, SDestructibleRuntimeDamage::Destroy);

void SDestructibleRuntimeDamage::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDestructibleRuntimeDamage*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nPieceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPieceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDamage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDamage);

	p_Stream << "}";
}

void SDestructibleRuntimeDamage::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDestructibleRuntimeDamage s_Object {};

	s_Object.m_nPieceIndex = simdjson::from_json_uint16(p_Document["m_nPieceIndex"]);

	s_Object.m_fDamage = simdjson::from_json_float32(p_Document["m_fDamage"]);

	*reinterpret_cast<SDestructibleRuntimeDamage*>(p_Target) = s_Object;
}

void SDestructibleRuntimeDamage::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDestructibleRuntimeDamage*>(p_Object);

}

bool SDestructibleRuntimeDamage::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDestructibleRuntimeDamage*>(p_Left);
	auto* s_Right = reinterpret_cast<SDestructibleRuntimeDamage*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDestructibleRuntimeDamage::operator==(const SDestructibleRuntimeDamage& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDestructibleRuntimeDamage>)
		return false;

	if (m_nPieceIndex != p_Other.m_nPieceIndex) return false;
	if (m_fDamage != p_Other.m_fDamage) return false;

	return true;
}

void SDestructibleRuntimeDamage::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDestructibleRuntimeDamage*>(p_Object);
	s_Object->~SDestructibleRuntimeDamage();
}

ZHMTypeInfo SDestructibleObjectSaveData::TypeInfo = ZHMTypeInfo("SDestructibleObjectSaveData", sizeof(SDestructibleObjectSaveData), alignof(SDestructibleObjectSaveData), SDestructibleObjectSaveData::WriteSimpleJson, SDestructibleObjectSaveData::FromSimpleJson, SDestructibleObjectSaveData::Serialize, SDestructibleObjectSaveData::Equals, SDestructibleObjectSaveData::Destroy);

void SDestructibleObjectSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDestructibleObjectSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_interactionData") << ":";
	SDestructibleInteractionHandlerData::WriteSimpleJson(&s_Object->m_interactionData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDestructiblePieces") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDestructiblePieces.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDestructiblePieces[i];
		SDestructiblePieceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aDestructiblePieces.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aConnectionData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aConnectionData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aConnectionData[i];
		SDestructibleRuntimeConnnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aConnectionData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDamageData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDamageData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDamageData[i];
		SDestructibleRuntimeDamage::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aDamageData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumAnchors") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumAnchors);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eRuntimeMemoryAllocationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ERuntimeMemoryAllocationState", static_cast<int>(s_Object->m_eRuntimeMemoryAllocationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSystemPhysicsType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EPhysicsObjectType", static_cast<int>(s_Object->m_eSystemPhysicsType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasSystemBeenDetached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasSystemBeenDetached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasSystemBeenFractured") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasSystemBeenFractured);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPhysicsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPhysicsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestructionEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestructionEnabled);

	p_Stream << "}";
}

void SDestructibleObjectSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDestructibleObjectSaveData s_Object {};

	{
		SDestructibleInteractionHandlerData s_Item {};
		SDestructibleInteractionHandlerData::FromSimpleJson(p_Document["m_interactionData"], &s_Item);
		s_Object.m_interactionData = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDestructiblePieces"];
	s_Object.m_aDestructiblePieces.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDestructiblePieceSaveData s_ArrayItem0;
		SDestructiblePieceSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aDestructiblePieces[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aConnectionData"];
	s_Object.m_aConnectionData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDestructibleRuntimeConnnection s_ArrayItem0;
		SDestructibleRuntimeConnnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aConnectionData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDamageData"];
	s_Object.m_aDamageData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDestructibleRuntimeDamage s_ArrayItem0;
		SDestructibleRuntimeDamage::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aDamageData[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_nNumAnchors = simdjson::from_json_uint16(p_Document["m_nNumAnchors"]);

	s_Object.m_eRuntimeMemoryAllocationState = static_cast<ERuntimeMemoryAllocationState>(ZHMEnums::GetEnumValueByName("ERuntimeMemoryAllocationState", std::string_view(p_Document["m_eRuntimeMemoryAllocationState"])));

	s_Object.m_eSystemPhysicsType = static_cast<EPhysicsObjectType>(ZHMEnums::GetEnumValueByName("EPhysicsObjectType", std::string_view(p_Document["m_eSystemPhysicsType"])));

	s_Object.m_bHasSystemBeenDetached = simdjson::from_json_bool(p_Document["m_bHasSystemBeenDetached"]);

	s_Object.m_bHasSystemBeenFractured = simdjson::from_json_bool(p_Document["m_bHasSystemBeenFractured"]);

	s_Object.m_bPhysicsEnabled = simdjson::from_json_bool(p_Document["m_bPhysicsEnabled"]);

	s_Object.m_bDestructionEnabled = simdjson::from_json_bool(p_Document["m_bDestructionEnabled"]);

	*reinterpret_cast<SDestructibleObjectSaveData*>(p_Target) = s_Object;
}

void SDestructibleObjectSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDestructibleObjectSaveData*>(p_Object);

	SDestructibleInteractionHandlerData::Serialize(&s_Object->m_interactionData, p_Serializer, p_OwnOffset + offsetof(SDestructibleObjectSaveData, m_interactionData));
	TArray<SDestructiblePieceSaveData>::Serialize(&s_Object->m_aDestructiblePieces, p_Serializer, p_OwnOffset + offsetof(SDestructibleObjectSaveData, m_aDestructiblePieces));
	TArray<SDestructibleRuntimeConnnection>::Serialize(&s_Object->m_aConnectionData, p_Serializer, p_OwnOffset + offsetof(SDestructibleObjectSaveData, m_aConnectionData));
	TArray<SDestructibleRuntimeDamage>::Serialize(&s_Object->m_aDamageData, p_Serializer, p_OwnOffset + offsetof(SDestructibleObjectSaveData, m_aDamageData));
}

bool SDestructibleObjectSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDestructibleObjectSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDestructibleObjectSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDestructibleObjectSaveData::operator==(const SDestructibleObjectSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDestructibleObjectSaveData>)
		return false;

	if (m_interactionData != p_Other.m_interactionData) return false;
	if (m_aDestructiblePieces != p_Other.m_aDestructiblePieces) return false;
	if (m_aConnectionData != p_Other.m_aConnectionData) return false;
	if (m_aDamageData != p_Other.m_aDamageData) return false;
	if (m_nNumAnchors != p_Other.m_nNumAnchors) return false;
	if (m_eRuntimeMemoryAllocationState != p_Other.m_eRuntimeMemoryAllocationState) return false;
	if (m_eSystemPhysicsType != p_Other.m_eSystemPhysicsType) return false;
	if (m_bHasSystemBeenDetached != p_Other.m_bHasSystemBeenDetached) return false;
	if (m_bHasSystemBeenFractured != p_Other.m_bHasSystemBeenFractured) return false;
	if (m_bPhysicsEnabled != p_Other.m_bPhysicsEnabled) return false;
	if (m_bDestructionEnabled != p_Other.m_bDestructionEnabled) return false;

	return true;
}

void SDestructibleObjectSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDestructibleObjectSaveData*>(p_Object);
	s_Object->~SDestructibleObjectSaveData();
}

ZHMTypeInfo SDetectedInPrivateGroupSaveData::TypeInfo = ZHMTypeInfo("SDetectedInPrivateGroupSaveData", sizeof(SDetectedInPrivateGroupSaveData), alignof(SDetectedInPrivateGroupSaveData), SDetectedInPrivateGroupSaveData::WriteSimpleJson, SDetectedInPrivateGroupSaveData::FromSimpleJson, SDetectedInPrivateGroupSaveData::Serialize, SDetectedInPrivateGroupSaveData::Equals, SDetectedInPrivateGroupSaveData::Destroy);

void SDetectedInPrivateGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeWaiting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeWaiting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rLead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDisbanded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDisbanded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirstWait") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirstWait);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);

	p_Stream << "}";
}

void SDetectedInPrivateGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDetectedInPrivateGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_fTimeWaiting = simdjson::from_json_float32(p_Document["m_fTimeWaiting"]);

	s_Object.m_rLead = simdjson::from_json_uint32(p_Document["m_rLead"]);

	s_Object.m_bDisbanded = simdjson::from_json_bool(p_Document["m_bDisbanded"]);

	s_Object.m_bFirstWait = simdjson::from_json_bool(p_Document["m_bFirstWait"]);

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	*reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Target) = s_Object;
}

void SDetectedInPrivateGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SDetectedInPrivateGroupSaveData, m_fsmState));
}

bool SDetectedInPrivateGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDetectedInPrivateGroupSaveData::operator==(const SDetectedInPrivateGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDetectedInPrivateGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_fTimeWaiting != p_Other.m_fTimeWaiting) return false;
	if (m_rLead != p_Other.m_rLead) return false;
	if (m_bDisbanded != p_Other.m_bDisbanded) return false;
	if (m_bFirstWait != p_Other.m_bFirstWait) return false;
	if (m_target != p_Other.m_target) return false;

	return true;
}

void SDetectedInPrivateGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDetectedInPrivateGroupSaveData*>(p_Object);
	s_Object->~SDetectedInPrivateGroupSaveData();
}

ZHMTypeInfo SDisguiseZoneSaveData::TypeInfo = ZHMTypeInfo("SDisguiseZoneSaveData", sizeof(SDisguiseZoneSaveData), alignof(SDisguiseZoneSaveData), SDisguiseZoneSaveData::WriteSimpleJson, SDisguiseZoneSaveData::FromSimpleJson, SDisguiseZoneSaveData::Serialize, SDisguiseZoneSaveData::Equals, SDisguiseZoneSaveData::Destroy);

void SDisguiseZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SDisguiseZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDisguiseZoneSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SDisguiseZoneSaveData*>(p_Target) = s_Object;
}

void SDisguiseZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);

}

bool SDisguiseZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDisguiseZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDisguiseZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDisguiseZoneSaveData::operator==(const SDisguiseZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDisguiseZoneSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SDisguiseZoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDisguiseZoneSaveData*>(p_Object);
	s_Object->~SDisguiseZoneSaveData();
}

ZHMTypeInfo SDoorSaveData::TypeInfo = ZHMTypeInfo("SDoorSaveData", sizeof(SDoorSaveData), alignof(SDoorSaveData), SDoorSaveData::WriteSimpleJson, SDoorSaveData::FromSimpleJson, SDoorSaveData::Serialize, SDoorSaveData::Equals, SDoorSaveData::Destroy);

void SDoorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nDoorState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDoorState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimPercent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimPercent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAnimPercent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAnimPercent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tOpenTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tOpenTime, p_Stream);

	p_Stream << "}";
}

void SDoorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDoorSaveData s_Object {};

	s_Object.m_nDoorState = simdjson::from_json_int32(p_Document["m_nDoorState"]);

	s_Object.m_fAnimPercent = simdjson::from_json_float32(p_Document["m_fAnimPercent"]);

	s_Object.m_fTargetAnimPercent = simdjson::from_json_float32(p_Document["m_fTargetAnimPercent"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tOpenTime"], &s_Item);
		s_Object.m_tOpenTime = s_Item;
	}

	*reinterpret_cast<SDoorSaveData*>(p_Target) = s_Object;
}

void SDoorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tOpenTime, p_Serializer, p_OwnOffset + offsetof(SDoorSaveData, m_tOpenTime));
}

bool SDoorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorSaveData::operator==(const SDoorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorSaveData>)
		return false;

	if (m_nDoorState != p_Other.m_nDoorState) return false;
	if (m_fAnimPercent != p_Other.m_fAnimPercent) return false;
	if (m_fTargetAnimPercent != p_Other.m_fTargetAnimPercent) return false;
	if (m_tOpenTime != p_Other.m_tOpenTime) return false;

	return true;
}

void SDoorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDoorSaveData*>(p_Object);
	s_Object->~SDoorSaveData();
}

ZHMTypeInfo SDoorSoundDefs::TypeInfo = ZHMTypeInfo("SDoorSoundDefs", sizeof(SDoorSoundDefs), alignof(SDoorSoundDefs), SDoorSoundDefs::WriteSimpleJson, SDoorSoundDefs::FromSimpleJson, SDoorSoundDefs::Serialize, SDoorSoundDefs::Equals, SDoorSoundDefs::Destroy);

void SDoorSoundDefs::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SDoorSoundDefs::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDoorSoundDefs s_Object {};

	*reinterpret_cast<SDoorSoundDefs*>(p_Target) = s_Object;
}

void SDoorSoundDefs::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);

}

bool SDoorSoundDefs::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorSoundDefs*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorSoundDefs*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorSoundDefs::operator==(const SDoorSoundDefs& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorSoundDefs>)
		return false;


	return true;
}

void SDoorSoundDefs::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDoorSoundDefs*>(p_Object);
	s_Object->~SDoorSoundDefs();
}

ZHMTypeInfo SDoorsSaveData::TypeInfo = ZHMTypeInfo("SDoorsSaveData", sizeof(SDoorsSaveData), alignof(SDoorsSaveData), SDoorsSaveData::WriteSimpleJson, SDoorsSaveData::FromSimpleJson, SDoorsSaveData::Serialize, SDoorsSaveData::Equals, SDoorsSaveData::Destroy);

void SDoorsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SDoorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDoorsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDoorsSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDoorSaveData s_ArrayItem0;
		SDoorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SDoorsSaveData*>(p_Target) = s_Object;
}

void SDoorsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDoorsSaveData, m_aEntities));
	TArray<SDoorSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SDoorsSaveData, m_aData));
}

bool SDoorsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDoorsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDoorsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDoorsSaveData::operator==(const SDoorsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDoorsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SDoorsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDoorsSaveData*>(p_Object);
	s_Object->~SDoorsSaveData();
}

ZHMTypeInfo SDrama2ActorSaveState::TypeInfo = ZHMTypeInfo("SDrama2ActorSaveState", sizeof(SDrama2ActorSaveState), alignof(SDrama2ActorSaveState), SDrama2ActorSaveState::WriteSimpleJson, SDrama2ActorSaveState::FromSimpleJson, SDrama2ActorSaveState::Serialize, SDrama2ActorSaveState::Equals, SDrama2ActorSaveState::Destroy);

void SDrama2ActorSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDrama2ActorSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSequence") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSequence);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sMatchName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sMatchName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tActorSpeakEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tActorSpeakEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSpeaking") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSpeaking);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOwnsCurrentBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOwnsCurrentBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRequired") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRequired);

	p_Stream << "}";
}

void SDrama2ActorSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDrama2ActorSaveState s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rSequence = simdjson::from_json_uint32(p_Document["m_rSequence"]);

	s_Object.m_rBehavior = simdjson::from_json_uint32(p_Document["m_rBehavior"]);

	s_Object.m_rCurrentSpeakEntity = simdjson::from_json_uint32(p_Document["m_rCurrentSpeakEntity"]);

	s_Object.m_rScreenplay = simdjson::from_json_uint32(p_Document["m_rScreenplay"]);

	s_Object.m_sMatchName = std::string_view(p_Document["m_sMatchName"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tActorSpeakEnd"], &s_Item);
		s_Object.m_tActorSpeakEnd = s_Item;
	}

	s_Object.m_bIsDone = simdjson::from_json_bool(p_Document["m_bIsDone"]);

	s_Object.m_bIsPaused = simdjson::from_json_bool(p_Document["m_bIsPaused"]);

	s_Object.m_bIsSpeaking = simdjson::from_json_bool(p_Document["m_bIsSpeaking"]);

	s_Object.m_bOwnsCurrentBehavior = simdjson::from_json_bool(p_Document["m_bOwnsCurrentBehavior"]);

	s_Object.m_bActive = simdjson::from_json_bool(p_Document["m_bActive"]);

	s_Object.m_bRequired = simdjson::from_json_bool(p_Document["m_bRequired"]);

	*reinterpret_cast<SDrama2ActorSaveState*>(p_Target) = s_Object;
}

void SDrama2ActorSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDrama2ActorSaveState*>(p_Object);

	ZString::Serialize(&s_Object->m_sMatchName, p_Serializer, p_OwnOffset + offsetof(SDrama2ActorSaveState, m_sMatchName));
	ZGameTime::Serialize(&s_Object->m_tActorSpeakEnd, p_Serializer, p_OwnOffset + offsetof(SDrama2ActorSaveState, m_tActorSpeakEnd));
}

bool SDrama2ActorSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDrama2ActorSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SDrama2ActorSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDrama2ActorSaveState::operator==(const SDrama2ActorSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDrama2ActorSaveState>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rSequence != p_Other.m_rSequence) return false;
	if (m_rBehavior != p_Other.m_rBehavior) return false;
	if (m_rCurrentSpeakEntity != p_Other.m_rCurrentSpeakEntity) return false;
	if (m_rScreenplay != p_Other.m_rScreenplay) return false;
	if (m_sMatchName != p_Other.m_sMatchName) return false;
	if (m_tActorSpeakEnd != p_Other.m_tActorSpeakEnd) return false;
	if (m_bIsDone != p_Other.m_bIsDone) return false;
	if (m_bIsPaused != p_Other.m_bIsPaused) return false;
	if (m_bIsSpeaking != p_Other.m_bIsSpeaking) return false;
	if (m_bOwnsCurrentBehavior != p_Other.m_bOwnsCurrentBehavior) return false;
	if (m_bActive != p_Other.m_bActive) return false;
	if (m_bRequired != p_Other.m_bRequired) return false;

	return true;
}

void SDrama2ActorSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDrama2ActorSaveState*>(p_Object);
	s_Object->~SDrama2ActorSaveState();
}

ZHMTypeInfo SDrama2ActorCollectionSaveData::TypeInfo = ZHMTypeInfo("SDrama2ActorCollectionSaveData", sizeof(SDrama2ActorCollectionSaveData), alignof(SDrama2ActorCollectionSaveData), SDrama2ActorCollectionSaveData::WriteSimpleJson, SDrama2ActorCollectionSaveData::FromSimpleJson, SDrama2ActorCollectionSaveData::Serialize, SDrama2ActorCollectionSaveData::Equals, SDrama2ActorCollectionSaveData::Destroy);

void SDrama2ActorCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDrama2ActorCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDrama2ActorSaveState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDrama2ActorCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDrama2ActorCollectionSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDrama2ActorSaveState s_ArrayItem0;
		SDrama2ActorSaveState::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SDrama2ActorCollectionSaveData*>(p_Target) = s_Object;
}

void SDrama2ActorCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDrama2ActorCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDrama2ActorCollectionSaveData, m_aEntities));
	TArray<SDrama2ActorSaveState>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDrama2ActorCollectionSaveData, m_aStates));
}

bool SDrama2ActorCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDrama2ActorCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDrama2ActorCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDrama2ActorCollectionSaveData::operator==(const SDrama2ActorCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDrama2ActorCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDrama2ActorCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDrama2ActorCollectionSaveData*>(p_Object);
	s_Object->~SDrama2ActorCollectionSaveData();
}

ZHMTypeInfo SDrama2SetupSaveData::TypeInfo = ZHMTypeInfo("SDrama2SetupSaveData", sizeof(SDrama2SetupSaveData), alignof(SDrama2SetupSaveData), SDrama2SetupSaveData::WriteSimpleJson, SDrama2SetupSaveData::FromSimpleJson, SDrama2SetupSaveData::Serialize, SDrama2SetupSaveData::Equals, SDrama2SetupSaveData::Destroy);

void SDrama2SetupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDrama2SetupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bDoneTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneTriggered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EScreenPlayState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);

	p_Stream << "}";
}

void SDrama2SetupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDrama2SetupSaveData s_Object {};

	s_Object.m_bDoneTriggered = simdjson::from_json_bool(p_Document["m_bDoneTriggered"]);

	s_Object.m_eState = static_cast<EScreenPlayState>(ZHMEnums::GetEnumValueByName("EScreenPlayState", std::string_view(p_Document["m_eState"])));

	s_Object.m_rSituation = simdjson::from_json_uint32(p_Document["m_rSituation"]);

	*reinterpret_cast<SDrama2SetupSaveData*>(p_Target) = s_Object;
}

void SDrama2SetupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDrama2SetupSaveData*>(p_Object);

}

bool SDrama2SetupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDrama2SetupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDrama2SetupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDrama2SetupSaveData::operator==(const SDrama2SetupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDrama2SetupSaveData>)
		return false;

	if (m_bDoneTriggered != p_Other.m_bDoneTriggered) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_rSituation != p_Other.m_rSituation) return false;

	return true;
}

void SDrama2SetupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDrama2SetupSaveData*>(p_Object);
	s_Object->~SDrama2SetupSaveData();
}

ZHMTypeInfo SDrama2SetupCollectionSaveData::TypeInfo = ZHMTypeInfo("SDrama2SetupCollectionSaveData", sizeof(SDrama2SetupCollectionSaveData), alignof(SDrama2SetupCollectionSaveData), SDrama2SetupCollectionSaveData::WriteSimpleJson, SDrama2SetupCollectionSaveData::FromSimpleJson, SDrama2SetupCollectionSaveData::Serialize, SDrama2SetupCollectionSaveData::Equals, SDrama2SetupCollectionSaveData::Destroy);

void SDrama2SetupCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDrama2SetupCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDrama2SetupSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDrama2SetupCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDrama2SetupCollectionSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDrama2SetupSaveData s_ArrayItem0;
		SDrama2SetupSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SDrama2SetupCollectionSaveData*>(p_Target) = s_Object;
}

void SDrama2SetupCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDrama2SetupCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDrama2SetupCollectionSaveData, m_aEntities));
	TArray<SDrama2SetupSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDrama2SetupCollectionSaveData, m_aStates));
}

bool SDrama2SetupCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDrama2SetupCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDrama2SetupCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDrama2SetupCollectionSaveData::operator==(const SDrama2SetupCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDrama2SetupCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDrama2SetupCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDrama2SetupCollectionSaveData*>(p_Object);
	s_Object->~SDrama2SetupCollectionSaveData();
}

ZHMTypeInfo SDrama2SituationSaveData::TypeInfo = ZHMTypeInfo("SDrama2SituationSaveData", sizeof(SDrama2SituationSaveData), alignof(SDrama2SituationSaveData), SDrama2SituationSaveData::WriteSimpleJson, SDrama2SituationSaveData::FromSimpleJson, SDrama2SituationSaveData::Serialize, SDrama2SituationSaveData::Equals, SDrama2SituationSaveData::Destroy);

void SDrama2SituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDrama2SituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nPriorityModifier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPriorityModifier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentDrama") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentDrama);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nDoneTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nDoneTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOnCooldown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOnCooldown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bProvidersStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bProvidersStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsTerminated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsTerminated);

	p_Stream << "}";
}

void SDrama2SituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDrama2SituationSaveData s_Object {};

	s_Object.m_nPriorityModifier = simdjson::from_json_float32(p_Document["m_nPriorityModifier"]);

	s_Object.m_nCurrentDrama = simdjson::from_json_int32(p_Document["m_nCurrentDrama"]);

	s_Object.m_nDoneTime = simdjson::from_json_float32(p_Document["m_nDoneTime"]);

	s_Object.m_bIsOnCooldown = simdjson::from_json_bool(p_Document["m_bIsOnCooldown"]);

	s_Object.m_bProvidersStarted = simdjson::from_json_bool(p_Document["m_bProvidersStarted"]);

	s_Object.m_bSituationRunning = simdjson::from_json_bool(p_Document["m_bSituationRunning"]);

	s_Object.m_bIsTerminated = simdjson::from_json_bool(p_Document["m_bIsTerminated"]);

	*reinterpret_cast<SDrama2SituationSaveData*>(p_Target) = s_Object;
}

void SDrama2SituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDrama2SituationSaveData*>(p_Object);

}

bool SDrama2SituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDrama2SituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDrama2SituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDrama2SituationSaveData::operator==(const SDrama2SituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDrama2SituationSaveData>)
		return false;

	if (m_nPriorityModifier != p_Other.m_nPriorityModifier) return false;
	if (m_nCurrentDrama != p_Other.m_nCurrentDrama) return false;
	if (m_nDoneTime != p_Other.m_nDoneTime) return false;
	if (m_bIsOnCooldown != p_Other.m_bIsOnCooldown) return false;
	if (m_bProvidersStarted != p_Other.m_bProvidersStarted) return false;
	if (m_bSituationRunning != p_Other.m_bSituationRunning) return false;
	if (m_bIsTerminated != p_Other.m_bIsTerminated) return false;

	return true;
}

void SDrama2SituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDrama2SituationSaveData*>(p_Object);
	s_Object->~SDrama2SituationSaveData();
}

ZHMTypeInfo SDrama2SituationCollectionSaveData::TypeInfo = ZHMTypeInfo("SDrama2SituationCollectionSaveData", sizeof(SDrama2SituationCollectionSaveData), alignof(SDrama2SituationCollectionSaveData), SDrama2SituationCollectionSaveData::WriteSimpleJson, SDrama2SituationCollectionSaveData::FromSimpleJson, SDrama2SituationCollectionSaveData::Serialize, SDrama2SituationCollectionSaveData::Equals, SDrama2SituationCollectionSaveData::Destroy);

void SDrama2SituationCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDrama2SituationCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDrama2SituationSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDrama2SituationCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDrama2SituationCollectionSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDrama2SituationSaveData s_ArrayItem0;
		SDrama2SituationSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SDrama2SituationCollectionSaveData*>(p_Target) = s_Object;
}

void SDrama2SituationCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDrama2SituationCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDrama2SituationCollectionSaveData, m_aEntities));
	TArray<SDrama2SituationSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDrama2SituationCollectionSaveData, m_aStates));
}

bool SDrama2SituationCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDrama2SituationCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDrama2SituationCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDrama2SituationCollectionSaveData::operator==(const SDrama2SituationCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDrama2SituationCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDrama2SituationCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDrama2SituationCollectionSaveData*>(p_Object);
	s_Object->~SDrama2SituationCollectionSaveData();
}

ZHMTypeInfo SDramaActorSaveState::TypeInfo = ZHMTypeInfo("SDramaActorSaveState", sizeof(SDramaActorSaveState), alignof(SDramaActorSaveState), SDramaActorSaveState::WriteSimpleJson, SDramaActorSaveState::FromSimpleJson, SDramaActorSaveState::Serialize, SDramaActorSaveState::Equals, SDramaActorSaveState::Destroy);

void SDramaActorSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSequence") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSequence);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sMatchName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sMatchName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tActorSpeakEnd") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tActorSpeakEnd, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsSpeaking") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSpeaking);

	p_Stream << "}";
}

void SDramaActorSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaActorSaveState s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rSequence = simdjson::from_json_uint32(p_Document["m_rSequence"]);

	s_Object.m_rBehavior = simdjson::from_json_uint32(p_Document["m_rBehavior"]);

	s_Object.m_rCurrentSpeakEntity = simdjson::from_json_uint32(p_Document["m_rCurrentSpeakEntity"]);

	s_Object.m_rScreenplay = simdjson::from_json_uint32(p_Document["m_rScreenplay"]);

	s_Object.m_sMatchName = std::string_view(p_Document["m_sMatchName"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tActorSpeakEnd"], &s_Item);
		s_Object.m_tActorSpeakEnd = s_Item;
	}

	s_Object.m_bIsDone = simdjson::from_json_bool(p_Document["m_bIsDone"]);

	s_Object.m_bIsPaused = simdjson::from_json_bool(p_Document["m_bIsPaused"]);

	s_Object.m_bIsSpeaking = simdjson::from_json_bool(p_Document["m_bIsSpeaking"]);

	*reinterpret_cast<SDramaActorSaveState*>(p_Target) = s_Object;
}

void SDramaActorSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);

	ZString::Serialize(&s_Object->m_sMatchName, p_Serializer, p_OwnOffset + offsetof(SDramaActorSaveState, m_sMatchName));
	ZGameTime::Serialize(&s_Object->m_tActorSpeakEnd, p_Serializer, p_OwnOffset + offsetof(SDramaActorSaveState, m_tActorSpeakEnd));
}

bool SDramaActorSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaActorSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaActorSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaActorSaveState::operator==(const SDramaActorSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaActorSaveState>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rSequence != p_Other.m_rSequence) return false;
	if (m_rBehavior != p_Other.m_rBehavior) return false;
	if (m_rCurrentSpeakEntity != p_Other.m_rCurrentSpeakEntity) return false;
	if (m_rScreenplay != p_Other.m_rScreenplay) return false;
	if (m_sMatchName != p_Other.m_sMatchName) return false;
	if (m_tActorSpeakEnd != p_Other.m_tActorSpeakEnd) return false;
	if (m_bIsDone != p_Other.m_bIsDone) return false;
	if (m_bIsPaused != p_Other.m_bIsPaused) return false;
	if (m_bIsSpeaking != p_Other.m_bIsSpeaking) return false;

	return true;
}

void SDramaActorSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaActorSaveState*>(p_Object);
	s_Object->~SDramaActorSaveState();
}

ZHMTypeInfo SDramaActorCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaActorCollectionSaveData", sizeof(SDramaActorCollectionSaveData), alignof(SDramaActorCollectionSaveData), SDramaActorCollectionSaveData::WriteSimpleJson, SDramaActorCollectionSaveData::FromSimpleJson, SDramaActorCollectionSaveData::Serialize, SDramaActorCollectionSaveData::Equals, SDramaActorCollectionSaveData::Destroy);

void SDramaActorCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaActorSaveState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaActorCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaActorCollectionSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDramaActorSaveState s_ArrayItem0;
		SDramaActorSaveState::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SDramaActorCollectionSaveData*>(p_Target) = s_Object;
}

void SDramaActorCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaActorCollectionSaveData, m_aEntities));
	TArray<SDramaActorSaveState>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaActorCollectionSaveData, m_aStates));
}

bool SDramaActorCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaActorCollectionSaveData::operator==(const SDramaActorCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaActorCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDramaActorCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaActorCollectionSaveData*>(p_Object);
	s_Object->~SDramaActorCollectionSaveData();
}

ZHMTypeInfo SDramaControllerSaveData::TypeInfo = ZHMTypeInfo("SDramaControllerSaveData", sizeof(SDramaControllerSaveData), alignof(SDramaControllerSaveData), SDramaControllerSaveData::WriteSimpleJson, SDramaControllerSaveData::FromSimpleJson, SDramaControllerSaveData::Serialize, SDramaControllerSaveData::Equals, SDramaControllerSaveData::Destroy);

void SDramaControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsStartCondValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsStartCondValid);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnableCondValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnableCondValid);

	p_Stream << "}";
}

void SDramaControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaControllerSaveData s_Object {};

	s_Object.m_bIsStartCondValid = simdjson::from_json_bool(p_Document["m_bIsStartCondValid"]);

	s_Object.m_bIsEnableCondValid = simdjson::from_json_bool(p_Document["m_bIsEnableCondValid"]);

	*reinterpret_cast<SDramaControllerSaveData*>(p_Target) = s_Object;
}

void SDramaControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaControllerSaveData*>(p_Object);

}

bool SDramaControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaControllerSaveData::operator==(const SDramaControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaControllerSaveData>)
		return false;

	if (m_bIsStartCondValid != p_Other.m_bIsStartCondValid) return false;
	if (m_bIsEnableCondValid != p_Other.m_bIsEnableCondValid) return false;

	return true;
}

void SDramaControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaControllerSaveData*>(p_Object);
	s_Object->~SDramaControllerSaveData();
}

ZHMTypeInfo SDramaSetupSaveData::TypeInfo = ZHMTypeInfo("SDramaSetupSaveData", sizeof(SDramaSetupSaveData), alignof(SDramaSetupSaveData), SDramaSetupSaveData::WriteSimpleJson, SDramaSetupSaveData::FromSimpleJson, SDramaSetupSaveData::Serialize, SDramaSetupSaveData::Equals, SDramaSetupSaveData::Destroy);

void SDramaSetupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bDoneTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneTriggered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZScreenplay.EState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSituation);

	p_Stream << "}";
}

void SDramaSetupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaSetupSaveData s_Object {};

	s_Object.m_bDoneTriggered = simdjson::from_json_bool(p_Document["m_bDoneTriggered"]);

	s_Object.m_eState = static_cast<ZScreenplay_EState>(ZHMEnums::GetEnumValueByName("ZScreenplay.EState", std::string_view(p_Document["m_eState"])));

	s_Object.m_rSituation = simdjson::from_json_uint32(p_Document["m_rSituation"]);

	*reinterpret_cast<SDramaSetupSaveData*>(p_Target) = s_Object;
}

void SDramaSetupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);

}

bool SDramaSetupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSetupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSetupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSetupSaveData::operator==(const SDramaSetupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSetupSaveData>)
		return false;

	if (m_bDoneTriggered != p_Other.m_bDoneTriggered) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_rSituation != p_Other.m_rSituation) return false;

	return true;
}

void SDramaSetupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaSetupSaveData*>(p_Object);
	s_Object->~SDramaSetupSaveData();
}

ZHMTypeInfo SDramaSetupCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaSetupCollectionSaveData", sizeof(SDramaSetupCollectionSaveData), alignof(SDramaSetupCollectionSaveData), SDramaSetupCollectionSaveData::WriteSimpleJson, SDramaSetupCollectionSaveData::FromSimpleJson, SDramaSetupCollectionSaveData::Serialize, SDramaSetupCollectionSaveData::Equals, SDramaSetupCollectionSaveData::Destroy);

void SDramaSetupCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaSetupSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaSetupCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaSetupCollectionSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDramaSetupSaveData s_ArrayItem0;
		SDramaSetupSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Target) = s_Object;
}

void SDramaSetupCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaSetupCollectionSaveData, m_aEntities));
	TArray<SDramaSetupSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaSetupCollectionSaveData, m_aStates));
}

bool SDramaSetupCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSetupCollectionSaveData::operator==(const SDramaSetupCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSetupCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDramaSetupCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaSetupCollectionSaveData*>(p_Object);
	s_Object->~SDramaSetupCollectionSaveData();
}

ZHMTypeInfo SDramaSituationSaveData::TypeInfo = ZHMTypeInfo("SDramaSituationSaveData", sizeof(SDramaSituationSaveData), alignof(SDramaSituationSaveData), SDramaSituationSaveData::WriteSimpleJson, SDramaSituationSaveData::FromSimpleJson, SDramaSituationSaveData::Serialize, SDramaSituationSaveData::Equals, SDramaSituationSaveData::Destroy);

void SDramaSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSituationRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsTerminated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsTerminated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPriorityModifier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPriorityModifier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentDrama") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentDrama);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bProvidersStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bProvidersStarted);

	p_Stream << "}";
}

void SDramaSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaSituationSaveData s_Object {};

	s_Object.m_bSituationRunning = simdjson::from_json_bool(p_Document["m_bSituationRunning"]);

	s_Object.m_bIsTerminated = simdjson::from_json_bool(p_Document["m_bIsTerminated"]);

	s_Object.m_nPriorityModifier = simdjson::from_json_float32(p_Document["m_nPriorityModifier"]);

	s_Object.m_nCurrentDrama = simdjson::from_json_int32(p_Document["m_nCurrentDrama"]);

	s_Object.m_bProvidersStarted = simdjson::from_json_bool(p_Document["m_bProvidersStarted"]);

	*reinterpret_cast<SDramaSituationSaveData*>(p_Target) = s_Object;
}

void SDramaSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);

}

bool SDramaSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSituationSaveData::operator==(const SDramaSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSituationSaveData>)
		return false;

	if (m_bSituationRunning != p_Other.m_bSituationRunning) return false;
	if (m_bIsTerminated != p_Other.m_bIsTerminated) return false;
	if (m_nPriorityModifier != p_Other.m_nPriorityModifier) return false;
	if (m_nCurrentDrama != p_Other.m_nCurrentDrama) return false;
	if (m_bProvidersStarted != p_Other.m_bProvidersStarted) return false;

	return true;
}

void SDramaSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaSituationSaveData*>(p_Object);
	s_Object->~SDramaSituationSaveData();
}

ZHMTypeInfo SDramaSituationCollectionSaveData::TypeInfo = ZHMTypeInfo("SDramaSituationCollectionSaveData", sizeof(SDramaSituationCollectionSaveData), alignof(SDramaSituationCollectionSaveData), SDramaSituationCollectionSaveData::WriteSimpleJson, SDramaSituationCollectionSaveData::FromSimpleJson, SDramaSituationCollectionSaveData::Serialize, SDramaSituationCollectionSaveData::Equals, SDramaSituationCollectionSaveData::Destroy);

void SDramaSituationCollectionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SDramaSituationSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDramaSituationCollectionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDramaSituationCollectionSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDramaSituationSaveData s_ArrayItem0;
		SDramaSituationSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Target) = s_Object;
}

void SDramaSituationCollectionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SDramaSituationCollectionSaveData, m_aEntities));
	TArray<SDramaSituationSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SDramaSituationCollectionSaveData, m_aStates));
}

bool SDramaSituationCollectionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDramaSituationCollectionSaveData::operator==(const SDramaSituationCollectionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDramaSituationCollectionSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aStates != p_Other.m_aStates) return false;

	return true;
}

void SDramaSituationCollectionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDramaSituationCollectionSaveData*>(p_Object);
	s_Object->~SDramaSituationCollectionSaveData();
}

ZHMTypeInfo SDynamicEnforcerCandidateSaveData::TypeInfo = ZHMTypeInfo("SDynamicEnforcerCandidateSaveData", sizeof(SDynamicEnforcerCandidateSaveData), alignof(SDynamicEnforcerCandidateSaveData), SDynamicEnforcerCandidateSaveData::WriteSimpleJson, SDynamicEnforcerCandidateSaveData::FromSimpleJson, SDynamicEnforcerCandidateSaveData::Serialize, SDynamicEnforcerCandidateSaveData::Equals, SDynamicEnforcerCandidateSaveData::Destroy);

void SDynamicEnforcerCandidateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadius);

	p_Stream << "}";
}

void SDynamicEnforcerCandidateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDynamicEnforcerCandidateSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	s_Object.m_eType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eType"])));

	s_Object.m_fRadius = simdjson::from_json_float32(p_Document["m_fRadius"]);

	*reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Target) = s_Object;
}

void SDynamicEnforcerCandidateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SDynamicEnforcerCandidateSaveData, m_vPosition));
}

bool SDynamicEnforcerCandidateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicEnforcerCandidateSaveData::operator==(const SDynamicEnforcerCandidateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicEnforcerCandidateSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_fRadius != p_Other.m_fRadius) return false;

	return true;
}

void SDynamicEnforcerCandidateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerCandidateSaveData*>(p_Object);
	s_Object->~SDynamicEnforcerCandidateSaveData();
}

ZHMTypeInfo SDynamicEnforcerServiceSaveData::TypeInfo = ZHMTypeInfo("SDynamicEnforcerServiceSaveData", sizeof(SDynamicEnforcerServiceSaveData), alignof(SDynamicEnforcerServiceSaveData), SDynamicEnforcerServiceSaveData::WriteSimpleJson, SDynamicEnforcerServiceSaveData::FromSimpleJson, SDynamicEnforcerServiceSaveData::Serialize, SDynamicEnforcerServiceSaveData::Equals, SDynamicEnforcerServiceSaveData::Destroy);

void SDynamicEnforcerServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aCandidates[i];
		SDynamicEnforcerCandidateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SDynamicEnforcerServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDynamicEnforcerServiceSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aCandidates"];
	s_Object.m_aCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDynamicEnforcerCandidateSaveData s_ArrayItem0;
		SDynamicEnforcerCandidateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aCandidates[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Target) = s_Object;
}

void SDynamicEnforcerServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);

	TArray<SDynamicEnforcerCandidateSaveData>::Serialize(&s_Object->m_aCandidates, p_Serializer, p_OwnOffset + offsetof(SDynamicEnforcerServiceSaveData, m_aCandidates));
}

bool SDynamicEnforcerServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicEnforcerServiceSaveData::operator==(const SDynamicEnforcerServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicEnforcerServiceSaveData>)
		return false;

	if (m_aCandidates != p_Other.m_aCandidates) return false;

	return true;
}

void SDynamicEnforcerServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDynamicEnforcerServiceSaveData*>(p_Object);
	s_Object->~SDynamicEnforcerServiceSaveData();
}

ZHMTypeInfo SDynamicObjectKeyValuePair::TypeInfo = ZHMTypeInfo("SDynamicObjectKeyValuePair", sizeof(SDynamicObjectKeyValuePair), alignof(SDynamicObjectKeyValuePair), SDynamicObjectKeyValuePair::WriteSimpleJson, SDynamicObjectKeyValuePair::FromSimpleJson, SDynamicObjectKeyValuePair::Serialize, SDynamicObjectKeyValuePair::Equals, SDynamicObjectKeyValuePair::Destroy);

void SDynamicObjectKeyValuePair::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("value") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->value, p_Stream);

	p_Stream << "}";
}

void SDynamicObjectKeyValuePair::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDynamicObjectKeyValuePair s_Object {};

	s_Object.sKey = std::string_view(p_Document["sKey"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["value"], &s_Item);
		s_Object.value = s_Item;
	}

	*reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Target) = s_Object;
}

void SDynamicObjectKeyValuePair::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);

	ZString::Serialize(&s_Object->sKey, p_Serializer, p_OwnOffset + offsetof(SDynamicObjectKeyValuePair, sKey));
	ZDynamicObject::Serialize(&s_Object->value, p_Serializer, p_OwnOffset + offsetof(SDynamicObjectKeyValuePair, value));
}

bool SDynamicObjectKeyValuePair::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicObjectKeyValuePair::operator==(const SDynamicObjectKeyValuePair& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicObjectKeyValuePair>)
		return false;

	if (sKey != p_Other.sKey) return false;
	if (value != p_Other.value) return false;

	return true;
}

void SDynamicObjectKeyValuePair::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDynamicObjectKeyValuePair*>(p_Object);
	s_Object->~SDynamicObjectKeyValuePair();
}

ZHMTypeInfo SDynamicRayCastEntitySaveData::TypeInfo = ZHMTypeInfo("SDynamicRayCastEntitySaveData", sizeof(SDynamicRayCastEntitySaveData), alignof(SDynamicRayCastEntitySaveData), SDynamicRayCastEntitySaveData::WriteSimpleJson, SDynamicRayCastEntitySaveData::FromSimpleJson, SDynamicRayCastEntitySaveData::Serialize, SDynamicRayCastEntitySaveData::Equals, SDynamicRayCastEntitySaveData::Destroy);

void SDynamicRayCastEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRayIntersecting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRayIntersecting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsCurrentlyEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsCurrentlyEnabled);

	p_Stream << "}";
}

void SDynamicRayCastEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SDynamicRayCastEntitySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bIsRayIntersecting = simdjson::from_json_bool(p_Document["m_bIsRayIntersecting"]);

	s_Object.m_bIsCurrentlyEnabled = simdjson::from_json_bool(p_Document["m_bIsCurrentlyEnabled"]);

	*reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Target) = s_Object;
}

void SDynamicRayCastEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);

}

bool SDynamicRayCastEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SDynamicRayCastEntitySaveData::operator==(const SDynamicRayCastEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SDynamicRayCastEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bIsRayIntersecting != p_Other.m_bIsRayIntersecting) return false;
	if (m_bIsCurrentlyEnabled != p_Other.m_bIsCurrentlyEnabled) return false;

	return true;
}

void SDynamicRayCastEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SDynamicRayCastEntitySaveData*>(p_Object);
	s_Object->~SDynamicRayCastEntitySaveData();
}

ZHMTypeInfo SEntityPath::TypeInfo = ZHMTypeInfo("SEntityPath", sizeof(SEntityPath), alignof(SEntityPath), SEntityPath::WriteSimpleJson, SEntityPath::FromSimpleJson, SEntityPath::Serialize, SEntityPath::Equals, SEntityPath::Destroy);

void SEntityPath::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nOwnerID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOwnerID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityPath") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityPath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityPath[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityPath.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityPath::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityPath s_Object {};

	s_Object.m_nOwnerID = simdjson::from_json_uint64(p_Document["m_nOwnerID"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityPath"];
	s_Object.m_aEntityPath.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntityPath[s_Index0++] = simdjson::from_json_uint64(s_Item0);
	}
	}

	*reinterpret_cast<SEntityPath*>(p_Target) = s_Object;
}

void SEntityPath::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);

	TArray<uint64>::Serialize(&s_Object->m_aEntityPath, p_Serializer, p_OwnOffset + offsetof(SEntityPath, m_aEntityPath));
}

bool SEntityPath::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityPath*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityPath*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityPath::operator==(const SEntityPath& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityPath>)
		return false;

	if (m_nOwnerID != p_Other.m_nOwnerID) return false;
	if (m_aEntityPath != p_Other.m_aEntityPath) return false;

	return true;
}

void SEntityPath::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityPath*>(p_Object);
	s_Object->~SEntityPath();
}

ZHMTypeInfo SEntityPinDescriptor::TypeInfo = ZHMTypeInfo("SEntityPinDescriptor", sizeof(SEntityPinDescriptor), alignof(SEntityPinDescriptor), SEntityPinDescriptor::WriteSimpleJson, SEntityPinDescriptor::FromSimpleJson, SEntityPinDescriptor::Serialize, SEntityPinDescriptor::Equals, SEntityPinDescriptor::Destroy);

void SEntityPinDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->type, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsPlaceholder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsPlaceholder);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsHidden);

	p_Stream << "}";
}

void SEntityPinDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityPinDescriptor s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	s_Object.sDisplayName = std::string_view(p_Document["sDisplayName"]);

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["type"], &s_Item);
		s_Object.type = s_Item;
	}

	s_Object.sHelpText = std::string_view(p_Document["sHelpText"]);

	s_Object.bIsPlaceholder = simdjson::from_json_bool(p_Document["bIsPlaceholder"]);

	s_Object.bIsHidden = simdjson::from_json_bool(p_Document["bIsHidden"]);

	*reinterpret_cast<SEntityPinDescriptor*>(p_Target) = s_Object;
}

void SEntityPinDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sDisplayName));
	ZResourceID::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, type));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SEntityPinDescriptor, sHelpText));
}

bool SEntityPinDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityPinDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityPinDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityPinDescriptor::operator==(const SEntityPinDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityPinDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (type != p_Other.type) return false;
	if (sHelpText != p_Other.sHelpText) return false;
	if (bIsPlaceholder != p_Other.bIsPlaceholder) return false;
	if (bIsHidden != p_Other.bIsHidden) return false;

	return true;
}

void SEntityPinDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityPinDescriptor*>(p_Object);
	s_Object->~SEntityPinDescriptor();
}

ZHMTypeInfo SEntityTemplateEntitySubset::TypeInfo = ZHMTypeInfo("SEntityTemplateEntitySubset", sizeof(SEntityTemplateEntitySubset), alignof(SEntityTemplateEntitySubset), SEntityTemplateEntitySubset::WriteSimpleJson, SEntityTemplateEntitySubset::FromSimpleJson, SEntityTemplateEntitySubset::Serialize, SEntityTemplateEntitySubset::Equals, SEntityTemplateEntitySubset::Destroy);

void SEntityTemplateEntitySubset::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("entities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entities.size(); ++i)
	{
		auto& s_Item0 = s_Object->entities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->entities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityTemplateEntitySubset::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateEntitySubset s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["entities"];
	s_Object.entities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.entities[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<SEntityTemplateEntitySubset*>(p_Target) = s_Object;
}

void SEntityTemplateEntitySubset::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);

	TArray<int32>::Serialize(&s_Object->entities, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateEntitySubset, entities));
}

bool SEntityTemplateEntitySubset::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateEntitySubset::operator==(const SEntityTemplateEntitySubset& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateEntitySubset>)
		return false;

	if (entities != p_Other.entities) return false;

	return true;
}

void SEntityTemplateEntitySubset::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateEntitySubset*>(p_Object);
	s_Object->~SEntityTemplateEntitySubset();
}

ZHMTypeInfo SEntityTemplateReference::TypeInfo = ZHMTypeInfo("SEntityTemplateReference", sizeof(SEntityTemplateReference), alignof(SEntityTemplateReference), SEntityTemplateReference::WriteSimpleJson, SEntityTemplateReference::FromSimpleJson, SEntityTemplateReference::Serialize, SEntityTemplateReference::Equals, SEntityTemplateReference::Destroy);

void SEntityTemplateReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->externalSceneIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->exposedEntity);

	p_Stream << "}";
}

void SEntityTemplateReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateReference s_Object {};

	s_Object.entityID = simdjson::from_json_uint64(p_Document["entityID"]);

	s_Object.externalSceneIndex = simdjson::from_json_int32(p_Document["externalSceneIndex"]);

	s_Object.entityIndex = simdjson::from_json_int32(p_Document["entityIndex"]);

	s_Object.exposedEntity = std::string_view(p_Document["exposedEntity"]);

	*reinterpret_cast<SEntityTemplateReference*>(p_Target) = s_Object;
}

void SEntityTemplateReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);

	ZString::Serialize(&s_Object->exposedEntity, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateReference, exposedEntity));
}

bool SEntityTemplateReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateReference*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateReference::operator==(const SEntityTemplateReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateReference>)
		return false;

	if (entityID != p_Other.entityID) return false;
	if (externalSceneIndex != p_Other.externalSceneIndex) return false;
	if (entityIndex != p_Other.entityIndex) return false;
	if (exposedEntity != p_Other.exposedEntity) return false;

	return true;
}

void SEntityTemplateReference::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateReference*>(p_Object);
	s_Object->~SEntityTemplateReference();
}

ZHMTypeInfo SEntityTemplateExposedEntity::TypeInfo = ZHMTypeInfo("SEntityTemplateExposedEntity", sizeof(SEntityTemplateExposedEntity), alignof(SEntityTemplateExposedEntity), SEntityTemplateExposedEntity::WriteSimpleJson, SEntityTemplateExposedEntity::FromSimpleJson, SEntityTemplateExposedEntity::Serialize, SEntityTemplateExposedEntity::Equals, SEntityTemplateExposedEntity::Destroy);

void SEntityTemplateExposedEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateExposedEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsArray") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsArray);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aTargets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aTargets.size(); ++i)
	{
		auto& s_Item0 = s_Object->aTargets[i];
		SEntityTemplateReference::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aTargets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEntityTemplateExposedEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplateExposedEntity s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	s_Object.bIsArray = simdjson::from_json_bool(p_Document["bIsArray"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aTargets"];
	s_Object.aTargets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateReference s_ArrayItem0;
		SEntityTemplateReference::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aTargets[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SEntityTemplateExposedEntity*>(p_Target) = s_Object;
}

void SEntityTemplateExposedEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateExposedEntity*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateExposedEntity, sName));
	TArray<SEntityTemplateReference>::Serialize(&s_Object->aTargets, p_Serializer, p_OwnOffset + offsetof(SEntityTemplateExposedEntity, aTargets));
}

bool SEntityTemplateExposedEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplateExposedEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplateExposedEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplateExposedEntity::operator==(const SEntityTemplateExposedEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplateExposedEntity>)
		return false;

	if (sName != p_Other.sName) return false;
	if (bIsArray != p_Other.bIsArray) return false;
	if (aTargets != p_Other.aTargets) return false;

	return true;
}

void SEntityTemplateExposedEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplateExposedEntity*>(p_Object);
	s_Object->~SEntityTemplateExposedEntity();
}

ZHMTypeInfo SEntityTemplatePinConnection::TypeInfo = ZHMTypeInfo("SEntityTemplatePinConnection", sizeof(SEntityTemplatePinConnection), alignof(SEntityTemplatePinConnection), SEntityTemplatePinConnection::WriteSimpleJson, SEntityTemplatePinConnection::FromSimpleJson, SEntityTemplatePinConnection::Serialize, SEntityTemplatePinConnection::Equals, SEntityTemplatePinConnection::Destroy);

void SEntityTemplatePinConnection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fromID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fromPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromPinName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toPinName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("constantPinValue") << ":";
	ZVariant::WriteSimpleJson(&s_Object->constantPinValue, p_Stream);

	p_Stream << "}";
}

void SEntityTemplatePinConnection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePinConnection s_Object {};

	s_Object.fromID = simdjson::from_json_int32(p_Document["fromID"]);

	s_Object.toID = simdjson::from_json_int32(p_Document["toID"]);

	s_Object.fromPinName = std::string_view(p_Document["fromPinName"]);

	s_Object.toPinName = std::string_view(p_Document["toPinName"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["constantPinValue"], &s_Item);
		s_Object.constantPinValue = s_Item;
	}

	*reinterpret_cast<SEntityTemplatePinConnection*>(p_Target) = s_Object;
}

void SEntityTemplatePinConnection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);

	ZString::Serialize(&s_Object->fromPinName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, fromPinName));
	ZString::Serialize(&s_Object->toPinName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, toPinName));
	ZVariant::Serialize(&s_Object->constantPinValue, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePinConnection, constantPinValue));
}

bool SEntityTemplatePinConnection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePinConnection*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePinConnection*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePinConnection::operator==(const SEntityTemplatePinConnection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePinConnection>)
		return false;

	if (fromID != p_Other.fromID) return false;
	if (toID != p_Other.toID) return false;
	if (fromPinName != p_Other.fromPinName) return false;
	if (toPinName != p_Other.toPinName) return false;
	if (constantPinValue != p_Other.constantPinValue) return false;

	return true;
}

void SEntityTemplatePinConnection::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePinConnection*>(p_Object);
	s_Object->~SEntityTemplatePinConnection();
}

ZHMTypeInfo SEntityTemplatePlatformSpecificProperty::TypeInfo = ZHMTypeInfo("SEntityTemplatePlatformSpecificProperty", sizeof(SEntityTemplatePlatformSpecificProperty), alignof(SEntityTemplatePlatformSpecificProperty), SEntityTemplatePlatformSpecificProperty::WriteSimpleJson, SEntityTemplatePlatformSpecificProperty::FromSimpleJson, SEntityTemplatePlatformSpecificProperty::Serialize, SEntityTemplatePlatformSpecificProperty::Equals, SEntityTemplatePlatformSpecificProperty::Destroy);

void SEntityTemplatePlatformSpecificProperty::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePlatformSpecificProperty*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("propertyValue") << ":";
	SEntityTemplateProperty::WriteSimpleJson(&s_Object->propertyValue, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("platform") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EVirtualPlatformID", static_cast<int>(s_Object->platform)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("postInit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->postInit);

	p_Stream << "}";
}

void SEntityTemplatePlatformSpecificProperty::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePlatformSpecificProperty s_Object {};

	{
		SEntityTemplateProperty s_Item {};
		SEntityTemplateProperty::FromSimpleJson(p_Document["propertyValue"], &s_Item);
		s_Object.propertyValue = s_Item;
	}

	s_Object.platform = static_cast<EVirtualPlatformID>(ZHMEnums::GetEnumValueByName("EVirtualPlatformID", std::string_view(p_Document["platform"])));

	s_Object.postInit = simdjson::from_json_bool(p_Document["postInit"]);

	*reinterpret_cast<SEntityTemplatePlatformSpecificProperty*>(p_Target) = s_Object;
}

void SEntityTemplatePlatformSpecificProperty::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePlatformSpecificProperty*>(p_Object);

	SEntityTemplateProperty::Serialize(&s_Object->propertyValue, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePlatformSpecificProperty, propertyValue));
}

bool SEntityTemplatePlatformSpecificProperty::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePlatformSpecificProperty*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePlatformSpecificProperty*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePlatformSpecificProperty::operator==(const SEntityTemplatePlatformSpecificProperty& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePlatformSpecificProperty>)
		return false;

	if (propertyValue != p_Other.propertyValue) return false;
	if (platform != p_Other.platform) return false;
	if (postInit != p_Other.postInit) return false;

	return true;
}

void SEntityTemplatePlatformSpecificProperty::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePlatformSpecificProperty*>(p_Object);
	s_Object->~SEntityTemplatePlatformSpecificProperty();
}

ZHMTypeInfo SEntityTemplatePropertyAlias::TypeInfo = ZHMTypeInfo("SEntityTemplatePropertyAlias", sizeof(SEntityTemplatePropertyAlias), alignof(SEntityTemplatePropertyAlias), SEntityTemplatePropertyAlias::WriteSimpleJson, SEntityTemplatePropertyAlias::FromSimpleJson, SEntityTemplatePropertyAlias::Serialize, SEntityTemplatePropertyAlias::Equals, SEntityTemplatePropertyAlias::Destroy);

void SEntityTemplatePropertyAlias::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sAliasName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sAliasName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sPropertyName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sPropertyName);

	p_Stream << "}";
}

void SEntityTemplatePropertyAlias::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePropertyAlias s_Object {};

	s_Object.sAliasName = std::string_view(p_Document["sAliasName"]);

	s_Object.entityID = simdjson::from_json_int32(p_Document["entityID"]);

	s_Object.sPropertyName = std::string_view(p_Document["sPropertyName"]);

	*reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Target) = s_Object;
}

void SEntityTemplatePropertyAlias::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);

	ZString::Serialize(&s_Object->sAliasName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyAlias, sAliasName));
	ZString::Serialize(&s_Object->sPropertyName, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyAlias, sPropertyName));
}

bool SEntityTemplatePropertyAlias::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePropertyAlias::operator==(const SEntityTemplatePropertyAlias& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePropertyAlias>)
		return false;

	if (sAliasName != p_Other.sAliasName) return false;
	if (entityID != p_Other.entityID) return false;
	if (sPropertyName != p_Other.sPropertyName) return false;

	return true;
}

void SEntityTemplatePropertyAlias::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyAlias*>(p_Object);
	s_Object->~SEntityTemplatePropertyAlias();
}

ZHMTypeInfo SEntityTemplatePropertyOverride::TypeInfo = ZHMTypeInfo("SEntityTemplatePropertyOverride", sizeof(SEntityTemplatePropertyOverride), alignof(SEntityTemplatePropertyOverride), SEntityTemplatePropertyOverride::WriteSimpleJson, SEntityTemplatePropertyOverride::FromSimpleJson, SEntityTemplatePropertyOverride::Serialize, SEntityTemplatePropertyOverride::Equals, SEntityTemplatePropertyOverride::Destroy);

void SEntityTemplatePropertyOverride::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("propertyOwner") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->propertyOwner, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValue") << ":";
	SEntityTemplateProperty::WriteSimpleJson(&s_Object->propertyValue, p_Stream);

	p_Stream << "}";
}

void SEntityTemplatePropertyOverride::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEntityTemplatePropertyOverride s_Object {};

	{
		SEntityTemplateReference s_Item {};
		SEntityTemplateReference::FromSimpleJson(p_Document["propertyOwner"], &s_Item);
		s_Object.propertyOwner = s_Item;
	}

	{
		SEntityTemplateProperty s_Item {};
		SEntityTemplateProperty::FromSimpleJson(p_Document["propertyValue"], &s_Item);
		s_Object.propertyValue = s_Item;
	}

	*reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Target) = s_Object;
}

void SEntityTemplatePropertyOverride::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->propertyOwner, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyOverride, propertyOwner));
	SEntityTemplateProperty::Serialize(&s_Object->propertyValue, p_Serializer, p_OwnOffset + offsetof(SEntityTemplatePropertyOverride, propertyValue));
}

bool SEntityTemplatePropertyOverride::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Left);
	auto* s_Right = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEntityTemplatePropertyOverride::operator==(const SEntityTemplatePropertyOverride& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEntityTemplatePropertyOverride>)
		return false;

	if (propertyOwner != p_Other.propertyOwner) return false;
	if (propertyValue != p_Other.propertyValue) return false;

	return true;
}

void SEntityTemplatePropertyOverride::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEntityTemplatePropertyOverride*>(p_Object);
	s_Object->~SEntityTemplatePropertyOverride();
}

ZHMTypeInfo SEnvironmentConfigResourceEntry::TypeInfo = ZHMTypeInfo("SEnvironmentConfigResourceEntry", sizeof(SEnvironmentConfigResourceEntry), alignof(SEnvironmentConfigResourceEntry), SEnvironmentConfigResourceEntry::WriteSimpleJson, SEnvironmentConfigResourceEntry::FromSimpleJson, SEnvironmentConfigResourceEntry::Serialize, SEnvironmentConfigResourceEntry::Equals, SEnvironmentConfigResourceEntry::Destroy);

void SEnvironmentConfigResourceEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Name") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Name);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ContractsDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->ContractsDatastoreRid, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("UnlockablesDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->UnlockablesDatastoreRid, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("BlobsDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->BlobsDatastoreRid, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ActivityDatastoreRid") << ":";
	ZResourceID::WriteSimpleJson(&s_Object->ActivityDatastoreRid, p_Stream);

	p_Stream << "}";
}

void SEnvironmentConfigResourceEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEnvironmentConfigResourceEntry s_Object {};

	s_Object.Name = std::string_view(p_Document["Name"]);

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["ContractsDatastoreRid"], &s_Item);
		s_Object.ContractsDatastoreRid = s_Item;
	}

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["UnlockablesDatastoreRid"], &s_Item);
		s_Object.UnlockablesDatastoreRid = s_Item;
	}

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["BlobsDatastoreRid"], &s_Item);
		s_Object.BlobsDatastoreRid = s_Item;
	}

	{
		ZResourceID s_Item {};
		ZResourceID::FromSimpleJson(p_Document["ActivityDatastoreRid"], &s_Item);
		s_Object.ActivityDatastoreRid = s_Item;
	}

	*reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Target) = s_Object;
}

void SEnvironmentConfigResourceEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);

	ZString::Serialize(&s_Object->Name, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, Name));
	ZResourceID::Serialize(&s_Object->ContractsDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, ContractsDatastoreRid));
	ZResourceID::Serialize(&s_Object->UnlockablesDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, UnlockablesDatastoreRid));
	ZResourceID::Serialize(&s_Object->BlobsDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, BlobsDatastoreRid));
	ZResourceID::Serialize(&s_Object->ActivityDatastoreRid, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResourceEntry, ActivityDatastoreRid));
}

bool SEnvironmentConfigResourceEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEnvironmentConfigResourceEntry::operator==(const SEnvironmentConfigResourceEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEnvironmentConfigResourceEntry>)
		return false;

	if (Name != p_Other.Name) return false;
	if (ContractsDatastoreRid != p_Other.ContractsDatastoreRid) return false;
	if (UnlockablesDatastoreRid != p_Other.UnlockablesDatastoreRid) return false;
	if (BlobsDatastoreRid != p_Other.BlobsDatastoreRid) return false;
	if (ActivityDatastoreRid != p_Other.ActivityDatastoreRid) return false;

	return true;
}

void SEnvironmentConfigResourceEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResourceEntry*>(p_Object);
	s_Object->~SEnvironmentConfigResourceEntry();
}

ZHMTypeInfo SEnvironmentConfigResource::TypeInfo = ZHMTypeInfo("SEnvironmentConfigResource", sizeof(SEnvironmentConfigResource), alignof(SEnvironmentConfigResource), SEnvironmentConfigResource::WriteSimpleJson, SEnvironmentConfigResource::FromSimpleJson, SEnvironmentConfigResource::Serialize, SEnvironmentConfigResource::Equals, SEnvironmentConfigResource::Destroy);

void SEnvironmentConfigResource::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Environments") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Environments.size(); ++i)
	{
		auto& s_Item0 = s_Object->Environments[i];
		SEnvironmentConfigResourceEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->Environments.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEnvironmentConfigResource::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEnvironmentConfigResource s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["Environments"];
	s_Object.Environments.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEnvironmentConfigResourceEntry s_ArrayItem0;
		SEnvironmentConfigResourceEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.Environments[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SEnvironmentConfigResource*>(p_Target) = s_Object;
}

void SEnvironmentConfigResource::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);

	TArray<SEnvironmentConfigResourceEntry>::Serialize(&s_Object->Environments, p_Serializer, p_OwnOffset + offsetof(SEnvironmentConfigResource, Environments));
}

bool SEnvironmentConfigResource::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEnvironmentConfigResource*>(p_Left);
	auto* s_Right = reinterpret_cast<SEnvironmentConfigResource*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEnvironmentConfigResource::operator==(const SEnvironmentConfigResource& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEnvironmentConfigResource>)
		return false;

	if (Environments != p_Other.Environments) return false;

	return true;
}

void SEnvironmentConfigResource::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEnvironmentConfigResource*>(p_Object);
	s_Object->~SEnvironmentConfigResource();
}

ZHMTypeInfo SEscortOutBehaviorSaveData::TypeInfo = ZHMTypeInfo("SEscortOutBehaviorSaveData", sizeof(SEscortOutBehaviorSaveData), alignof(SEscortOutBehaviorSaveData), SEscortOutBehaviorSaveData::WriteSimpleJson, SEscortOutBehaviorSaveData::FromSimpleJson, SEscortOutBehaviorSaveData::Serialize, SEscortOutBehaviorSaveData::Equals, SEscortOutBehaviorSaveData::Destroy);

void SEscortOutBehaviorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bConversationHelperPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bConversationHelperPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsm") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsm, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vExitPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vExitPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWarningTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWarningTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHardWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHardWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEscortStateSilenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEscortStateSilenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitHitmanToComplyWarningTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitHitmanToComplyWarningTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitHitmanToComplyStateTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitHitmanToComplyStateTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastLookBack") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastLookBack, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReachedExitPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReachedExitPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowExitWarningEnded") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowExitWarningEnded);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bJustShowExit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bJustShowExit);

	p_Stream << "}";
}

void SEscortOutBehaviorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortOutBehaviorSaveData s_Object {};

	s_Object.m_nSituation = simdjson::from_json_int32(p_Document["m_nSituation"]);

	s_Object.m_bConversationHelperPaused = simdjson::from_json_bool(p_Document["m_bConversationHelperPaused"]);

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsm"], &s_Item);
		s_Object.m_fsm = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vExitPosition"], &s_Item);
		s_Object.m_vExitPosition = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tWarningTime"], &s_Item);
		s_Object.m_tWarningTime = s_Item;
	}

	s_Object.m_bHardWarning = simdjson::from_json_bool(p_Document["m_bHardWarning"]);

	s_Object.m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tEscortStateSilenceTime"], &s_Item);
		s_Object.m_tEscortStateSilenceTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tWaitHitmanToComplyWarningTime"], &s_Item);
		s_Object.m_tWaitHitmanToComplyWarningTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tWaitHitmanToComplyStateTime"], &s_Item);
		s_Object.m_tWaitHitmanToComplyStateTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastLookBack"], &s_Item);
		s_Object.m_tLastLookBack = s_Item;
	}

	s_Object.m_bReachedExitPosition = simdjson::from_json_bool(p_Document["m_bReachedExitPosition"]);

	s_Object.m_bShowExitWarningEnded = simdjson::from_json_bool(p_Document["m_bShowExitWarningEnded"]);

	s_Object.m_bJustShowExit = simdjson::from_json_bool(p_Document["m_bJustShowExit"]);

	*reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Target) = s_Object;
}

void SEscortOutBehaviorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsm, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_fsm));
	float4::Serialize(&s_Object->m_vExitPosition, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_vExitPosition));
	ZGameTime::Serialize(&s_Object->m_tWarningTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWarningTime));
	ZGameTime::Serialize(&s_Object->m_tEscortStateSilenceTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tEscortStateSilenceTime));
	ZGameTime::Serialize(&s_Object->m_tWaitHitmanToComplyWarningTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWaitHitmanToComplyWarningTime));
	ZGameTime::Serialize(&s_Object->m_tWaitHitmanToComplyStateTime, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tWaitHitmanToComplyStateTime));
	ZGameTime::Serialize(&s_Object->m_tLastLookBack, p_Serializer, p_OwnOffset + offsetof(SEscortOutBehaviorSaveData, m_tLastLookBack));
}

bool SEscortOutBehaviorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortOutBehaviorSaveData::operator==(const SEscortOutBehaviorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortOutBehaviorSaveData>)
		return false;

	if (m_nSituation != p_Other.m_nSituation) return false;
	if (m_bConversationHelperPaused != p_Other.m_bConversationHelperPaused) return false;
	if (m_fsm != p_Other.m_fsm) return false;
	if (m_vExitPosition != p_Other.m_vExitPosition) return false;
	if (m_tWarningTime != p_Other.m_tWarningTime) return false;
	if (m_bHardWarning != p_Other.m_bHardWarning) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_tEscortStateSilenceTime != p_Other.m_tEscortStateSilenceTime) return false;
	if (m_tWaitHitmanToComplyWarningTime != p_Other.m_tWaitHitmanToComplyWarningTime) return false;
	if (m_tWaitHitmanToComplyStateTime != p_Other.m_tWaitHitmanToComplyStateTime) return false;
	if (m_tLastLookBack != p_Other.m_tLastLookBack) return false;
	if (m_bReachedExitPosition != p_Other.m_bReachedExitPosition) return false;
	if (m_bShowExitWarningEnded != p_Other.m_bShowExitWarningEnded) return false;
	if (m_bJustShowExit != p_Other.m_bJustShowExit) return false;

	return true;
}

void SEscortOutBehaviorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortOutBehaviorSaveData*>(p_Object);
	s_Object->~SEscortOutBehaviorSaveData();
}

ZHMTypeInfo SEscortOutOrderSaveData::TypeInfo = ZHMTypeInfo("SEscortOutOrderSaveData", sizeof(SEscortOutOrderSaveData), alignof(SEscortOutOrderSaveData), SEscortOutOrderSaveData::WriteSimpleJson, SEscortOutOrderSaveData::FromSimpleJson, SEscortOutOrderSaveData::Serialize, SEscortOutOrderSaveData::Equals, SEscortOutOrderSaveData::Destroy);

void SEscortOutOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aExitPoints") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aExitPoints.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aExitPoints[i];
		float4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aExitPoints.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEscortOutOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortOutOrderSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aExitPoints"];
	s_Object.m_aExitPoints.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		float4 s_ArrayItem0;
		float4::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aExitPoints[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SEscortOutOrderSaveData*>(p_Target) = s_Object;
}

void SEscortOutOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);

	TArray<float4>::Serialize(&s_Object->m_aExitPoints, p_Serializer, p_OwnOffset + offsetof(SEscortOutOrderSaveData, m_aExitPoints));
}

bool SEscortOutOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortOutOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortOutOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortOutOrderSaveData::operator==(const SEscortOutOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortOutOrderSaveData>)
		return false;

	if (m_aExitPoints != p_Other.m_aExitPoints) return false;

	return true;
}

void SEscortOutOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortOutOrderSaveData*>(p_Object);
	s_Object->~SEscortOutOrderSaveData();
}

ZHMTypeInfo SEscortSituation2ActorStateSaveData::TypeInfo = ZHMTypeInfo("SEscortSituation2ActorStateSaveData", sizeof(SEscortSituation2ActorStateSaveData), alignof(SEscortSituation2ActorStateSaveData), SEscortSituation2ActorStateSaveData::WriteSimpleJson, SEscortSituation2ActorStateSaveData::FromSimpleJson, SEscortSituation2ActorStateSaveData::Serialize, SEscortSituation2ActorStateSaveData::Equals, SEscortSituation2ActorStateSaveData::Destroy);

void SEscortSituation2ActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2ActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituation2Entity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituation2Entity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SEscortSituation2ActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituation2ActorStateSaveData s_Object {};

	s_Object.m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_eState = static_cast<ZEscortSituation2Entity_EEscortState>(ZHMEnums::GetEnumValueByName("ZEscortSituation2Entity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object.m_eStatePrevious = static_cast<ZEscortSituation2Entity_EEscortState>(ZHMEnums::GetEnumValueByName("ZEscortSituation2Entity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object.m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

	*reinterpret_cast<SEscortSituation2ActorStateSaveData*>(p_Target) = s_Object;
}

void SEscortSituation2ActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2ActorStateSaveData*>(p_Object);

}

bool SEscortSituation2ActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituation2ActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituation2ActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituation2ActorStateSaveData::operator==(const SEscortSituation2ActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituation2ActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

void SEscortSituation2ActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2ActorStateSaveData*>(p_Object);
	s_Object->~SEscortSituation2ActorStateSaveData();
}

ZHMTypeInfo SEscortSituation2Actors::TypeInfo = ZHMTypeInfo("SEscortSituation2Actors", sizeof(SEscortSituation2Actors), alignof(SEscortSituation2Actors), SEscortSituation2Actors::WriteSimpleJson, SEscortSituation2Actors::FromSimpleJson, SEscortSituation2Actors::Serialize, SEscortSituation2Actors::Equals, SEscortSituation2Actors::Destroy);

void SEscortSituation2Actors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2Actors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SEscortSituation2Actors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituation2Actors s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SEscortSituation2Actors*>(p_Target) = s_Object;
}

void SEscortSituation2Actors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2Actors*>(p_Object);

}

bool SEscortSituation2Actors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituation2Actors*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituation2Actors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituation2Actors::operator==(const SEscortSituation2Actors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituation2Actors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SEscortSituation2Actors::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2Actors*>(p_Object);
	s_Object->~SEscortSituation2Actors();
}

ZHMTypeInfo SEscortSituation2SaveData::TypeInfo = ZHMTypeInfo("SEscortSituation2SaveData", sizeof(SEscortSituation2SaveData), alignof(SEscortSituation2SaveData), SEscortSituation2SaveData::WriteSimpleJson, SEscortSituation2SaveData::FromSimpleJson, SEscortSituation2SaveData::Serialize, SEscortSituation2SaveData::Equals, SEscortSituation2SaveData::Destroy);

void SEscortSituation2SaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2SaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceSearch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceSearch);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFoundDeadTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFoundDeadTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetDeadTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetDeadTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituation2Entity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SEscortSituation2Actors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SEscortSituation2ActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSearchActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSearchActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSearchActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSearchActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEscortSituation2SaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituation2SaveData s_Object {};

	s_Object.m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object.m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object.m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object.m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object.m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	s_Object.m_bForceSearch = simdjson::from_json_bool(p_Document["m_bForceSearch"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Item);
		s_Object.m_vLastPosition = s_Item;
	}

	s_Object.m_bFoundDeadTarget = simdjson::from_json_bool(p_Document["m_bFoundDeadTarget"]);

	s_Object.m_nTargetDeadTime = simdjson::from_json_int64(p_Document["m_nTargetDeadTime"]);

	s_Object.m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object.m_eTargetState = static_cast<ZEscortSituation2Entity_ETargetState>(ZHMEnums::GetEnumValueByName("ZEscortSituation2Entity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object.m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object.m_eTargetActState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object.m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object.m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAddedActors"];
	s_Object.m_aAddedActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEscortSituation2Actors s_ArrayItem0;
		SEscortSituation2Actors::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAddedActors[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEscortSituation2ActorStateSaveData s_ArrayItem0;
		SEscortSituation2ActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEscortActs"];
	s_Object.m_aEscortActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEscortActs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSearchActs"];
	s_Object.m_aSearchActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aSearchActs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SEscortSituation2SaveData*>(p_Target) = s_Object;
}

void SEscortSituation2SaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2SaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SEscortSituation2SaveData, m_vLastPosition));
	TArray<SEscortSituation2Actors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SEscortSituation2SaveData, m_aAddedActors));
	TArray<SEscortSituation2ActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SEscortSituation2SaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SEscortSituation2SaveData, m_aEscortActs));
	TArray<uint32>::Serialize(&s_Object->m_aSearchActs, p_Serializer, p_OwnOffset + offsetof(SEscortSituation2SaveData, m_aSearchActs));
}

bool SEscortSituation2SaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituation2SaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituation2SaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituation2SaveData::operator==(const SEscortSituation2SaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituation2SaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_bForceSearch != p_Other.m_bForceSearch) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bFoundDeadTarget != p_Other.m_bFoundDeadTarget) return false;
	if (m_nTargetDeadTime != p_Other.m_nTargetDeadTime) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;
	if (m_aSearchActs != p_Other.m_aSearchActs) return false;

	return true;
}

void SEscortSituation2SaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituation2SaveData*>(p_Object);
	s_Object->~SEscortSituation2SaveData();
}

ZHMTypeInfo SEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SEscortSituationActorStateSaveData", sizeof(SEscortSituationActorStateSaveData), alignof(SEscortSituationActorStateSaveData), SEscortSituationActorStateSaveData::WriteSimpleJson, SEscortSituationActorStateSaveData::FromSimpleJson, SEscortSituationActorStateSaveData::Serialize, SEscortSituationActorStateSaveData::Equals, SEscortSituationActorStateSaveData::Destroy);

void SEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituationActorStateSaveData s_Object {};

	s_Object.m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_eState = static_cast<ZEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object.m_eStatePrevious = static_cast<ZEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object.m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

	*reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Target) = s_Object;
}

void SEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);

}

bool SEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationActorStateSaveData::operator==(const SEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

void SEscortSituationActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActorStateSaveData*>(p_Object);
	s_Object->~SEscortSituationActorStateSaveData();
}

ZHMTypeInfo SEscortSituationActors::TypeInfo = ZHMTypeInfo("SEscortSituationActors", sizeof(SEscortSituationActors), alignof(SEscortSituationActors), SEscortSituationActors::WriteSimpleJson, SEscortSituationActors::FromSimpleJson, SEscortSituationActors::Serialize, SEscortSituationActors::Equals, SEscortSituationActors::Destroy);

void SEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituationActors s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SEscortSituationActors*>(p_Target) = s_Object;
}

void SEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);

}

bool SEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationActors::operator==(const SEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SEscortSituationActors::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituationActors*>(p_Object);
	s_Object->~SEscortSituationActors();
}

ZHMTypeInfo SEscortSituationSaveData::TypeInfo = ZHMTypeInfo("SEscortSituationSaveData", sizeof(SEscortSituationSaveData), alignof(SEscortSituationSaveData), SEscortSituationSaveData::WriteSimpleJson, SEscortSituationSaveData::FromSimpleJson, SEscortSituationSaveData::Serialize, SEscortSituationSaveData::Equals, SEscortSituationSaveData::Destroy);

void SEscortSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceSearch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceSearch);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFoundDeadTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFoundDeadTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetDeadTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetDeadTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SEscortSituationActors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SEscortSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSearchActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSearchActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSearchActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSearchActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEscortSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEscortSituationSaveData s_Object {};

	s_Object.m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object.m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object.m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object.m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object.m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	s_Object.m_bForceSearch = simdjson::from_json_bool(p_Document["m_bForceSearch"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Item);
		s_Object.m_vLastPosition = s_Item;
	}

	s_Object.m_bFoundDeadTarget = simdjson::from_json_bool(p_Document["m_bFoundDeadTarget"]);

	s_Object.m_nTargetDeadTime = simdjson::from_json_int64(p_Document["m_nTargetDeadTime"]);

	s_Object.m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object.m_eTargetState = static_cast<ZEscortSituationEntity_ETargetState>(ZHMEnums::GetEnumValueByName("ZEscortSituationEntity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object.m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object.m_eTargetActState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object.m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object.m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAddedActors"];
	s_Object.m_aAddedActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEscortSituationActors s_ArrayItem0;
		SEscortSituationActors::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAddedActors[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEscortSituationActorStateSaveData s_ArrayItem0;
		SEscortSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEscortActs"];
	s_Object.m_aEscortActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEscortActs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSearchActs"];
	s_Object.m_aSearchActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aSearchActs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SEscortSituationSaveData*>(p_Target) = s_Object;
}

void SEscortSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_vLastPosition));
	TArray<SEscortSituationActors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aAddedActors));
	TArray<SEscortSituationActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aEscortActs));
	TArray<uint32>::Serialize(&s_Object->m_aSearchActs, p_Serializer, p_OwnOffset + offsetof(SEscortSituationSaveData, m_aSearchActs));
}

bool SEscortSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEscortSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEscortSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEscortSituationSaveData::operator==(const SEscortSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEscortSituationSaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_bForceSearch != p_Other.m_bForceSearch) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bFoundDeadTarget != p_Other.m_bFoundDeadTarget) return false;
	if (m_nTargetDeadTime != p_Other.m_nTargetDeadTime) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;
	if (m_aSearchActs != p_Other.m_aSearchActs) return false;

	return true;
}

void SEscortSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEscortSituationSaveData*>(p_Object);
	s_Object->~SEscortSituationSaveData();
}

ZHMTypeInfo SEvacuateSituationMemberSaveData::TypeInfo = ZHMTypeInfo("SEvacuateSituationMemberSaveData", sizeof(SEvacuateSituationMemberSaveData), alignof(SEvacuateSituationMemberSaveData), SEvacuateSituationMemberSaveData::WriteSimpleJson, SEvacuateSituationMemberSaveData::FromSimpleJson, SEvacuateSituationMemberSaveData::Serialize, SEvacuateSituationMemberSaveData::Equals, SEvacuateSituationMemberSaveData::Destroy);

void SEvacuateSituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pGuardDutyPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuardDutyPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nPatrolWaypointSubIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nPatrolWaypointSubIndex);

	p_Stream << "}";
}

void SEvacuateSituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvacuateSituationMemberSaveData s_Object {};

	s_Object.m_pGuardDutyPoint = simdjson::from_json_uint32(p_Document["m_pGuardDutyPoint"]);

	s_Object.m_nPatrolWaypointIndex = simdjson::from_json_int32(p_Document["m_nPatrolWaypointIndex"]);

	s_Object.m_nPatrolWaypointSubIndex = simdjson::from_json_uint32(p_Document["m_nPatrolWaypointSubIndex"]);

	*reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Target) = s_Object;
}

void SEvacuateSituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);

}

bool SEvacuateSituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateSituationMemberSaveData::operator==(const SEvacuateSituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateSituationMemberSaveData>)
		return false;

	if (m_pGuardDutyPoint != p_Other.m_pGuardDutyPoint) return false;
	if (m_nPatrolWaypointIndex != p_Other.m_nPatrolWaypointIndex) return false;
	if (m_nPatrolWaypointSubIndex != p_Other.m_nPatrolWaypointSubIndex) return false;

	return true;
}

void SEvacuateSituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationMemberSaveData*>(p_Object);
	s_Object->~SEvacuateSituationMemberSaveData();
}

ZHMTypeInfo SEvacuateSituationSaveData::TypeInfo = ZHMTypeInfo("SEvacuateSituationSaveData", sizeof(SEvacuateSituationSaveData), alignof(SEvacuateSituationSaveData), SEvacuateSituationSaveData::WriteSimpleJson, SEvacuateSituationSaveData::FromSimpleJson, SEvacuateSituationSaveData::Serialize, SEvacuateSituationSaveData::Equals, SEvacuateSituationSaveData::Destroy);

void SEvacuateSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastSeriousSituation") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastSeriousSituation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastThreat") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastThreat, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tresspassGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_tresspassGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_evacuateGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_evacuateGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_evacuateGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_evacuateGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_activeSafeRooms") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_activeSafeRooms.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_activeSafeRooms[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_activeSafeRooms.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vipsUnderFire") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_vipsUnderFire.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_vipsUnderFire[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_vipsUnderFire.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEvacuateSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvacuateSituationSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastSeriousSituation"], &s_Item);
		s_Object.m_tLastSeriousSituation = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastThreat"], &s_Item);
		s_Object.m_tLastThreat = s_Item;
	}

	s_Object.m_tresspassGroup = simdjson::from_json_int32(p_Document["m_tresspassGroup"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_evacuateGroups"];
	s_Object.m_evacuateGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_evacuateGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_activeSafeRooms"];
	s_Object.m_activeSafeRooms.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_activeSafeRooms[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_vipsUnderFire"];
	s_Object.m_vipsUnderFire.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_vipsUnderFire[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SEvacuateSituationSaveData*>(p_Target) = s_Object;
}

void SEvacuateSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tLastSeriousSituation, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_tLastSeriousSituation));
	ZGameTime::Serialize(&s_Object->m_tLastThreat, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_tLastThreat));
	TArray<int32>::Serialize(&s_Object->m_evacuateGroups, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_evacuateGroups));
	TArray<uint32>::Serialize(&s_Object->m_activeSafeRooms, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_activeSafeRooms));
	TArray<uint32>::Serialize(&s_Object->m_vipsUnderFire, p_Serializer, p_OwnOffset + offsetof(SEvacuateSituationSaveData, m_vipsUnderFire));
}

bool SEvacuateSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateSituationSaveData::operator==(const SEvacuateSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateSituationSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tLastSeriousSituation != p_Other.m_tLastSeriousSituation) return false;
	if (m_tLastThreat != p_Other.m_tLastThreat) return false;
	if (m_tresspassGroup != p_Other.m_tresspassGroup) return false;
	if (m_evacuateGroups != p_Other.m_evacuateGroups) return false;
	if (m_activeSafeRooms != p_Other.m_activeSafeRooms) return false;
	if (m_vipsUnderFire != p_Other.m_vipsUnderFire) return false;

	return true;
}

void SEvacuateSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvacuateSituationSaveData*>(p_Object);
	s_Object->~SEvacuateSituationSaveData();
}

ZHMTypeInfo SEvacuateTrespassGroupSaveData::TypeInfo = ZHMTypeInfo("SEvacuateTrespassGroupSaveData", sizeof(SEvacuateTrespassGroupSaveData), alignof(SEvacuateTrespassGroupSaveData), SEvacuateTrespassGroupSaveData::WriteSimpleJson, SEvacuateTrespassGroupSaveData::FromSimpleJson, SEvacuateTrespassGroupSaveData::Serialize, SEvacuateTrespassGroupSaveData::Equals, SEvacuateTrespassGroupSaveData::Destroy);

void SEvacuateTrespassGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_safeRoomNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_safeRoomNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_leader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_leader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_assistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_escalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_escalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_completed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_completed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_standDown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_standDown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_warningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_warningCount);

	p_Stream << "}";
}

void SEvacuateTrespassGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvacuateTrespassGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_safeRoomNode = simdjson::from_json_uint32(p_Document["m_safeRoomNode"]);

	s_Object.m_leader = simdjson::from_json_uint32(p_Document["m_leader"]);

	s_Object.m_assistant = simdjson::from_json_uint32(p_Document["m_assistant"]);

	s_Object.m_escalate = simdjson::from_json_bool(p_Document["m_escalate"]);

	s_Object.m_completed = simdjson::from_json_bool(p_Document["m_completed"]);

	s_Object.m_standDown = simdjson::from_json_bool(p_Document["m_standDown"]);

	s_Object.m_warningCount = simdjson::from_json_int32(p_Document["m_warningCount"]);

	*reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Target) = s_Object;
}

void SEvacuateTrespassGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateTrespassGroupSaveData, m_fsmState));
}

bool SEvacuateTrespassGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateTrespassGroupSaveData::operator==(const SEvacuateTrespassGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateTrespassGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_safeRoomNode != p_Other.m_safeRoomNode) return false;
	if (m_leader != p_Other.m_leader) return false;
	if (m_assistant != p_Other.m_assistant) return false;
	if (m_escalate != p_Other.m_escalate) return false;
	if (m_completed != p_Other.m_completed) return false;
	if (m_standDown != p_Other.m_standDown) return false;
	if (m_warningCount != p_Other.m_warningCount) return false;

	return true;
}

void SEvacuateTrespassGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvacuateTrespassGroupSaveData*>(p_Object);
	s_Object->~SEvacuateTrespassGroupSaveData();
}

ZHMTypeInfo SEvacuateVIPGroupSaveData::TypeInfo = ZHMTypeInfo("SEvacuateVIPGroupSaveData", sizeof(SEvacuateVIPGroupSaveData), alignof(SEvacuateVIPGroupSaveData), SEvacuateVIPGroupSaveData::WriteSimpleJson, SEvacuateVIPGroupSaveData::FromSimpleJson, SEvacuateVIPGroupSaveData::Serialize, SEvacuateVIPGroupSaveData::Equals, SEvacuateVIPGroupSaveData::Destroy);

void SEvacuateVIPGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIP") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIP);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVIPActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVIPActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEvacuationNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEvacuationNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSafeRoomNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSafeRoomNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCompromisedEvacNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCompromisedEvacNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_assignedBodyguards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_assignedBodyguards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_assignedBodyguards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_assignedBodyguards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEvacuationStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEvacuationStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tCornered") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tCornered, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tTacticalPoint") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tTacticalPoint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSafeRoom") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tSafeRoom, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tSafeRoomStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tSafeRoomStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInitialFlee") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInitialFlee);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_safeRoomVIPSentActingStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_safeRoomVIPSentActingStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_isSetupPhaseComplete") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_isSetupPhaseComplete);

	p_Stream << "}";
}

void SEvacuateVIPGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvacuateVIPGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_rVIP = simdjson::from_json_uint32(p_Document["m_rVIP"]);

	s_Object.m_rVIPActor = simdjson::from_json_uint32(p_Document["m_rVIPActor"]);

	s_Object.m_rEvacuationNode = simdjson::from_json_uint32(p_Document["m_rEvacuationNode"]);

	s_Object.m_rSafeRoomNode = simdjson::from_json_uint32(p_Document["m_rSafeRoomNode"]);

	s_Object.m_rCompromisedEvacNode = simdjson::from_json_uint32(p_Document["m_rCompromisedEvacNode"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_assignedBodyguards"];
	s_Object.m_assignedBodyguards.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_assignedBodyguards[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tEvacuationStart"], &s_Item);
		s_Object.m_tEvacuationStart = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tCornered"], &s_Item);
		s_Object.m_tCornered = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tTacticalPoint"], &s_Item);
		s_Object.m_tTacticalPoint = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tSafeRoom"], &s_Item);
		s_Object.m_tSafeRoom = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tSafeRoomStandDown"], &s_Item);
		s_Object.m_tSafeRoomStandDown = s_Item;
	}

	s_Object.m_bInitialFlee = simdjson::from_json_bool(p_Document["m_bInitialFlee"]);

	s_Object.m_safeRoomVIPSentActingStarted = simdjson::from_json_bool(p_Document["m_safeRoomVIPSentActingStarted"]);

	s_Object.m_isSetupPhaseComplete = simdjson::from_json_bool(p_Document["m_isSetupPhaseComplete"]);

	*reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Target) = s_Object;
}

void SEvacuateVIPGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_fsmState));
	TArray<uint32>::Serialize(&s_Object->m_assignedBodyguards, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_assignedBodyguards));
	ZGameTime::Serialize(&s_Object->m_tEvacuationStart, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tEvacuationStart));
	ZGameTime::Serialize(&s_Object->m_tCornered, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tCornered));
	ZGameTime::Serialize(&s_Object->m_tTacticalPoint, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tTacticalPoint));
	ZGameTime::Serialize(&s_Object->m_tSafeRoom, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tSafeRoom));
	ZGameTime::Serialize(&s_Object->m_tSafeRoomStandDown, p_Serializer, p_OwnOffset + offsetof(SEvacuateVIPGroupSaveData, m_tSafeRoomStandDown));
}

bool SEvacuateVIPGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvacuateVIPGroupSaveData::operator==(const SEvacuateVIPGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvacuateVIPGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rVIP != p_Other.m_rVIP) return false;
	if (m_rVIPActor != p_Other.m_rVIPActor) return false;
	if (m_rEvacuationNode != p_Other.m_rEvacuationNode) return false;
	if (m_rSafeRoomNode != p_Other.m_rSafeRoomNode) return false;
	if (m_rCompromisedEvacNode != p_Other.m_rCompromisedEvacNode) return false;
	if (m_assignedBodyguards != p_Other.m_assignedBodyguards) return false;
	if (m_tEvacuationStart != p_Other.m_tEvacuationStart) return false;
	if (m_tCornered != p_Other.m_tCornered) return false;
	if (m_tTacticalPoint != p_Other.m_tTacticalPoint) return false;
	if (m_tSafeRoom != p_Other.m_tSafeRoom) return false;
	if (m_tSafeRoomStandDown != p_Other.m_tSafeRoomStandDown) return false;
	if (m_bInitialFlee != p_Other.m_bInitialFlee) return false;
	if (m_safeRoomVIPSentActingStarted != p_Other.m_safeRoomVIPSentActingStarted) return false;
	if (m_isSetupPhaseComplete != p_Other.m_isSetupPhaseComplete) return false;

	return true;
}

void SEvacuateVIPGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvacuateVIPGroupSaveData*>(p_Object);
	s_Object->~SEvacuateVIPGroupSaveData();
}

ZHMTypeInfo SEventChannelSaveData::TypeInfo = ZHMTypeInfo("SEventChannelSaveData", sizeof(SEventChannelSaveData), alignof(SEventChannelSaveData), SEventChannelSaveData::WriteSimpleJson, SEventChannelSaveData::FromSimpleJson, SEventChannelSaveData::Serialize, SEventChannelSaveData::Equals, SEventChannelSaveData::Destroy);

void SEventChannelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SEventChannelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEventChannelSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SEventChannelSaveData*>(p_Target) = s_Object;
}

void SEventChannelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);

}

bool SEventChannelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEventChannelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEventChannelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEventChannelSaveData::operator==(const SEventChannelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEventChannelSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SEventChannelSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEventChannelSaveData*>(p_Object);
	s_Object->~SEventChannelSaveData();
}

ZHMTypeInfo SEvergreenMenuCursorDecorationData::TypeInfo = ZHMTypeInfo("SEvergreenMenuCursorDecorationData", sizeof(SEvergreenMenuCursorDecorationData), alignof(SEvergreenMenuCursorDecorationData), SEvergreenMenuCursorDecorationData::WriteSimpleJson, SEvergreenMenuCursorDecorationData::FromSimpleJson, SEvergreenMenuCursorDecorationData::Serialize, SEvergreenMenuCursorDecorationData::Equals, SEvergreenMenuCursorDecorationData::Destroy);

void SEvergreenMenuCursorDecorationData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuCursorDecorationData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isIconCutOut") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isIconCutOut);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isIconFramed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isIconFramed);

	p_Stream << "}";
}

void SEvergreenMenuCursorDecorationData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvergreenMenuCursorDecorationData s_Object {};

	s_Object.icon = std::string_view(p_Document["icon"]);

	s_Object.isIconCutOut = simdjson::from_json_bool(p_Document["isIconCutOut"]);

	s_Object.isIconFramed = simdjson::from_json_bool(p_Document["isIconFramed"]);

	*reinterpret_cast<SEvergreenMenuCursorDecorationData*>(p_Target) = s_Object;
}

void SEvergreenMenuCursorDecorationData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuCursorDecorationData*>(p_Object);

	ZString::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuCursorDecorationData, icon));
}

bool SEvergreenMenuCursorDecorationData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvergreenMenuCursorDecorationData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvergreenMenuCursorDecorationData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvergreenMenuCursorDecorationData::operator==(const SEvergreenMenuCursorDecorationData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvergreenMenuCursorDecorationData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (isIconCutOut != p_Other.isIconCutOut) return false;
	if (isIconFramed != p_Other.isIconFramed) return false;

	return true;
}

void SEvergreenMenuCursorDecorationData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuCursorDecorationData*>(p_Object);
	s_Object->~SEvergreenMenuCursorDecorationData();
}

ZHMTypeInfo SEvergreenMenuLabelData::TypeInfo = ZHMTypeInfo("SEvergreenMenuLabelData", sizeof(SEvergreenMenuLabelData), alignof(SEvergreenMenuLabelData), SEvergreenMenuLabelData::WriteSimpleJson, SEvergreenMenuLabelData::FromSimpleJson, SEvergreenMenuLabelData::Serialize, SEvergreenMenuLabelData::Equals, SEvergreenMenuLabelData::Destroy);

void SEvergreenMenuLabelData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuLabelData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("purpose") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EEvergreenMenuLabelPurpose", static_cast<int>(s_Object->purpose)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrTitle);

	p_Stream << "}";
}

void SEvergreenMenuLabelData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvergreenMenuLabelData s_Object {};

	s_Object.purpose = static_cast<EEvergreenMenuLabelPurpose>(ZHMEnums::GetEnumValueByName("EEvergreenMenuLabelPurpose", std::string_view(p_Document["purpose"])));

	s_Object.lstrTitle = std::string_view(p_Document["lstrTitle"]);

	*reinterpret_cast<SEvergreenMenuLabelData*>(p_Target) = s_Object;
}

void SEvergreenMenuLabelData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuLabelData*>(p_Object);

	ZString::Serialize(&s_Object->lstrTitle, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuLabelData, lstrTitle));
}

bool SEvergreenMenuLabelData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvergreenMenuLabelData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvergreenMenuLabelData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvergreenMenuLabelData::operator==(const SEvergreenMenuLabelData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvergreenMenuLabelData>)
		return false;

	if (purpose != p_Other.purpose) return false;
	if (lstrTitle != p_Other.lstrTitle) return false;

	return true;
}

void SEvergreenMenuLabelData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuLabelData*>(p_Object);
	s_Object->~SEvergreenMenuLabelData();
}

ZHMTypeInfo SEvergreenMenuHeadlineData::TypeInfo = ZHMTypeInfo("SEvergreenMenuHeadlineData", sizeof(SEvergreenMenuHeadlineData), alignof(SEvergreenMenuHeadlineData), SEvergreenMenuHeadlineData::WriteSimpleJson, SEvergreenMenuHeadlineData::FromSimpleJson, SEvergreenMenuHeadlineData::Serialize, SEvergreenMenuHeadlineData::Equals, SEvergreenMenuHeadlineData::Destroy);

void SEvergreenMenuHeadlineData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuHeadlineData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("lstrMicroMessage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrMicroMessage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrTitle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("microicons") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->microicons.size(); ++i)
	{
		auto& s_Item0 = s_Object->microicons[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->microicons.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("labels") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->labels.size(); ++i)
	{
		auto& s_Item0 = s_Object->labels[i];
		SEvergreenMenuLabelData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->labels.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEvergreenMenuHeadlineData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvergreenMenuHeadlineData s_Object {};

	s_Object.lstrMicroMessage = std::string_view(p_Document["lstrMicroMessage"]);

	s_Object.icon = std::string_view(p_Document["icon"]);

	s_Object.lstrTitle = std::string_view(p_Document["lstrTitle"]);

	s_Object.lstrHeader = std::string_view(p_Document["lstrHeader"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["microicons"];
	s_Object.microicons.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.microicons[s_Index0++] = std::string_view(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["labels"];
	s_Object.labels.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEvergreenMenuLabelData s_ArrayItem0;
		SEvergreenMenuLabelData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.labels[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SEvergreenMenuHeadlineData*>(p_Target) = s_Object;
}

void SEvergreenMenuHeadlineData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuHeadlineData*>(p_Object);

	ZString::Serialize(&s_Object->lstrMicroMessage, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuHeadlineData, lstrMicroMessage));
	ZString::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuHeadlineData, icon));
	ZString::Serialize(&s_Object->lstrTitle, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuHeadlineData, lstrTitle));
	ZString::Serialize(&s_Object->lstrHeader, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuHeadlineData, lstrHeader));
	TArray<ZString>::Serialize(&s_Object->microicons, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuHeadlineData, microicons));
	TArray<SEvergreenMenuLabelData>::Serialize(&s_Object->labels, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuHeadlineData, labels));
}

bool SEvergreenMenuHeadlineData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvergreenMenuHeadlineData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvergreenMenuHeadlineData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvergreenMenuHeadlineData::operator==(const SEvergreenMenuHeadlineData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvergreenMenuHeadlineData>)
		return false;

	if (lstrMicroMessage != p_Other.lstrMicroMessage) return false;
	if (icon != p_Other.icon) return false;
	if (lstrTitle != p_Other.lstrTitle) return false;
	if (lstrHeader != p_Other.lstrHeader) return false;
	if (microicons != p_Other.microicons) return false;
	if (labels != p_Other.labels) return false;

	return true;
}

void SEvergreenMenuHeadlineData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuHeadlineData*>(p_Object);
	s_Object->~SEvergreenMenuHeadlineData();
}

ZHMTypeInfo SEvergreenMenuPerkData::TypeInfo = ZHMTypeInfo("SEvergreenMenuPerkData", sizeof(SEvergreenMenuPerkData), alignof(SEvergreenMenuPerkData), SEvergreenMenuPerkData::WriteSimpleJson, SEvergreenMenuPerkData::FromSimpleJson, SEvergreenMenuPerkData::Serialize, SEvergreenMenuPerkData::Equals, SEvergreenMenuPerkData::Destroy);

void SEvergreenMenuPerkData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuPerkData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrTitle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("purposeColorTint") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EEvergreenMenuLabelPurpose", static_cast<int>(s_Object->purposeColorTint)));

	p_Stream << "}";
}

void SEvergreenMenuPerkData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvergreenMenuPerkData s_Object {};

	s_Object.icon = std::string_view(p_Document["icon"]);

	s_Object.lstrTitle = std::string_view(p_Document["lstrTitle"]);

	s_Object.lstrDescription = std::string_view(p_Document["lstrDescription"]);

	s_Object.purposeColorTint = static_cast<EEvergreenMenuLabelPurpose>(ZHMEnums::GetEnumValueByName("EEvergreenMenuLabelPurpose", std::string_view(p_Document["purposeColorTint"])));

	*reinterpret_cast<SEvergreenMenuPerkData*>(p_Target) = s_Object;
}

void SEvergreenMenuPerkData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuPerkData*>(p_Object);

	ZString::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuPerkData, icon));
	ZString::Serialize(&s_Object->lstrTitle, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuPerkData, lstrTitle));
	ZString::Serialize(&s_Object->lstrDescription, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuPerkData, lstrDescription));
}

bool SEvergreenMenuPerkData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvergreenMenuPerkData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvergreenMenuPerkData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvergreenMenuPerkData::operator==(const SEvergreenMenuPerkData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvergreenMenuPerkData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (lstrTitle != p_Other.lstrTitle) return false;
	if (lstrDescription != p_Other.lstrDescription) return false;
	if (purposeColorTint != p_Other.purposeColorTint) return false;

	return true;
}

void SEvergreenMenuPerkData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuPerkData*>(p_Object);
	s_Object->~SEvergreenMenuPerkData();
}

ZHMTypeInfo SEvergreenMenuInfoPanelRData::TypeInfo = ZHMTypeInfo("SEvergreenMenuInfoPanelRData", sizeof(SEvergreenMenuInfoPanelRData), alignof(SEvergreenMenuInfoPanelRData), SEvergreenMenuInfoPanelRData::WriteSimpleJson, SEvergreenMenuInfoPanelRData::FromSimpleJson, SEvergreenMenuInfoPanelRData::Serialize, SEvergreenMenuInfoPanelRData::Equals, SEvergreenMenuInfoPanelRData::Destroy);

void SEvergreenMenuInfoPanelRData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuInfoPanelRData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrTitle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("perks") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->perks.size(); ++i)
	{
		auto& s_Item0 = s_Object->perks[i];
		SEvergreenMenuPerkData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->perks.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("labels") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->labels.size(); ++i)
	{
		auto& s_Item0 = s_Object->labels[i];
		SEvergreenMenuLabelData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->labels.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SEvergreenMenuInfoPanelRData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvergreenMenuInfoPanelRData s_Object {};

	s_Object.icon = std::string_view(p_Document["icon"]);

	s_Object.lstrTitle = std::string_view(p_Document["lstrTitle"]);

	s_Object.lstrHeader = std::string_view(p_Document["lstrHeader"]);

	s_Object.lstrDescription = std::string_view(p_Document["lstrDescription"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["perks"];
	s_Object.perks.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEvergreenMenuPerkData s_ArrayItem0;
		SEvergreenMenuPerkData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.perks[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["labels"];
	s_Object.labels.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEvergreenMenuLabelData s_ArrayItem0;
		SEvergreenMenuLabelData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.labels[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SEvergreenMenuInfoPanelRData*>(p_Target) = s_Object;
}

void SEvergreenMenuInfoPanelRData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuInfoPanelRData*>(p_Object);

	ZString::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuInfoPanelRData, icon));
	ZString::Serialize(&s_Object->lstrTitle, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuInfoPanelRData, lstrTitle));
	ZString::Serialize(&s_Object->lstrHeader, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuInfoPanelRData, lstrHeader));
	ZString::Serialize(&s_Object->lstrDescription, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuInfoPanelRData, lstrDescription));
	TArray<SEvergreenMenuPerkData>::Serialize(&s_Object->perks, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuInfoPanelRData, perks));
	TArray<SEvergreenMenuLabelData>::Serialize(&s_Object->labels, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuInfoPanelRData, labels));
}

bool SEvergreenMenuInfoPanelRData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvergreenMenuInfoPanelRData*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvergreenMenuInfoPanelRData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvergreenMenuInfoPanelRData::operator==(const SEvergreenMenuInfoPanelRData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvergreenMenuInfoPanelRData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (lstrTitle != p_Other.lstrTitle) return false;
	if (lstrHeader != p_Other.lstrHeader) return false;
	if (lstrDescription != p_Other.lstrDescription) return false;
	if (perks != p_Other.perks) return false;
	if (labels != p_Other.labels) return false;

	return true;
}

void SEvergreenMenuInfoPanelRData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuInfoPanelRData*>(p_Object);
	s_Object->~SEvergreenMenuInfoPanelRData();
}

ZHMTypeInfo SEvergreenMenuPromptDesc::TypeInfo = ZHMTypeInfo("SEvergreenMenuPromptDesc", sizeof(SEvergreenMenuPromptDesc), alignof(SEvergreenMenuPromptDesc), SEvergreenMenuPromptDesc::WriteSimpleJson, SEvergreenMenuPromptDesc::FromSimpleJson, SEvergreenMenuPromptDesc::Serialize, SEvergreenMenuPromptDesc::Equals, SEvergreenMenuPromptDesc::Destroy);

void SEvergreenMenuPromptDesc::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuPromptDesc*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("actiontype") << ":";
	p_Stream << simdjson::as_json_string(s_Object->actiontype);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("actionlabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->actionlabel);

	p_Stream << "}";
}

void SEvergreenMenuPromptDesc::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SEvergreenMenuPromptDesc s_Object {};

	s_Object.actiontype = std::string_view(p_Document["actiontype"]);

	s_Object.actionlabel = std::string_view(p_Document["actionlabel"]);

	*reinterpret_cast<SEvergreenMenuPromptDesc*>(p_Target) = s_Object;
}

void SEvergreenMenuPromptDesc::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuPromptDesc*>(p_Object);

	ZString::Serialize(&s_Object->actiontype, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuPromptDesc, actiontype));
	ZString::Serialize(&s_Object->actionlabel, p_Serializer, p_OwnOffset + offsetof(SEvergreenMenuPromptDesc, actionlabel));
}

bool SEvergreenMenuPromptDesc::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SEvergreenMenuPromptDesc*>(p_Left);
	auto* s_Right = reinterpret_cast<SEvergreenMenuPromptDesc*>(p_Right);

	return *s_Left == *s_Right;
}

bool SEvergreenMenuPromptDesc::operator==(const SEvergreenMenuPromptDesc& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SEvergreenMenuPromptDesc>)
		return false;

	if (actiontype != p_Other.actiontype) return false;
	if (actionlabel != p_Other.actionlabel) return false;

	return true;
}

void SEvergreenMenuPromptDesc::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SEvergreenMenuPromptDesc*>(p_Object);
	s_Object->~SEvergreenMenuPromptDesc();
}

ZHMTypeInfo SExitSaveData::TypeInfo = ZHMTypeInfo("SExitSaveData", sizeof(SExitSaveData), alignof(SExitSaveData), SExitSaveData::WriteSimpleJson, SExitSaveData::FromSimpleJson, SExitSaveData::Serialize, SExitSaveData::Equals, SExitSaveData::Destroy);

void SExitSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SExitSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExitSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SExitSaveData*>(p_Target) = s_Object;
}

void SExitSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);

}

bool SExitSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExitSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SExitSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExitSaveData::operator==(const SExitSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExitSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SExitSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExitSaveData*>(p_Object);
	s_Object->~SExitSaveData();
}

ZHMTypeInfo SExitsActiveSaveData::TypeInfo = ZHMTypeInfo("SExitsActiveSaveData", sizeof(SExitsActiveSaveData), alignof(SExitsActiveSaveData), SExitsActiveSaveData::WriteSimpleJson, SExitsActiveSaveData::FromSimpleJson, SExitsActiveSaveData::Serialize, SExitsActiveSaveData::Equals, SExitsActiveSaveData::Destroy);

void SExitsActiveSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExitsActiveSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsActive);

	p_Stream << "}";
}

void SExitsActiveSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExitsActiveSaveData s_Object {};

	s_Object.m_bIsActive = simdjson::from_json_bool(p_Document["m_bIsActive"]);

	*reinterpret_cast<SExitsActiveSaveData*>(p_Target) = s_Object;
}

void SExitsActiveSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExitsActiveSaveData*>(p_Object);

}

bool SExitsActiveSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExitsActiveSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SExitsActiveSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExitsActiveSaveData::operator==(const SExitsActiveSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExitsActiveSaveData>)
		return false;

	if (m_bIsActive != p_Other.m_bIsActive) return false;

	return true;
}

void SExitsActiveSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExitsActiveSaveData*>(p_Object);
	s_Object->~SExitsActiveSaveData();
}

ZHMTypeInfo SExposedEntityDescriptor::TypeInfo = ZHMTypeInfo("SExposedEntityDescriptor", sizeof(SExposedEntityDescriptor), alignof(SExposedEntityDescriptor), SExposedEntityDescriptor::WriteSimpleJson, SExposedEntityDescriptor::FromSimpleJson, SExposedEntityDescriptor::Serialize, SExposedEntityDescriptor::Equals, SExposedEntityDescriptor::Destroy);

void SExposedEntityDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsArray") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsArray);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsHidden") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsHidden);

	p_Stream << "}";
}

void SExposedEntityDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExposedEntityDescriptor s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	s_Object.sDisplayName = std::string_view(p_Document["sDisplayName"]);

	s_Object.sHelpText = std::string_view(p_Document["sHelpText"]);

	s_Object.bIsArray = simdjson::from_json_bool(p_Document["bIsArray"]);

	s_Object.bIsHidden = simdjson::from_json_bool(p_Document["bIsHidden"]);

	*reinterpret_cast<SExposedEntityDescriptor*>(p_Target) = s_Object;
}

void SExposedEntityDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sDisplayName));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SExposedEntityDescriptor, sHelpText));
}

bool SExposedEntityDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExposedEntityDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SExposedEntityDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExposedEntityDescriptor::operator==(const SExposedEntityDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExposedEntityDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (sHelpText != p_Other.sHelpText) return false;
	if (bIsArray != p_Other.bIsArray) return false;
	if (bIsHidden != p_Other.bIsHidden) return false;

	return true;
}

void SExposedEntityDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExposedEntityDescriptor*>(p_Object);
	s_Object->~SExposedEntityDescriptor();
}

ZHMTypeInfo SExposedEntityTypeDescriptor::TypeInfo = ZHMTypeInfo("SExposedEntityTypeDescriptor", sizeof(SExposedEntityTypeDescriptor), alignof(SExposedEntityTypeDescriptor), SExposedEntityTypeDescriptor::WriteSimpleJson, SExposedEntityTypeDescriptor::FromSimpleJson, SExposedEntityTypeDescriptor::Serialize, SExposedEntityTypeDescriptor::Equals, SExposedEntityTypeDescriptor::Destroy);

void SExposedEntityTypeDescriptor::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExposedEntityTypeDescriptor*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("types") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->types.size(); ++i)
	{
		auto& s_Item0 = s_Object->types[i];
		ZResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->types.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aSupportedTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSupportedTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSupportedTypes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aSupportedTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SExposedEntityTypeDescriptor::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExposedEntityTypeDescriptor s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["types"];
	s_Object.types.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZResourceID s_ArrayItem0;
		ZResourceID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.types[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aSupportedTypes"];
	s_Object.aSupportedTypes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.aSupportedTypes[s_Index0++] = std::string_view(s_Item0);
	}
	}

	*reinterpret_cast<SExposedEntityTypeDescriptor*>(p_Target) = s_Object;
}

void SExposedEntityTypeDescriptor::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExposedEntityTypeDescriptor*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SExposedEntityTypeDescriptor, sName));
	TArray<ZResourceID>::Serialize(&s_Object->types, p_Serializer, p_OwnOffset + offsetof(SExposedEntityTypeDescriptor, types));
	TArray<ZString>::Serialize(&s_Object->aSupportedTypes, p_Serializer, p_OwnOffset + offsetof(SExposedEntityTypeDescriptor, aSupportedTypes));
}

bool SExposedEntityTypeDescriptor::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExposedEntityTypeDescriptor*>(p_Left);
	auto* s_Right = reinterpret_cast<SExposedEntityTypeDescriptor*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExposedEntityTypeDescriptor::operator==(const SExposedEntityTypeDescriptor& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExposedEntityTypeDescriptor>)
		return false;

	if (sName != p_Other.sName) return false;
	if (types != p_Other.types) return false;
	if (aSupportedTypes != p_Other.aSupportedTypes) return false;

	return true;
}

void SExposedEntityTypeDescriptor::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExposedEntityTypeDescriptor*>(p_Object);
	s_Object->~SExposedEntityTypeDescriptor();
}

ZHMTypeInfo STypeReference::TypeInfo = ZHMTypeInfo("STypeReference", sizeof(STypeReference), alignof(STypeReference), STypeReference::WriteSimpleJson, STypeReference::FromSimpleJson, STypeReference::Serialize, STypeReference::Equals, STypeReference::Destroy);

void STypeReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STypeReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sEntityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sEntityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sTypeArgName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sTypeArgName);

	p_Stream << "}";
}

void STypeReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STypeReference s_Object {};

	s_Object.sEntityID = std::string_view(p_Document["sEntityID"]);

	s_Object.sTypeArgName = std::string_view(p_Document["sTypeArgName"]);

	*reinterpret_cast<STypeReference*>(p_Target) = s_Object;
}

void STypeReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STypeReference*>(p_Object);

	ZString::Serialize(&s_Object->sEntityID, p_Serializer, p_OwnOffset + offsetof(STypeReference, sEntityID));
	ZString::Serialize(&s_Object->sTypeArgName, p_Serializer, p_OwnOffset + offsetof(STypeReference, sTypeArgName));
}

bool STypeReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STypeReference*>(p_Left);
	auto* s_Right = reinterpret_cast<STypeReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool STypeReference::operator==(const STypeReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STypeReference>)
		return false;

	if (sEntityID != p_Other.sEntityID) return false;
	if (sTypeArgName != p_Other.sTypeArgName) return false;

	return true;
}

void STypeReference::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STypeReference*>(p_Object);
	s_Object->~STypeReference();
}

ZHMTypeInfo SExposedTypeInfo::TypeInfo = ZHMTypeInfo("SExposedTypeInfo", sizeof(SExposedTypeInfo), alignof(SExposedTypeInfo), SExposedTypeInfo::WriteSimpleJson, SExposedTypeInfo::FromSimpleJson, SExposedTypeInfo::Serialize, SExposedTypeInfo::Equals, SExposedTypeInfo::Destroy);

void SExposedTypeInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExposedTypeInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sDisplayName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDisplayName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sHelpText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sHelpText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("target") << ":";
	STypeReference::WriteSimpleJson(&s_Object->target, p_Stream);

	p_Stream << "}";
}

void SExposedTypeInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExposedTypeInfo s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	s_Object.sDisplayName = std::string_view(p_Document["sDisplayName"]);

	s_Object.sHelpText = std::string_view(p_Document["sHelpText"]);

	{
		STypeReference s_Item {};
		STypeReference::FromSimpleJson(p_Document["target"], &s_Item);
		s_Object.target = s_Item;
	}

	*reinterpret_cast<SExposedTypeInfo*>(p_Target) = s_Object;
}

void SExposedTypeInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExposedTypeInfo*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SExposedTypeInfo, sName));
	ZString::Serialize(&s_Object->sDisplayName, p_Serializer, p_OwnOffset + offsetof(SExposedTypeInfo, sDisplayName));
	ZString::Serialize(&s_Object->sHelpText, p_Serializer, p_OwnOffset + offsetof(SExposedTypeInfo, sHelpText));
	STypeReference::Serialize(&s_Object->target, p_Serializer, p_OwnOffset + offsetof(SExposedTypeInfo, target));
}

bool SExposedTypeInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExposedTypeInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SExposedTypeInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExposedTypeInfo::operator==(const SExposedTypeInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExposedTypeInfo>)
		return false;

	if (sName != p_Other.sName) return false;
	if (sDisplayName != p_Other.sDisplayName) return false;
	if (sHelpText != p_Other.sHelpText) return false;
	if (target != p_Other.target) return false;

	return true;
}

void SExposedTypeInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExposedTypeInfo*>(p_Object);
	s_Object->~SExposedTypeInfo();
}

ZHMTypeInfo SExtendedCppEntityProperty::TypeInfo = ZHMTypeInfo("SExtendedCppEntityProperty", sizeof(SExtendedCppEntityProperty), alignof(SExtendedCppEntityProperty), SExtendedCppEntityProperty::WriteSimpleJson, SExtendedCppEntityProperty::FromSimpleJson, SExtendedCppEntityProperty::Serialize, SExtendedCppEntityProperty::Equals, SExtendedCppEntityProperty::Destroy);

void SExtendedCppEntityProperty::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExtendedCppEntityProperty*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("propertyName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->propertyName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EExtendedPropertyType", static_cast<int>(s_Object->propertyType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rtEditable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rtEditable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("extraData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->extraData);

	p_Stream << "}";
}

void SExtendedCppEntityProperty::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExtendedCppEntityProperty s_Object {};

	s_Object.propertyName = std::string_view(p_Document["propertyName"]);

	s_Object.propertyType = static_cast<EExtendedPropertyType>(ZHMEnums::GetEnumValueByName("EExtendedPropertyType", std::string_view(p_Document["propertyType"])));

	s_Object.rtEditable = simdjson::from_json_bool(p_Document["rtEditable"]);

	s_Object.extraData = simdjson::from_json_uint64(p_Document["extraData"]);

	*reinterpret_cast<SExtendedCppEntityProperty*>(p_Target) = s_Object;
}

void SExtendedCppEntityProperty::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExtendedCppEntityProperty*>(p_Object);

	ZString::Serialize(&s_Object->propertyName, p_Serializer, p_OwnOffset + offsetof(SExtendedCppEntityProperty, propertyName));
}

bool SExtendedCppEntityProperty::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExtendedCppEntityProperty*>(p_Left);
	auto* s_Right = reinterpret_cast<SExtendedCppEntityProperty*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExtendedCppEntityProperty::operator==(const SExtendedCppEntityProperty& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExtendedCppEntityProperty>)
		return false;

	if (propertyName != p_Other.propertyName) return false;
	if (propertyType != p_Other.propertyType) return false;
	if (rtEditable != p_Other.rtEditable) return false;
	if (extraData != p_Other.extraData) return false;

	return true;
}

void SExtendedCppEntityProperty::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExtendedCppEntityProperty*>(p_Object);
	s_Object->~SExtendedCppEntityProperty();
}

ZHMTypeInfo SExtendedCppEntityBlueprint::TypeInfo = ZHMTypeInfo("SExtendedCppEntityBlueprint", sizeof(SExtendedCppEntityBlueprint), alignof(SExtendedCppEntityBlueprint), SExtendedCppEntityBlueprint::WriteSimpleJson, SExtendedCppEntityBlueprint::FromSimpleJson, SExtendedCppEntityBlueprint::Serialize, SExtendedCppEntityBlueprint::Equals, SExtendedCppEntityBlueprint::Destroy);

void SExtendedCppEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExtendedCppEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("properties") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->properties.size(); ++i)
	{
		auto& s_Item0 = s_Object->properties[i];
		SExtendedCppEntityProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->properties.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SExtendedCppEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExtendedCppEntityBlueprint s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["properties"];
	s_Object.properties.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SExtendedCppEntityProperty s_ArrayItem0;
		SExtendedCppEntityProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.properties[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SExtendedCppEntityBlueprint*>(p_Target) = s_Object;
}

void SExtendedCppEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExtendedCppEntityBlueprint*>(p_Object);

	TArray<SExtendedCppEntityProperty>::Serialize(&s_Object->properties, p_Serializer, p_OwnOffset + offsetof(SExtendedCppEntityBlueprint, properties));
}

bool SExtendedCppEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExtendedCppEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<SExtendedCppEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExtendedCppEntityBlueprint::operator==(const SExtendedCppEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExtendedCppEntityBlueprint>)
		return false;

	if (properties != p_Other.properties) return false;

	return true;
}

void SExtendedCppEntityBlueprint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExtendedCppEntityBlueprint*>(p_Object);
	s_Object->~SExtendedCppEntityBlueprint();
}

ZHMTypeInfo SExternalEntityTemplatePinConnection::TypeInfo = ZHMTypeInfo("SExternalEntityTemplatePinConnection", sizeof(SExternalEntityTemplatePinConnection), alignof(SExternalEntityTemplatePinConnection), SExternalEntityTemplatePinConnection::WriteSimpleJson, SExternalEntityTemplatePinConnection::FromSimpleJson, SExternalEntityTemplatePinConnection::Serialize, SExternalEntityTemplatePinConnection::Equals, SExternalEntityTemplatePinConnection::Destroy);

void SExternalEntityTemplatePinConnection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SExternalEntityTemplatePinConnection*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("fromEntity") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->fromEntity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toEntity") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->toEntity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fromPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fromPinName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("toPinName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->toPinName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("constantPinValue") << ":";
	ZVariant::WriteSimpleJson(&s_Object->constantPinValue, p_Stream);

	p_Stream << "}";
}

void SExternalEntityTemplatePinConnection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SExternalEntityTemplatePinConnection s_Object {};

	{
		SEntityTemplateReference s_Item {};
		SEntityTemplateReference::FromSimpleJson(p_Document["fromEntity"], &s_Item);
		s_Object.fromEntity = s_Item;
	}

	{
		SEntityTemplateReference s_Item {};
		SEntityTemplateReference::FromSimpleJson(p_Document["toEntity"], &s_Item);
		s_Object.toEntity = s_Item;
	}

	s_Object.fromPinName = std::string_view(p_Document["fromPinName"]);

	s_Object.toPinName = std::string_view(p_Document["toPinName"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["constantPinValue"], &s_Item);
		s_Object.constantPinValue = s_Item;
	}

	*reinterpret_cast<SExternalEntityTemplatePinConnection*>(p_Target) = s_Object;
}

void SExternalEntityTemplatePinConnection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SExternalEntityTemplatePinConnection*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->fromEntity, p_Serializer, p_OwnOffset + offsetof(SExternalEntityTemplatePinConnection, fromEntity));
	SEntityTemplateReference::Serialize(&s_Object->toEntity, p_Serializer, p_OwnOffset + offsetof(SExternalEntityTemplatePinConnection, toEntity));
	ZString::Serialize(&s_Object->fromPinName, p_Serializer, p_OwnOffset + offsetof(SExternalEntityTemplatePinConnection, fromPinName));
	ZString::Serialize(&s_Object->toPinName, p_Serializer, p_OwnOffset + offsetof(SExternalEntityTemplatePinConnection, toPinName));
	ZVariant::Serialize(&s_Object->constantPinValue, p_Serializer, p_OwnOffset + offsetof(SExternalEntityTemplatePinConnection, constantPinValue));
}

bool SExternalEntityTemplatePinConnection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SExternalEntityTemplatePinConnection*>(p_Left);
	auto* s_Right = reinterpret_cast<SExternalEntityTemplatePinConnection*>(p_Right);

	return *s_Left == *s_Right;
}

bool SExternalEntityTemplatePinConnection::operator==(const SExternalEntityTemplatePinConnection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SExternalEntityTemplatePinConnection>)
		return false;

	if (fromEntity != p_Other.fromEntity) return false;
	if (toEntity != p_Other.toEntity) return false;
	if (fromPinName != p_Other.fromPinName) return false;
	if (toPinName != p_Other.toPinName) return false;
	if (constantPinValue != p_Other.constantPinValue) return false;

	return true;
}

void SExternalEntityTemplatePinConnection::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SExternalEntityTemplatePinConnection*>(p_Object);
	s_Object->~SExternalEntityTemplatePinConnection();
}

ZHMTypeInfo SFaceOrderSaveData::TypeInfo = ZHMTypeInfo("SFaceOrderSaveData", sizeof(SFaceOrderSaveData), alignof(SFaceOrderSaveData), SFaceOrderSaveData::WriteSimpleJson, SFaceOrderSaveData::FromSimpleJson, SFaceOrderSaveData::Serialize, SFaceOrderSaveData::Equals, SFaceOrderSaveData::Destroy);

void SFaceOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bLookAt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAimAt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAimAt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateKnownPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateKnownPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDurationVariance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDurationVariance);

	p_Stream << "}";
}

void SFaceOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFaceOrderSaveData s_Object {};

	s_Object.m_bLookAt = simdjson::from_json_bool(p_Document["m_bLookAt"]);

	s_Object.m_bAimAt = simdjson::from_json_bool(p_Document["m_bAimAt"]);

	s_Object.m_bUpdateKnownPosition = simdjson::from_json_bool(p_Document["m_bUpdateKnownPosition"]);

	s_Object.m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object.m_fDurationVariance = simdjson::from_json_float32(p_Document["m_fDurationVariance"]);

	*reinterpret_cast<SFaceOrderSaveData*>(p_Target) = s_Object;
}

void SFaceOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);

}

bool SFaceOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFaceOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFaceOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFaceOrderSaveData::operator==(const SFaceOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFaceOrderSaveData>)
		return false;

	if (m_bLookAt != p_Other.m_bLookAt) return false;
	if (m_bAimAt != p_Other.m_bAimAt) return false;
	if (m_bUpdateKnownPosition != p_Other.m_bUpdateKnownPosition) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_fDurationVariance != p_Other.m_fDurationVariance) return false;

	return true;
}

void SFaceOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFaceOrderSaveData*>(p_Object);
	s_Object->~SFaceOrderSaveData();
}

ZHMTypeInfo SFleeOrderSaveData::TypeInfo = ZHMTypeInfo("SFleeOrderSaveData", sizeof(SFleeOrderSaveData), alignof(SFleeOrderSaveData), SFleeOrderSaveData::WriteSimpleJson, SFleeOrderSaveData::FromSimpleJson, SFleeOrderSaveData::Serialize, SFleeOrderSaveData::Equals, SFleeOrderSaveData::Destroy);

void SFleeOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eHelpReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eHelpReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGridNodeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGridNodeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFleeForHelp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFleeForHelp);

	p_Stream << "}";
}

void SFleeOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFleeOrderSaveData s_Object {};

	s_Object.m_eHelpReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eHelpReason"])));

	s_Object.m_nGridNodeIndex = simdjson::from_json_uint16(p_Document["m_nGridNodeIndex"]);

	s_Object.m_bFleeForHelp = simdjson::from_json_bool(p_Document["m_bFleeForHelp"]);

	*reinterpret_cast<SFleeOrderSaveData*>(p_Target) = s_Object;
}

void SFleeOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);

}

bool SFleeOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFleeOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFleeOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFleeOrderSaveData::operator==(const SFleeOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFleeOrderSaveData>)
		return false;

	if (m_eHelpReason != p_Other.m_eHelpReason) return false;
	if (m_nGridNodeIndex != p_Other.m_nGridNodeIndex) return false;
	if (m_bFleeForHelp != p_Other.m_bFleeForHelp) return false;

	return true;
}

void SFleeOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFleeOrderSaveData*>(p_Object);
	s_Object->~SFleeOrderSaveData();
}

ZHMTypeInfo SFontDefinition::TypeInfo = ZHMTypeInfo("SFontDefinition", sizeof(SFontDefinition), alignof(SFontDefinition), SFontDefinition::WriteSimpleJson, SFontDefinition::FromSimpleJson, SFontDefinition::Serialize, SFontDefinition::Equals, SFontDefinition::Destroy);

void SFontDefinition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFontId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sFontName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eFontFlags") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EFontFlags", static_cast<int>(s_Object->eFontFlags)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fScaleFactor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fScaleFactor);

	p_Stream << "}";
}

void SFontDefinition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFontDefinition s_Object {};

	s_Object.sFontId = std::string_view(p_Document["sFontId"]);

	s_Object.sFontName = std::string_view(p_Document["sFontName"]);

	s_Object.eFontFlags = static_cast<EFontFlags>(ZHMEnums::GetEnumValueByName("EFontFlags", std::string_view(p_Document["eFontFlags"])));

	s_Object.fScaleFactor = simdjson::from_json_float32(p_Document["fScaleFactor"]);

	*reinterpret_cast<SFontDefinition*>(p_Target) = s_Object;
}

void SFontDefinition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);

	ZString::Serialize(&s_Object->sFontId, p_Serializer, p_OwnOffset + offsetof(SFontDefinition, sFontId));
	ZString::Serialize(&s_Object->sFontName, p_Serializer, p_OwnOffset + offsetof(SFontDefinition, sFontName));
}

bool SFontDefinition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFontDefinition*>(p_Left);
	auto* s_Right = reinterpret_cast<SFontDefinition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFontDefinition::operator==(const SFontDefinition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFontDefinition>)
		return false;

	if (sFontId != p_Other.sFontId) return false;
	if (sFontName != p_Other.sFontName) return false;
	if (eFontFlags != p_Other.eFontFlags) return false;
	if (fScaleFactor != p_Other.fScaleFactor) return false;

	return true;
}

void SFontDefinition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFontDefinition*>(p_Object);
	s_Object->~SFontDefinition();
}

ZHMTypeInfo SFontLibraryDefinition::TypeInfo = ZHMTypeInfo("SFontLibraryDefinition", sizeof(SFontLibraryDefinition), alignof(SFontLibraryDefinition), SFontLibraryDefinition::WriteSimpleJson, SFontLibraryDefinition::FromSimpleJson, SFontLibraryDefinition::Serialize, SFontLibraryDefinition::Equals, SFontLibraryDefinition::Destroy);

void SFontLibraryDefinition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFontLocaleID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFontLocaleID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFontDefinitions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFontDefinitions.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFontDefinitions[i];
		SFontDefinition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aFontDefinitions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SFontLibraryDefinition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFontLibraryDefinition s_Object {};

	s_Object.sFontLocaleID = std::string_view(p_Document["sFontLocaleID"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFontDefinitions"];
	s_Object.m_aFontDefinitions.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SFontDefinition s_ArrayItem0;
		SFontDefinition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aFontDefinitions[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SFontLibraryDefinition*>(p_Target) = s_Object;
}

void SFontLibraryDefinition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);

	ZString::Serialize(&s_Object->sFontLocaleID, p_Serializer, p_OwnOffset + offsetof(SFontLibraryDefinition, sFontLocaleID));
	TArray<SFontDefinition>::Serialize(&s_Object->m_aFontDefinitions, p_Serializer, p_OwnOffset + offsetof(SFontLibraryDefinition, m_aFontDefinitions));
}

bool SFontLibraryDefinition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFontLibraryDefinition*>(p_Left);
	auto* s_Right = reinterpret_cast<SFontLibraryDefinition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFontLibraryDefinition::operator==(const SFontLibraryDefinition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFontLibraryDefinition>)
		return false;

	if (sFontLocaleID != p_Other.sFontLocaleID) return false;
	if (m_aFontDefinitions != p_Other.m_aFontDefinitions) return false;

	return true;
}

void SFontLibraryDefinition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFontLibraryDefinition*>(p_Object);
	s_Object->~SFontLibraryDefinition();
}

ZHMTypeInfo SFooStruct::TypeInfo = ZHMTypeInfo("SFooStruct", sizeof(SFooStruct), alignof(SFooStruct), SFooStruct::WriteSimpleJson, SFooStruct::FromSimpleJson, SFooStruct::Serialize, SFooStruct::Equals, SFooStruct::Destroy);

void SFooStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFooStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eTest") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTest);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sOther") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sOther);

	p_Stream << "}";
}

void SFooStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFooStruct s_Object {};

	s_Object.m_eTest = simdjson::from_json_uint32(p_Document["m_eTest"]);

	s_Object.m_sOther = std::string_view(p_Document["m_sOther"]);

	*reinterpret_cast<SFooStruct*>(p_Target) = s_Object;
}

void SFooStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFooStruct*>(p_Object);

	ZString::Serialize(&s_Object->m_sOther, p_Serializer, p_OwnOffset + offsetof(SFooStruct, m_sOther));
}

bool SFooStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFooStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SFooStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFooStruct::operator==(const SFooStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFooStruct>)
		return false;

	if (m_eTest != p_Other.m_eTest) return false;
	if (m_sOther != p_Other.m_sOther) return false;

	return true;
}

void SFooStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFooStruct*>(p_Object);
	s_Object->~SFooStruct();
}

ZHMTypeInfo SFootIKEventData::TypeInfo = ZHMTypeInfo("SFootIKEventData", sizeof(SFootIKEventData), alignof(SFootIKEventData), SFootIKEventData::WriteSimpleJson, SFootIKEventData::FromSimpleJson, SFootIKEventData::Serialize, SFootIKEventData::Equals, SFootIKEventData::Destroy);

void SFootIKEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Foot") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SFootIKEventData.EFoot", static_cast<int>(s_Object->m_Foot)));

	p_Stream << "}";
}

void SFootIKEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFootIKEventData s_Object {};

	s_Object.m_Foot = static_cast<SFootIKEventData_EFoot>(ZHMEnums::GetEnumValueByName("SFootIKEventData.EFoot", std::string_view(p_Document["m_Foot"])));

	*reinterpret_cast<SFootIKEventData*>(p_Target) = s_Object;
}

void SFootIKEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);

}

bool SFootIKEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFootIKEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFootIKEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFootIKEventData::operator==(const SFootIKEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFootIKEventData>)
		return false;

	if (m_Foot != p_Other.m_Foot) return false;

	return true;
}

void SFootIKEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFootIKEventData*>(p_Object);
	s_Object->~SFootIKEventData();
}

ZHMTypeInfo SFriskSuspectGroupSaveData::TypeInfo = ZHMTypeInfo("SFriskSuspectGroupSaveData", sizeof(SFriskSuspectGroupSaveData), alignof(SFriskSuspectGroupSaveData), SFriskSuspectGroupSaveData::WriteSimpleJson, SFriskSuspectGroupSaveData::FromSimpleJson, SFriskSuspectGroupSaveData::Serialize, SFriskSuspectGroupSaveData::Equals, SFriskSuspectGroupSaveData::Destroy);

void SFriskSuspectGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHitmanIsGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHitmanIsGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAssistantState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZFriskSuspectGroup.EAssistantState", static_cast<int>(s_Object->m_eAssistantState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDisturbanceType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eDisturbanceType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eHitmanGreetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZFriskSuspectGroup.EHitmanGreetState", static_cast<int>(s_Object->m_eHitmanGreetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tHitmanGreet") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tHitmanGreet, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tWaitToComplyTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tWaitToComplyTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarnOnWeaponFound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarnOnWeaponFound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWeaponFound") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWeaponFound);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMoveWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMoveWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirskRequestRepeated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirskRequestRepeated);

	p_Stream << "}";
}

void SFriskSuspectGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SFriskSuspectGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_bHitmanIsGuard = simdjson::from_json_bool(p_Document["m_bHitmanIsGuard"]);

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object.m_eAssistantState = static_cast<ZFriskSuspectGroup_EAssistantState>(ZHMEnums::GetEnumValueByName("ZFriskSuspectGroup.EAssistantState", std::string_view(p_Document["m_eAssistantState"])));

	s_Object.m_eDisturbanceType = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eDisturbanceType"])));

	s_Object.m_eHitmanGreetState = static_cast<ZFriskSuspectGroup_EHitmanGreetState>(ZHMEnums::GetEnumValueByName("ZFriskSuspectGroup.EHitmanGreetState", std::string_view(p_Document["m_eHitmanGreetState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tHitmanGreet"], &s_Item);
		s_Object.m_tHitmanGreet = s_Item;
	}

	s_Object.m_fMovingTime = simdjson::from_json_float32(p_Document["m_fMovingTime"]);

	s_Object.m_fRunningTime = simdjson::from_json_float32(p_Document["m_fRunningTime"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tWaitToComplyTime"], &s_Item);
		s_Object.m_tWaitToComplyTime = s_Item;
	}

	s_Object.m_bWarnOnWeaponFound = simdjson::from_json_bool(p_Document["m_bWarnOnWeaponFound"]);

	s_Object.m_bWeaponFound = simdjson::from_json_bool(p_Document["m_bWeaponFound"]);

	s_Object.m_bMoveWarning = simdjson::from_json_bool(p_Document["m_bMoveWarning"]);

	s_Object.m_bFirskRequestRepeated = simdjson::from_json_bool(p_Document["m_bFirskRequestRepeated"]);

	*reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Target) = s_Object;
}

void SFriskSuspectGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tHitmanGreet, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_tHitmanGreet));
	ZGameTime::Serialize(&s_Object->m_tWaitToComplyTime, p_Serializer, p_OwnOffset + offsetof(SFriskSuspectGroupSaveData, m_tWaitToComplyTime));
}

bool SFriskSuspectGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SFriskSuspectGroupSaveData::operator==(const SFriskSuspectGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SFriskSuspectGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_bHitmanIsGuard != p_Other.m_bHitmanIsGuard) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_eAssistantState != p_Other.m_eAssistantState) return false;
	if (m_eDisturbanceType != p_Other.m_eDisturbanceType) return false;
	if (m_eHitmanGreetState != p_Other.m_eHitmanGreetState) return false;
	if (m_tHitmanGreet != p_Other.m_tHitmanGreet) return false;
	if (m_fMovingTime != p_Other.m_fMovingTime) return false;
	if (m_fRunningTime != p_Other.m_fRunningTime) return false;
	if (m_tWaitToComplyTime != p_Other.m_tWaitToComplyTime) return false;
	if (m_bWarnOnWeaponFound != p_Other.m_bWarnOnWeaponFound) return false;
	if (m_bWeaponFound != p_Other.m_bWeaponFound) return false;
	if (m_bMoveWarning != p_Other.m_bMoveWarning) return false;
	if (m_bFirskRequestRepeated != p_Other.m_bFirskRequestRepeated) return false;

	return true;
}

void SFriskSuspectGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SFriskSuspectGroupSaveData*>(p_Object);
	s_Object->~SFriskSuspectGroupSaveData();
}

ZHMTypeInfo SGBufferSample::TypeInfo = ZHMTypeInfo("SGBufferSample", sizeof(SGBufferSample), alignof(SGBufferSample), SGBufferSample::WriteSimpleJson, SGBufferSample::FromSimpleJson, SGBufferSample::Serialize, SGBufferSample::Equals, SGBufferSample::Destroy);

void SGBufferSample::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("normal") << ":";
	SVector3::WriteSimpleJson(&s_Object->normal, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("diffuse") << ":";
	SVector3::WriteSimpleJson(&s_Object->diffuse, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("specular") << ":";
	SVector3::WriteSimpleJson(&s_Object->specular, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("accumulatedLight") << ":";
	SVector3::WriteSimpleJson(&s_Object->accumulatedLight, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("glossiness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->glossiness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("translucency") << ":";
	p_Stream << simdjson::as_json_string(s_Object->translucency);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ao") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ao);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("shadingModel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->shadingModel);

	p_Stream << "}";
}

void SGBufferSample::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGBufferSample s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["normal"], &s_Item);
		s_Object.normal = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["diffuse"], &s_Item);
		s_Object.diffuse = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["specular"], &s_Item);
		s_Object.specular = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["accumulatedLight"], &s_Item);
		s_Object.accumulatedLight = s_Item;
	}

	s_Object.glossiness = simdjson::from_json_float32(p_Document["glossiness"]);

	s_Object.translucency = simdjson::from_json_float32(p_Document["translucency"]);

	s_Object.ao = simdjson::from_json_float32(p_Document["ao"]);

	s_Object.shadingModel = simdjson::from_json_uint32(p_Document["shadingModel"]);

	*reinterpret_cast<SGBufferSample*>(p_Target) = s_Object;
}

void SGBufferSample::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);

	SVector3::Serialize(&s_Object->normal, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, normal));
	SVector3::Serialize(&s_Object->diffuse, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, diffuse));
	SVector3::Serialize(&s_Object->specular, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, specular));
	SVector3::Serialize(&s_Object->accumulatedLight, p_Serializer, p_OwnOffset + offsetof(SGBufferSample, accumulatedLight));
}

bool SGBufferSample::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGBufferSample*>(p_Left);
	auto* s_Right = reinterpret_cast<SGBufferSample*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGBufferSample::operator==(const SGBufferSample& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGBufferSample>)
		return false;

	if (normal != p_Other.normal) return false;
	if (diffuse != p_Other.diffuse) return false;
	if (specular != p_Other.specular) return false;
	if (accumulatedLight != p_Other.accumulatedLight) return false;
	if (glossiness != p_Other.glossiness) return false;
	if (translucency != p_Other.translucency) return false;
	if (ao != p_Other.ao) return false;
	if (shadingModel != p_Other.shadingModel) return false;

	return true;
}

void SGBufferSample::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGBufferSample*>(p_Object);
	s_Object->~SGBufferSample();
}

ZHMTypeInfo SGProperties::TypeInfo = ZHMTypeInfo("SGProperties", sizeof(SGProperties), alignof(SGProperties), SGProperties::WriteSimpleJson, SGProperties::FromSimpleJson, SGProperties::Serialize, SGProperties::Equals, SGProperties::Destroy);

void SGProperties::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("vMin") << ":";
	float4::WriteSimpleJson(&s_Object->vMin, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vMax") << ":";
	float4::WriteSimpleJson(&s_Object->vMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nGridWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nGridWidth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fGridSpacing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fGridSpacing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVisibilityRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVisibilityRange);

	p_Stream << "}";
}

void SGProperties::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGProperties s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vMin"], &s_Item);
		s_Object.vMin = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vMax"], &s_Item);
		s_Object.vMax = s_Item;
	}

	s_Object.nGridWidth = simdjson::from_json_int32(p_Document["nGridWidth"]);

	s_Object.fGridSpacing = simdjson::from_json_float32(p_Document["fGridSpacing"]);

	s_Object.nVisibilityRange = simdjson::from_json_int32(p_Document["nVisibilityRange"]);

	*reinterpret_cast<SGProperties*>(p_Target) = s_Object;
}

void SGProperties::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);

	float4::Serialize(&s_Object->vMin, p_Serializer, p_OwnOffset + offsetof(SGProperties, vMin));
	float4::Serialize(&s_Object->vMax, p_Serializer, p_OwnOffset + offsetof(SGProperties, vMax));
}

bool SGProperties::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGProperties*>(p_Left);
	auto* s_Right = reinterpret_cast<SGProperties*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGProperties::operator==(const SGProperties& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGProperties>)
		return false;

	if (vMin != p_Other.vMin) return false;
	if (vMax != p_Other.vMax) return false;
	if (nGridWidth != p_Other.nGridWidth) return false;
	if (fGridSpacing != p_Other.fGridSpacing) return false;
	if (nVisibilityRange != p_Other.nVisibilityRange) return false;

	return true;
}

void SGProperties::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGProperties*>(p_Object);
	s_Object->~SGProperties();
}

ZHMTypeInfo SGUIViewPort::TypeInfo = ZHMTypeInfo("SGUIViewPort", sizeof(SGUIViewPort), alignof(SGUIViewPort), SGUIViewPort::WriteSimpleJson, SGUIViewPort::FromSimpleJson, SGUIViewPort::Serialize, SGUIViewPort::Equals, SGUIViewPort::Destroy);

void SGUIViewPort::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGUIViewPort*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("x") << ":";
	p_Stream << simdjson::as_json_string(s_Object->x);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("y") << ":";
	p_Stream << simdjson::as_json_string(s_Object->y);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("h") << ":";
	p_Stream << simdjson::as_json_string(s_Object->h);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("w") << ":";
	p_Stream << simdjson::as_json_string(s_Object->w);

	p_Stream << "}";
}

void SGUIViewPort::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGUIViewPort s_Object {};

	s_Object.x = simdjson::from_json_uint32(p_Document["x"]);

	s_Object.y = simdjson::from_json_uint32(p_Document["y"]);

	s_Object.h = simdjson::from_json_uint32(p_Document["h"]);

	s_Object.w = simdjson::from_json_uint32(p_Document["w"]);

	*reinterpret_cast<SGUIViewPort*>(p_Target) = s_Object;
}

void SGUIViewPort::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGUIViewPort*>(p_Object);

}

bool SGUIViewPort::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGUIViewPort*>(p_Left);
	auto* s_Right = reinterpret_cast<SGUIViewPort*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGUIViewPort::operator==(const SGUIViewPort& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGUIViewPort>)
		return false;

	if (x != p_Other.x) return false;
	if (y != p_Other.y) return false;
	if (h != p_Other.h) return false;
	if (w != p_Other.w) return false;

	return true;
}

void SGUIViewPort::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGUIViewPort*>(p_Object);
	s_Object->~SGUIViewPort();
}

ZHMTypeInfo SGWaypoint::TypeInfo = ZHMTypeInfo("SGWaypoint", sizeof(SGWaypoint), alignof(SGWaypoint), SGWaypoint::WriteSimpleJson, SGWaypoint::FromSimpleJson, SGWaypoint::Serialize, SGWaypoint::Equals, SGWaypoint::Destroy);

void SGWaypoint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nNeighbor0") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor0);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor1") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor1);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor2") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor2);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor3") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor3);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor4") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor4);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor5") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor5);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor6") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor6);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nNeighbor7") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nNeighbor7);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("vPos") << ":";
	float4::WriteSimpleJson(&s_Object->vPos, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVisionDataOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVisionDataOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nLayerIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nLayerIndex);

	p_Stream << "}";
}

void SGWaypoint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGWaypoint s_Object {};

	s_Object.nNeighbor0 = simdjson::from_json_uint16(p_Document["nNeighbor0"]);

	s_Object.nNeighbor1 = simdjson::from_json_uint16(p_Document["nNeighbor1"]);

	s_Object.nNeighbor2 = simdjson::from_json_uint16(p_Document["nNeighbor2"]);

	s_Object.nNeighbor3 = simdjson::from_json_uint16(p_Document["nNeighbor3"]);

	s_Object.nNeighbor4 = simdjson::from_json_uint16(p_Document["nNeighbor4"]);

	s_Object.nNeighbor5 = simdjson::from_json_uint16(p_Document["nNeighbor5"]);

	s_Object.nNeighbor6 = simdjson::from_json_uint16(p_Document["nNeighbor6"]);

	s_Object.nNeighbor7 = simdjson::from_json_uint16(p_Document["nNeighbor7"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["vPos"], &s_Item);
		s_Object.vPos = s_Item;
	}

	s_Object.nVisionDataOffset = simdjson::from_json_uint32(p_Document["nVisionDataOffset"]);

	s_Object.nLayerIndex = simdjson::from_json_int16(p_Document["nLayerIndex"]);

	*reinterpret_cast<SGWaypoint*>(p_Target) = s_Object;
}

void SGWaypoint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);

	float4::Serialize(&s_Object->vPos, p_Serializer, p_OwnOffset + offsetof(SGWaypoint, vPos));
}

bool SGWaypoint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGWaypoint*>(p_Left);
	auto* s_Right = reinterpret_cast<SGWaypoint*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGWaypoint::operator==(const SGWaypoint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGWaypoint>)
		return false;

	if (nNeighbor0 != p_Other.nNeighbor0) return false;
	if (nNeighbor1 != p_Other.nNeighbor1) return false;
	if (nNeighbor2 != p_Other.nNeighbor2) return false;
	if (nNeighbor3 != p_Other.nNeighbor3) return false;
	if (nNeighbor4 != p_Other.nNeighbor4) return false;
	if (nNeighbor5 != p_Other.nNeighbor5) return false;
	if (nNeighbor6 != p_Other.nNeighbor6) return false;
	if (nNeighbor7 != p_Other.nNeighbor7) return false;
	if (vPos != p_Other.vPos) return false;
	if (nVisionDataOffset != p_Other.nVisionDataOffset) return false;
	if (nLayerIndex != p_Other.nLayerIndex) return false;

	return true;
}

void SGWaypoint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGWaypoint*>(p_Object);
	s_Object->~SGWaypoint();
}

ZHMTypeInfo SGaitTransitionEntry::TypeInfo = ZHMTypeInfo("SGaitTransitionEntry", sizeof(SGaitTransitionEntry), alignof(SGaitTransitionEntry), SGaitTransitionEntry::WriteSimpleJson, SGaitTransitionEntry::FromSimpleJson, SGaitTransitionEntry::Serialize, SGaitTransitionEntry::Equals, SGaitTransitionEntry::Destroy);

void SGaitTransitionEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGaitTransitionEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_gait") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EGait", static_cast<int>(s_Object->m_gait)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_speed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESpeed", static_cast<int>(s_Object->m_speed)));

	p_Stream << "}";
}

void SGaitTransitionEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGaitTransitionEntry s_Object {};

	s_Object.m_gait = static_cast<EGait>(ZHMEnums::GetEnumValueByName("EGait", std::string_view(p_Document["m_gait"])));

	s_Object.m_speed = static_cast<ESpeed>(ZHMEnums::GetEnumValueByName("ESpeed", std::string_view(p_Document["m_speed"])));

	*reinterpret_cast<SGaitTransitionEntry*>(p_Target) = s_Object;
}

void SGaitTransitionEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGaitTransitionEntry*>(p_Object);

}

bool SGaitTransitionEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGaitTransitionEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SGaitTransitionEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGaitTransitionEntry::operator==(const SGaitTransitionEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGaitTransitionEntry>)
		return false;

	if (m_gait != p_Other.m_gait) return false;
	if (m_speed != p_Other.m_speed) return false;

	return true;
}

void SGaitTransitionEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGaitTransitionEntry*>(p_Object);
	s_Object->~SGaitTransitionEntry();
}

ZHMTypeInfo SGameCamProfileEntitySaveData::TypeInfo = ZHMTypeInfo("SGameCamProfileEntitySaveData", sizeof(SGameCamProfileEntitySaveData), alignof(SGameCamProfileEntitySaveData), SGameCamProfileEntitySaveData::WriteSimpleJson, SGameCamProfileEntitySaveData::FromSimpleJson, SGameCamProfileEntitySaveData::Serialize, SGameCamProfileEntitySaveData::Equals, SGameCamProfileEntitySaveData::Destroy);

void SGameCamProfileEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHero") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHero);

	p_Stream << "}";
}

void SGameCamProfileEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameCamProfileEntitySaveData s_Object {};

	s_Object.m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object.m_rHero = simdjson::from_json_uint32(p_Document["m_rHero"]);

	*reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Target) = s_Object;
}

void SGameCamProfileEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);

}

bool SGameCamProfileEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameCamProfileEntitySaveData::operator==(const SGameCamProfileEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameCamProfileEntitySaveData>)
		return false;

	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_rHero != p_Other.m_rHero) return false;

	return true;
}

void SGameCamProfileEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameCamProfileEntitySaveData*>(p_Object);
	s_Object->~SGameCamProfileEntitySaveData();
}

ZHMTypeInfo SItemKeywordProxySaveData::TypeInfo = ZHMTypeInfo("SItemKeywordProxySaveData", sizeof(SItemKeywordProxySaveData), alignof(SItemKeywordProxySaveData), SItemKeywordProxySaveData::WriteSimpleJson, SItemKeywordProxySaveData::FromSimpleJson, SItemKeywordProxySaveData::Serialize, SItemKeywordProxySaveData::Equals, SItemKeywordProxySaveData::Destroy);

void SItemKeywordProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SItemKeywordProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemKeywordProxySaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SItemKeywordProxySaveData*>(p_Target) = s_Object;
}

void SItemKeywordProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);

}

bool SItemKeywordProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemKeywordProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemKeywordProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemKeywordProxySaveData::operator==(const SItemKeywordProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemKeywordProxySaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SItemKeywordProxySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxySaveData*>(p_Object);
	s_Object->~SItemKeywordProxySaveData();
}

ZHMTypeInfo SItemKeywordProxiesSaveData::TypeInfo = ZHMTypeInfo("SItemKeywordProxiesSaveData", sizeof(SItemKeywordProxiesSaveData), alignof(SItemKeywordProxiesSaveData), SItemKeywordProxiesSaveData::WriteSimpleJson, SItemKeywordProxiesSaveData::FromSimpleJson, SItemKeywordProxiesSaveData::Serialize, SItemKeywordProxiesSaveData::Equals, SItemKeywordProxiesSaveData::Destroy);

void SItemKeywordProxiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItemKeywordProxySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemKeywordProxiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemKeywordProxiesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SItemKeywordProxySaveData s_ArrayItem0;
		SItemKeywordProxySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Target) = s_Object;
}

void SItemKeywordProxiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SItemKeywordProxiesSaveData, m_aEntities));
	TArray<SItemKeywordProxySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SItemKeywordProxiesSaveData, m_aData));
}

bool SItemKeywordProxiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemKeywordProxiesSaveData::operator==(const SItemKeywordProxiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemKeywordProxiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SItemKeywordProxiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemKeywordProxiesSaveData*>(p_Object);
	s_Object->~SItemKeywordProxiesSaveData();
}

ZHMTypeInfo SItemSaveData::TypeInfo = ZHMTypeInfo("SItemSaveData", sizeof(SItemSaveData), alignof(SItemSaveData), SItemSaveData::WriteSimpleJson, SItemSaveData::FromSimpleJson, SItemSaveData::Serialize, SItemSaveData::Equals, SItemSaveData::Destroy);

void SItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnablePickup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnablePickup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKinematic") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKinematic);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSleeping") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSleeping);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsPerceptible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsPerceptible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vVelocity") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vVelocity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rTransformParent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTransformParent);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSpawner") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSpawner);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rOwner") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rOwner);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHoldingContainer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHoldingContainer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pPreviousOwner") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pPreviousOwner);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTurnedOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTurnedOn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEverOwnedByHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEverOwnedByHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasPlacedAndAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasPlacedAndAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bObjectInPhysicsWorld") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bObjectInPhysicsWorld);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nQuantity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nQuantity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eGlowType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ERenderGlowTypes", static_cast<int>(s_Object->m_eGlowType)));

	p_Stream << "}";
}

void SItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemSaveData s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vRotation"], &s_Item);
		s_Object.m_vRotation = s_Item;
	}

	s_Object.m_bShowItem = simdjson::from_json_bool(p_Document["m_bShowItem"]);

	s_Object.m_bEnablePickup = simdjson::from_json_bool(p_Document["m_bEnablePickup"]);

	s_Object.m_bKinematic = simdjson::from_json_bool(p_Document["m_bKinematic"]);

	s_Object.m_bSleeping = simdjson::from_json_bool(p_Document["m_bSleeping"]);

	s_Object.m_bIsPerceptible = simdjson::from_json_bool(p_Document["m_bIsPerceptible"]);

	s_Object.m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vVelocity"], &s_Item);
		s_Object.m_vVelocity = s_Item;
	}

	s_Object.m_rTransformParent = simdjson::from_json_uint32(p_Document["m_rTransformParent"]);

	s_Object.m_rSpawner = simdjson::from_json_uint32(p_Document["m_rSpawner"]);

	s_Object.m_rOwner = simdjson::from_json_uint32(p_Document["m_rOwner"]);

	s_Object.m_rHoldingContainer = simdjson::from_json_uint32(p_Document["m_rHoldingContainer"]);

	s_Object.m_pPreviousOwner = simdjson::from_json_uint32(p_Document["m_pPreviousOwner"]);

	s_Object.m_bTurnedOn = simdjson::from_json_bool(p_Document["m_bTurnedOn"]);

	s_Object.m_bEverOwnedByHitman = simdjson::from_json_bool(p_Document["m_bEverOwnedByHitman"]);

	s_Object.m_bWasPlacedAndAttached = simdjson::from_json_bool(p_Document["m_bWasPlacedAndAttached"]);

	s_Object.m_bObjectInPhysicsWorld = simdjson::from_json_bool(p_Document["m_bObjectInPhysicsWorld"]);

	s_Object.m_nQuantity = simdjson::from_json_int32(p_Document["m_nQuantity"]);

	s_Object.m_eGlowType = static_cast<ERenderGlowTypes>(ZHMEnums::GetEnumValueByName("ERenderGlowTypes", std::string_view(p_Document["m_eGlowType"])));

	*reinterpret_cast<SItemSaveData*>(p_Target) = s_Object;
}

void SItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vRotation));
	SVector3::Serialize(&s_Object->m_vVelocity, p_Serializer, p_OwnOffset + offsetof(SItemSaveData, m_vVelocity));
}

bool SItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemSaveData::operator==(const SItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemSaveData>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_bShowItem != p_Other.m_bShowItem) return false;
	if (m_bEnablePickup != p_Other.m_bEnablePickup) return false;
	if (m_bKinematic != p_Other.m_bKinematic) return false;
	if (m_bSleeping != p_Other.m_bSleeping) return false;
	if (m_bIsPerceptible != p_Other.m_bIsPerceptible) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;
	if (m_vVelocity != p_Other.m_vVelocity) return false;
	if (m_rTransformParent != p_Other.m_rTransformParent) return false;
	if (m_rSpawner != p_Other.m_rSpawner) return false;
	if (m_rOwner != p_Other.m_rOwner) return false;
	if (m_rHoldingContainer != p_Other.m_rHoldingContainer) return false;
	if (m_pPreviousOwner != p_Other.m_pPreviousOwner) return false;
	if (m_bTurnedOn != p_Other.m_bTurnedOn) return false;
	if (m_bEverOwnedByHitman != p_Other.m_bEverOwnedByHitman) return false;
	if (m_bWasPlacedAndAttached != p_Other.m_bWasPlacedAndAttached) return false;
	if (m_bObjectInPhysicsWorld != p_Other.m_bObjectInPhysicsWorld) return false;
	if (m_nQuantity != p_Other.m_nQuantity) return false;
	if (m_eGlowType != p_Other.m_eGlowType) return false;

	return true;
}

void SItemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemSaveData*>(p_Object);
	s_Object->~SItemSaveData();
}

ZHMTypeInfo SItemsSaveData::TypeInfo = ZHMTypeInfo("SItemsSaveData", sizeof(SItemsSaveData), alignof(SItemsSaveData), SItemsSaveData::WriteSimpleJson, SItemsSaveData::FromSimpleJson, SItemsSaveData::Serialize, SItemsSaveData::Equals, SItemsSaveData::Destroy);

void SItemsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemsSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SItemSaveData s_ArrayItem0;
		SItemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SItemsSaveData*>(p_Target) = s_Object;
}

void SItemsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SItemsSaveData, m_aEntities));
	TArray<SItemSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SItemsSaveData, m_aData));
}

bool SItemsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemsSaveData::operator==(const SItemsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SItemsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemsSaveData*>(p_Object);
	s_Object->~SItemsSaveData();
}

ZHMTypeInfo SLampCoreSaveState::TypeInfo = ZHMTypeInfo("SLampCoreSaveState", sizeof(SLampCoreSaveState), alignof(SLampCoreSaveState), SLampCoreSaveState::WriteSimpleJson, SLampCoreSaveState::FromSimpleJson, SLampCoreSaveState::Serialize, SLampCoreSaveState::Equals, SLampCoreSaveState::Destroy);

void SLampCoreSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fDiffusePower") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDiffusePower);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSwitchState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSwitchState);

	p_Stream << "}";
}

void SLampCoreSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLampCoreSaveState s_Object {};

	s_Object.m_fDiffusePower = simdjson::from_json_float32(p_Document["m_fDiffusePower"]);

	s_Object.m_bSwitchState = simdjson::from_json_bool(p_Document["m_bSwitchState"]);

	*reinterpret_cast<SLampCoreSaveState*>(p_Target) = s_Object;
}

void SLampCoreSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);

}

bool SLampCoreSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLampCoreSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SLampCoreSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLampCoreSaveState::operator==(const SLampCoreSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLampCoreSaveState>)
		return false;

	if (m_fDiffusePower != p_Other.m_fDiffusePower) return false;
	if (m_bSwitchState != p_Other.m_bSwitchState) return false;

	return true;
}

void SLampCoreSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveState*>(p_Object);
	s_Object->~SLampCoreSaveState();
}

ZHMTypeInfo SLampCoreSaveData::TypeInfo = ZHMTypeInfo("SLampCoreSaveData", sizeof(SLampCoreSaveData), alignof(SLampCoreSaveData), SLampCoreSaveData::WriteSimpleJson, SLampCoreSaveData::FromSimpleJson, SLampCoreSaveData::Serialize, SLampCoreSaveData::Equals, SLampCoreSaveData::Destroy);

void SLampCoreSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SLampCoreSaveState::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLampCoreSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLampCoreSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLampCoreSaveState s_ArrayItem0;
		SLampCoreSaveState::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SLampCoreSaveData*>(p_Target) = s_Object;
}

void SLampCoreSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SLampCoreSaveData, m_aEntities));
	TArray<SLampCoreSaveState>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SLampCoreSaveData, m_aData));
}

bool SLampCoreSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLampCoreSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLampCoreSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLampCoreSaveData::operator==(const SLampCoreSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLampCoreSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SLampCoreSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLampCoreSaveData*>(p_Object);
	s_Object->~SLampCoreSaveData();
}

ZHMTypeInfo SMathLerpSaveData_SColorRGB::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SColorRGB", sizeof(SMathLerpSaveData_SColorRGB), alignof(SMathLerpSaveData_SColorRGB), SMathLerpSaveData_SColorRGB::WriteSimpleJson, SMathLerpSaveData_SColorRGB::FromSimpleJson, SMathLerpSaveData_SColorRGB::Serialize, SMathLerpSaveData_SColorRGB::Equals, SMathLerpSaveData_SColorRGB::Destroy);

void SMathLerpSaveData_SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SColorRGB s_Object {};

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);

	SColorRGB::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGB, m_A));
	SColorRGB::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGB, m_B));
}

bool SMathLerpSaveData_SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SColorRGB::operator==(const SMathLerpSaveData_SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SColorRGB>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SColorRGB::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGB*>(p_Object);
	s_Object->~SMathLerpSaveData_SColorRGB();
}

ZHMTypeInfo SMathLerpsSaveData_SColorRGB::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SColorRGB", sizeof(SMathLerpsSaveData_SColorRGB), alignof(SMathLerpsSaveData_SColorRGB), SMathLerpsSaveData_SColorRGB::WriteSimpleJson, SMathLerpsSaveData_SColorRGB::FromSimpleJson, SMathLerpsSaveData_SColorRGB::Serialize, SMathLerpsSaveData_SColorRGB::Equals, SMathLerpsSaveData_SColorRGB::Destroy);

void SMathLerpsSaveData_SColorRGB::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SColorRGB::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SColorRGB::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SColorRGB s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SColorRGB s_ArrayItem0;
		SMathLerpSaveData_SColorRGB::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SColorRGB::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGB, m_aEntities));
	TArray<SMathLerpSaveData_SColorRGB>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGB, m_aData));
}

bool SMathLerpsSaveData_SColorRGB::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SColorRGB::operator==(const SMathLerpsSaveData_SColorRGB& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SColorRGB>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SColorRGB::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGB*>(p_Object);
	s_Object->~SMathLerpsSaveData_SColorRGB();
}

ZHMTypeInfo SMathLerpSaveData_SColorRGBA::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SColorRGBA", sizeof(SMathLerpSaveData_SColorRGBA), alignof(SMathLerpSaveData_SColorRGBA), SMathLerpSaveData_SColorRGBA::WriteSimpleJson, SMathLerpSaveData_SColorRGBA::FromSimpleJson, SMathLerpSaveData_SColorRGBA::Serialize, SMathLerpSaveData_SColorRGBA::Equals, SMathLerpSaveData_SColorRGBA::Destroy);

void SMathLerpSaveData_SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SColorRGBA::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SColorRGBA::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SColorRGBA s_Object {};

	{
		SColorRGBA s_Item {};
		SColorRGBA::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SColorRGBA s_Item {};
		SColorRGBA::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);

	SColorRGBA::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGBA, m_A));
	SColorRGBA::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SColorRGBA, m_B));
}

bool SMathLerpSaveData_SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SColorRGBA::operator==(const SMathLerpSaveData_SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SColorRGBA>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SColorRGBA::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SColorRGBA*>(p_Object);
	s_Object->~SMathLerpSaveData_SColorRGBA();
}

ZHMTypeInfo SMathLerpsSaveData_SColorRGBA::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SColorRGBA", sizeof(SMathLerpsSaveData_SColorRGBA), alignof(SMathLerpsSaveData_SColorRGBA), SMathLerpsSaveData_SColorRGBA::WriteSimpleJson, SMathLerpsSaveData_SColorRGBA::FromSimpleJson, SMathLerpsSaveData_SColorRGBA::Serialize, SMathLerpsSaveData_SColorRGBA::Equals, SMathLerpsSaveData_SColorRGBA::Destroy);

void SMathLerpsSaveData_SColorRGBA::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SColorRGBA::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SColorRGBA::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SColorRGBA s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SColorRGBA s_ArrayItem0;
		SMathLerpSaveData_SColorRGBA::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SColorRGBA::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGBA, m_aEntities));
	TArray<SMathLerpSaveData_SColorRGBA>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SColorRGBA, m_aData));
}

bool SMathLerpsSaveData_SColorRGBA::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SColorRGBA::operator==(const SMathLerpsSaveData_SColorRGBA& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SColorRGBA>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SColorRGBA::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SColorRGBA*>(p_Object);
	s_Object->~SMathLerpsSaveData_SColorRGBA();
}

ZHMTypeInfo SMathLerpSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector2", sizeof(SMathLerpSaveData_SVector2), alignof(SMathLerpSaveData_SVector2), SMathLerpSaveData_SVector2::WriteSimpleJson, SMathLerpSaveData_SVector2::FromSimpleJson, SMathLerpSaveData_SVector2::Serialize, SMathLerpSaveData_SVector2::Equals, SMathLerpSaveData_SVector2::Destroy);

void SMathLerpSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SVector2 s_Object {};

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);

	SVector2::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector2, m_A));
	SVector2::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector2, m_B));
}

bool SMathLerpSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector2::operator==(const SMathLerpSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector2>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector2*>(p_Object);
	s_Object->~SMathLerpSaveData_SVector2();
}

ZHMTypeInfo SMathLerpsSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector2", sizeof(SMathLerpsSaveData_SVector2), alignof(SMathLerpsSaveData_SVector2), SMathLerpsSaveData_SVector2::WriteSimpleJson, SMathLerpsSaveData_SVector2::FromSimpleJson, SMathLerpsSaveData_SVector2::Serialize, SMathLerpsSaveData_SVector2::Equals, SMathLerpsSaveData_SVector2::Destroy);

void SMathLerpsSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SVector2 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SVector2 s_ArrayItem0;
		SMathLerpSaveData_SVector2::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector2, m_aEntities));
	TArray<SMathLerpSaveData_SVector2>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector2, m_aData));
}

bool SMathLerpsSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector2::operator==(const SMathLerpsSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector2>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector2*>(p_Object);
	s_Object->~SMathLerpsSaveData_SVector2();
}

ZHMTypeInfo SMathLerpSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector3", sizeof(SMathLerpSaveData_SVector3), alignof(SMathLerpSaveData_SVector3), SMathLerpSaveData_SVector3::WriteSimpleJson, SMathLerpSaveData_SVector3::FromSimpleJson, SMathLerpSaveData_SVector3::Serialize, SMathLerpSaveData_SVector3::Equals, SMathLerpSaveData_SVector3::Destroy);

void SMathLerpSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SVector3 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);

	SVector3::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector3, m_A));
	SVector3::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector3, m_B));
}

bool SMathLerpSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector3::operator==(const SMathLerpSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector3>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector3*>(p_Object);
	s_Object->~SMathLerpSaveData_SVector3();
}

ZHMTypeInfo SMathLerpsSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector3", sizeof(SMathLerpsSaveData_SVector3), alignof(SMathLerpsSaveData_SVector3), SMathLerpsSaveData_SVector3::WriteSimpleJson, SMathLerpsSaveData_SVector3::FromSimpleJson, SMathLerpsSaveData_SVector3::Serialize, SMathLerpsSaveData_SVector3::Equals, SMathLerpsSaveData_SVector3::Destroy);

void SMathLerpsSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SVector3 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SVector3 s_ArrayItem0;
		SMathLerpSaveData_SVector3::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector3, m_aEntities));
	TArray<SMathLerpSaveData_SVector3>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector3, m_aData));
}

bool SMathLerpsSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector3::operator==(const SMathLerpsSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector3>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector3*>(p_Object);
	s_Object->~SMathLerpsSaveData_SVector3();
}

ZHMTypeInfo SMathLerpSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_SVector4", sizeof(SMathLerpSaveData_SVector4), alignof(SMathLerpSaveData_SVector4), SMathLerpSaveData_SVector4::WriteSimpleJson, SMathLerpSaveData_SVector4::FromSimpleJson, SMathLerpSaveData_SVector4::Serialize, SMathLerpSaveData_SVector4::Equals, SMathLerpSaveData_SVector4::Destroy);

void SMathLerpSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_A, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_B, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_SVector4 s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_A"], &s_Item);
		s_Object.m_A = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_B"], &s_Item);
		s_Object.m_B = s_Item;
	}

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathLerpSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);

	SVector4::Serialize(&s_Object->m_A, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector4, m_A));
	SVector4::Serialize(&s_Object->m_B, p_Serializer, p_OwnOffset + offsetof(SMathLerpSaveData_SVector4, m_B));
}

bool SMathLerpSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_SVector4::operator==(const SMathLerpSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_SVector4>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_SVector4*>(p_Object);
	s_Object->~SMathLerpSaveData_SVector4();
}

ZHMTypeInfo SMathLerpsSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_SVector4", sizeof(SMathLerpsSaveData_SVector4), alignof(SMathLerpsSaveData_SVector4), SMathLerpsSaveData_SVector4::WriteSimpleJson, SMathLerpsSaveData_SVector4::FromSimpleJson, SMathLerpsSaveData_SVector4::Serialize, SMathLerpsSaveData_SVector4::Equals, SMathLerpsSaveData_SVector4::Destroy);

void SMathLerpsSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_SVector4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_SVector4 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_SVector4 s_ArrayItem0;
		SMathLerpSaveData_SVector4::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector4, m_aEntities));
	TArray<SMathLerpSaveData_SVector4>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_SVector4, m_aData));
}

bool SMathLerpsSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_SVector4::operator==(const SMathLerpsSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_SVector4>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_SVector4*>(p_Object);
	s_Object->~SMathLerpsSaveData_SVector4();
}

ZHMTypeInfo SMathLerpSaveData_float32::TypeInfo = ZHMTypeInfo("SMathLerpSaveData_float32", sizeof(SMathLerpSaveData_float32), alignof(SMathLerpSaveData_float32), SMathLerpSaveData_float32::WriteSimpleJson, SMathLerpSaveData_float32::FromSimpleJson, SMathLerpSaveData_float32::Serialize, SMathLerpSaveData_float32::Equals, SMathLerpSaveData_float32::Destroy);

void SMathLerpSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_A") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_A);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_B") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_B);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fT") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fT);

	p_Stream << "}";
}

void SMathLerpSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpSaveData_float32 s_Object {};

	s_Object.m_A = simdjson::from_json_float32(p_Document["m_A"]);

	s_Object.m_B = simdjson::from_json_float32(p_Document["m_B"]);

	s_Object.m_fT = simdjson::from_json_float32(p_Document["m_fT"]);

	*reinterpret_cast<SMathLerpSaveData_float32*>(p_Target) = s_Object;
}

void SMathLerpSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);

}

bool SMathLerpSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpSaveData_float32::operator==(const SMathLerpSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpSaveData_float32>)
		return false;

	if (m_A != p_Other.m_A) return false;
	if (m_B != p_Other.m_B) return false;
	if (m_fT != p_Other.m_fT) return false;

	return true;
}

void SMathLerpSaveData_float32::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpSaveData_float32*>(p_Object);
	s_Object->~SMathLerpSaveData_float32();
}

ZHMTypeInfo SMathLerpsSaveData_float32::TypeInfo = ZHMTypeInfo("SMathLerpsSaveData_float32", sizeof(SMathLerpsSaveData_float32), alignof(SMathLerpsSaveData_float32), SMathLerpsSaveData_float32::WriteSimpleJson, SMathLerpsSaveData_float32::FromSimpleJson, SMathLerpsSaveData_float32::Serialize, SMathLerpsSaveData_float32::Equals, SMathLerpsSaveData_float32::Destroy);

void SMathLerpsSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathLerpSaveData_float32::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathLerpsSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathLerpsSaveData_float32 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathLerpSaveData_float32 s_ArrayItem0;
		SMathLerpSaveData_float32::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathLerpsSaveData_float32*>(p_Target) = s_Object;
}

void SMathLerpsSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_float32, m_aEntities));
	TArray<SMathLerpSaveData_float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathLerpsSaveData_float32, m_aData));
}

bool SMathLerpsSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathLerpsSaveData_float32::operator==(const SMathLerpsSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathLerpsSaveData_float32>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathLerpsSaveData_float32::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathLerpsSaveData_float32*>(p_Object);
	s_Object->~SMathLerpsSaveData_float32();
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector2", sizeof(SMathMultiplyDivideSaveData_SVector2), alignof(SMathMultiplyDivideSaveData_SVector2), SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector2::FromSimpleJson, SMathMultiplyDivideSaveData_SVector2::Serialize, SMathMultiplyDivideSaveData_SVector2::Equals, SMathMultiplyDivideSaveData_SVector2::Destroy);

void SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultiplyDivideSaveData_SVector2 s_Object {};

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	s_Object.m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

	*reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathMultiplyDivideSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);

	SVector2::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector2, m_fA));
	SVector2::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector2, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector2::operator==(const SMathMultiplyDivideSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector2>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

void SMathMultiplyDivideSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector2*>(p_Object);
	s_Object->~SMathMultiplyDivideSaveData_SVector2();
}

ZHMTypeInfo SMathMultipliesSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector2", sizeof(SMathMultipliesSaveData_SVector2), alignof(SMathMultipliesSaveData_SVector2), SMathMultipliesSaveData_SVector2::WriteSimpleJson, SMathMultipliesSaveData_SVector2::FromSimpleJson, SMathMultipliesSaveData_SVector2::Serialize, SMathMultipliesSaveData_SVector2::Equals, SMathMultipliesSaveData_SVector2::Destroy);

void SMathMultipliesSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultipliesSaveData_SVector2 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathMultiplyDivideSaveData_SVector2 s_ArrayItem0;
		SMathMultiplyDivideSaveData_SVector2::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathMultipliesSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector2, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector2>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector2, m_aData));
}

bool SMathMultipliesSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector2::operator==(const SMathMultipliesSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector2>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathMultipliesSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector2*>(p_Object);
	s_Object->~SMathMultipliesSaveData_SVector2();
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector3", sizeof(SMathMultiplyDivideSaveData_SVector3), alignof(SMathMultiplyDivideSaveData_SVector3), SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector3::FromSimpleJson, SMathMultiplyDivideSaveData_SVector3::Serialize, SMathMultiplyDivideSaveData_SVector3::Equals, SMathMultiplyDivideSaveData_SVector3::Destroy);

void SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultiplyDivideSaveData_SVector3 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	s_Object.m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

	*reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathMultiplyDivideSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);

	SVector3::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector3, m_fA));
	SVector3::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector3, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector3::operator==(const SMathMultiplyDivideSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector3>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

void SMathMultiplyDivideSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector3*>(p_Object);
	s_Object->~SMathMultiplyDivideSaveData_SVector3();
}

ZHMTypeInfo SMathMultipliesSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector3", sizeof(SMathMultipliesSaveData_SVector3), alignof(SMathMultipliesSaveData_SVector3), SMathMultipliesSaveData_SVector3::WriteSimpleJson, SMathMultipliesSaveData_SVector3::FromSimpleJson, SMathMultipliesSaveData_SVector3::Serialize, SMathMultipliesSaveData_SVector3::Equals, SMathMultipliesSaveData_SVector3::Destroy);

void SMathMultipliesSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector3::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultipliesSaveData_SVector3 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathMultiplyDivideSaveData_SVector3 s_ArrayItem0;
		SMathMultiplyDivideSaveData_SVector3::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathMultipliesSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector3, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector3>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector3, m_aData));
}

bool SMathMultipliesSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector3::operator==(const SMathMultipliesSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector3>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathMultipliesSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector3*>(p_Object);
	s_Object->~SMathMultipliesSaveData_SVector3();
}

ZHMTypeInfo SMathMultiplyDivideSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_SVector4", sizeof(SMathMultiplyDivideSaveData_SVector4), alignof(SMathMultiplyDivideSaveData_SVector4), SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson, SMathMultiplyDivideSaveData_SVector4::FromSimpleJson, SMathMultiplyDivideSaveData_SVector4::Serialize, SMathMultiplyDivideSaveData_SVector4::Equals, SMathMultiplyDivideSaveData_SVector4::Destroy);

void SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_fB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultiplyDivideSaveData_SVector4 s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	s_Object.m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

	*reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathMultiplyDivideSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);

	SVector4::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector4, m_fA));
	SVector4::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathMultiplyDivideSaveData_SVector4, m_fB));
}

bool SMathMultiplyDivideSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_SVector4::operator==(const SMathMultiplyDivideSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_SVector4>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

void SMathMultiplyDivideSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_SVector4*>(p_Object);
	s_Object->~SMathMultiplyDivideSaveData_SVector4();
}

ZHMTypeInfo SMathMultipliesSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_SVector4", sizeof(SMathMultipliesSaveData_SVector4), alignof(SMathMultipliesSaveData_SVector4), SMathMultipliesSaveData_SVector4::WriteSimpleJson, SMathMultipliesSaveData_SVector4::FromSimpleJson, SMathMultipliesSaveData_SVector4::Serialize, SMathMultipliesSaveData_SVector4::Equals, SMathMultipliesSaveData_SVector4::Destroy);

void SMathMultipliesSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_SVector4::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultipliesSaveData_SVector4 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathMultiplyDivideSaveData_SVector4 s_ArrayItem0;
		SMathMultiplyDivideSaveData_SVector4::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathMultipliesSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector4, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_SVector4>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_SVector4, m_aData));
}

bool SMathMultipliesSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_SVector4::operator==(const SMathMultipliesSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_SVector4>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathMultipliesSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_SVector4*>(p_Object);
	s_Object->~SMathMultipliesSaveData_SVector4();
}

ZHMTypeInfo SMathMultiplyDivideSaveData_float32::TypeInfo = ZHMTypeInfo("SMathMultiplyDivideSaveData_float32", sizeof(SMathMultiplyDivideSaveData_float32), alignof(SMathMultiplyDivideSaveData_float32), SMathMultiplyDivideSaveData_float32::WriteSimpleJson, SMathMultiplyDivideSaveData_float32::FromSimpleJson, SMathMultiplyDivideSaveData_float32::Serialize, SMathMultiplyDivideSaveData_float32::Equals, SMathMultiplyDivideSaveData_float32::Destroy);

void SMathMultiplyDivideSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fA);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fB);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDivide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDivide);

	p_Stream << "}";
}

void SMathMultiplyDivideSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultiplyDivideSaveData_float32 s_Object {};

	s_Object.m_fA = simdjson::from_json_float32(p_Document["m_fA"]);

	s_Object.m_fB = simdjson::from_json_float32(p_Document["m_fB"]);

	s_Object.m_bDivide = simdjson::from_json_bool(p_Document["m_bDivide"]);

	*reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Target) = s_Object;
}

void SMathMultiplyDivideSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);

}

bool SMathMultiplyDivideSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultiplyDivideSaveData_float32::operator==(const SMathMultiplyDivideSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultiplyDivideSaveData_float32>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;
	if (m_bDivide != p_Other.m_bDivide) return false;

	return true;
}

void SMathMultiplyDivideSaveData_float32::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultiplyDivideSaveData_float32*>(p_Object);
	s_Object->~SMathMultiplyDivideSaveData_float32();
}

ZHMTypeInfo SMathMultipliesSaveData_float32::TypeInfo = ZHMTypeInfo("SMathMultipliesSaveData_float32", sizeof(SMathMultipliesSaveData_float32), alignof(SMathMultipliesSaveData_float32), SMathMultipliesSaveData_float32::WriteSimpleJson, SMathMultipliesSaveData_float32::FromSimpleJson, SMathMultipliesSaveData_float32::Serialize, SMathMultipliesSaveData_float32::Equals, SMathMultipliesSaveData_float32::Destroy);

void SMathMultipliesSaveData_float32::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SMathMultiplyDivideSaveData_float32::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMathMultipliesSaveData_float32::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathMultipliesSaveData_float32 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SMathMultiplyDivideSaveData_float32 s_ArrayItem0;
		SMathMultiplyDivideSaveData_float32::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Target) = s_Object;
}

void SMathMultipliesSaveData_float32::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_float32, m_aEntities));
	TArray<SMathMultiplyDivideSaveData_float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SMathMultipliesSaveData_float32, m_aData));
}

bool SMathMultipliesSaveData_float32::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathMultipliesSaveData_float32::operator==(const SMathMultipliesSaveData_float32& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathMultipliesSaveData_float32>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SMathMultipliesSaveData_float32::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathMultipliesSaveData_float32*>(p_Object);
	s_Object->~SMathMultipliesSaveData_float32();
}

ZHMTypeInfo SShotListenerSaveData::TypeInfo = ZHMTypeInfo("SShotListenerSaveData", sizeof(SShotListenerSaveData), alignof(SShotListenerSaveData), SShotListenerSaveData::WriteSimpleJson, SShotListenerSaveData::FromSimpleJson, SShotListenerSaveData::Serialize, SShotListenerSaveData::Equals, SShotListenerSaveData::Destroy);

void SShotListenerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNPCShotProcessed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNPCShotProcessed);

	p_Stream << "}";
}

void SShotListenerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SShotListenerSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bNPCShotProcessed = simdjson::from_json_bool(p_Document["m_bNPCShotProcessed"]);

	*reinterpret_cast<SShotListenerSaveData*>(p_Target) = s_Object;
}

void SShotListenerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);

}

bool SShotListenerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShotListenerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShotListenerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShotListenerSaveData::operator==(const SShotListenerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShotListenerSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bNPCShotProcessed != p_Other.m_bNPCShotProcessed) return false;

	return true;
}

void SShotListenerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SShotListenerSaveData*>(p_Object);
	s_Object->~SShotListenerSaveData();
}

ZHMTypeInfo SShotListenersSaveData::TypeInfo = ZHMTypeInfo("SShotListenersSaveData", sizeof(SShotListenersSaveData), alignof(SShotListenersSaveData), SShotListenersSaveData::WriteSimpleJson, SShotListenersSaveData::FromSimpleJson, SShotListenersSaveData::Serialize, SShotListenersSaveData::Equals, SShotListenersSaveData::Destroy);

void SShotListenersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SShotListenerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SShotListenersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SShotListenersSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SShotListenerSaveData s_ArrayItem0;
		SShotListenerSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SShotListenersSaveData*>(p_Target) = s_Object;
}

void SShotListenersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SShotListenersSaveData, m_aEntities));
	TArray<SShotListenerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SShotListenersSaveData, m_aData));
}

bool SShotListenersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SShotListenersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SShotListenersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SShotListenersSaveData::operator==(const SShotListenersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SShotListenersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SShotListenersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SShotListenersSaveData*>(p_Object);
	s_Object->~SShotListenersSaveData();
}

ZHMTypeInfo SItsATrapSaveData::TypeInfo = ZHMTypeInfo("SItsATrapSaveData", sizeof(SItsATrapSaveData), alignof(SItsATrapSaveData), SItsATrapSaveData::WriteSimpleJson, SItsATrapSaveData::FromSimpleJson, SItsATrapSaveData::Serialize, SItsATrapSaveData::Equals, SItsATrapSaveData::Destroy);

void SItsATrapSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimer);

	p_Stream << "}";
}

void SItsATrapSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItsATrapSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_fTimer = simdjson::from_json_float32(p_Document["m_fTimer"]);

	*reinterpret_cast<SItsATrapSaveData*>(p_Target) = s_Object;
}

void SItsATrapSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);

}

bool SItsATrapSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItsATrapSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItsATrapSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItsATrapSaveData::operator==(const SItsATrapSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItsATrapSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fTimer != p_Other.m_fTimer) return false;

	return true;
}

void SItsATrapSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItsATrapSaveData*>(p_Object);
	s_Object->~SItsATrapSaveData();
}

ZHMTypeInfo STrapsSaveData::TypeInfo = ZHMTypeInfo("STrapsSaveData", sizeof(STrapsSaveData), alignof(STrapsSaveData), STrapsSaveData::WriteSimpleJson, STrapsSaveData::FromSimpleJson, STrapsSaveData::Serialize, STrapsSaveData::Equals, STrapsSaveData::Destroy);

void STrapsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SItsATrapSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrapsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrapsSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SItsATrapSaveData s_ArrayItem0;
		SItsATrapSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STrapsSaveData*>(p_Target) = s_Object;
}

void STrapsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(STrapsSaveData, m_aEntities));
	TArray<SItsATrapSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(STrapsSaveData, m_aData));
}

bool STrapsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrapsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrapsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrapsSaveData::operator==(const STrapsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrapsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void STrapsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrapsSaveData*>(p_Object);
	s_Object->~STrapsSaveData();
}

ZHMTypeInfo SVIPEvacuationNodeSaveData::TypeInfo = ZHMTypeInfo("SVIPEvacuationNodeSaveData", sizeof(SVIPEvacuationNodeSaveData), alignof(SVIPEvacuationNodeSaveData), SVIPEvacuationNodeSaveData::WriteSimpleJson, SVIPEvacuationNodeSaveData::FromSimpleJson, SVIPEvacuationNodeSaveData::Serialize, SVIPEvacuationNodeSaveData::Equals, SVIPEvacuationNodeSaveData::Destroy);

void SVIPEvacuationNodeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fPenaltyMultiplier") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPenaltyMultiplier);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPenaltyDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPenaltyDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tPenalty") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tPenalty, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_compromisedOnEnter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_compromisedOnEnter);

	p_Stream << "}";
}

void SVIPEvacuationNodeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVIPEvacuationNodeSaveData s_Object {};

	s_Object.m_fPenaltyMultiplier = simdjson::from_json_float32(p_Document["m_fPenaltyMultiplier"]);

	s_Object.m_fPenaltyDuration = simdjson::from_json_float32(p_Document["m_fPenaltyDuration"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tPenalty"], &s_Item);
		s_Object.m_tPenalty = s_Item;
	}

	s_Object.m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object.m_compromisedOnEnter = simdjson::from_json_bool(p_Document["m_compromisedOnEnter"]);

	*reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Target) = s_Object;
}

void SVIPEvacuationNodeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tPenalty, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodeSaveData, m_tPenalty));
}

bool SVIPEvacuationNodeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVIPEvacuationNodeSaveData::operator==(const SVIPEvacuationNodeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVIPEvacuationNodeSaveData>)
		return false;

	if (m_fPenaltyMultiplier != p_Other.m_fPenaltyMultiplier) return false;
	if (m_fPenaltyDuration != p_Other.m_fPenaltyDuration) return false;
	if (m_tPenalty != p_Other.m_tPenalty) return false;
	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_compromisedOnEnter != p_Other.m_compromisedOnEnter) return false;

	return true;
}

void SVIPEvacuationNodeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodeSaveData*>(p_Object);
	s_Object->~SVIPEvacuationNodeSaveData();
}

ZHMTypeInfo SVIPEvacuationNodesSaveData::TypeInfo = ZHMTypeInfo("SVIPEvacuationNodesSaveData", sizeof(SVIPEvacuationNodesSaveData), alignof(SVIPEvacuationNodesSaveData), SVIPEvacuationNodesSaveData::WriteSimpleJson, SVIPEvacuationNodesSaveData::FromSimpleJson, SVIPEvacuationNodesSaveData::Serialize, SVIPEvacuationNodesSaveData::Equals, SVIPEvacuationNodesSaveData::Destroy);

void SVIPEvacuationNodesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SVIPEvacuationNodeSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVIPEvacuationNodesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVIPEvacuationNodesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVIPEvacuationNodeSaveData s_ArrayItem0;
		SVIPEvacuationNodeSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Target) = s_Object;
}

void SVIPEvacuationNodesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodesSaveData, m_aEntities));
	TArray<SVIPEvacuationNodeSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SVIPEvacuationNodesSaveData, m_aData));
}

bool SVIPEvacuationNodesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVIPEvacuationNodesSaveData::operator==(const SVIPEvacuationNodesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVIPEvacuationNodesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SVIPEvacuationNodesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVIPEvacuationNodesSaveData*>(p_Object);
	s_Object->~SVIPEvacuationNodesSaveData();
}

ZHMTypeInfo SVolumeTriggerListenerSaveData::TypeInfo = ZHMTypeInfo("SVolumeTriggerListenerSaveData", sizeof(SVolumeTriggerListenerSaveData), alignof(SVolumeTriggerListenerSaveData), SVolumeTriggerListenerSaveData::WriteSimpleJson, SVolumeTriggerListenerSaveData::FromSimpleJson, SVolumeTriggerListenerSaveData::Serialize, SVolumeTriggerListenerSaveData::Equals, SVolumeTriggerListenerSaveData::Destroy);

void SVolumeTriggerListenerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bColliding") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bColliding);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInternalEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInternalEnabled);

	p_Stream << "}";
}

void SVolumeTriggerListenerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVolumeTriggerListenerSaveData s_Object {};

	s_Object.m_bColliding = simdjson::from_json_bool(p_Document["m_bColliding"]);

	s_Object.m_bInternalEnabled = simdjson::from_json_bool(p_Document["m_bInternalEnabled"]);

	*reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Target) = s_Object;
}

void SVolumeTriggerListenerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);

}

bool SVolumeTriggerListenerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVolumeTriggerListenerSaveData::operator==(const SVolumeTriggerListenerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVolumeTriggerListenerSaveData>)
		return false;

	if (m_bColliding != p_Other.m_bColliding) return false;
	if (m_bInternalEnabled != p_Other.m_bInternalEnabled) return false;

	return true;
}

void SVolumeTriggerListenerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggerListenerSaveData*>(p_Object);
	s_Object->~SVolumeTriggerListenerSaveData();
}

ZHMTypeInfo SVolumeTriggersSaveData::TypeInfo = ZHMTypeInfo("SVolumeTriggersSaveData", sizeof(SVolumeTriggersSaveData), alignof(SVolumeTriggersSaveData), SVolumeTriggersSaveData::WriteSimpleJson, SVolumeTriggersSaveData::FromSimpleJson, SVolumeTriggersSaveData::Serialize, SVolumeTriggersSaveData::Equals, SVolumeTriggersSaveData::Destroy);

void SVolumeTriggersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SVolumeTriggerListenerSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVolumeTriggersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVolumeTriggersSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVolumeTriggerListenerSaveData s_ArrayItem0;
		SVolumeTriggerListenerSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SVolumeTriggersSaveData*>(p_Target) = s_Object;
}

void SVolumeTriggersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SVolumeTriggersSaveData, m_aEntities));
	TArray<SVolumeTriggerListenerSaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SVolumeTriggersSaveData, m_aData));
}

bool SVolumeTriggersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVolumeTriggersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVolumeTriggersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVolumeTriggersSaveData::operator==(const SVolumeTriggersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVolumeTriggersSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SVolumeTriggersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVolumeTriggersSaveData*>(p_Object);
	s_Object->~SVolumeTriggersSaveData();
}

ZHMTypeInfo SGameEntitySaveData::TypeInfo = ZHMTypeInfo("SGameEntitySaveData", sizeof(SGameEntitySaveData), alignof(SGameEntitySaveData), SGameEntitySaveData::WriteSimpleJson, SGameEntitySaveData::FromSimpleJson, SGameEntitySaveData::Serialize, SGameEntitySaveData::Equals, SGameEntitySaveData::Destroy);

void SGameEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_DoorData") << ":";
	SDoorsSaveData::WriteSimpleJson(&s_Object->m_DoorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemsData") << ":";
	SItemsSaveData::WriteSimpleJson(&s_Object->m_ItemsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_VolumeTriggersData") << ":";
	SVolumeTriggersSaveData::WriteSimpleJson(&s_Object->m_VolumeTriggersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_float32") << ":";
	SMathMultipliesSaveData_float32::WriteSimpleJson(&s_Object->m_MathMultipliesData_float32, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector2") << ":";
	SMathMultipliesSaveData_SVector2::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector2, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector3") << ":";
	SMathMultipliesSaveData_SVector3::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector3, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathMultipliesData_Vector4") << ":";
	SMathMultipliesSaveData_SVector4::WriteSimpleJson(&s_Object->m_MathMultipliesData_Vector4, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ShotListenersData") << ":";
	SShotListenersSaveData::WriteSimpleJson(&s_Object->m_ShotListenersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TrapsData") << ":";
	STrapsSaveData::WriteSimpleJson(&s_Object->m_TrapsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorProxiesData") << ":";
	SActorProxiesSaveData::WriteSimpleJson(&s_Object->m_ActorProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorStandInEntitiesData") << ":";
	SActorStandInEntitiesSaveData::WriteSimpleJson(&s_Object->m_ActorStandInEntitiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorBoneAttachmentsData") << ":";
	SActorBoneAttachmentsSaveData::WriteSimpleJson(&s_Object->m_ActorBoneAttachmentsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ActorKeywordProxiesData") << ":";
	SActorKeywordProxiesSaveData::WriteSimpleJson(&s_Object->m_ActorKeywordProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemKeywordProxiesData") << ":";
	SItemKeywordProxiesSaveData::WriteSimpleJson(&s_Object->m_ItemKeywordProxiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LampCoreData") << ":";
	SLampCoreSaveData::WriteSimpleJson(&s_Object->m_LampCoreData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_VIPEvacuationNodesData") << ":";
	SVIPEvacuationNodesSaveData::WriteSimpleJson(&s_Object->m_VIPEvacuationNodesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CollisionControllerAspectsData") << ":";
	SCollisionControllerAspectsSaveData::WriteSimpleJson(&s_Object->m_CollisionControllerAspectsData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_BodyContainersData") << ":";
	SBodyContainersSaveData::WriteSimpleJson(&s_Object->m_BodyContainersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_float32") << ":";
	SMathLerpsSaveData_float32::WriteSimpleJson(&s_Object->m_MathLerpsData_float32, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector2") << ":";
	SMathLerpsSaveData_SVector2::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector2, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector3") << ":";
	SMathLerpsSaveData_SVector3::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector3, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SVector4") << ":";
	SMathLerpsSaveData_SVector4::WriteSimpleJson(&s_Object->m_MathLerpsData_SVector4, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SColorRGB") << ":";
	SMathLerpsSaveData_SColorRGB::WriteSimpleJson(&s_Object->m_MathLerpsData_SColorRGB, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MathLerpsData_SColorRGBA") << ":";
	SMathLerpsSaveData_SColorRGBA::WriteSimpleJson(&s_Object->m_MathLerpsData_SColorRGBA, p_Stream);

	p_Stream << "}";
}

void SGameEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameEntitySaveData s_Object {};

	{
		SDoorsSaveData s_Item {};
		SDoorsSaveData::FromSimpleJson(p_Document["m_DoorData"], &s_Item);
		s_Object.m_DoorData = s_Item;
	}

	{
		SItemsSaveData s_Item {};
		SItemsSaveData::FromSimpleJson(p_Document["m_ItemsData"], &s_Item);
		s_Object.m_ItemsData = s_Item;
	}

	{
		SVolumeTriggersSaveData s_Item {};
		SVolumeTriggersSaveData::FromSimpleJson(p_Document["m_VolumeTriggersData"], &s_Item);
		s_Object.m_VolumeTriggersData = s_Item;
	}

	{
		SMathMultipliesSaveData_float32 s_Item {};
		SMathMultipliesSaveData_float32::FromSimpleJson(p_Document["m_MathMultipliesData_float32"], &s_Item);
		s_Object.m_MathMultipliesData_float32 = s_Item;
	}

	{
		SMathMultipliesSaveData_SVector2 s_Item {};
		SMathMultipliesSaveData_SVector2::FromSimpleJson(p_Document["m_MathMultipliesData_Vector2"], &s_Item);
		s_Object.m_MathMultipliesData_Vector2 = s_Item;
	}

	{
		SMathMultipliesSaveData_SVector3 s_Item {};
		SMathMultipliesSaveData_SVector3::FromSimpleJson(p_Document["m_MathMultipliesData_Vector3"], &s_Item);
		s_Object.m_MathMultipliesData_Vector3 = s_Item;
	}

	{
		SMathMultipliesSaveData_SVector4 s_Item {};
		SMathMultipliesSaveData_SVector4::FromSimpleJson(p_Document["m_MathMultipliesData_Vector4"], &s_Item);
		s_Object.m_MathMultipliesData_Vector4 = s_Item;
	}

	{
		SShotListenersSaveData s_Item {};
		SShotListenersSaveData::FromSimpleJson(p_Document["m_ShotListenersData"], &s_Item);
		s_Object.m_ShotListenersData = s_Item;
	}

	{
		STrapsSaveData s_Item {};
		STrapsSaveData::FromSimpleJson(p_Document["m_TrapsData"], &s_Item);
		s_Object.m_TrapsData = s_Item;
	}

	{
		SActorProxiesSaveData s_Item {};
		SActorProxiesSaveData::FromSimpleJson(p_Document["m_ActorProxiesData"], &s_Item);
		s_Object.m_ActorProxiesData = s_Item;
	}

	{
		SActorStandInEntitiesSaveData s_Item {};
		SActorStandInEntitiesSaveData::FromSimpleJson(p_Document["m_ActorStandInEntitiesData"], &s_Item);
		s_Object.m_ActorStandInEntitiesData = s_Item;
	}

	{
		SActorBoneAttachmentsSaveData s_Item {};
		SActorBoneAttachmentsSaveData::FromSimpleJson(p_Document["m_ActorBoneAttachmentsData"], &s_Item);
		s_Object.m_ActorBoneAttachmentsData = s_Item;
	}

	{
		SActorKeywordProxiesSaveData s_Item {};
		SActorKeywordProxiesSaveData::FromSimpleJson(p_Document["m_ActorKeywordProxiesData"], &s_Item);
		s_Object.m_ActorKeywordProxiesData = s_Item;
	}

	{
		SItemKeywordProxiesSaveData s_Item {};
		SItemKeywordProxiesSaveData::FromSimpleJson(p_Document["m_ItemKeywordProxiesData"], &s_Item);
		s_Object.m_ItemKeywordProxiesData = s_Item;
	}

	{
		SLampCoreSaveData s_Item {};
		SLampCoreSaveData::FromSimpleJson(p_Document["m_LampCoreData"], &s_Item);
		s_Object.m_LampCoreData = s_Item;
	}

	{
		SVIPEvacuationNodesSaveData s_Item {};
		SVIPEvacuationNodesSaveData::FromSimpleJson(p_Document["m_VIPEvacuationNodesData"], &s_Item);
		s_Object.m_VIPEvacuationNodesData = s_Item;
	}

	{
		SCollisionControllerAspectsSaveData s_Item {};
		SCollisionControllerAspectsSaveData::FromSimpleJson(p_Document["m_CollisionControllerAspectsData"], &s_Item);
		s_Object.m_CollisionControllerAspectsData = s_Item;
	}

	{
		SBodyContainersSaveData s_Item {};
		SBodyContainersSaveData::FromSimpleJson(p_Document["m_BodyContainersData"], &s_Item);
		s_Object.m_BodyContainersData = s_Item;
	}

	{
		SMathLerpsSaveData_float32 s_Item {};
		SMathLerpsSaveData_float32::FromSimpleJson(p_Document["m_MathLerpsData_float32"], &s_Item);
		s_Object.m_MathLerpsData_float32 = s_Item;
	}

	{
		SMathLerpsSaveData_SVector2 s_Item {};
		SMathLerpsSaveData_SVector2::FromSimpleJson(p_Document["m_MathLerpsData_SVector2"], &s_Item);
		s_Object.m_MathLerpsData_SVector2 = s_Item;
	}

	{
		SMathLerpsSaveData_SVector3 s_Item {};
		SMathLerpsSaveData_SVector3::FromSimpleJson(p_Document["m_MathLerpsData_SVector3"], &s_Item);
		s_Object.m_MathLerpsData_SVector3 = s_Item;
	}

	{
		SMathLerpsSaveData_SVector4 s_Item {};
		SMathLerpsSaveData_SVector4::FromSimpleJson(p_Document["m_MathLerpsData_SVector4"], &s_Item);
		s_Object.m_MathLerpsData_SVector4 = s_Item;
	}

	{
		SMathLerpsSaveData_SColorRGB s_Item {};
		SMathLerpsSaveData_SColorRGB::FromSimpleJson(p_Document["m_MathLerpsData_SColorRGB"], &s_Item);
		s_Object.m_MathLerpsData_SColorRGB = s_Item;
	}

	{
		SMathLerpsSaveData_SColorRGBA s_Item {};
		SMathLerpsSaveData_SColorRGBA::FromSimpleJson(p_Document["m_MathLerpsData_SColorRGBA"], &s_Item);
		s_Object.m_MathLerpsData_SColorRGBA = s_Item;
	}

	*reinterpret_cast<SGameEntitySaveData*>(p_Target) = s_Object;
}

void SGameEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);

	SDoorsSaveData::Serialize(&s_Object->m_DoorData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_DoorData));
	SItemsSaveData::Serialize(&s_Object->m_ItemsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ItemsData));
	SVolumeTriggersSaveData::Serialize(&s_Object->m_VolumeTriggersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_VolumeTriggersData));
	SMathMultipliesSaveData_float32::Serialize(&s_Object->m_MathMultipliesData_float32, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_float32));
	SMathMultipliesSaveData_SVector2::Serialize(&s_Object->m_MathMultipliesData_Vector2, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector2));
	SMathMultipliesSaveData_SVector3::Serialize(&s_Object->m_MathMultipliesData_Vector3, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector3));
	SMathMultipliesSaveData_SVector4::Serialize(&s_Object->m_MathMultipliesData_Vector4, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathMultipliesData_Vector4));
	SShotListenersSaveData::Serialize(&s_Object->m_ShotListenersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ShotListenersData));
	STrapsSaveData::Serialize(&s_Object->m_TrapsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_TrapsData));
	SActorProxiesSaveData::Serialize(&s_Object->m_ActorProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorProxiesData));
	SActorStandInEntitiesSaveData::Serialize(&s_Object->m_ActorStandInEntitiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorStandInEntitiesData));
	SActorBoneAttachmentsSaveData::Serialize(&s_Object->m_ActorBoneAttachmentsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorBoneAttachmentsData));
	SActorKeywordProxiesSaveData::Serialize(&s_Object->m_ActorKeywordProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ActorKeywordProxiesData));
	SItemKeywordProxiesSaveData::Serialize(&s_Object->m_ItemKeywordProxiesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_ItemKeywordProxiesData));
	SLampCoreSaveData::Serialize(&s_Object->m_LampCoreData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_LampCoreData));
	SVIPEvacuationNodesSaveData::Serialize(&s_Object->m_VIPEvacuationNodesData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_VIPEvacuationNodesData));
	SCollisionControllerAspectsSaveData::Serialize(&s_Object->m_CollisionControllerAspectsData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_CollisionControllerAspectsData));
	SBodyContainersSaveData::Serialize(&s_Object->m_BodyContainersData, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_BodyContainersData));
	SMathLerpsSaveData_float32::Serialize(&s_Object->m_MathLerpsData_float32, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_float32));
	SMathLerpsSaveData_SVector2::Serialize(&s_Object->m_MathLerpsData_SVector2, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector2));
	SMathLerpsSaveData_SVector3::Serialize(&s_Object->m_MathLerpsData_SVector3, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector3));
	SMathLerpsSaveData_SVector4::Serialize(&s_Object->m_MathLerpsData_SVector4, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SVector4));
	SMathLerpsSaveData_SColorRGB::Serialize(&s_Object->m_MathLerpsData_SColorRGB, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SColorRGB));
	SMathLerpsSaveData_SColorRGBA::Serialize(&s_Object->m_MathLerpsData_SColorRGBA, p_Serializer, p_OwnOffset + offsetof(SGameEntitySaveData, m_MathLerpsData_SColorRGBA));
}

bool SGameEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameEntitySaveData::operator==(const SGameEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameEntitySaveData>)
		return false;

	if (m_DoorData != p_Other.m_DoorData) return false;
	if (m_ItemsData != p_Other.m_ItemsData) return false;
	if (m_VolumeTriggersData != p_Other.m_VolumeTriggersData) return false;
	if (m_MathMultipliesData_float32 != p_Other.m_MathMultipliesData_float32) return false;
	if (m_MathMultipliesData_Vector2 != p_Other.m_MathMultipliesData_Vector2) return false;
	if (m_MathMultipliesData_Vector3 != p_Other.m_MathMultipliesData_Vector3) return false;
	if (m_MathMultipliesData_Vector4 != p_Other.m_MathMultipliesData_Vector4) return false;
	if (m_ShotListenersData != p_Other.m_ShotListenersData) return false;
	if (m_TrapsData != p_Other.m_TrapsData) return false;
	if (m_ActorProxiesData != p_Other.m_ActorProxiesData) return false;
	if (m_ActorStandInEntitiesData != p_Other.m_ActorStandInEntitiesData) return false;
	if (m_ActorBoneAttachmentsData != p_Other.m_ActorBoneAttachmentsData) return false;
	if (m_ActorKeywordProxiesData != p_Other.m_ActorKeywordProxiesData) return false;
	if (m_ItemKeywordProxiesData != p_Other.m_ItemKeywordProxiesData) return false;
	if (m_LampCoreData != p_Other.m_LampCoreData) return false;
	if (m_VIPEvacuationNodesData != p_Other.m_VIPEvacuationNodesData) return false;
	if (m_CollisionControllerAspectsData != p_Other.m_CollisionControllerAspectsData) return false;
	if (m_BodyContainersData != p_Other.m_BodyContainersData) return false;
	if (m_MathLerpsData_float32 != p_Other.m_MathLerpsData_float32) return false;
	if (m_MathLerpsData_SVector2 != p_Other.m_MathLerpsData_SVector2) return false;
	if (m_MathLerpsData_SVector3 != p_Other.m_MathLerpsData_SVector3) return false;
	if (m_MathLerpsData_SVector4 != p_Other.m_MathLerpsData_SVector4) return false;
	if (m_MathLerpsData_SColorRGB != p_Other.m_MathLerpsData_SColorRGB) return false;
	if (m_MathLerpsData_SColorRGBA != p_Other.m_MathLerpsData_SColorRGBA) return false;

	return true;
}

void SGameEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameEntitySaveData*>(p_Object);
	s_Object->~SGameEntitySaveData();
}

ZHMTypeInfo SKeywordSaveData::TypeInfo = ZHMTypeInfo("SKeywordSaveData", sizeof(SKeywordSaveData), alignof(SKeywordSaveData), SKeywordSaveData::WriteSimpleJson, SKeywordSaveData::FromSimpleJson, SKeywordSaveData::Serialize, SKeywordSaveData::Equals, SKeywordSaveData::Destroy);

void SKeywordSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_HolderSaveableId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_HolderSaveableId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_KeywordID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_KeywordID);

	p_Stream << "}";
}

void SKeywordSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SKeywordSaveData s_Object {};

	s_Object.m_HolderSaveableId = simdjson::from_json_uint32(p_Document["m_HolderSaveableId"]);

	s_Object.m_KeywordID = simdjson::from_json_int32(p_Document["m_KeywordID"]);

	*reinterpret_cast<SKeywordSaveData*>(p_Target) = s_Object;
}

void SKeywordSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);

}

bool SKeywordSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SKeywordSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SKeywordSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SKeywordSaveData::operator==(const SKeywordSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SKeywordSaveData>)
		return false;

	if (m_HolderSaveableId != p_Other.m_HolderSaveableId) return false;
	if (m_KeywordID != p_Other.m_KeywordID) return false;

	return true;
}

void SKeywordSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SKeywordSaveData*>(p_Object);
	s_Object->~SKeywordSaveData();
}

ZHMTypeInfo SGameKeywordManagerSaveData::TypeInfo = ZHMTypeInfo("SGameKeywordManagerSaveData", sizeof(SGameKeywordManagerSaveData), alignof(SGameKeywordManagerSaveData), SGameKeywordManagerSaveData::WriteSimpleJson, SGameKeywordManagerSaveData::FromSimpleJson, SGameKeywordManagerSaveData::Serialize, SGameKeywordManagerSaveData::Equals, SGameKeywordManagerSaveData::Destroy);

void SGameKeywordManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKeywordsData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeywordsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeywordsData[i];
		SKeywordSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aKeywordsData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aKeywordStringData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeywordStringData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeywordStringData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aKeywordStringData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameKeywordManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameKeywordManagerSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKeywordsData"];
	s_Object.m_aKeywordsData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SKeywordSaveData s_ArrayItem0;
		SKeywordSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aKeywordsData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKeywordStringData"];
	s_Object.m_aKeywordStringData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aKeywordStringData[s_Index0++] = std::string_view(s_Item0);
	}
	}

	*reinterpret_cast<SGameKeywordManagerSaveData*>(p_Target) = s_Object;
}

void SGameKeywordManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);

	TArray<SKeywordSaveData>::Serialize(&s_Object->m_aKeywordsData, p_Serializer, p_OwnOffset + offsetof(SGameKeywordManagerSaveData, m_aKeywordsData));
	TArray<ZString>::Serialize(&s_Object->m_aKeywordStringData, p_Serializer, p_OwnOffset + offsetof(SGameKeywordManagerSaveData, m_aKeywordStringData));
}

bool SGameKeywordManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameKeywordManagerSaveData::operator==(const SGameKeywordManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameKeywordManagerSaveData>)
		return false;

	if (m_aKeywordsData != p_Other.m_aKeywordsData) return false;
	if (m_aKeywordStringData != p_Other.m_aKeywordStringData) return false;

	return true;
}

void SGameKeywordManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameKeywordManagerSaveData*>(p_Object);
	s_Object->~SGameKeywordManagerSaveData();
}

ZHMTypeInfo SGameStatsWeapon::TypeInfo = ZHMTypeInfo("SGameStatsWeapon", sizeof(SGameStatsWeapon), alignof(SGameStatsWeapon), SGameStatsWeapon::WriteSimpleJson, SGameStatsWeapon::FromSimpleJson, SGameStatsWeapon::Serialize, SGameStatsWeapon::Equals, SGameStatsWeapon::Destroy);

void SGameStatsWeapon::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_WeaponRepositoryID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_WeaponRepositoryID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eItemWeapon") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eItemType", static_cast<int>(s_Object->m_eItemWeapon)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSpecialSituation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EWeaponSpecialSituation", static_cast<int>(s_Object->m_eSpecialSituation)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAmmoType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eAmmoType", static_cast<int>(s_Object->m_eAmmoType)));

	p_Stream << "}";
}

void SGameStatsWeapon::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameStatsWeapon s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_WeaponRepositoryID"], &s_Item);
		s_Object.m_WeaponRepositoryID = s_Item;
	}

	s_Object.m_eItemWeapon = static_cast<eItemType>(ZHMEnums::GetEnumValueByName("eItemType", std::string_view(p_Document["m_eItemWeapon"])));

	s_Object.m_eSpecialSituation = static_cast<EWeaponSpecialSituation>(ZHMEnums::GetEnumValueByName("EWeaponSpecialSituation", std::string_view(p_Document["m_eSpecialSituation"])));

	s_Object.m_eAmmoType = static_cast<eAmmoType>(ZHMEnums::GetEnumValueByName("eAmmoType", std::string_view(p_Document["m_eAmmoType"])));

	*reinterpret_cast<SGameStatsWeapon*>(p_Target) = s_Object;
}

void SGameStatsWeapon::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_WeaponRepositoryID, p_Serializer, p_OwnOffset + offsetof(SGameStatsWeapon, m_WeaponRepositoryID));
}

bool SGameStatsWeapon::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameStatsWeapon*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameStatsWeapon*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameStatsWeapon::operator==(const SGameStatsWeapon& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameStatsWeapon>)
		return false;

	if (m_WeaponRepositoryID != p_Other.m_WeaponRepositoryID) return false;
	if (m_eItemWeapon != p_Other.m_eItemWeapon) return false;
	if (m_eSpecialSituation != p_Other.m_eSpecialSituation) return false;
	if (m_eAmmoType != p_Other.m_eAmmoType) return false;

	return true;
}

void SGameStatsWeapon::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameStatsWeapon*>(p_Object);
	s_Object->~SGameStatsWeapon();
}

ZHMTypeInfo STimerEntityCommandSaveData::TypeInfo = ZHMTypeInfo("STimerEntityCommandSaveData", sizeof(STimerEntityCommandSaveData), alignof(STimerEntityCommandSaveData), STimerEntityCommandSaveData::WriteSimpleJson, STimerEntityCommandSaveData::FromSimpleJson, STimerEntityCommandSaveData::Serialize, STimerEntityCommandSaveData::Equals, STimerEntityCommandSaveData::Destroy);

void STimerEntityCommandSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ETimerEntityCommandType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInterval);

	p_Stream << "}";
}

void STimerEntityCommandSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerEntityCommandSaveData s_Object {};

	s_Object.m_eType = static_cast<ETimerEntityCommandType>(ZHMEnums::GetEnumValueByName("ETimerEntityCommandType", std::string_view(p_Document["m_eType"])));

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_fInterval = simdjson::from_json_float32(p_Document["m_fInterval"]);

	*reinterpret_cast<STimerEntityCommandSaveData*>(p_Target) = s_Object;
}

void STimerEntityCommandSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);

}

bool STimerEntityCommandSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntityCommandSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntityCommandSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntityCommandSaveData::operator==(const STimerEntityCommandSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntityCommandSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_fInterval != p_Other.m_fInterval) return false;

	return true;
}

void STimerEntityCommandSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerEntityCommandSaveData*>(p_Object);
	s_Object->~STimerEntityCommandSaveData();
}

ZHMTypeInfo STimerEntityStateSaveData::TypeInfo = ZHMTypeInfo("STimerEntityStateSaveData", sizeof(STimerEntityStateSaveData), alignof(STimerEntityStateSaveData), STimerEntityStateSaveData::WriteSimpleJson, STimerEntityStateSaveData::FromSimpleJson, STimerEntityStateSaveData::Serialize, STimerEntityStateSaveData::Equals, STimerEntityStateSaveData::Destroy);

void STimerEntityStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fNextEventTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fNextEventTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPending") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPending);

	p_Stream << "}";
}

void STimerEntityStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerEntityStateSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_fNextEventTime = simdjson::from_json_float32(p_Document["m_fNextEventTime"]);

	s_Object.m_bPending = simdjson::from_json_bool(p_Document["m_bPending"]);

	*reinterpret_cast<STimerEntityStateSaveData*>(p_Target) = s_Object;
}

void STimerEntityStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);

}

bool STimerEntityStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntityStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntityStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntityStateSaveData::operator==(const STimerEntityStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntityStateSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_fNextEventTime != p_Other.m_fNextEventTime) return false;
	if (m_bPending != p_Other.m_bPending) return false;

	return true;
}

void STimerEntityStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerEntityStateSaveData*>(p_Object);
	s_Object->~STimerEntityStateSaveData();
}

ZHMTypeInfo SGameTimersSaveData::TypeInfo = ZHMTypeInfo("SGameTimersSaveData", sizeof(SGameTimersSaveData), alignof(SGameTimersSaveData), SGameTimersSaveData::WriteSimpleJson, SGameTimersSaveData::FromSimpleJson, SGameTimersSaveData::Serialize, SGameTimersSaveData::Equals, SGameTimersSaveData::Destroy);

void SGameTimersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTimerEntityCommands") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTimerEntityCommands.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTimerEntityCommands[i];
		STimerEntityCommandSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTimerEntityCommands.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTimerEntityState") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTimerEntityState.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTimerEntityState[i];
		STimerEntityStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTimerEntityState.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPendingTimers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPendingTimers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPendingTimers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aPendingTimers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameTimersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameTimersSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTimerEntityCommands"];
	s_Object.m_aTimerEntityCommands.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STimerEntityCommandSaveData s_ArrayItem0;
		STimerEntityCommandSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTimerEntityCommands[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTimerEntityState"];
	s_Object.m_aTimerEntityState.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STimerEntityStateSaveData s_ArrayItem0;
		STimerEntityStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTimerEntityState[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPendingTimers"];
	s_Object.m_aPendingTimers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aPendingTimers[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SGameTimersSaveData*>(p_Target) = s_Object;
}

void SGameTimersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);

	TArray<STimerEntityCommandSaveData>::Serialize(&s_Object->m_aTimerEntityCommands, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aTimerEntityCommands));
	TArray<STimerEntityStateSaveData>::Serialize(&s_Object->m_aTimerEntityState, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aTimerEntityState));
	TArray<uint32>::Serialize(&s_Object->m_aPendingTimers, p_Serializer, p_OwnOffset + offsetof(SGameTimersSaveData, m_aPendingTimers));
}

bool SGameTimersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameTimersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameTimersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameTimersSaveData::operator==(const SGameTimersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameTimersSaveData>)
		return false;

	if (m_aTimerEntityCommands != p_Other.m_aTimerEntityCommands) return false;
	if (m_aTimerEntityState != p_Other.m_aTimerEntityState) return false;
	if (m_aPendingTimers != p_Other.m_aPendingTimers) return false;

	return true;
}

void SGameTimersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameTimersSaveData*>(p_Object);
	s_Object->~SGameTimersSaveData();
}

ZHMTypeInfo SGateSaveData::TypeInfo = ZHMTypeInfo("SGateSaveData", sizeof(SGateSaveData), alignof(SGateSaveData), SGateSaveData::WriteSimpleJson, SGateSaveData::FromSimpleJson, SGateSaveData::Serialize, SGateSaveData::Equals, SGateSaveData::Destroy);

void SGateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOpen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOpen);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpenFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpenFraction);

	p_Stream << "}";
}

void SGateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGateSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_bIsOpen = simdjson::from_json_bool(p_Document["m_bIsOpen"]);

	s_Object.m_fOpenFraction = simdjson::from_json_float32(p_Document["m_fOpenFraction"]);

	*reinterpret_cast<SGateSaveData*>(p_Target) = s_Object;
}

void SGateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);

}

bool SGateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGateSaveData::operator==(const SGateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGateSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsOpen != p_Other.m_bIsOpen) return false;
	if (m_fOpenFraction != p_Other.m_fOpenFraction) return false;

	return true;
}

void SGateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGateSaveData*>(p_Object);
	s_Object->~SGateSaveData();
}

ZHMTypeInfo SLightSaveData::TypeInfo = ZHMTypeInfo("SLightSaveData", sizeof(SLightSaveData), alignof(SLightSaveData), SLightSaveData::WriteSimpleJson, SLightSaveData::FromSimpleJson, SLightSaveData::Serialize, SLightSaveData::Equals, SLightSaveData::Destroy);

void SLightSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DiffuseColor") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_DiffuseColor, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDiffusePower") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDiffusePower);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAspectXByY_Actual") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAspectXByY_Actual);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);

	p_Stream << "}";
}

void SLightSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLightSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_DiffuseColor"], &s_Item);
		s_Object.m_DiffuseColor = s_Item;
	}

	s_Object.m_fDiffusePower = simdjson::from_json_float32(p_Document["m_fDiffusePower"]);

	s_Object.m_fAspectXByY_Actual = simdjson::from_json_float32(p_Document["m_fAspectXByY_Actual"]);

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	*reinterpret_cast<SLightSaveData*>(p_Target) = s_Object;
}

void SLightSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);

	SColorRGB::Serialize(&s_Object->m_DiffuseColor, p_Serializer, p_OwnOffset + offsetof(SLightSaveData, m_DiffuseColor));
}

bool SLightSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLightSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLightSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLightSaveData::operator==(const SLightSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLightSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_DiffuseColor != p_Other.m_DiffuseColor) return false;
	if (m_fDiffusePower != p_Other.m_fDiffusePower) return false;
	if (m_fAspectXByY_Actual != p_Other.m_fAspectXByY_Actual) return false;
	if (m_bVisible != p_Other.m_bVisible) return false;

	return true;
}

void SLightSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLightSaveData*>(p_Object);
	s_Object->~SLightSaveData();
}

ZHMTypeInfo SParticleEmitterSaveData::TypeInfo = ZHMTypeInfo("SParticleEmitterSaveData", sizeof(SParticleEmitterSaveData), alignof(SParticleEmitterSaveData), SParticleEmitterSaveData::WriteSimpleJson, SParticleEmitterSaveData::FromSimpleJson, SParticleEmitterSaveData::Serialize, SParticleEmitterSaveData::Equals, SParticleEmitterSaveData::Destroy);

void SParticleEmitterSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionTimeLeft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionTimeLeft);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionTimeFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionTimeFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEmissionCntLeft") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEmissionCntLeft);

	p_Stream << "}";
}

void SParticleEmitterSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SParticleEmitterSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_bIsActivated = simdjson::from_json_bool(p_Document["m_bIsActivated"]);

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	s_Object.m_fEmissionTimeLeft = simdjson::from_json_float32(p_Document["m_fEmissionTimeLeft"]);

	s_Object.m_fEmissionTimeFraction = simdjson::from_json_float32(p_Document["m_fEmissionTimeFraction"]);

	s_Object.m_fEmissionCntLeft = simdjson::from_json_float32(p_Document["m_fEmissionCntLeft"]);

	*reinterpret_cast<SParticleEmitterSaveData*>(p_Target) = s_Object;
}

void SParticleEmitterSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);

}

bool SParticleEmitterSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SParticleEmitterSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SParticleEmitterSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SParticleEmitterSaveData::operator==(const SParticleEmitterSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SParticleEmitterSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bIsActivated != p_Other.m_bIsActivated) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;
	if (m_fEmissionTimeLeft != p_Other.m_fEmissionTimeLeft) return false;
	if (m_fEmissionTimeFraction != p_Other.m_fEmissionTimeFraction) return false;
	if (m_fEmissionCntLeft != p_Other.m_fEmissionCntLeft) return false;

	return true;
}

void SParticleEmitterSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SParticleEmitterSaveData*>(p_Object);
	s_Object->~SParticleEmitterSaveData();
}

ZHMTypeInfo SPostfilterParametersSaveData::TypeInfo = ZHMTypeInfo("SPostfilterParametersSaveData", sizeof(SPostfilterParametersSaveData), alignof(SPostfilterParametersSaveData), SPostfilterParametersSaveData::WriteSimpleJson, SPostfilterParametersSaveData::FromSimpleJson, SPostfilterParametersSaveData::Serialize, SPostfilterParametersSaveData::Equals, SPostfilterParametersSaveData::Destroy);

void SPostfilterParametersSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDepthOfFieldEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDepthOfFieldEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDepthOfFieldBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDepthOfFieldBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRadialBlurEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRadialBlurEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadialBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadialBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRadialBlurCenter") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vRadialBlurCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRadialBlurStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRadialBlurStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpatialBlurEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpatialBlurEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurriness") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurriness);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSpatialBlurCenter") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vSpatialBlurCenter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fSpatialBlurFade") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpatialBlurFade);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDistortionWobbleEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDistortionWobbleEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistortionWobbleScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistortionWobbleScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDistortionWobbleWaveLength") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vDistortionWobbleWaveLength, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDistortionWobbleSpeed") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vDistortionWobbleSpeed, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDistortionWobbleUseRealTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDistortionWobbleUseRealTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHDRActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHDRActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHDREnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHDREnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationSpeed") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationSpeed, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationLuminanceMinMax") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationLuminanceMinMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vHDRAdaptationMiddleGrayMinMax") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_vHDRAdaptationMiddleGrayMinMax, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRWhitePoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRWhitePoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRBrightPassThreshold") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRBrightPassThreshold);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHDRBrightPassMaxPercentage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHDRBrightPassMaxPercentage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HDRColorTint") << ":";
	SColorRGB::WriteSimpleJson(&s_Object->m_HDRColorTint, p_Stream);

	p_Stream << "}";
}

void SPostfilterParametersSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPostfilterParametersSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	s_Object.m_bDepthOfFieldEnabled = simdjson::from_json_bool(p_Document["m_bDepthOfFieldEnabled"]);

	s_Object.m_fDepthOfFieldBlurriness = simdjson::from_json_float32(p_Document["m_fDepthOfFieldBlurriness"]);

	s_Object.m_bRadialBlurEnabled = simdjson::from_json_bool(p_Document["m_bRadialBlurEnabled"]);

	s_Object.m_fRadialBlurriness = simdjson::from_json_float32(p_Document["m_fRadialBlurriness"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vRadialBlurCenter"], &s_Item);
		s_Object.m_vRadialBlurCenter = s_Item;
	}

	s_Object.m_fRadialBlurStart = simdjson::from_json_float32(p_Document["m_fRadialBlurStart"]);

	s_Object.m_bSpatialBlurEnabled = simdjson::from_json_bool(p_Document["m_bSpatialBlurEnabled"]);

	s_Object.m_fSpatialBlurriness = simdjson::from_json_float32(p_Document["m_fSpatialBlurriness"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vSpatialBlurCenter"], &s_Item);
		s_Object.m_vSpatialBlurCenter = s_Item;
	}

	s_Object.m_fSpatialBlurStart = simdjson::from_json_float32(p_Document["m_fSpatialBlurStart"]);

	s_Object.m_fSpatialBlurFade = simdjson::from_json_float32(p_Document["m_fSpatialBlurFade"]);

	s_Object.m_bDistortionWobbleEnabled = simdjson::from_json_bool(p_Document["m_bDistortionWobbleEnabled"]);

	s_Object.m_fDistortionWobbleScale = simdjson::from_json_float32(p_Document["m_fDistortionWobbleScale"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vDistortionWobbleWaveLength"], &s_Item);
		s_Object.m_vDistortionWobbleWaveLength = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vDistortionWobbleSpeed"], &s_Item);
		s_Object.m_vDistortionWobbleSpeed = s_Item;
	}

	s_Object.m_bDistortionWobbleUseRealTime = simdjson::from_json_bool(p_Document["m_bDistortionWobbleUseRealTime"]);

	s_Object.m_bHDRActive = simdjson::from_json_bool(p_Document["m_bHDRActive"]);

	s_Object.m_bHDREnabled = simdjson::from_json_bool(p_Document["m_bHDREnabled"]);

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationSpeed"], &s_Item);
		s_Object.m_vHDRAdaptationSpeed = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationLuminanceMinMax"], &s_Item);
		s_Object.m_vHDRAdaptationLuminanceMinMax = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_vHDRAdaptationMiddleGrayMinMax"], &s_Item);
		s_Object.m_vHDRAdaptationMiddleGrayMinMax = s_Item;
	}

	s_Object.m_fHDRWhitePoint = simdjson::from_json_float32(p_Document["m_fHDRWhitePoint"]);

	s_Object.m_fHDRBrightPassThreshold = simdjson::from_json_float32(p_Document["m_fHDRBrightPassThreshold"]);

	s_Object.m_fHDRBrightPassMaxPercentage = simdjson::from_json_float32(p_Document["m_fHDRBrightPassMaxPercentage"]);

	{
		SColorRGB s_Item {};
		SColorRGB::FromSimpleJson(p_Document["m_HDRColorTint"], &s_Item);
		s_Object.m_HDRColorTint = s_Item;
	}

	*reinterpret_cast<SPostfilterParametersSaveData*>(p_Target) = s_Object;
}

void SPostfilterParametersSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);

	SVector2::Serialize(&s_Object->m_vRadialBlurCenter, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vRadialBlurCenter));
	SVector3::Serialize(&s_Object->m_vSpatialBlurCenter, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vSpatialBlurCenter));
	SVector2::Serialize(&s_Object->m_vDistortionWobbleWaveLength, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vDistortionWobbleWaveLength));
	SVector2::Serialize(&s_Object->m_vDistortionWobbleSpeed, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vDistortionWobbleSpeed));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationSpeed, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationSpeed));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationLuminanceMinMax, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationLuminanceMinMax));
	SVector2::Serialize(&s_Object->m_vHDRAdaptationMiddleGrayMinMax, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_vHDRAdaptationMiddleGrayMinMax));
	SColorRGB::Serialize(&s_Object->m_HDRColorTint, p_Serializer, p_OwnOffset + offsetof(SPostfilterParametersSaveData, m_HDRColorTint));
}

bool SPostfilterParametersSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPostfilterParametersSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPostfilterParametersSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPostfilterParametersSaveData::operator==(const SPostfilterParametersSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPostfilterParametersSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_bDepthOfFieldEnabled != p_Other.m_bDepthOfFieldEnabled) return false;
	if (m_fDepthOfFieldBlurriness != p_Other.m_fDepthOfFieldBlurriness) return false;
	if (m_bRadialBlurEnabled != p_Other.m_bRadialBlurEnabled) return false;
	if (m_fRadialBlurriness != p_Other.m_fRadialBlurriness) return false;
	if (m_vRadialBlurCenter != p_Other.m_vRadialBlurCenter) return false;
	if (m_fRadialBlurStart != p_Other.m_fRadialBlurStart) return false;
	if (m_bSpatialBlurEnabled != p_Other.m_bSpatialBlurEnabled) return false;
	if (m_fSpatialBlurriness != p_Other.m_fSpatialBlurriness) return false;
	if (m_vSpatialBlurCenter != p_Other.m_vSpatialBlurCenter) return false;
	if (m_fSpatialBlurStart != p_Other.m_fSpatialBlurStart) return false;
	if (m_fSpatialBlurFade != p_Other.m_fSpatialBlurFade) return false;
	if (m_bDistortionWobbleEnabled != p_Other.m_bDistortionWobbleEnabled) return false;
	if (m_fDistortionWobbleScale != p_Other.m_fDistortionWobbleScale) return false;
	if (m_vDistortionWobbleWaveLength != p_Other.m_vDistortionWobbleWaveLength) return false;
	if (m_vDistortionWobbleSpeed != p_Other.m_vDistortionWobbleSpeed) return false;
	if (m_bDistortionWobbleUseRealTime != p_Other.m_bDistortionWobbleUseRealTime) return false;
	if (m_bHDRActive != p_Other.m_bHDRActive) return false;
	if (m_bHDREnabled != p_Other.m_bHDREnabled) return false;
	if (m_vHDRAdaptationSpeed != p_Other.m_vHDRAdaptationSpeed) return false;
	if (m_vHDRAdaptationLuminanceMinMax != p_Other.m_vHDRAdaptationLuminanceMinMax) return false;
	if (m_vHDRAdaptationMiddleGrayMinMax != p_Other.m_vHDRAdaptationMiddleGrayMinMax) return false;
	if (m_fHDRWhitePoint != p_Other.m_fHDRWhitePoint) return false;
	if (m_fHDRBrightPassThreshold != p_Other.m_fHDRBrightPassThreshold) return false;
	if (m_fHDRBrightPassMaxPercentage != p_Other.m_fHDRBrightPassMaxPercentage) return false;
	if (m_HDRColorTint != p_Other.m_HDRColorTint) return false;

	return true;
}

void SPostfilterParametersSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPostfilterParametersSaveData*>(p_Object);
	s_Object->~SPostfilterParametersSaveData();
}

ZHMTypeInfo SRenderMaterialSaveData::TypeInfo = ZHMTypeInfo("SRenderMaterialSaveData", sizeof(SRenderMaterialSaveData), alignof(SRenderMaterialSaveData), SRenderMaterialSaveData::WriteSimpleJson, SRenderMaterialSaveData::FromSimpleJson, SRenderMaterialSaveData::Serialize, SRenderMaterialSaveData::Equals, SRenderMaterialSaveData::Destroy);

void SRenderMaterialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDynamicParametersData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDynamicParametersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDynamicParametersData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDynamicParametersData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);

	p_Stream << "}";
}

void SRenderMaterialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRenderMaterialSaveData s_Object {};

	s_Object.m_rEntity = simdjson::from_json_uint32(p_Document["m_rEntity"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDynamicParametersData"];
	s_Object.m_aDynamicParametersData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aDynamicParametersData[s_Index0++] = simdjson::from_json_uint8(s_Item0);
	}
	}

	s_Object.m_bActive = simdjson::from_json_bool(p_Document["m_bActive"]);

	*reinterpret_cast<SRenderMaterialSaveData*>(p_Target) = s_Object;
}

void SRenderMaterialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aDynamicParametersData, p_Serializer, p_OwnOffset + offsetof(SRenderMaterialSaveData, m_aDynamicParametersData));
}

bool SRenderMaterialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRenderMaterialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRenderMaterialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRenderMaterialSaveData::operator==(const SRenderMaterialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRenderMaterialSaveData>)
		return false;

	if (m_rEntity != p_Other.m_rEntity) return false;
	if (m_aDynamicParametersData != p_Other.m_aDynamicParametersData) return false;
	if (m_bActive != p_Other.m_bActive) return false;

	return true;
}

void SRenderMaterialSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRenderMaterialSaveData*>(p_Object);
	s_Object->~SRenderMaterialSaveData();
}

ZHMTypeInfo SGameplayRenderablesSaveData::TypeInfo = ZHMTypeInfo("SGameplayRenderablesSaveData", sizeof(SGameplayRenderablesSaveData), alignof(SGameplayRenderablesSaveData), SGameplayRenderablesSaveData::WriteSimpleJson, SGameplayRenderablesSaveData::FromSimpleJson, SGameplayRenderablesSaveData::Serialize, SGameplayRenderablesSaveData::Equals, SGameplayRenderablesSaveData::Destroy);

void SGameplayRenderablesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aLightData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aLightData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aLightData[i];
		SLightSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aLightData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMaterialData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMaterialData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMaterialData[i];
		SRenderMaterialSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aMaterialData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aParticleData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aParticleData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aParticleData[i];
		SParticleEmitterSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aParticleData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aBoneAttachData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBoneAttachData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBoneAttachData[i];
		SBoneAttachSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aBoneAttachData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPostFilterParametersData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPostFilterParametersData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPostFilterParametersData[i];
		SPostfilterParametersSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPostFilterParametersData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGateData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGateData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGateData[i];
		SGateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGateData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGameplayRenderablesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGameplayRenderablesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aLightData"];
	s_Object.m_aLightData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLightSaveData s_ArrayItem0;
		SLightSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aLightData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aMaterialData"];
	s_Object.m_aMaterialData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SRenderMaterialSaveData s_ArrayItem0;
		SRenderMaterialSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aMaterialData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aParticleData"];
	s_Object.m_aParticleData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SParticleEmitterSaveData s_ArrayItem0;
		SParticleEmitterSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aParticleData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBoneAttachData"];
	s_Object.m_aBoneAttachData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SBoneAttachSaveData s_ArrayItem0;
		SBoneAttachSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aBoneAttachData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPostFilterParametersData"];
	s_Object.m_aPostFilterParametersData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SPostfilterParametersSaveData s_ArrayItem0;
		SPostfilterParametersSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aPostFilterParametersData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGateData"];
	s_Object.m_aGateData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SGateSaveData s_ArrayItem0;
		SGateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGateData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SGameplayRenderablesSaveData*>(p_Target) = s_Object;
}

void SGameplayRenderablesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);

	TArray<SLightSaveData>::Serialize(&s_Object->m_aLightData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aLightData));
	TArray<SRenderMaterialSaveData>::Serialize(&s_Object->m_aMaterialData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aMaterialData));
	TArray<SParticleEmitterSaveData>::Serialize(&s_Object->m_aParticleData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aParticleData));
	TArray<SBoneAttachSaveData>::Serialize(&s_Object->m_aBoneAttachData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aBoneAttachData));
	TArray<SPostfilterParametersSaveData>::Serialize(&s_Object->m_aPostFilterParametersData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aPostFilterParametersData));
	TArray<SGateSaveData>::Serialize(&s_Object->m_aGateData, p_Serializer, p_OwnOffset + offsetof(SGameplayRenderablesSaveData, m_aGateData));
}

bool SGameplayRenderablesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGameplayRenderablesSaveData::operator==(const SGameplayRenderablesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGameplayRenderablesSaveData>)
		return false;

	if (m_aLightData != p_Other.m_aLightData) return false;
	if (m_aMaterialData != p_Other.m_aMaterialData) return false;
	if (m_aParticleData != p_Other.m_aParticleData) return false;
	if (m_aBoneAttachData != p_Other.m_aBoneAttachData) return false;
	if (m_aPostFilterParametersData != p_Other.m_aPostFilterParametersData) return false;
	if (m_aGateData != p_Other.m_aGateData) return false;

	return true;
}

void SGameplayRenderablesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGameplayRenderablesSaveData*>(p_Object);
	s_Object->~SGameplayRenderablesSaveData();
}

ZHMTypeInfo SGeomScaleSaveData::TypeInfo = ZHMTypeInfo("SGeomScaleSaveData", sizeof(SGeomScaleSaveData), alignof(SGeomScaleSaveData), SGeomScaleSaveData::WriteSimpleJson, SGeomScaleSaveData::FromSimpleJson, SGeomScaleSaveData::Serialize, SGeomScaleSaveData::Equals, SGeomScaleSaveData::Destroy);

void SGeomScaleSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGeomScaleSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPrimitiveScale") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vPrimitiveScale, p_Stream);

	p_Stream << "}";
}

void SGeomScaleSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGeomScaleSaveData s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vPrimitiveScale"], &s_Item);
		s_Object.m_vPrimitiveScale = s_Item;
	}

	*reinterpret_cast<SGeomScaleSaveData*>(p_Target) = s_Object;
}

void SGeomScaleSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGeomScaleSaveData*>(p_Object);

	SVector4::Serialize(&s_Object->m_vPrimitiveScale, p_Serializer, p_OwnOffset + offsetof(SGeomScaleSaveData, m_vPrimitiveScale));
}

bool SGeomScaleSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGeomScaleSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGeomScaleSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGeomScaleSaveData::operator==(const SGeomScaleSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGeomScaleSaveData>)
		return false;

	if (m_vPrimitiveScale != p_Other.m_vPrimitiveScale) return false;

	return true;
}

void SGeomScaleSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGeomScaleSaveData*>(p_Object);
	s_Object->~SGeomScaleSaveData();
}

ZHMTypeInfo SGetHelpGroupSaveData::TypeInfo = ZHMTypeInfo("SGetHelpGroupSaveData", sizeof(SGetHelpGroupSaveData), alignof(SGetHelpGroupSaveData), SGetHelpGroupSaveData::WriteSimpleJson, SGetHelpGroupSaveData::FromSimpleJson, SGetHelpGroupSaveData::Serialize, SGetHelpGroupSaveData::Equals, SGetHelpGroupSaveData::Destroy);

void SGetHelpGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vLastKnownTargetPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vLastKnownTargetPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rReturnNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rReturnNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_blocked") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_blocked.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_blocked[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_blocked.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReportingToHitman") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReportingToHitman);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStartedReportDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStartedReportDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMultipleBodies") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMultipleBodies);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGetHelpOrderCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGetHelpOrderCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDoneReporting") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDoneReporting);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tGetHelpCompleted") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGetHelpCompleted, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_type") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_type)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pReporter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pReporter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IllegalItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IllegalItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_additionalGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_additionalGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_additionalGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_additionalGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGetHelpGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGetHelpGroupSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vLastKnownTargetPosition"], &s_Item);
		s_Object.m_vLastKnownTargetPosition = s_Item;
	}

	s_Object.m_rReturnNode = simdjson::from_json_uint16(p_Document["m_rReturnNode"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_blocked"];
	s_Object.m_blocked.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_blocked[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	s_Object.m_bReportingToHitman = simdjson::from_json_bool(p_Document["m_bReportingToHitman"]);

	s_Object.m_bStartedReportDialog = simdjson::from_json_bool(p_Document["m_bStartedReportDialog"]);

	s_Object.m_bMultipleBodies = simdjson::from_json_bool(p_Document["m_bMultipleBodies"]);

	s_Object.m_bGetHelpOrderCompleted = simdjson::from_json_bool(p_Document["m_bGetHelpOrderCompleted"]);

	s_Object.m_bDoneReporting = simdjson::from_json_bool(p_Document["m_bDoneReporting"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tGetHelpCompleted"], &s_Item);
		s_Object.m_tGetHelpCompleted = s_Item;
	}

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_type = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_type"])));

	s_Object.m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	s_Object.m_pReporter = simdjson::from_json_uint32(p_Document["m_pReporter"]);

	s_Object.m_pGuard = simdjson::from_json_uint32(p_Document["m_pGuard"]);

	s_Object.m_IllegalItem = simdjson::from_json_uint32(p_Document["m_IllegalItem"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_additionalGuards"];
	s_Object.m_additionalGuards.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_additionalGuards[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SGetHelpGroupSaveData*>(p_Target) = s_Object;
}

void SGetHelpGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vLastKnownTargetPosition, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_vLastKnownTargetPosition));
	TArray<uint16>::Serialize(&s_Object->m_blocked, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_blocked));
	ZGameTime::Serialize(&s_Object->m_tGetHelpCompleted, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_tGetHelpCompleted));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_fsmState));
	TArray<uint32>::Serialize(&s_Object->m_additionalGuards, p_Serializer, p_OwnOffset + offsetof(SGetHelpGroupSaveData, m_additionalGuards));
}

bool SGetHelpGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpGroupSaveData::operator==(const SGetHelpGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpGroupSaveData>)
		return false;

	if (m_vLastKnownTargetPosition != p_Other.m_vLastKnownTargetPosition) return false;
	if (m_rReturnNode != p_Other.m_rReturnNode) return false;
	if (m_blocked != p_Other.m_blocked) return false;
	if (m_bReportingToHitman != p_Other.m_bReportingToHitman) return false;
	if (m_bStartedReportDialog != p_Other.m_bStartedReportDialog) return false;
	if (m_bMultipleBodies != p_Other.m_bMultipleBodies) return false;
	if (m_bGetHelpOrderCompleted != p_Other.m_bGetHelpOrderCompleted) return false;
	if (m_bDoneReporting != p_Other.m_bDoneReporting) return false;
	if (m_tGetHelpCompleted != p_Other.m_tGetHelpCompleted) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_type != p_Other.m_type) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pReporter != p_Other.m_pReporter) return false;
	if (m_pGuard != p_Other.m_pGuard) return false;
	if (m_IllegalItem != p_Other.m_IllegalItem) return false;
	if (m_additionalGuards != p_Other.m_additionalGuards) return false;

	return true;
}

void SGetHelpGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGetHelpGroupSaveData*>(p_Object);
	s_Object->~SGetHelpGroupSaveData();
}

ZHMTypeInfo SGetHelpOrderSaveData::TypeInfo = ZHMTypeInfo("SGetHelpOrderSaveData", sizeof(SGetHelpOrderSaveData), alignof(SGetHelpOrderSaveData), SGetHelpOrderSaveData::WriteSimpleJson, SGetHelpOrderSaveData::FromSimpleJson, SGetHelpOrderSaveData::Serialize, SGetHelpOrderSaveData::Equals, SGetHelpOrderSaveData::Destroy);

void SGetHelpOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_helpType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_helpType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInitialGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInitialGuard);

	p_Stream << "}";
}

void SGetHelpOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGetHelpOrderSaveData s_Object {};

	s_Object.m_helpType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_helpType"])));

	s_Object.m_rInitialGuard = simdjson::from_json_uint32(p_Document["m_rInitialGuard"]);

	*reinterpret_cast<SGetHelpOrderSaveData*>(p_Target) = s_Object;
}

void SGetHelpOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);

}

bool SGetHelpOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpOrderSaveData::operator==(const SGetHelpOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpOrderSaveData>)
		return false;

	if (m_helpType != p_Other.m_helpType) return false;
	if (m_rInitialGuard != p_Other.m_rInitialGuard) return false;

	return true;
}

void SGetHelpOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGetHelpOrderSaveData*>(p_Object);
	s_Object->~SGetHelpOrderSaveData();
}

ZHMTypeInfo SHelpingActorSaveData::TypeInfo = ZHMTypeInfo("SHelpingActorSaveData", sizeof(SHelpingActorSaveData), alignof(SHelpingActorSaveData), SHelpingActorSaveData::WriteSimpleJson, SHelpingActorSaveData::FromSimpleJson, SHelpingActorSaveData::Serialize, SHelpingActorSaveData::Equals, SHelpingActorSaveData::Destroy);

void SHelpingActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_HelpTargetKnowledgeIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_HelpTargetKnowledgeIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SHelpingActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHelpingActorSaveData s_Object {};

	s_Object.m_HelpTargetKnowledgeIndex = simdjson::from_json_int32(p_Document["m_HelpTargetKnowledgeIndex"]);

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SHelpingActorSaveData*>(p_Target) = s_Object;
}

void SHelpingActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);

}

bool SHelpingActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHelpingActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHelpingActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHelpingActorSaveData::operator==(const SHelpingActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHelpingActorSaveData>)
		return false;

	if (m_HelpTargetKnowledgeIndex != p_Other.m_HelpTargetKnowledgeIndex) return false;
	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SHelpingActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHelpingActorSaveData*>(p_Object);
	s_Object->~SHelpingActorSaveData();
}

ZHMTypeInfo SGetHelpServiceSaveData::TypeInfo = ZHMTypeInfo("SGetHelpServiceSaveData", sizeof(SGetHelpServiceSaveData), alignof(SGetHelpServiceSaveData), SGetHelpServiceSaveData::WriteSimpleJson, SGetHelpServiceSaveData::FromSimpleJson, SGetHelpServiceSaveData::Serialize, SGetHelpServiceSaveData::Equals, SGetHelpServiceSaveData::Destroy);

void SGetHelpServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aHelpingActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aHelpingActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aHelpingActors[i];
		SHelpingActorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aHelpingActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SGetHelpServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGetHelpServiceSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aHelpingActors"];
	s_Object.m_aHelpingActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHelpingActorSaveData s_ArrayItem0;
		SHelpingActorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aHelpingActors[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SGetHelpServiceSaveData*>(p_Target) = s_Object;
}

void SGetHelpServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);

	TArray<SHelpingActorSaveData>::Serialize(&s_Object->m_aHelpingActors, p_Serializer, p_OwnOffset + offsetof(SGetHelpServiceSaveData, m_aHelpingActors));
}

bool SGetHelpServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetHelpServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetHelpServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetHelpServiceSaveData::operator==(const SGetHelpServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetHelpServiceSaveData>)
		return false;

	if (m_aHelpingActors != p_Other.m_aHelpingActors) return false;

	return true;
}

void SGetHelpServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGetHelpServiceSaveData*>(p_Object);
	s_Object->~SGetHelpServiceSaveData();
}

ZHMTypeInfo SGetIActorPositionSaveData::TypeInfo = ZHMTypeInfo("SGetIActorPositionSaveData", sizeof(SGetIActorPositionSaveData), alignof(SGetIActorPositionSaveData), SGetIActorPositionSaveData::WriteSimpleJson, SGetIActorPositionSaveData::FromSimpleJson, SGetIActorPositionSaveData::Serialize, SGetIActorPositionSaveData::Equals, SGetIActorPositionSaveData::Destroy);

void SGetIActorPositionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGetIActorPositionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_StoredActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_StoredActor);

	p_Stream << "}";
}

void SGetIActorPositionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGetIActorPositionSaveData s_Object {};

	s_Object.m_StoredActor = simdjson::from_json_uint32(p_Document["m_StoredActor"]);

	*reinterpret_cast<SGetIActorPositionSaveData*>(p_Target) = s_Object;
}

void SGetIActorPositionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGetIActorPositionSaveData*>(p_Object);

}

bool SGetIActorPositionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGetIActorPositionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGetIActorPositionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGetIActorPositionSaveData::operator==(const SGetIActorPositionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGetIActorPositionSaveData>)
		return false;

	if (m_StoredActor != p_Other.m_StoredActor) return false;

	return true;
}

void SGetIActorPositionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGetIActorPositionSaveData*>(p_Object);
	s_Object->~SGetIActorPositionSaveData();
}

ZHMTypeInfo SGuardBodySituationMemberSaveData::TypeInfo = ZHMTypeInfo("SGuardBodySituationMemberSaveData", sizeof(SGuardBodySituationMemberSaveData), alignof(SGuardBodySituationMemberSaveData), SGuardBodySituationMemberSaveData::WriteSimpleJson, SGuardBodySituationMemberSaveData::FromSimpleJson, SGuardBodySituationMemberSaveData::Serialize, SGuardBodySituationMemberSaveData::Equals, SGuardBodySituationMemberSaveData::Destroy);

void SGuardBodySituationMemberSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSearchingForMorgue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchingForMorgue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IsExitingSuccessfulBehavior") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IsExitingSuccessfulBehavior);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rBodybag") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rBodybag);

	p_Stream << "}";
}

void SGuardBodySituationMemberSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGuardBodySituationMemberSaveData s_Object {};

	s_Object.m_bSearchingForMorgue = simdjson::from_json_bool(p_Document["m_bSearchingForMorgue"]);

	s_Object.m_IsExitingSuccessfulBehavior = simdjson::from_json_bool(p_Document["m_IsExitingSuccessfulBehavior"]);

	s_Object.m_rDeadBody = simdjson::from_json_uint32(p_Document["m_rDeadBody"]);

	s_Object.m_rBodybag = simdjson::from_json_uint32(p_Document["m_rBodybag"]);

	*reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Target) = s_Object;
}

void SGuardBodySituationMemberSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);

}

bool SGuardBodySituationMemberSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardBodySituationMemberSaveData::operator==(const SGuardBodySituationMemberSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardBodySituationMemberSaveData>)
		return false;

	if (m_bSearchingForMorgue != p_Other.m_bSearchingForMorgue) return false;
	if (m_IsExitingSuccessfulBehavior != p_Other.m_IsExitingSuccessfulBehavior) return false;
	if (m_rDeadBody != p_Other.m_rDeadBody) return false;
	if (m_rBodybag != p_Other.m_rBodybag) return false;

	return true;
}

void SGuardBodySituationMemberSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationMemberSaveData*>(p_Object);
	s_Object->~SGuardBodySituationMemberSaveData();
}

ZHMTypeInfo SGuardBodySituationSaveData::TypeInfo = ZHMTypeInfo("SGuardBodySituationSaveData", sizeof(SGuardBodySituationSaveData), alignof(SGuardBodySituationSaveData), SGuardBodySituationSaveData::WriteSimpleJson, SGuardBodySituationSaveData::FromSimpleJson, SGuardBodySituationSaveData::Serialize, SGuardBodySituationSaveData::Equals, SGuardBodySituationSaveData::Destroy);

void SGuardBodySituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bBystanderFieldsFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBystanderFieldsFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLastGetHelpGroupFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLastGetHelpGroupFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneCanSeeBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneCanSeeBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSomeoneHandledBodybag") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSomeoneHandledBodybag);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);

	p_Stream << "}";
}

void SGuardBodySituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGuardBodySituationSaveData s_Object {};

	s_Object.m_bBystanderFieldsFailed = simdjson::from_json_bool(p_Document["m_bBystanderFieldsFailed"]);

	s_Object.m_bLastGetHelpGroupFailed = simdjson::from_json_bool(p_Document["m_bLastGetHelpGroupFailed"]);

	s_Object.m_bSomeoneCanSeeBody = simdjson::from_json_bool(p_Document["m_bSomeoneCanSeeBody"]);

	s_Object.m_bSomeoneHandledBodybag = simdjson::from_json_bool(p_Document["m_bSomeoneHandledBodybag"]);

	s_Object.m_pGetHelpGroup = simdjson::from_json_int32(p_Document["m_pGetHelpGroup"]);

	*reinterpret_cast<SGuardBodySituationSaveData*>(p_Target) = s_Object;
}

void SGuardBodySituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);

}

bool SGuardBodySituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardBodySituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardBodySituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardBodySituationSaveData::operator==(const SGuardBodySituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardBodySituationSaveData>)
		return false;

	if (m_bBystanderFieldsFailed != p_Other.m_bBystanderFieldsFailed) return false;
	if (m_bLastGetHelpGroupFailed != p_Other.m_bLastGetHelpGroupFailed) return false;
	if (m_bSomeoneCanSeeBody != p_Other.m_bSomeoneCanSeeBody) return false;
	if (m_bSomeoneHandledBodybag != p_Other.m_bSomeoneHandledBodybag) return false;
	if (m_pGetHelpGroup != p_Other.m_pGetHelpGroup) return false;

	return true;
}

void SGuardBodySituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGuardBodySituationSaveData*>(p_Object);
	s_Object->~SGuardBodySituationSaveData();
}

ZHMTypeInfo SGuardPointOrderSaveData::TypeInfo = ZHMTypeInfo("SGuardPointOrderSaveData", sizeof(SGuardPointOrderSaveData), alignof(SGuardPointOrderSaveData), SGuardPointOrderSaveData::WriteSimpleJson, SGuardPointOrderSaveData::FromSimpleJson, SGuardPointOrderSaveData::Serialize, SGuardPointOrderSaveData::Equals, SGuardPointOrderSaveData::Destroy);

void SGuardPointOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_guardPoint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_guardPoint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_walkOnly") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_walkOnly);

	p_Stream << "}";
}

void SGuardPointOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SGuardPointOrderSaveData s_Object {};

	s_Object.m_guardPoint = simdjson::from_json_uint32(p_Document["m_guardPoint"]);

	s_Object.m_walkOnly = simdjson::from_json_bool(p_Document["m_walkOnly"]);

	*reinterpret_cast<SGuardPointOrderSaveData*>(p_Target) = s_Object;
}

void SGuardPointOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);

}

bool SGuardPointOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SGuardPointOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SGuardPointOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SGuardPointOrderSaveData::operator==(const SGuardPointOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SGuardPointOrderSaveData>)
		return false;

	if (m_guardPoint != p_Other.m_guardPoint) return false;
	if (m_walkOnly != p_Other.m_walkOnly) return false;

	return true;
}

void SGuardPointOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SGuardPointOrderSaveData*>(p_Object);
	s_Object->~SGuardPointOrderSaveData();
}

ZHMTypeInfo SHM5CrippleBoxSaveData::TypeInfo = ZHMTypeInfo("SHM5CrippleBoxSaveData", sizeof(SHM5CrippleBoxSaveData), alignof(SHM5CrippleBoxSaveData), SHM5CrippleBoxSaveData::WriteSimpleJson, SHM5CrippleBoxSaveData::FromSimpleJson, SHM5CrippleBoxSaveData::Serialize, SHM5CrippleBoxSaveData::Equals, SHM5CrippleBoxSaveData::Destroy);

void SHM5CrippleBoxSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bInSequence") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInSequence);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllowBaseMovements") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllowBaseMovements);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSequenceAllowCamera") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSequenceAllowCamera);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLedges") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLedges);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCover") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCover);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTakeClothes") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTakeClothes);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLadder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLadder);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPullVictimFromWindow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPullVictimFromWindow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFiberWireKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFiberWireKill);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bClimbWindow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bClimbWindow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bThrowBodyOverRail") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bThrowBodyOverRail);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDumpBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDumpBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOperateCPDoor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOperateCPDoor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHideInCloset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHideInCloset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombat") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombat);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGrabVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGrabVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPushVictimThroughWindowAndRail") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPushVictimThroughWindowAndRail);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKickVictimOverLedge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKickVictimOverLedge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPickupItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPickupItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDragBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDragBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bThrowItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bThrowItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPlaceItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlaceItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseDeathAnimation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseDeathAnimation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLimitedAmmo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLimitedAmmo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTurn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTurn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSneak") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSneak);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoSnapSneak") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoSnapSneak);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandUp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandUp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFastWalk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFastWalk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMovementAllowed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMovementAllowed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIdleAnimationsAllowed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIdleAnimationsAllowed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanHolsterItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanHolsterItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverTakedown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverTakedown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCoverToCover") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCoverToCover);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatSnapNeck") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatSnapNeck);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatChoke") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatChoke);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatPistolFinish") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatPistolFinish);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatProps") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatProps);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatStandart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatStandart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCloseCombatFakeSwing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCloseCombatFakeSwing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGameCameraAutoAlign") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGameCameraAutoAlign);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCameraSide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCameraSide);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInstinct") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInstinct);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBlindFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBlindFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHairTrigger") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHairTrigger);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFire") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFire);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOpenLogbook") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOpenLogbook);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOpenPauseMenu") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOpenPauseMenu);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivatedByPinSignal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivatedByPinSignal);

	p_Stream << "}";
}

void SHM5CrippleBoxSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHM5CrippleBoxSaveData s_Object {};

	s_Object.m_bInSequence = simdjson::from_json_bool(p_Document["m_bInSequence"]);

	s_Object.m_bAllowBaseMovements = simdjson::from_json_bool(p_Document["m_bAllowBaseMovements"]);

	s_Object.m_bSequenceAllowCamera = simdjson::from_json_bool(p_Document["m_bSequenceAllowCamera"]);

	s_Object.m_bLedges = simdjson::from_json_bool(p_Document["m_bLedges"]);

	s_Object.m_bCover = simdjson::from_json_bool(p_Document["m_bCover"]);

	s_Object.m_bTakeClothes = simdjson::from_json_bool(p_Document["m_bTakeClothes"]);

	s_Object.m_bLadder = simdjson::from_json_bool(p_Document["m_bLadder"]);

	s_Object.m_bPullVictimFromWindow = simdjson::from_json_bool(p_Document["m_bPullVictimFromWindow"]);

	s_Object.m_bFiberWireKill = simdjson::from_json_bool(p_Document["m_bFiberWireKill"]);

	s_Object.m_bClimbWindow = simdjson::from_json_bool(p_Document["m_bClimbWindow"]);

	s_Object.m_bThrowBodyOverRail = simdjson::from_json_bool(p_Document["m_bThrowBodyOverRail"]);

	s_Object.m_bDumpBody = simdjson::from_json_bool(p_Document["m_bDumpBody"]);

	s_Object.m_bOperateCPDoor = simdjson::from_json_bool(p_Document["m_bOperateCPDoor"]);

	s_Object.m_bHideInCloset = simdjson::from_json_bool(p_Document["m_bHideInCloset"]);

	s_Object.m_bCloseCombat = simdjson::from_json_bool(p_Document["m_bCloseCombat"]);

	s_Object.m_bGrabVictim = simdjson::from_json_bool(p_Document["m_bGrabVictim"]);

	s_Object.m_bPushVictimThroughWindowAndRail = simdjson::from_json_bool(p_Document["m_bPushVictimThroughWindowAndRail"]);

	s_Object.m_bKickVictimOverLedge = simdjson::from_json_bool(p_Document["m_bKickVictimOverLedge"]);

	s_Object.m_bPickupItem = simdjson::from_json_bool(p_Document["m_bPickupItem"]);

	s_Object.m_bDropItem = simdjson::from_json_bool(p_Document["m_bDropItem"]);

	s_Object.m_bDragBody = simdjson::from_json_bool(p_Document["m_bDragBody"]);

	s_Object.m_bThrowItem = simdjson::from_json_bool(p_Document["m_bThrowItem"]);

	s_Object.m_bPlaceItem = simdjson::from_json_bool(p_Document["m_bPlaceItem"]);

	s_Object.m_bUseDeathAnimation = simdjson::from_json_bool(p_Document["m_bUseDeathAnimation"]);

	s_Object.m_bLimitedAmmo = simdjson::from_json_bool(p_Document["m_bLimitedAmmo"]);

	s_Object.m_bRun = simdjson::from_json_bool(p_Document["m_bRun"]);

	s_Object.m_bTurn = simdjson::from_json_bool(p_Document["m_bTurn"]);

	s_Object.m_bSneak = simdjson::from_json_bool(p_Document["m_bSneak"]);

	s_Object.m_bNoSnapSneak = simdjson::from_json_bool(p_Document["m_bNoSnapSneak"]);

	s_Object.m_bStandUp = simdjson::from_json_bool(p_Document["m_bStandUp"]);

	s_Object.m_bFastWalk = simdjson::from_json_bool(p_Document["m_bFastWalk"]);

	s_Object.m_bMovementAllowed = simdjson::from_json_bool(p_Document["m_bMovementAllowed"]);

	s_Object.m_bIdleAnimationsAllowed = simdjson::from_json_bool(p_Document["m_bIdleAnimationsAllowed"]);

	s_Object.m_bItems = simdjson::from_json_bool(p_Document["m_bItems"]);

	s_Object.m_bCanHolsterItems = simdjson::from_json_bool(p_Document["m_bCanHolsterItems"]);

	s_Object.m_bCoverTakedown = simdjson::from_json_bool(p_Document["m_bCoverTakedown"]);

	s_Object.m_bCoverScale = simdjson::from_json_bool(p_Document["m_bCoverScale"]);

	s_Object.m_bCoverToCover = simdjson::from_json_bool(p_Document["m_bCoverToCover"]);

	s_Object.m_bCloseCombatSnapNeck = simdjson::from_json_bool(p_Document["m_bCloseCombatSnapNeck"]);

	s_Object.m_bCloseCombatChoke = simdjson::from_json_bool(p_Document["m_bCloseCombatChoke"]);

	s_Object.m_bCloseCombatPistolFinish = simdjson::from_json_bool(p_Document["m_bCloseCombatPistolFinish"]);

	s_Object.m_bCloseCombatProps = simdjson::from_json_bool(p_Document["m_bCloseCombatProps"]);

	s_Object.m_bCloseCombatStandart = simdjson::from_json_bool(p_Document["m_bCloseCombatStandart"]);

	s_Object.m_bCloseCombatFakeSwing = simdjson::from_json_bool(p_Document["m_bCloseCombatFakeSwing"]);

	s_Object.m_bGameCameraAutoAlign = simdjson::from_json_bool(p_Document["m_bGameCameraAutoAlign"]);

	s_Object.m_bCameraSide = simdjson::from_json_bool(p_Document["m_bCameraSide"]);

	s_Object.m_bInstinct = simdjson::from_json_bool(p_Document["m_bInstinct"]);

	s_Object.m_bBlindFire = simdjson::from_json_bool(p_Document["m_bBlindFire"]);

	s_Object.m_bAim = simdjson::from_json_bool(p_Document["m_bAim"]);

	s_Object.m_bHairTrigger = simdjson::from_json_bool(p_Document["m_bHairTrigger"]);

	s_Object.m_bFire = simdjson::from_json_bool(p_Document["m_bFire"]);

	s_Object.m_bOpenLogbook = simdjson::from_json_bool(p_Document["m_bOpenLogbook"]);

	s_Object.m_bOpenPauseMenu = simdjson::from_json_bool(p_Document["m_bOpenPauseMenu"]);

	s_Object.m_bActivatedByPinSignal = simdjson::from_json_bool(p_Document["m_bActivatedByPinSignal"]);

	*reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Target) = s_Object;
}

void SHM5CrippleBoxSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);

}

bool SHM5CrippleBoxSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHM5CrippleBoxSaveData::operator==(const SHM5CrippleBoxSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHM5CrippleBoxSaveData>)
		return false;

	if (m_bInSequence != p_Other.m_bInSequence) return false;
	if (m_bAllowBaseMovements != p_Other.m_bAllowBaseMovements) return false;
	if (m_bSequenceAllowCamera != p_Other.m_bSequenceAllowCamera) return false;
	if (m_bLedges != p_Other.m_bLedges) return false;
	if (m_bCover != p_Other.m_bCover) return false;
	if (m_bTakeClothes != p_Other.m_bTakeClothes) return false;
	if (m_bLadder != p_Other.m_bLadder) return false;
	if (m_bPullVictimFromWindow != p_Other.m_bPullVictimFromWindow) return false;
	if (m_bFiberWireKill != p_Other.m_bFiberWireKill) return false;
	if (m_bClimbWindow != p_Other.m_bClimbWindow) return false;
	if (m_bThrowBodyOverRail != p_Other.m_bThrowBodyOverRail) return false;
	if (m_bDumpBody != p_Other.m_bDumpBody) return false;
	if (m_bOperateCPDoor != p_Other.m_bOperateCPDoor) return false;
	if (m_bHideInCloset != p_Other.m_bHideInCloset) return false;
	if (m_bCloseCombat != p_Other.m_bCloseCombat) return false;
	if (m_bGrabVictim != p_Other.m_bGrabVictim) return false;
	if (m_bPushVictimThroughWindowAndRail != p_Other.m_bPushVictimThroughWindowAndRail) return false;
	if (m_bKickVictimOverLedge != p_Other.m_bKickVictimOverLedge) return false;
	if (m_bPickupItem != p_Other.m_bPickupItem) return false;
	if (m_bDropItem != p_Other.m_bDropItem) return false;
	if (m_bDragBody != p_Other.m_bDragBody) return false;
	if (m_bThrowItem != p_Other.m_bThrowItem) return false;
	if (m_bPlaceItem != p_Other.m_bPlaceItem) return false;
	if (m_bUseDeathAnimation != p_Other.m_bUseDeathAnimation) return false;
	if (m_bLimitedAmmo != p_Other.m_bLimitedAmmo) return false;
	if (m_bRun != p_Other.m_bRun) return false;
	if (m_bTurn != p_Other.m_bTurn) return false;
	if (m_bSneak != p_Other.m_bSneak) return false;
	if (m_bNoSnapSneak != p_Other.m_bNoSnapSneak) return false;
	if (m_bStandUp != p_Other.m_bStandUp) return false;
	if (m_bFastWalk != p_Other.m_bFastWalk) return false;
	if (m_bMovementAllowed != p_Other.m_bMovementAllowed) return false;
	if (m_bIdleAnimationsAllowed != p_Other.m_bIdleAnimationsAllowed) return false;
	if (m_bItems != p_Other.m_bItems) return false;
	if (m_bCanHolsterItems != p_Other.m_bCanHolsterItems) return false;
	if (m_bCoverTakedown != p_Other.m_bCoverTakedown) return false;
	if (m_bCoverScale != p_Other.m_bCoverScale) return false;
	if (m_bCoverToCover != p_Other.m_bCoverToCover) return false;
	if (m_bCloseCombatSnapNeck != p_Other.m_bCloseCombatSnapNeck) return false;
	if (m_bCloseCombatChoke != p_Other.m_bCloseCombatChoke) return false;
	if (m_bCloseCombatPistolFinish != p_Other.m_bCloseCombatPistolFinish) return false;
	if (m_bCloseCombatProps != p_Other.m_bCloseCombatProps) return false;
	if (m_bCloseCombatStandart != p_Other.m_bCloseCombatStandart) return false;
	if (m_bCloseCombatFakeSwing != p_Other.m_bCloseCombatFakeSwing) return false;
	if (m_bGameCameraAutoAlign != p_Other.m_bGameCameraAutoAlign) return false;
	if (m_bCameraSide != p_Other.m_bCameraSide) return false;
	if (m_bInstinct != p_Other.m_bInstinct) return false;
	if (m_bBlindFire != p_Other.m_bBlindFire) return false;
	if (m_bAim != p_Other.m_bAim) return false;
	if (m_bHairTrigger != p_Other.m_bHairTrigger) return false;
	if (m_bFire != p_Other.m_bFire) return false;
	if (m_bOpenLogbook != p_Other.m_bOpenLogbook) return false;
	if (m_bOpenPauseMenu != p_Other.m_bOpenPauseMenu) return false;
	if (m_bActivatedByPinSignal != p_Other.m_bActivatedByPinSignal) return false;

	return true;
}

void SHM5CrippleBoxSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHM5CrippleBoxSaveData*>(p_Object);
	s_Object->~SHM5CrippleBoxSaveData();
}

ZHMTypeInfo SHUDPIPControllerSaveData::TypeInfo = ZHMTypeInfo("SHUDPIPControllerSaveData", sizeof(SHUDPIPControllerSaveData), alignof(SHUDPIPControllerSaveData), SHUDPIPControllerSaveData::WriteSimpleJson, SHUDPIPControllerSaveData::FromSimpleJson, SHUDPIPControllerSaveData::Serialize, SHUDPIPControllerSaveData::Equals, SHUDPIPControllerSaveData::Destroy);

void SHUDPIPControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPIPControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPiPEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPiPEnabled);

	p_Stream << "}";
}

void SHUDPIPControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDPIPControllerSaveData s_Object {};

	s_Object.m_bPiPEnabled = simdjson::from_json_bool(p_Document["m_bPiPEnabled"]);

	*reinterpret_cast<SHUDPIPControllerSaveData*>(p_Target) = s_Object;
}

void SHUDPIPControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDPIPControllerSaveData*>(p_Object);

}

bool SHUDPIPControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDPIPControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDPIPControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDPIPControllerSaveData::operator==(const SHUDPIPControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDPIPControllerSaveData>)
		return false;

	if (m_bPiPEnabled != p_Other.m_bPiPEnabled) return false;

	return true;
}

void SHUDPIPControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDPIPControllerSaveData*>(p_Object);
	s_Object->~SHUDPIPControllerSaveData();
}

ZHMTypeInfo SHUDPromptDisplayInfo::TypeInfo = ZHMTypeInfo("SHUDPromptDisplayInfo", sizeof(SHUDPromptDisplayInfo), alignof(SHUDPromptDisplayInfo), SHUDPromptDisplayInfo::WriteSimpleJson, SHUDPromptDisplayInfo::FromSimpleJson, SHUDPromptDisplayInfo::Serialize, SHUDPromptDisplayInfo::Equals, SHUDPromptDisplayInfo::Destroy);

void SHUDPromptDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActionPromptState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIconId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIconId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTypeId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTypeId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoActionAvailable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoActionAvailable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sGlyph") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sGlyph);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOpacity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOpacity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegalItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegalItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspiciousItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspiciousItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropTempHolsterableItems") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropTempHolsterableItems);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFontSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFontSize);

	p_Stream << "}";
}

void SHUDPromptDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDPromptDisplayInfo s_Object {};

	s_Object.m_bActive = simdjson::from_json_bool(p_Document["m_bActive"]);

	s_Object.m_eState = static_cast<EActionPromptState>(ZHMEnums::GetEnumValueByName("EActionPromptState", std::string_view(p_Document["m_eState"])));

	s_Object.m_nIconId = simdjson::from_json_int32(p_Document["m_nIconId"]);

	s_Object.m_eTypeId = simdjson::from_json_int32(p_Document["m_eTypeId"]);

	s_Object.m_fProgress = simdjson::from_json_float32(p_Document["m_fProgress"]);

	s_Object.m_fDistance = simdjson::from_json_float32(p_Document["m_fDistance"]);

	s_Object.m_bShowWarning = simdjson::from_json_bool(p_Document["m_bShowWarning"]);

	s_Object.m_bNoActionAvailable = simdjson::from_json_bool(p_Document["m_bNoActionAvailable"]);

	s_Object.m_sLabel = std::string_view(p_Document["m_sLabel"]);

	s_Object.m_sDescription = std::string_view(p_Document["m_sDescription"]);

	s_Object.m_sGlyph = std::string_view(p_Document["m_sGlyph"]);

	s_Object.m_fOpacity = simdjson::from_json_float32(p_Document["m_fOpacity"]);

	s_Object.m_bIllegalItem = simdjson::from_json_bool(p_Document["m_bIllegalItem"]);

	s_Object.m_bSuspiciousItem = simdjson::from_json_bool(p_Document["m_bSuspiciousItem"]);

	s_Object.m_bDropTempHolsterableItems = simdjson::from_json_bool(p_Document["m_bDropTempHolsterableItems"]);

	s_Object.m_nFontSize = simdjson::from_json_int32(p_Document["m_nFontSize"]);

	*reinterpret_cast<SHUDPromptDisplayInfo*>(p_Target) = s_Object;
}

void SHUDPromptDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->m_sLabel, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sLabel));
	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sDescription));
	ZString::Serialize(&s_Object->m_sGlyph, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfo, m_sGlyph));
}

bool SHUDPromptDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDPromptDisplayInfo::operator==(const SHUDPromptDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDPromptDisplayInfo>)
		return false;

	if (m_bActive != p_Other.m_bActive) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_nIconId != p_Other.m_nIconId) return false;
	if (m_eTypeId != p_Other.m_eTypeId) return false;
	if (m_fProgress != p_Other.m_fProgress) return false;
	if (m_fDistance != p_Other.m_fDistance) return false;
	if (m_bShowWarning != p_Other.m_bShowWarning) return false;
	if (m_bNoActionAvailable != p_Other.m_bNoActionAvailable) return false;
	if (m_sLabel != p_Other.m_sLabel) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_sGlyph != p_Other.m_sGlyph) return false;
	if (m_fOpacity != p_Other.m_fOpacity) return false;
	if (m_bIllegalItem != p_Other.m_bIllegalItem) return false;
	if (m_bSuspiciousItem != p_Other.m_bSuspiciousItem) return false;
	if (m_bDropTempHolsterableItems != p_Other.m_bDropTempHolsterableItems) return false;
	if (m_nFontSize != p_Other.m_nFontSize) return false;

	return true;
}

void SHUDPromptDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfo*>(p_Object);
	s_Object->~SHUDPromptDisplayInfo();
}

ZHMTypeInfo SHUDPromptDisplayInfoArray_Dummy::TypeInfo = ZHMTypeInfo("SHUDPromptDisplayInfoArray_Dummy", sizeof(SHUDPromptDisplayInfoArray_Dummy), alignof(SHUDPromptDisplayInfoArray_Dummy), SHUDPromptDisplayInfoArray_Dummy::WriteSimpleJson, SHUDPromptDisplayInfoArray_Dummy::FromSimpleJson, SHUDPromptDisplayInfoArray_Dummy::Serialize, SHUDPromptDisplayInfoArray_Dummy::Equals, SHUDPromptDisplayInfoArray_Dummy::Destroy);

void SHUDPromptDisplayInfoArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SHUDPromptDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SHUDPromptDisplayInfoArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDPromptDisplayInfoArray_Dummy s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object.dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHUDPromptDisplayInfo s_ArrayItem0;
		SHUDPromptDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Target) = s_Object;
}

void SHUDPromptDisplayInfoArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);

	TArray<SHUDPromptDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SHUDPromptDisplayInfoArray_Dummy, dummy));
}

bool SHUDPromptDisplayInfoArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDPromptDisplayInfoArray_Dummy::operator==(const SHUDPromptDisplayInfoArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDPromptDisplayInfoArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SHUDPromptDisplayInfoArray_Dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDPromptDisplayInfoArray_Dummy*>(p_Object);
	s_Object->~SHUDPromptDisplayInfoArray_Dummy();
}

ZHMTypeInfo SHUDTimerControllerSaveData::TypeInfo = ZHMTypeInfo("SHUDTimerControllerSaveData", sizeof(SHUDTimerControllerSaveData), alignof(SHUDTimerControllerSaveData), SHUDTimerControllerSaveData::WriteSimpleJson, SHUDTimerControllerSaveData::FromSimpleJson, SHUDTimerControllerSaveData::Serialize, SHUDTimerControllerSaveData::Equals, SHUDTimerControllerSaveData::Destroy);

void SHUDTimerControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pCurrentInstance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCurrentInstance);

	p_Stream << "}";
}

void SHUDTimerControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDTimerControllerSaveData s_Object {};

	s_Object.m_pCurrentInstance = simdjson::from_json_uint32(p_Document["m_pCurrentInstance"]);

	*reinterpret_cast<SHUDTimerControllerSaveData*>(p_Target) = s_Object;
}

void SHUDTimerControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);

}

bool SHUDTimerControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDTimerControllerSaveData::operator==(const SHUDTimerControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDTimerControllerSaveData>)
		return false;

	if (m_pCurrentInstance != p_Other.m_pCurrentInstance) return false;

	return true;
}

void SHUDTimerControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDTimerControllerSaveData*>(p_Object);
	s_Object->~SHUDTimerControllerSaveData();
}

ZHMTypeInfo SHUDVisibilityController2SaveData::TypeInfo = ZHMTypeInfo("SHUDVisibilityController2SaveData", sizeof(SHUDVisibilityController2SaveData), alignof(SHUDVisibilityController2SaveData), SHUDVisibilityController2SaveData::WriteSimpleJson, SHUDVisibilityController2SaveData::FromSimpleJson, SHUDVisibilityController2SaveData::Serialize, SHUDVisibilityController2SaveData::Equals, SHUDVisibilityController2SaveData::Destroy);

void SHUDVisibilityController2SaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eCurrentRequest") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHUDUIRoot.EHUDVisibility", static_cast<int>(s_Object->m_eCurrentRequest)));

	p_Stream << "}";
}

void SHUDVisibilityController2SaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHUDVisibilityController2SaveData s_Object {};

	s_Object.m_eCurrentRequest = static_cast<ZHUDUIRoot_EHUDVisibility>(ZHMEnums::GetEnumValueByName("ZHUDUIRoot.EHUDVisibility", std::string_view(p_Document["m_eCurrentRequest"])));

	*reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Target) = s_Object;
}

void SHUDVisibilityController2SaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);

}

bool SHUDVisibilityController2SaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHUDVisibilityController2SaveData::operator==(const SHUDVisibilityController2SaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHUDVisibilityController2SaveData>)
		return false;

	if (m_eCurrentRequest != p_Other.m_eCurrentRequest) return false;

	return true;
}

void SHUDVisibilityController2SaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHUDVisibilityController2SaveData*>(p_Object);
	s_Object->~SHUDVisibilityController2SaveData();
}

ZHMTypeInfo SHandleDistractionSituationSaveData::TypeInfo = ZHMTypeInfo("SHandleDistractionSituationSaveData", sizeof(SHandleDistractionSituationSaveData), alignof(SHandleDistractionSituationSaveData), SHandleDistractionSituationSaveData::WriteSimpleJson, SHandleDistractionSituationSaveData::FromSimpleJson, SHandleDistractionSituationSaveData::Serialize, SHandleDistractionSituationSaveData::Equals, SHandleDistractionSituationSaveData::Destroy);

void SHandleDistractionSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHandleDistractionSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pAssistant") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pAssistant);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pPreliminaryLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pPreliminaryLeader);

	p_Stream << "}";
}

void SHandleDistractionSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHandleDistractionSituationSaveData s_Object {};

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pAssistant = simdjson::from_json_uint32(p_Document["m_pAssistant"]);

	s_Object.m_pPreliminaryLeader = simdjson::from_json_uint32(p_Document["m_pPreliminaryLeader"]);

	*reinterpret_cast<SHandleDistractionSituationSaveData*>(p_Target) = s_Object;
}

void SHandleDistractionSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHandleDistractionSituationSaveData*>(p_Object);

}

bool SHandleDistractionSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHandleDistractionSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHandleDistractionSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHandleDistractionSituationSaveData::operator==(const SHandleDistractionSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHandleDistractionSituationSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pAssistant != p_Other.m_pAssistant) return false;
	if (m_pPreliminaryLeader != p_Other.m_pPreliminaryLeader) return false;

	return true;
}

void SHandleDistractionSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHandleDistractionSituationSaveData*>(p_Object);
	s_Object->~SHandleDistractionSituationSaveData();
}

ZHMTypeInfo SHeroCameraStandInSaveState::TypeInfo = ZHMTypeInfo("SHeroCameraStandInSaveState", sizeof(SHeroCameraStandInSaveState), alignof(SHeroCameraStandInSaveState), SHeroCameraStandInSaveState::WriteSimpleJson, SHeroCameraStandInSaveState::FromSimpleJson, SHeroCameraStandInSaveState::Serialize, SHeroCameraStandInSaveState::Equals, SHeroCameraStandInSaveState::Destroy);

void SHeroCameraStandInSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroCameraStandInSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rHero") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHero);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);

	p_Stream << "}";
}

void SHeroCameraStandInSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroCameraStandInSaveState s_Object {};

	s_Object.m_rHero = simdjson::from_json_uint32(p_Document["m_rHero"]);

	s_Object.m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	*reinterpret_cast<SHeroCameraStandInSaveState*>(p_Target) = s_Object;
}

void SHeroCameraStandInSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroCameraStandInSaveState*>(p_Object);

}

bool SHeroCameraStandInSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroCameraStandInSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroCameraStandInSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroCameraStandInSaveState::operator==(const SHeroCameraStandInSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroCameraStandInSaveState>)
		return false;

	if (m_rHero != p_Other.m_rHero) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;

	return true;
}

void SHeroCameraStandInSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroCameraStandInSaveState*>(p_Object);
	s_Object->~SHeroCameraStandInSaveState();
}

ZHMTypeInfo SHeroEscortSituation2ActorStateSaveData::TypeInfo = ZHMTypeInfo("SHeroEscortSituation2ActorStateSaveData", sizeof(SHeroEscortSituation2ActorStateSaveData), alignof(SHeroEscortSituation2ActorStateSaveData), SHeroEscortSituation2ActorStateSaveData::WriteSimpleJson, SHeroEscortSituation2ActorStateSaveData::FromSimpleJson, SHeroEscortSituation2ActorStateSaveData::Serialize, SHeroEscortSituation2ActorStateSaveData::Equals, SHeroEscortSituation2ActorStateSaveData::Destroy);

void SHeroEscortSituation2ActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2ActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituation2Entity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituation2Entity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SHeroEscortSituation2ActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituation2ActorStateSaveData s_Object {};

	s_Object.m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_eState = static_cast<ZHeroEscortSituation2Entity_EEscortState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituation2Entity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object.m_eStatePrevious = static_cast<ZHeroEscortSituation2Entity_EEscortState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituation2Entity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object.m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

	*reinterpret_cast<SHeroEscortSituation2ActorStateSaveData*>(p_Target) = s_Object;
}

void SHeroEscortSituation2ActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2ActorStateSaveData*>(p_Object);

}

bool SHeroEscortSituation2ActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituation2ActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituation2ActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituation2ActorStateSaveData::operator==(const SHeroEscortSituation2ActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituation2ActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

void SHeroEscortSituation2ActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2ActorStateSaveData*>(p_Object);
	s_Object->~SHeroEscortSituation2ActorStateSaveData();
}

ZHMTypeInfo SHeroEscortSituation2Actors::TypeInfo = ZHMTypeInfo("SHeroEscortSituation2Actors", sizeof(SHeroEscortSituation2Actors), alignof(SHeroEscortSituation2Actors), SHeroEscortSituation2Actors::WriteSimpleJson, SHeroEscortSituation2Actors::FromSimpleJson, SHeroEscortSituation2Actors::Serialize, SHeroEscortSituation2Actors::Equals, SHeroEscortSituation2Actors::Destroy);

void SHeroEscortSituation2Actors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2Actors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SHeroEscortSituation2Actors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituation2Actors s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SHeroEscortSituation2Actors*>(p_Target) = s_Object;
}

void SHeroEscortSituation2Actors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2Actors*>(p_Object);

}

bool SHeroEscortSituation2Actors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituation2Actors*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituation2Actors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituation2Actors::operator==(const SHeroEscortSituation2Actors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituation2Actors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SHeroEscortSituation2Actors::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2Actors*>(p_Object);
	s_Object->~SHeroEscortSituation2Actors();
}

ZHMTypeInfo SHeroEscortSituation2SaveData::TypeInfo = ZHMTypeInfo("SHeroEscortSituation2SaveData", sizeof(SHeroEscortSituation2SaveData), alignof(SHeroEscortSituation2SaveData), SHeroEscortSituation2SaveData::WriteSimpleJson, SHeroEscortSituation2SaveData::FromSimpleJson, SHeroEscortSituation2SaveData::Serialize, SHeroEscortSituation2SaveData::Equals, SHeroEscortSituation2SaveData::Destroy);

void SHeroEscortSituation2SaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2SaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituation2Entity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SHeroEscortSituation2Actors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SHeroEscortSituation2ActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeSinceLossOfSight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeSinceLossOfSight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RecordedHitmanOutfit") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_RecordedHitmanOutfit, p_Stream);

	p_Stream << "}";
}

void SHeroEscortSituation2SaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituation2SaveData s_Object {};

	s_Object.m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object.m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object.m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object.m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object.m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Item);
		s_Object.m_vLastPosition = s_Item;
	}

	s_Object.m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object.m_eTargetState = static_cast<ZHeroEscortSituation2Entity_ETargetState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituation2Entity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object.m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object.m_eTargetActState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object.m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object.m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAddedActors"];
	s_Object.m_aAddedActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHeroEscortSituation2Actors s_ArrayItem0;
		SHeroEscortSituation2Actors::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAddedActors[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHeroEscortSituation2ActorStateSaveData s_ArrayItem0;
		SHeroEscortSituation2ActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEscortActs"];
	s_Object.m_aEscortActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEscortActs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_fTimeSinceLossOfSight = simdjson::from_json_float32(p_Document["m_fTimeSinceLossOfSight"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_RecordedHitmanOutfit"], &s_Item);
		s_Object.m_RecordedHitmanOutfit = s_Item;
	}

	*reinterpret_cast<SHeroEscortSituation2SaveData*>(p_Target) = s_Object;
}

void SHeroEscortSituation2SaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2SaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituation2SaveData, m_vLastPosition));
	TArray<SHeroEscortSituation2Actors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituation2SaveData, m_aAddedActors));
	TArray<SHeroEscortSituation2ActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituation2SaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituation2SaveData, m_aEscortActs));
	ZRepositoryID::Serialize(&s_Object->m_RecordedHitmanOutfit, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituation2SaveData, m_RecordedHitmanOutfit));
}

bool SHeroEscortSituation2SaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituation2SaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituation2SaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituation2SaveData::operator==(const SHeroEscortSituation2SaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituation2SaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;
	if (m_fTimeSinceLossOfSight != p_Other.m_fTimeSinceLossOfSight) return false;
	if (m_RecordedHitmanOutfit != p_Other.m_RecordedHitmanOutfit) return false;

	return true;
}

void SHeroEscortSituation2SaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituation2SaveData*>(p_Object);
	s_Object->~SHeroEscortSituation2SaveData();
}

ZHMTypeInfo SHeroEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SHeroEscortSituationActorStateSaveData", sizeof(SHeroEscortSituationActorStateSaveData), alignof(SHeroEscortSituationActorStateSaveData), SHeroEscortSituationActorStateSaveData::WriteSimpleJson, SHeroEscortSituationActorStateSaveData::FromSimpleJson, SHeroEscortSituationActorStateSaveData::Serialize, SHeroEscortSituationActorStateSaveData::Equals, SHeroEscortSituationActorStateSaveData::Destroy);

void SHeroEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SHeroEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituationActorStateSaveData s_Object {};

	s_Object.m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_eState = static_cast<ZHeroEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object.m_eStatePrevious = static_cast<ZHeroEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object.m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

	*reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Target) = s_Object;
}

void SHeroEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);

}

bool SHeroEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituationActorStateSaveData::operator==(const SHeroEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

void SHeroEscortSituationActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActorStateSaveData*>(p_Object);
	s_Object->~SHeroEscortSituationActorStateSaveData();
}

ZHMTypeInfo SHeroEscortSituationActors::TypeInfo = ZHMTypeInfo("SHeroEscortSituationActors", sizeof(SHeroEscortSituationActors), alignof(SHeroEscortSituationActors), SHeroEscortSituationActors::WriteSimpleJson, SHeroEscortSituationActors::FromSimpleJson, SHeroEscortSituationActors::Serialize, SHeroEscortSituationActors::Equals, SHeroEscortSituationActors::Destroy);

void SHeroEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SHeroEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituationActors s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SHeroEscortSituationActors*>(p_Target) = s_Object;
}

void SHeroEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);

}

bool SHeroEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituationActors::operator==(const SHeroEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SHeroEscortSituationActors::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationActors*>(p_Object);
	s_Object->~SHeroEscortSituationActors();
}

ZHMTypeInfo SHeroEscortSituationSaveData::TypeInfo = ZHMTypeInfo("SHeroEscortSituationSaveData", sizeof(SHeroEscortSituationSaveData), alignof(SHeroEscortSituationSaveData), SHeroEscortSituationSaveData::WriteSimpleJson, SHeroEscortSituationSaveData::FromSimpleJson, SHeroEscortSituationSaveData::Serialize, SHeroEscortSituationSaveData::Equals, SHeroEscortSituationSaveData::Destroy);

void SHeroEscortSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHeroEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SHeroEscortSituationActors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SHeroEscortSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeSinceLossOfSight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeSinceLossOfSight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RecordedHitmanOutfit") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_RecordedHitmanOutfit, p_Stream);

	p_Stream << "}";
}

void SHeroEscortSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroEscortSituationSaveData s_Object {};

	s_Object.m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object.m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object.m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object.m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object.m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Item);
		s_Object.m_vLastPosition = s_Item;
	}

	s_Object.m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object.m_eTargetState = static_cast<ZHeroEscortSituationEntity_ETargetState>(ZHMEnums::GetEnumValueByName("ZHeroEscortSituationEntity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object.m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object.m_eTargetActState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object.m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object.m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAddedActors"];
	s_Object.m_aAddedActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHeroEscortSituationActors s_ArrayItem0;
		SHeroEscortSituationActors::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAddedActors[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHeroEscortSituationActorStateSaveData s_ArrayItem0;
		SHeroEscortSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEscortActs"];
	s_Object.m_aEscortActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEscortActs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_fTimeSinceLossOfSight = simdjson::from_json_float32(p_Document["m_fTimeSinceLossOfSight"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_RecordedHitmanOutfit"], &s_Item);
		s_Object.m_RecordedHitmanOutfit = s_Item;
	}

	*reinterpret_cast<SHeroEscortSituationSaveData*>(p_Target) = s_Object;
}

void SHeroEscortSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_vLastPosition));
	TArray<SHeroEscortSituationActors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_aAddedActors));
	TArray<SHeroEscortSituationActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_aEscortActs));
	ZRepositoryID::Serialize(&s_Object->m_RecordedHitmanOutfit, p_Serializer, p_OwnOffset + offsetof(SHeroEscortSituationSaveData, m_RecordedHitmanOutfit));
}

bool SHeroEscortSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroEscortSituationSaveData::operator==(const SHeroEscortSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroEscortSituationSaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;
	if (m_fTimeSinceLossOfSight != p_Other.m_fTimeSinceLossOfSight) return false;
	if (m_RecordedHitmanOutfit != p_Other.m_RecordedHitmanOutfit) return false;

	return true;
}

void SHeroEscortSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroEscortSituationSaveData*>(p_Object);
	s_Object->~SHeroEscortSituationSaveData();
}

ZHMTypeInfo SHeroItemActionSaveData::TypeInfo = ZHMTypeInfo("SHeroItemActionSaveData", sizeof(SHeroItemActionSaveData), alignof(SHeroItemActionSaveData), SHeroItemActionSaveData::WriteSimpleJson, SHeroItemActionSaveData::FromSimpleJson, SHeroItemActionSaveData::Serialize, SHeroItemActionSaveData::Equals, SHeroItemActionSaveData::Destroy);

void SHeroItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SHeroItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroItemActionSaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SHeroItemActionSaveData*>(p_Target) = s_Object;
}

void SHeroItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);

}

bool SHeroItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroItemActionSaveData::operator==(const SHeroItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroItemActionSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SHeroItemActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroItemActionSaveData*>(p_Object);
	s_Object->~SHeroItemActionSaveData();
}

ZHMTypeInfo SHeroItemAttachmentSaveData::TypeInfo = ZHMTypeInfo("SHeroItemAttachmentSaveData", sizeof(SHeroItemAttachmentSaveData), alignof(SHeroItemAttachmentSaveData), SHeroItemAttachmentSaveData::WriteSimpleJson, SHeroItemAttachmentSaveData::FromSimpleJson, SHeroItemAttachmentSaveData::Serialize, SHeroItemAttachmentSaveData::Equals, SHeroItemAttachmentSaveData::Destroy);

void SHeroItemAttachmentSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SHeroItemAttachmentSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroItemAttachmentSaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Target) = s_Object;
}

void SHeroItemAttachmentSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);

}

bool SHeroItemAttachmentSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroItemAttachmentSaveData::operator==(const SHeroItemAttachmentSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroItemAttachmentSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SHeroItemAttachmentSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroItemAttachmentSaveData*>(p_Object);
	s_Object->~SHeroItemAttachmentSaveData();
}

ZHMTypeInfo SHeroStandInSaveState::TypeInfo = ZHMTypeInfo("SHeroStandInSaveState", sizeof(SHeroStandInSaveState), alignof(SHeroStandInSaveState), SHeroStandInSaveState::WriteSimpleJson, SHeroStandInSaveState::FromSimpleJson, SHeroStandInSaveState::Serialize, SHeroStandInSaveState::Equals, SHeroStandInSaveState::Destroy);

void SHeroStandInSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rHero") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHero);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);

	p_Stream << "}";
}

void SHeroStandInSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHeroStandInSaveState s_Object {};

	s_Object.m_rHero = simdjson::from_json_uint32(p_Document["m_rHero"]);

	s_Object.m_rCurrentSpeakEntity = simdjson::from_json_uint32(p_Document["m_rCurrentSpeakEntity"]);

	s_Object.m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	*reinterpret_cast<SHeroStandInSaveState*>(p_Target) = s_Object;
}

void SHeroStandInSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);

}

bool SHeroStandInSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHeroStandInSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SHeroStandInSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHeroStandInSaveState::operator==(const SHeroStandInSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHeroStandInSaveState>)
		return false;

	if (m_rHero != p_Other.m_rHero) return false;
	if (m_rCurrentSpeakEntity != p_Other.m_rCurrentSpeakEntity) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;

	return true;
}

void SHeroStandInSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHeroStandInSaveState*>(p_Object);
	s_Object->~SHeroStandInSaveState();
}

ZHMTypeInfo SHintEntrySaveData::TypeInfo = ZHMTypeInfo("SHintEntrySaveData", sizeof(SHintEntrySaveData), alignof(SHintEntrySaveData), SHintEntrySaveData::WriteSimpleJson, SHintEntrySaveData::FromSimpleJson, SHintEntrySaveData::Serialize, SHintEntrySaveData::Equals, SHintEntrySaveData::Destroy);

void SHintEntrySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsValid);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_hint") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_hint);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_context") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_context);

	p_Stream << "}";
}

void SHintEntrySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHintEntrySaveData s_Object {};

	s_Object.m_bIsValid = simdjson::from_json_bool(p_Document["m_bIsValid"]);

	s_Object.m_hint = simdjson::from_json_uint32(p_Document["m_hint"]);

	s_Object.m_context = simdjson::from_json_uint32(p_Document["m_context"]);

	*reinterpret_cast<SHintEntrySaveData*>(p_Target) = s_Object;
}

void SHintEntrySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);

}

bool SHintEntrySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHintEntrySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHintEntrySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHintEntrySaveData::operator==(const SHintEntrySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHintEntrySaveData>)
		return false;

	if (m_bIsValid != p_Other.m_bIsValid) return false;
	if (m_hint != p_Other.m_hint) return false;
	if (m_context != p_Other.m_context) return false;

	return true;
}

void SHintEntrySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHintEntrySaveData*>(p_Object);
	s_Object->~SHintEntrySaveData();
}

ZHMTypeInfo SHintManagerSaveData::TypeInfo = ZHMTypeInfo("SHintManagerSaveData", sizeof(SHintManagerSaveData), alignof(SHintManagerSaveData), SHintManagerSaveData::WriteSimpleJson, SHintManagerSaveData::FromSimpleJson, SHintManagerSaveData::Serialize, SHintManagerSaveData::Equals, SHintManagerSaveData::Destroy);

void SHintManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_activeHint") << ":";
	SHintEntrySaveData::WriteSimpleJson(&s_Object->m_activeHint, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aQueue") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aQueue.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aQueue[i];
		SHintEntrySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aQueue.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRunning);

	p_Stream << "}";
}

void SHintManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHintManagerSaveData s_Object {};

	{
		SHintEntrySaveData s_Item {};
		SHintEntrySaveData::FromSimpleJson(p_Document["m_activeHint"], &s_Item);
		s_Object.m_activeHint = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aQueue"];
	s_Object.m_aQueue.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SHintEntrySaveData s_ArrayItem0;
		SHintEntrySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aQueue[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_bIsRunning = simdjson::from_json_bool(p_Document["m_bIsRunning"]);

	*reinterpret_cast<SHintManagerSaveData*>(p_Target) = s_Object;
}

void SHintManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);

	SHintEntrySaveData::Serialize(&s_Object->m_activeHint, p_Serializer, p_OwnOffset + offsetof(SHintManagerSaveData, m_activeHint));
	TArray<SHintEntrySaveData>::Serialize(&s_Object->m_aQueue, p_Serializer, p_OwnOffset + offsetof(SHintManagerSaveData, m_aQueue));
}

bool SHintManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHintManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHintManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHintManagerSaveData::operator==(const SHintManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHintManagerSaveData>)
		return false;

	if (m_activeHint != p_Other.m_activeHint) return false;
	if (m_aQueue != p_Other.m_aQueue) return false;
	if (m_bIsRunning != p_Other.m_bIsRunning) return false;

	return true;
}

void SHintManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHintManagerSaveData*>(p_Object);
	s_Object->~SHintManagerSaveData();
}

ZHMTypeInfo SHitmanSaveData::TypeInfo = ZHMTypeInfo("SHitmanSaveData", sizeof(SHitmanSaveData), alignof(SHitmanSaveData), SHitmanSaveData::WriteSimpleJson, SHitmanSaveData::FromSimpleJson, SHitmanSaveData::Serialize, SHitmanSaveData::Equals, SHitmanSaveData::Destroy);

void SHitmanSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHitmanSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_OutfitID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_OutfitID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitCharset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitCharset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nOutfitVariation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nOutfitVariation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHealth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHealth);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Inventory") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Inventory, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Camera") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Camera, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMovementType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EBaseMovementType", static_cast<int>(s_Object->m_eMovementType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MovementData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_MovementData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLethalAgilityElementUsed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLethalAgilityElementUsed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsChangingClothes") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsChangingClothes);

	p_Stream << "}";
}

void SHitmanSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHitmanSaveData s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_OutfitID"], &s_Item);
		s_Object.m_OutfitID = s_Item;
	}

	s_Object.m_nOutfitCharset = simdjson::from_json_int32(p_Document["m_nOutfitCharset"]);

	s_Object.m_nOutfitVariation = simdjson::from_json_int32(p_Document["m_nOutfitVariation"]);

	s_Object.m_fHealth = simdjson::from_json_float32(p_Document["m_fHealth"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vRotation"], &s_Item);
		s_Object.m_vRotation = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Inventory"], &s_Item);
		s_Object.m_Inventory = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Camera"], &s_Item);
		s_Object.m_Camera = s_Item;
	}

	s_Object.m_eMovementType = static_cast<EBaseMovementType>(ZHMEnums::GetEnumValueByName("EBaseMovementType", std::string_view(p_Document["m_eMovementType"])));

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_MovementData"], &s_Item);
		s_Object.m_MovementData = s_Item;
	}

	s_Object.m_bLethalAgilityElementUsed = simdjson::from_json_bool(p_Document["m_bLethalAgilityElementUsed"]);

	s_Object.m_bIsChangingClothes = simdjson::from_json_bool(p_Document["m_bIsChangingClothes"]);

	*reinterpret_cast<SHitmanSaveData*>(p_Target) = s_Object;
}

void SHitmanSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHitmanSaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_OutfitID, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_OutfitID));
	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_vRotation));
	ZVariant::Serialize(&s_Object->m_Inventory, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_Inventory));
	ZVariant::Serialize(&s_Object->m_Camera, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_Camera));
	ZVariant::Serialize(&s_Object->m_MovementData, p_Serializer, p_OwnOffset + offsetof(SHitmanSaveData, m_MovementData));
}

bool SHitmanSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHitmanSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHitmanSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHitmanSaveData::operator==(const SHitmanSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHitmanSaveData>)
		return false;

	if (m_OutfitID != p_Other.m_OutfitID) return false;
	if (m_nOutfitCharset != p_Other.m_nOutfitCharset) return false;
	if (m_nOutfitVariation != p_Other.m_nOutfitVariation) return false;
	if (m_fHealth != p_Other.m_fHealth) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_Inventory != p_Other.m_Inventory) return false;
	if (m_Camera != p_Other.m_Camera) return false;
	if (m_eMovementType != p_Other.m_eMovementType) return false;
	if (m_MovementData != p_Other.m_MovementData) return false;
	if (m_bLethalAgilityElementUsed != p_Other.m_bLethalAgilityElementUsed) return false;
	if (m_bIsChangingClothes != p_Other.m_bIsChangingClothes) return false;

	return true;
}

void SHitmanSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHitmanSaveData*>(p_Object);
	s_Object->~SHitmanSaveData();
}

ZHMTypeInfo SHudMissionTimerControllerData::TypeInfo = ZHMTypeInfo("SHudMissionTimerControllerData", sizeof(SHudMissionTimerControllerData), alignof(SHudMissionTimerControllerData), SHudMissionTimerControllerData::WriteSimpleJson, SHudMissionTimerControllerData::FromSimpleJson, SHudMissionTimerControllerData::Serialize, SHudMissionTimerControllerData::Equals, SHudMissionTimerControllerData::Destroy);

void SHudMissionTimerControllerData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fScoreGameTimeStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_fScoreGameTimeStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasIntroCutFired") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasIntroCutFired);

	p_Stream << "}";
}

void SHudMissionTimerControllerData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SHudMissionTimerControllerData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_fScoreGameTimeStart"], &s_Item);
		s_Object.m_fScoreGameTimeStart = s_Item;
	}

	s_Object.m_bWasIntroCutFired = simdjson::from_json_bool(p_Document["m_bWasIntroCutFired"]);

	*reinterpret_cast<SHudMissionTimerControllerData*>(p_Target) = s_Object;
}

void SHudMissionTimerControllerData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_fScoreGameTimeStart, p_Serializer, p_OwnOffset + offsetof(SHudMissionTimerControllerData, m_fScoreGameTimeStart));
}

bool SHudMissionTimerControllerData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SHudMissionTimerControllerData*>(p_Left);
	auto* s_Right = reinterpret_cast<SHudMissionTimerControllerData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SHudMissionTimerControllerData::operator==(const SHudMissionTimerControllerData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SHudMissionTimerControllerData>)
		return false;

	if (m_fScoreGameTimeStart != p_Other.m_fScoreGameTimeStart) return false;
	if (m_bWasIntroCutFired != p_Other.m_bWasIntroCutFired) return false;

	return true;
}

void SHudMissionTimerControllerData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SHudMissionTimerControllerData*>(p_Object);
	s_Object->~SHudMissionTimerControllerData();
}

ZHMTypeInfo SIntelData::TypeInfo = ZHMTypeInfo("SIntelData", sizeof(SIntelData), alignof(SIntelData), SIntelData::WriteSimpleJson, SIntelData::FromSimpleJson, SIntelData::Serialize, SIntelData::Equals, SIntelData::Destroy);

void SIntelData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sHeadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sHeadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyHeadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyHeadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodytext") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodytext);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sImage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sImage);

	p_Stream << "}";
}

void SIntelData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelData s_Object {};

	s_Object.m_sHeadline = std::string_view(p_Document["m_sHeadline"]);

	s_Object.m_sBodyHeadline = std::string_view(p_Document["m_sBodyHeadline"]);

	s_Object.m_sBodytext = std::string_view(p_Document["m_sBodytext"]);

	s_Object.m_sImage = std::string_view(p_Document["m_sImage"]);

	*reinterpret_cast<SIntelData*>(p_Target) = s_Object;
}

void SIntelData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);

	ZString::Serialize(&s_Object->m_sHeadline, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sHeadline));
	ZString::Serialize(&s_Object->m_sBodyHeadline, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sBodyHeadline));
	ZString::Serialize(&s_Object->m_sBodytext, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sBodytext));
	ZString::Serialize(&s_Object->m_sImage, p_Serializer, p_OwnOffset + offsetof(SIntelData, m_sImage));
}

bool SIntelData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelData*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelData::operator==(const SIntelData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelData>)
		return false;

	if (m_sHeadline != p_Other.m_sHeadline) return false;
	if (m_sBodyHeadline != p_Other.m_sBodyHeadline) return false;
	if (m_sBodytext != p_Other.m_sBodytext) return false;
	if (m_sImage != p_Other.m_sImage) return false;

	return true;
}

void SIntelData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelData*>(p_Object);
	s_Object->~SIntelData();
}

ZHMTypeInfo SIntelDataArray_dummy::TypeInfo = ZHMTypeInfo("SIntelDataArray_dummy", sizeof(SIntelDataArray_dummy), alignof(SIntelDataArray_dummy), SIntelDataArray_dummy::WriteSimpleJson, SIntelDataArray_dummy::FromSimpleJson, SIntelDataArray_dummy::Serialize, SIntelDataArray_dummy::Equals, SIntelDataArray_dummy::Destroy);

void SIntelDataArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelDataArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelDataArray_dummy s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object.dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SIntelData s_ArrayItem0;
		SIntelData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SIntelDataArray_dummy*>(p_Target) = s_Object;
}

void SIntelDataArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);

	TArray<SIntelData>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelDataArray_dummy, dummy));
}

bool SIntelDataArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDataArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDataArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDataArray_dummy::operator==(const SIntelDataArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDataArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SIntelDataArray_dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelDataArray_dummy*>(p_Object);
	s_Object->~SIntelDataArray_dummy();
}

ZHMTypeInfo SIntelDisplayInfo::TypeInfo = ZHMTypeInfo("SIntelDisplayInfo", sizeof(SIntelDisplayInfo), alignof(SIntelDisplayInfo), SIntelDisplayInfo::WriteSimpleJson, SIntelDisplayInfo::FromSimpleJson, SIntelDisplayInfo::Serialize, SIntelDisplayInfo::Equals, SIntelDisplayInfo::Destroy);

void SIntelDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("index") << ":";
	p_Stream << simdjson::as_json_string(s_Object->index);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->selected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("headline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->headline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bodyheadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bodyheadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("text") << ":";
	p_Stream << simdjson::as_json_string(s_Object->text);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("img") << ":";
	p_Stream << simdjson::as_json_string(s_Object->img);

	p_Stream << "}";
}

void SIntelDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelDisplayInfo s_Object {};

	s_Object.index = simdjson::from_json_int32(p_Document["index"]);

	s_Object.selected = simdjson::from_json_bool(p_Document["selected"]);

	s_Object.active = simdjson::from_json_bool(p_Document["active"]);

	s_Object.headline = std::string_view(p_Document["headline"]);

	s_Object.bodyheadline = std::string_view(p_Document["bodyheadline"]);

	s_Object.text = std::string_view(p_Document["text"]);

	s_Object.img = std::string_view(p_Document["img"]);

	*reinterpret_cast<SIntelDisplayInfo*>(p_Target) = s_Object;
}

void SIntelDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->headline, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, headline));
	ZString::Serialize(&s_Object->bodyheadline, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, bodyheadline));
	ZString::Serialize(&s_Object->text, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, text));
	ZString::Serialize(&s_Object->img, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfo, img));
}

bool SIntelDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDisplayInfo::operator==(const SIntelDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDisplayInfo>)
		return false;

	if (index != p_Other.index) return false;
	if (selected != p_Other.selected) return false;
	if (active != p_Other.active) return false;
	if (headline != p_Other.headline) return false;
	if (bodyheadline != p_Other.bodyheadline) return false;
	if (text != p_Other.text) return false;
	if (img != p_Other.img) return false;

	return true;
}

void SIntelDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfo*>(p_Object);
	s_Object->~SIntelDisplayInfo();
}

ZHMTypeInfo SIntelDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SIntelDisplayInfoArray_dummy", sizeof(SIntelDisplayInfoArray_dummy), alignof(SIntelDisplayInfoArray_dummy), SIntelDisplayInfoArray_dummy::WriteSimpleJson, SIntelDisplayInfoArray_dummy::FromSimpleJson, SIntelDisplayInfoArray_dummy::Serialize, SIntelDisplayInfoArray_dummy::Equals, SIntelDisplayInfoArray_dummy::Destroy);

void SIntelDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelDisplayInfoArray_dummy s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object.dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SIntelDisplayInfo s_ArrayItem0;
		SIntelDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Target) = s_Object;
}

void SIntelDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);

	TArray<SIntelDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelDisplayInfoArray_dummy, dummy));
}

bool SIntelDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelDisplayInfoArray_dummy::operator==(const SIntelDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SIntelDisplayInfoArray_dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelDisplayInfoArray_dummy*>(p_Object);
	s_Object->~SIntelDisplayInfoArray_dummy();
}

ZHMTypeInfo SIntelListDisplayInfo::TypeInfo = ZHMTypeInfo("SIntelListDisplayInfo", sizeof(SIntelListDisplayInfo), alignof(SIntelListDisplayInfo), SIntelListDisplayInfo::WriteSimpleJson, SIntelListDisplayInfo::FromSimpleJson, SIntelListDisplayInfo::Serialize, SIntelListDisplayInfo::Equals, SIntelListDisplayInfo::Destroy);

void SIntelListDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("index") << ":";
	p_Stream << simdjson::as_json_string(s_Object->index);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("active") << ":";
	p_Stream << simdjson::as_json_string(s_Object->active);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("newInfo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->newInfo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);

	p_Stream << "}";
}

void SIntelListDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelListDisplayInfo s_Object {};

	s_Object.index = simdjson::from_json_int32(p_Document["index"]);

	s_Object.active = simdjson::from_json_bool(p_Document["active"]);

	s_Object.newInfo = simdjson::from_json_bool(p_Document["newInfo"]);

	s_Object.label = std::string_view(p_Document["label"]);

	*reinterpret_cast<SIntelListDisplayInfo*>(p_Target) = s_Object;
}

void SIntelListDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SIntelListDisplayInfo, label));
}

bool SIntelListDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelListDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelListDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelListDisplayInfo::operator==(const SIntelListDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelListDisplayInfo>)
		return false;

	if (index != p_Other.index) return false;
	if (active != p_Other.active) return false;
	if (newInfo != p_Other.newInfo) return false;
	if (label != p_Other.label) return false;

	return true;
}

void SIntelListDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfo*>(p_Object);
	s_Object->~SIntelListDisplayInfo();
}

ZHMTypeInfo SIntelListDisplayInfoArray_dummy::TypeInfo = ZHMTypeInfo("SIntelListDisplayInfoArray_dummy", sizeof(SIntelListDisplayInfoArray_dummy), alignof(SIntelListDisplayInfoArray_dummy), SIntelListDisplayInfoArray_dummy::WriteSimpleJson, SIntelListDisplayInfoArray_dummy::FromSimpleJson, SIntelListDisplayInfoArray_dummy::Serialize, SIntelListDisplayInfoArray_dummy::Equals, SIntelListDisplayInfoArray_dummy::Destroy);

void SIntelListDisplayInfoArray_dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SIntelListDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SIntelListDisplayInfoArray_dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelListDisplayInfoArray_dummy s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object.dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SIntelListDisplayInfo s_ArrayItem0;
		SIntelListDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Target) = s_Object;
}

void SIntelListDisplayInfoArray_dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);

	TArray<SIntelListDisplayInfo>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SIntelListDisplayInfoArray_dummy, dummy));
}

bool SIntelListDisplayInfoArray_dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelListDisplayInfoArray_dummy::operator==(const SIntelListDisplayInfoArray_dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelListDisplayInfoArray_dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SIntelListDisplayInfoArray_dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelListDisplayInfoArray_dummy*>(p_Object);
	s_Object->~SIntelListDisplayInfoArray_dummy();
}

ZHMTypeInfo SIntelSaveData::TypeInfo = ZHMTypeInfo("SIntelSaveData", sizeof(SIntelSaveData), alignof(SIntelSaveData), SIntelSaveData::WriteSimpleJson, SIntelSaveData::FromSimpleJson, SIntelSaveData::Serialize, SIntelSaveData::Equals, SIntelSaveData::Destroy);

void SIntelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentStage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentStage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHandlerAudioPlayPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHandlerAudioPlayPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTracked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTracked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUnlocked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUnlocked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegistered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsLastTriggered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsLastTriggered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsHandlerAudioPlaying") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsHandlerAudioPlaying);

	p_Stream << "}";
}

void SIntelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SIntelSaveData s_Object {};

	s_Object.m_rCurrentStage = simdjson::from_json_uint32(p_Document["m_rCurrentStage"]);

	s_Object.m_fHandlerAudioPlayPosition = simdjson::from_json_float32(p_Document["m_fHandlerAudioPlayPosition"]);

	s_Object.m_bTracked = simdjson::from_json_bool(p_Document["m_bTracked"]);

	s_Object.m_bUnlocked = simdjson::from_json_bool(p_Document["m_bUnlocked"]);

	s_Object.m_bRegistered = simdjson::from_json_bool(p_Document["m_bRegistered"]);

	s_Object.m_bIsLastTriggered = simdjson::from_json_bool(p_Document["m_bIsLastTriggered"]);

	s_Object.m_bIsHandlerAudioPlaying = simdjson::from_json_bool(p_Document["m_bIsHandlerAudioPlaying"]);

	*reinterpret_cast<SIntelSaveData*>(p_Target) = s_Object;
}

void SIntelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);

}

bool SIntelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SIntelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SIntelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SIntelSaveData::operator==(const SIntelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SIntelSaveData>)
		return false;

	if (m_rCurrentStage != p_Other.m_rCurrentStage) return false;
	if (m_fHandlerAudioPlayPosition != p_Other.m_fHandlerAudioPlayPosition) return false;
	if (m_bTracked != p_Other.m_bTracked) return false;
	if (m_bUnlocked != p_Other.m_bUnlocked) return false;
	if (m_bRegistered != p_Other.m_bRegistered) return false;
	if (m_bIsLastTriggered != p_Other.m_bIsLastTriggered) return false;
	if (m_bIsHandlerAudioPlaying != p_Other.m_bIsHandlerAudioPlaying) return false;

	return true;
}

void SIntelSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SIntelSaveData*>(p_Object);
	s_Object->~SIntelSaveData();
}

ZHMTypeInfo SInteractionIndicatorInstanceData_SUIControlData::TypeInfo = ZHMTypeInfo("SInteractionIndicatorInstanceData.SUIControlData", sizeof(SInteractionIndicatorInstanceData_SUIControlData), alignof(SInteractionIndicatorInstanceData_SUIControlData), SInteractionIndicatorInstanceData_SUIControlData::WriteSimpleJson, SInteractionIndicatorInstanceData_SUIControlData::FromSimpleJson, SInteractionIndicatorInstanceData_SUIControlData::Serialize, SInteractionIndicatorInstanceData_SUIControlData::Equals, SInteractionIndicatorInstanceData_SUIControlData::Destroy);

void SInteractionIndicatorInstanceData_SUIControlData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData_SUIControlData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTypeId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eTypeId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nIconId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIconId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sGlyph") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sGlyph);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNoActionAvailable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNoActionAvailable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIllegalItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIllegalItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSuspiciousItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSuspiciousItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bContainsItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bContainsItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFontSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFontSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsTxtDirReversed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsTxtDirReversed);

	p_Stream << "}";
}

void SInteractionIndicatorInstanceData_SUIControlData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInteractionIndicatorInstanceData_SUIControlData s_Object {};

	s_Object.m_eState = simdjson::from_json_int32(p_Document["m_eState"]);

	s_Object.m_eTypeId = simdjson::from_json_int32(p_Document["m_eTypeId"]);

	s_Object.m_nIconId = simdjson::from_json_int32(p_Document["m_nIconId"]);

	s_Object.m_fProgress = simdjson::from_json_float32(p_Document["m_fProgress"]);

	s_Object.m_sLabel = std::string_view(p_Document["m_sLabel"]);

	s_Object.m_sDescription = std::string_view(p_Document["m_sDescription"]);

	s_Object.m_sGlyph = std::string_view(p_Document["m_sGlyph"]);

	s_Object.m_bIllegal = simdjson::from_json_bool(p_Document["m_bIllegal"]);

	s_Object.m_bNoActionAvailable = simdjson::from_json_bool(p_Document["m_bNoActionAvailable"]);

	s_Object.m_bInRange = simdjson::from_json_bool(p_Document["m_bInRange"]);

	s_Object.m_bIllegalItem = simdjson::from_json_bool(p_Document["m_bIllegalItem"]);

	s_Object.m_bSuspiciousItem = simdjson::from_json_bool(p_Document["m_bSuspiciousItem"]);

	s_Object.m_bContainsItem = simdjson::from_json_bool(p_Document["m_bContainsItem"]);

	s_Object.m_nFontSize = simdjson::from_json_int32(p_Document["m_nFontSize"]);

	s_Object.m_bIsTxtDirReversed = simdjson::from_json_bool(p_Document["m_bIsTxtDirReversed"]);

	*reinterpret_cast<SInteractionIndicatorInstanceData_SUIControlData*>(p_Target) = s_Object;
}

void SInteractionIndicatorInstanceData_SUIControlData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData_SUIControlData*>(p_Object);

	ZString::Serialize(&s_Object->m_sLabel, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData_SUIControlData, m_sLabel));
	ZString::Serialize(&s_Object->m_sDescription, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData_SUIControlData, m_sDescription));
	ZString::Serialize(&s_Object->m_sGlyph, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData_SUIControlData, m_sGlyph));
}

bool SInteractionIndicatorInstanceData_SUIControlData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInteractionIndicatorInstanceData_SUIControlData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInteractionIndicatorInstanceData_SUIControlData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInteractionIndicatorInstanceData_SUIControlData::operator==(const SInteractionIndicatorInstanceData_SUIControlData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInteractionIndicatorInstanceData_SUIControlData>)
		return false;

	if (m_eState != p_Other.m_eState) return false;
	if (m_eTypeId != p_Other.m_eTypeId) return false;
	if (m_nIconId != p_Other.m_nIconId) return false;
	if (m_fProgress != p_Other.m_fProgress) return false;
	if (m_sLabel != p_Other.m_sLabel) return false;
	if (m_sDescription != p_Other.m_sDescription) return false;
	if (m_sGlyph != p_Other.m_sGlyph) return false;
	if (m_bIllegal != p_Other.m_bIllegal) return false;
	if (m_bNoActionAvailable != p_Other.m_bNoActionAvailable) return false;
	if (m_bInRange != p_Other.m_bInRange) return false;
	if (m_bIllegalItem != p_Other.m_bIllegalItem) return false;
	if (m_bSuspiciousItem != p_Other.m_bSuspiciousItem) return false;
	if (m_bContainsItem != p_Other.m_bContainsItem) return false;
	if (m_nFontSize != p_Other.m_nFontSize) return false;
	if (m_bIsTxtDirReversed != p_Other.m_bIsTxtDirReversed) return false;

	return true;
}

void SInteractionIndicatorInstanceData_SUIControlData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData_SUIControlData*>(p_Object);
	s_Object->~SInteractionIndicatorInstanceData_SUIControlData();
}

ZHMTypeInfo SInteractionIndicatorInstanceData::TypeInfo = ZHMTypeInfo("SInteractionIndicatorInstanceData", sizeof(SInteractionIndicatorInstanceData), alignof(SInteractionIndicatorInstanceData), SInteractionIndicatorInstanceData::WriteSimpleJson, SInteractionIndicatorInstanceData::FromSimpleJson, SInteractionIndicatorInstanceData::Serialize, SInteractionIndicatorInstanceData::Equals, SInteractionIndicatorInstanceData::Destroy);

void SInteractionIndicatorInstanceData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nStableID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStableID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uicData") << ":";
	SInteractionIndicatorInstanceData_SUIControlData::WriteSimpleJson(&s_Object->m_uicData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAnimation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAnimation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRotateIndicator") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRotateIndicator);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vRotation") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vRotation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedDataUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedDataUpdate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bNeedAlphaUpdate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bNeedAlphaUpdate);

	p_Stream << "}";
}

void SInteractionIndicatorInstanceData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInteractionIndicatorInstanceData s_Object {};

	s_Object.m_nStableID = simdjson::from_json_uint32(p_Document["m_nStableID"]);

	{
		SInteractionIndicatorInstanceData_SUIControlData s_Item {};
		SInteractionIndicatorInstanceData_SUIControlData::FromSimpleJson(p_Document["m_uicData"], &s_Item);
		s_Object.m_uicData = s_Item;
	}

	s_Object.m_fAnimation = simdjson::from_json_float32(p_Document["m_fAnimation"]);

	s_Object.m_bRotateIndicator = simdjson::from_json_bool(p_Document["m_bRotateIndicator"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vRotation"], &s_Item);
		s_Object.m_vRotation = s_Item;
	}

	s_Object.m_bNeedDataUpdate = simdjson::from_json_bool(p_Document["m_bNeedDataUpdate"]);

	s_Object.m_bNeedAlphaUpdate = simdjson::from_json_bool(p_Document["m_bNeedAlphaUpdate"]);

	*reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Target) = s_Object;
}

void SInteractionIndicatorInstanceData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);

	SInteractionIndicatorInstanceData_SUIControlData::Serialize(&s_Object->m_uicData, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_uicData));
	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_vPosition));
	SVector3::Serialize(&s_Object->m_vRotation, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceData, m_vRotation));
}

bool SInteractionIndicatorInstanceData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInteractionIndicatorInstanceData::operator==(const SInteractionIndicatorInstanceData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInteractionIndicatorInstanceData>)
		return false;

	if (m_nStableID != p_Other.m_nStableID) return false;
	if (m_uicData != p_Other.m_uicData) return false;
	if (m_fAnimation != p_Other.m_fAnimation) return false;
	if (m_bRotateIndicator != p_Other.m_bRotateIndicator) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vRotation != p_Other.m_vRotation) return false;
	if (m_bNeedDataUpdate != p_Other.m_bNeedDataUpdate) return false;
	if (m_bNeedAlphaUpdate != p_Other.m_bNeedAlphaUpdate) return false;

	return true;
}

void SInteractionIndicatorInstanceData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceData*>(p_Object);
	s_Object->~SInteractionIndicatorInstanceData();
}

ZHMTypeInfo SInteractionIndicatorInstanceDataArray_Dummy::TypeInfo = ZHMTypeInfo("SInteractionIndicatorInstanceDataArray_Dummy", sizeof(SInteractionIndicatorInstanceDataArray_Dummy), alignof(SInteractionIndicatorInstanceDataArray_Dummy), SInteractionIndicatorInstanceDataArray_Dummy::WriteSimpleJson, SInteractionIndicatorInstanceDataArray_Dummy::FromSimpleJson, SInteractionIndicatorInstanceDataArray_Dummy::Serialize, SInteractionIndicatorInstanceDataArray_Dummy::Equals, SInteractionIndicatorInstanceDataArray_Dummy::Destroy);

void SInteractionIndicatorInstanceDataArray_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->dummy[i];
		SInteractionIndicatorInstanceData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInteractionIndicatorInstanceDataArray_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInteractionIndicatorInstanceDataArray_Dummy s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["dummy"];
	s_Object.dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInteractionIndicatorInstanceData s_ArrayItem0;
		SInteractionIndicatorInstanceData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Target) = s_Object;
}

void SInteractionIndicatorInstanceDataArray_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);

	TArray<SInteractionIndicatorInstanceData>::Serialize(&s_Object->dummy, p_Serializer, p_OwnOffset + offsetof(SInteractionIndicatorInstanceDataArray_Dummy, dummy));
}

bool SInteractionIndicatorInstanceDataArray_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInteractionIndicatorInstanceDataArray_Dummy::operator==(const SInteractionIndicatorInstanceDataArray_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInteractionIndicatorInstanceDataArray_Dummy>)
		return false;

	if (dummy != p_Other.dummy) return false;

	return true;
}

void SInteractionIndicatorInstanceDataArray_Dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInteractionIndicatorInstanceDataArray_Dummy*>(p_Object);
	s_Object->~SInteractionIndicatorInstanceDataArray_Dummy();
}

ZHMTypeInfo SInventoryControllerItemSaveData::TypeInfo = ZHMTypeInfo("SInventoryControllerItemSaveData", sizeof(SInventoryControllerItemSaveData), alignof(SInventoryControllerItemSaveData), SInventoryControllerItemSaveData::WriteSimpleJson, SInventoryControllerItemSaveData::FromSimpleJson, SInventoryControllerItemSaveData::Serialize, SInventoryControllerItemSaveData::Equals, SInventoryControllerItemSaveData::Destroy);

void SInventoryControllerItemSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItemEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItemEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmo);

	p_Stream << "}";
}

void SInventoryControllerItemSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryControllerItemSaveData s_Object {};

	s_Object.m_rItemEntity = simdjson::from_json_uint32(p_Document["m_rItemEntity"]);

	s_Object.m_nAmmo = simdjson::from_json_uint32(p_Document["m_nAmmo"]);

	*reinterpret_cast<SInventoryControllerItemSaveData*>(p_Target) = s_Object;
}

void SInventoryControllerItemSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);

}

bool SInventoryControllerItemSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryControllerItemSaveData::operator==(const SInventoryControllerItemSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryControllerItemSaveData>)
		return false;

	if (m_rItemEntity != p_Other.m_rItemEntity) return false;
	if (m_nAmmo != p_Other.m_nAmmo) return false;

	return true;
}

void SInventoryControllerItemSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerItemSaveData*>(p_Object);
	s_Object->~SInventoryControllerItemSaveData();
}

ZHMTypeInfo SInventoryControllerSlotSaveData::TypeInfo = ZHMTypeInfo("SInventoryControllerSlotSaveData", sizeof(SInventoryControllerSlotSaveData), alignof(SInventoryControllerSlotSaveData), SInventoryControllerSlotSaveData::WriteSimpleJson, SInventoryControllerSlotSaveData::FromSimpleJson, SInventoryControllerSlotSaveData::Serialize, SInventoryControllerSlotSaveData::Equals, SInventoryControllerSlotSaveData::Destroy);

void SInventoryControllerSlotSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSlotSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		SInventoryControllerItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStorageType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInventoryStorageType", static_cast<int>(s_Object->m_eStorageType)));

	p_Stream << "}";
}

void SInventoryControllerSlotSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryControllerSlotSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aItems"];
	s_Object.m_aItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInventoryControllerItemSaveData s_ArrayItem0;
		SInventoryControllerItemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItems[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_eStorageType = static_cast<EInventoryStorageType>(ZHMEnums::GetEnumValueByName("EInventoryStorageType", std::string_view(p_Document["m_eStorageType"])));

	*reinterpret_cast<SInventoryControllerSlotSaveData*>(p_Target) = s_Object;
}

void SInventoryControllerSlotSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSlotSaveData*>(p_Object);

	TArray<SInventoryControllerItemSaveData>::Serialize(&s_Object->m_aItems, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSlotSaveData, m_aItems));
}

bool SInventoryControllerSlotSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryControllerSlotSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryControllerSlotSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryControllerSlotSaveData::operator==(const SInventoryControllerSlotSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryControllerSlotSaveData>)
		return false;

	if (m_aItems != p_Other.m_aItems) return false;
	if (m_eStorageType != p_Other.m_eStorageType) return false;

	return true;
}

void SInventoryControllerSlotSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSlotSaveData*>(p_Object);
	s_Object->~SInventoryControllerSlotSaveData();
}

ZHMTypeInfo SStoredSlotSaveData::TypeInfo = ZHMTypeInfo("SStoredSlotSaveData", sizeof(SStoredSlotSaveData), alignof(SStoredSlotSaveData), SStoredSlotSaveData::WriteSimpleJson, SStoredSlotSaveData::FromSimpleJson, SStoredSlotSaveData::Serialize, SStoredSlotSaveData::Equals, SStoredSlotSaveData::Destroy);

void SStoredSlotSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iStoredInventorySlotIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iStoredInventorySlotIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iStoreReason") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iStoreReason);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItemsStored") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemsStored);

	p_Stream << "}";
}

void SStoredSlotSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStoredSlotSaveData s_Object {};

	s_Object.m_iStoredInventorySlotIndex = simdjson::from_json_uint32(p_Document["m_iStoredInventorySlotIndex"]);

	s_Object.m_iStoreReason = simdjson::from_json_uint8(p_Document["m_iStoreReason"]);

	s_Object.m_bItemsStored = simdjson::from_json_bool(p_Document["m_bItemsStored"]);

	*reinterpret_cast<SStoredSlotSaveData*>(p_Target) = s_Object;
}

void SStoredSlotSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);

}

bool SStoredSlotSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStoredSlotSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStoredSlotSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStoredSlotSaveData::operator==(const SStoredSlotSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStoredSlotSaveData>)
		return false;

	if (m_iStoredInventorySlotIndex != p_Other.m_iStoredInventorySlotIndex) return false;
	if (m_iStoreReason != p_Other.m_iStoreReason) return false;
	if (m_bItemsStored != p_Other.m_bItemsStored) return false;

	return true;
}

void SStoredSlotSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SStoredSlotSaveData*>(p_Object);
	s_Object->~SStoredSlotSaveData();
}

ZHMTypeInfo SInventoryControllerSaveData::TypeInfo = ZHMTypeInfo("SInventoryControllerSaveData", sizeof(SInventoryControllerSaveData), alignof(SInventoryControllerSaveData), SInventoryControllerSaveData::WriteSimpleJson, SInventoryControllerSaveData::FromSimpleJson, SInventoryControllerSaveData::Serialize, SInventoryControllerSaveData::Equals, SInventoryControllerSaveData::Destroy);

void SInventoryControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItems[i];
		SInventoryControllerItemSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEquippedItemIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEquippedItemIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nMostRecentItemIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nMostRecentItemIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StoredSlot") << ":";
	SStoredSlotSaveData::WriteSimpleJson(&s_Object->m_StoredSlot, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSlots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSlots.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSlots[i];
		SInventoryControllerSlotSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSlots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aPendingPickupItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPendingPickupItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPendingPickupItems[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aPendingPickupItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountGun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountGun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRevolver") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRevolver);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountSMG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountSMG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRifle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRifle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountShotgun") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountShotgun);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountSniper") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountSniper);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountMG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountMG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountRPG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountRPG);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountFake") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountFake);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountLightPistol") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountLightPistol);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountDartTranquilizer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountDartTranquilizer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nAmmoCountAmmoShotgunBeanbag") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nAmmoCountAmmoShotgunBeanbag);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAmmoIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAmmoIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAmmoIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAmmoIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAmmoCounts") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAmmoCounts.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAmmoCounts[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAmmoCounts.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInventoryControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryControllerSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aItems"];
	s_Object.m_aItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInventoryControllerItemSaveData s_ArrayItem0;
		SInventoryControllerItemSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItems[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_nEquippedItemIndex = simdjson::from_json_uint32(p_Document["m_nEquippedItemIndex"]);

	s_Object.m_nMostRecentItemIndex = simdjson::from_json_uint32(p_Document["m_nMostRecentItemIndex"]);

	{
		SStoredSlotSaveData s_Item {};
		SStoredSlotSaveData::FromSimpleJson(p_Document["m_StoredSlot"], &s_Item);
		s_Object.m_StoredSlot = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSlots"];
	s_Object.m_aSlots.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInventoryControllerSlotSaveData s_ArrayItem0;
		SInventoryControllerSlotSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSlots[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPendingPickupItems"];
	s_Object.m_aPendingPickupItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aPendingPickupItems[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_nAmmoCountGun = simdjson::from_json_uint32(p_Document["m_nAmmoCountGun"]);

	s_Object.m_nAmmoCountRevolver = simdjson::from_json_uint32(p_Document["m_nAmmoCountRevolver"]);

	s_Object.m_nAmmoCountSMG = simdjson::from_json_uint32(p_Document["m_nAmmoCountSMG"]);

	s_Object.m_nAmmoCountRifle = simdjson::from_json_uint32(p_Document["m_nAmmoCountRifle"]);

	s_Object.m_nAmmoCountShotgun = simdjson::from_json_uint32(p_Document["m_nAmmoCountShotgun"]);

	s_Object.m_nAmmoCountSniper = simdjson::from_json_uint32(p_Document["m_nAmmoCountSniper"]);

	s_Object.m_nAmmoCountMG = simdjson::from_json_uint32(p_Document["m_nAmmoCountMG"]);

	s_Object.m_nAmmoCountRPG = simdjson::from_json_uint32(p_Document["m_nAmmoCountRPG"]);

	s_Object.m_nAmmoCountFake = simdjson::from_json_uint32(p_Document["m_nAmmoCountFake"]);

	s_Object.m_nAmmoCountLightPistol = simdjson::from_json_uint32(p_Document["m_nAmmoCountLightPistol"]);

	s_Object.m_nAmmoCountDartTranquilizer = simdjson::from_json_uint32(p_Document["m_nAmmoCountDartTranquilizer"]);

	s_Object.m_nAmmoCountAmmoShotgunBeanbag = simdjson::from_json_uint32(p_Document["m_nAmmoCountAmmoShotgunBeanbag"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAmmoIds"];
	s_Object.m_aAmmoIds.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAmmoIds[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAmmoCounts"];
	s_Object.m_aAmmoCounts.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aAmmoCounts[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SInventoryControllerSaveData*>(p_Target) = s_Object;
}

void SInventoryControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);

	TArray<SInventoryControllerItemSaveData>::Serialize(&s_Object->m_aItems, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_aItems));
	SStoredSlotSaveData::Serialize(&s_Object->m_StoredSlot, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_StoredSlot));
	TArray<SInventoryControllerSlotSaveData>::Serialize(&s_Object->m_aSlots, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_aSlots));
	TArray<uint32>::Serialize(&s_Object->m_aPendingPickupItems, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_aPendingPickupItems));
	TArray<ZRepositoryID>::Serialize(&s_Object->m_aAmmoIds, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_aAmmoIds));
	TArray<uint32>::Serialize(&s_Object->m_aAmmoCounts, p_Serializer, p_OwnOffset + offsetof(SInventoryControllerSaveData, m_aAmmoCounts));
}

bool SInventoryControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryControllerSaveData::operator==(const SInventoryControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryControllerSaveData>)
		return false;

	if (m_aItems != p_Other.m_aItems) return false;
	if (m_nEquippedItemIndex != p_Other.m_nEquippedItemIndex) return false;
	if (m_nMostRecentItemIndex != p_Other.m_nMostRecentItemIndex) return false;
	if (m_StoredSlot != p_Other.m_StoredSlot) return false;
	if (m_aSlots != p_Other.m_aSlots) return false;
	if (m_aPendingPickupItems != p_Other.m_aPendingPickupItems) return false;
	if (m_nAmmoCountGun != p_Other.m_nAmmoCountGun) return false;
	if (m_nAmmoCountRevolver != p_Other.m_nAmmoCountRevolver) return false;
	if (m_nAmmoCountSMG != p_Other.m_nAmmoCountSMG) return false;
	if (m_nAmmoCountRifle != p_Other.m_nAmmoCountRifle) return false;
	if (m_nAmmoCountShotgun != p_Other.m_nAmmoCountShotgun) return false;
	if (m_nAmmoCountSniper != p_Other.m_nAmmoCountSniper) return false;
	if (m_nAmmoCountMG != p_Other.m_nAmmoCountMG) return false;
	if (m_nAmmoCountRPG != p_Other.m_nAmmoCountRPG) return false;
	if (m_nAmmoCountFake != p_Other.m_nAmmoCountFake) return false;
	if (m_nAmmoCountLightPistol != p_Other.m_nAmmoCountLightPistol) return false;
	if (m_nAmmoCountDartTranquilizer != p_Other.m_nAmmoCountDartTranquilizer) return false;
	if (m_nAmmoCountAmmoShotgunBeanbag != p_Other.m_nAmmoCountAmmoShotgunBeanbag) return false;
	if (m_aAmmoIds != p_Other.m_aAmmoIds) return false;
	if (m_aAmmoCounts != p_Other.m_aAmmoCounts) return false;

	return true;
}

void SInventoryControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryControllerSaveData*>(p_Object);
	s_Object->~SInventoryControllerSaveData();
}

ZHMTypeInfo SInventoryInfo::TypeInfo = ZHMTypeInfo("SInventoryInfo", sizeof(SInventoryInfo), alignof(SInventoryInfo), SInventoryInfo::WriteSimpleJson, SInventoryInfo::FromSimpleJson, SInventoryInfo::Serialize, SInventoryInfo::Equals, SInventoryInfo::Destroy);

void SInventoryInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aPockets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aPockets.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aPockets[i];
		SInventoryItem::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aPockets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CarriedItem") << ":";
	SInventoryItem::WriteSimpleJson(&s_Object->m_CarriedItem, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aContainerItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aContainerItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aContainerItems[i];
		SContainerItemInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aContainerItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInventoryInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryInfo s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aPockets"];
	s_Object.m_aPockets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInventoryItem s_ArrayItem0;
		SInventoryItem::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aPockets[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		SInventoryItem s_Item {};
		SInventoryItem::FromSimpleJson(p_Document["m_CarriedItem"], &s_Item);
		s_Object.m_CarriedItem = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aContainerItems"];
	s_Object.m_aContainerItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SContainerItemInfo s_ArrayItem0;
		SContainerItemInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aContainerItems[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SInventoryInfo*>(p_Target) = s_Object;
}

void SInventoryInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryInfo*>(p_Object);

	TArray<SInventoryItem>::Serialize(&s_Object->m_aPockets, p_Serializer, p_OwnOffset + offsetof(SInventoryInfo, m_aPockets));
	SInventoryItem::Serialize(&s_Object->m_CarriedItem, p_Serializer, p_OwnOffset + offsetof(SInventoryInfo, m_CarriedItem));
	TArray<SContainerItemInfo>::Serialize(&s_Object->m_aContainerItems, p_Serializer, p_OwnOffset + offsetof(SInventoryInfo, m_aContainerItems));
}

bool SInventoryInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryInfo::operator==(const SInventoryInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryInfo>)
		return false;

	if (m_aPockets != p_Other.m_aPockets) return false;
	if (m_CarriedItem != p_Other.m_CarriedItem) return false;
	if (m_aContainerItems != p_Other.m_aContainerItems) return false;

	return true;
}

void SInventoryInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryInfo*>(p_Object);
	s_Object->~SInventoryInfo();
}

ZHMTypeInfo SInventoryMovementConfig::TypeInfo = ZHMTypeInfo("SInventoryMovementConfig", sizeof(SInventoryMovementConfig), alignof(SInventoryMovementConfig), SInventoryMovementConfig::WriteSimpleJson, SInventoryMovementConfig::FromSimpleJson, SInventoryMovementConfig::Serialize, SInventoryMovementConfig::Equals, SInventoryMovementConfig::Destroy);

void SInventoryMovementConfig::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryMovementConfig*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eItemHandlingRightHand") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInventoryConfigItemHandling", static_cast<int>(s_Object->m_eItemHandlingRightHand)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eItemHandlingLeftHand") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInventoryConfigItemHandling", static_cast<int>(s_Object->m_eItemHandlingLeftHand)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eFormerEquippedItems") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInventoryConfigFormerEquippedItems", static_cast<int>(s_Object->m_eFormerEquippedItems)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCustomRule") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EInventoryConfigCustomRule", static_cast<int>(s_Object->m_eCustomRule)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDropBackHolsteredItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDropBackHolsteredItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSlowAnimation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSlowAnimation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceInstantInventoryChange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceInstantInventoryChange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCancelIfInventoryInUse") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCancelIfInventoryInUse);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSafeDrop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSafeDrop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vSafeDropPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vSafeDropPosition, p_Stream);

	p_Stream << "}";
}

void SInventoryMovementConfig::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryMovementConfig s_Object {};

	s_Object.m_eItemHandlingRightHand = static_cast<EInventoryConfigItemHandling>(ZHMEnums::GetEnumValueByName("EInventoryConfigItemHandling", std::string_view(p_Document["m_eItemHandlingRightHand"])));

	s_Object.m_eItemHandlingLeftHand = static_cast<EInventoryConfigItemHandling>(ZHMEnums::GetEnumValueByName("EInventoryConfigItemHandling", std::string_view(p_Document["m_eItemHandlingLeftHand"])));

	s_Object.m_eFormerEquippedItems = static_cast<EInventoryConfigFormerEquippedItems>(ZHMEnums::GetEnumValueByName("EInventoryConfigFormerEquippedItems", std::string_view(p_Document["m_eFormerEquippedItems"])));

	s_Object.m_eCustomRule = static_cast<EInventoryConfigCustomRule>(ZHMEnums::GetEnumValueByName("EInventoryConfigCustomRule", std::string_view(p_Document["m_eCustomRule"])));

	s_Object.m_bDropBackHolsteredItem = simdjson::from_json_bool(p_Document["m_bDropBackHolsteredItem"]);

	s_Object.m_bSlowAnimation = simdjson::from_json_bool(p_Document["m_bSlowAnimation"]);

	s_Object.m_bForceInstantInventoryChange = simdjson::from_json_bool(p_Document["m_bForceInstantInventoryChange"]);

	s_Object.m_bCancelIfInventoryInUse = simdjson::from_json_bool(p_Document["m_bCancelIfInventoryInUse"]);

	s_Object.m_bSafeDrop = simdjson::from_json_bool(p_Document["m_bSafeDrop"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vSafeDropPosition"], &s_Item);
		s_Object.m_vSafeDropPosition = s_Item;
	}

	*reinterpret_cast<SInventoryMovementConfig*>(p_Target) = s_Object;
}

void SInventoryMovementConfig::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryMovementConfig*>(p_Object);

	float4::Serialize(&s_Object->m_vSafeDropPosition, p_Serializer, p_OwnOffset + offsetof(SInventoryMovementConfig, m_vSafeDropPosition));
}

bool SInventoryMovementConfig::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryMovementConfig*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryMovementConfig*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryMovementConfig::operator==(const SInventoryMovementConfig& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryMovementConfig>)
		return false;

	if (m_eItemHandlingRightHand != p_Other.m_eItemHandlingRightHand) return false;
	if (m_eItemHandlingLeftHand != p_Other.m_eItemHandlingLeftHand) return false;
	if (m_eFormerEquippedItems != p_Other.m_eFormerEquippedItems) return false;
	if (m_eCustomRule != p_Other.m_eCustomRule) return false;
	if (m_bDropBackHolsteredItem != p_Other.m_bDropBackHolsteredItem) return false;
	if (m_bSlowAnimation != p_Other.m_bSlowAnimation) return false;
	if (m_bForceInstantInventoryChange != p_Other.m_bForceInstantInventoryChange) return false;
	if (m_bCancelIfInventoryInUse != p_Other.m_bCancelIfInventoryInUse) return false;
	if (m_bSafeDrop != p_Other.m_bSafeDrop) return false;
	if (m_vSafeDropPosition != p_Other.m_vSafeDropPosition) return false;

	return true;
}

void SInventoryMovementConfig::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryMovementConfig*>(p_Object);
	s_Object->~SInventoryMovementConfig();
}

ZHMTypeInfo SInventoryUISlotSlim::TypeInfo = ZHMTypeInfo("SInventoryUISlotSlim", sizeof(SInventoryUISlotSlim), alignof(SInventoryUISlotSlim), SInventoryUISlotSlim::WriteSimpleJson, SInventoryUISlotSlim::FromSimpleJson, SInventoryUISlotSlim::Serialize, SInventoryUISlotSlim::Equals, SInventoryUISlotSlim::Destroy);

void SInventoryUISlotSlim::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlotSlim*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZVariant::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedIcon") << ":";
	ZVariant::WriteSimpleJson(&s_Object->containedIcon, p_Stream);

	p_Stream << "}";
}

void SInventoryUISlotSlim::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryUISlotSlim s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["containedIcon"], &s_Item);
		s_Object.containedIcon = s_Item;
	}

	*reinterpret_cast<SInventoryUISlotSlim*>(p_Target) = s_Object;
}

void SInventoryUISlotSlim::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlotSlim*>(p_Object);

	ZVariant::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlotSlim, icon));
	ZVariant::Serialize(&s_Object->containedIcon, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlotSlim, containedIcon));
}

bool SInventoryUISlotSlim::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryUISlotSlim*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryUISlotSlim*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryUISlotSlim::operator==(const SInventoryUISlotSlim& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryUISlotSlim>)
		return false;

	if (icon != p_Other.icon) return false;
	if (containedIcon != p_Other.containedIcon) return false;

	return true;
}

void SInventoryUISlotSlim::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlotSlim*>(p_Object);
	s_Object->~SInventoryUISlotSlim();
}

ZHMTypeInfo SInventoryUI::TypeInfo = ZHMTypeInfo("SInventoryUI", sizeof(SInventoryUI), alignof(SInventoryUI), SInventoryUI::WriteSimpleJson, SInventoryUI::FromSimpleJson, SInventoryUI::Serialize, SInventoryUI::Equals, SInventoryUI::Destroy);

void SInventoryUI::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryUI*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mainslotsSlim") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslotsSlim.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslotsSlim[i];
		SInventoryUISlotSlim::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->mainslotsSlim.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslotsCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->otherslotsCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selectedIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->selectedIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isActionInventory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isActionInventory);

	p_Stream << "}";
}

void SInventoryUI::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryUI s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["mainslotsSlim"];
	s_Object.mainslotsSlim.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInventoryUISlotSlim s_ArrayItem0;
		SInventoryUISlotSlim::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.mainslotsSlim[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.otherslotsCount = simdjson::from_json_int32(p_Document["otherslotsCount"]);

	s_Object.selectedIndex = simdjson::from_json_int32(p_Document["selectedIndex"]);

	s_Object.isActionInventory = simdjson::from_json_bool(p_Document["isActionInventory"]);

	*reinterpret_cast<SInventoryUI*>(p_Target) = s_Object;
}

void SInventoryUI::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryUI*>(p_Object);

	TArray<SInventoryUISlotSlim>::Serialize(&s_Object->mainslotsSlim, p_Serializer, p_OwnOffset + offsetof(SInventoryUI, mainslotsSlim));
}

bool SInventoryUI::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryUI*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryUI*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryUI::operator==(const SInventoryUI& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryUI>)
		return false;

	if (mainslotsSlim != p_Other.mainslotsSlim) return false;
	if (otherslotsCount != p_Other.otherslotsCount) return false;
	if (selectedIndex != p_Other.selectedIndex) return false;
	if (isActionInventory != p_Other.isActionInventory) return false;

	return true;
}

void SInventoryUI::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryUI*>(p_Object);
	s_Object->~SInventoryUI();
}

ZHMTypeInfo SInventoryUISlot::TypeInfo = ZHMTypeInfo("SInventoryUISlot", sizeof(SInventoryUISlot), alignof(SInventoryUISlot), SInventoryUISlot::WriteSimpleJson, SInventoryUISlot::FromSimpleJson, SInventoryUISlot::Serialize, SInventoryUISlot::Equals, SInventoryUISlot::Destroy);

void SInventoryUISlot::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlot*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->containedLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("description") << ":";
	p_Stream << simdjson::as_json_string(s_Object->description);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("perks") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->perks.size(); ++i)
	{
		auto& s_Item0 = s_Object->perks[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->perks.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("silencer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->silencer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("count") << ":";
	p_Stream << simdjson::as_json_string(s_Object->count);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ammo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ammo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("id") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("weaponCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->weaponCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nItemHUDType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nItemHUDType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategoryLKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategoryLKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inventoryCategoryIcon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->inventoryCategoryIcon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isDroppable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isDroppable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isContainer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isContainer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containsItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->containsItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nContainedItemHUDType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nContainedItemHUDType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bContainedItemIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bContainedItemIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bContainedItemSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bContainedItemSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bContainedItemDetectedDuringFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bContainedItemDetectedDuringFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("detectedDuringFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->detectedDuringFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("actionAndKillTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->actionAndKillTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->actionAndKillTypes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->actionAndKillTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("suspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->suspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("illegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->illegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("canReload") << ":";
	p_Stream << simdjson::as_json_string(s_Object->canReload);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sPoisonType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sPoisonType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("evergreenRarity") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("eEvergreenItemRarity", static_cast<int>(s_Object->evergreenRarity)));

	p_Stream << "}";
}

void SInventoryUISlot::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryUISlot s_Object {};

	s_Object.label = std::string_view(p_Document["label"]);

	s_Object.containedLabel = std::string_view(p_Document["containedLabel"]);

	s_Object.description = std::string_view(p_Document["description"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["perks"];
	s_Object.perks.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.perks[s_Index0++] = std::string_view(s_Item0);
	}
	}

	s_Object.silencer = simdjson::from_json_bool(p_Document["silencer"]);

	s_Object.count = simdjson::from_json_int32(p_Document["count"]);

	s_Object.ammo = simdjson::from_json_int32(p_Document["ammo"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["id"], &s_Item);
		s_Object.id = s_Item;
	}

	s_Object.weaponCategory = std::string_view(p_Document["weaponCategory"]);

	s_Object.nAmmoRemaining = simdjson::from_json_int32(p_Document["nAmmoRemaining"]);

	s_Object.nAmmoTotal = simdjson::from_json_int32(p_Document["nAmmoTotal"]);

	s_Object.nAmmoInClip = simdjson::from_json_int32(p_Document["nAmmoInClip"]);

	s_Object.nWeaponType = simdjson::from_json_int32(p_Document["nWeaponType"]);

	s_Object.nItemHUDType = simdjson::from_json_int32(p_Document["nItemHUDType"]);

	s_Object.itemCategory = std::string_view(p_Document["itemCategory"]);

	s_Object.itemCategoryLKey = std::string_view(p_Document["itemCategoryLKey"]);

	s_Object.inventoryCategoryIcon = std::string_view(p_Document["inventoryCategoryIcon"]);

	s_Object.isDroppable = simdjson::from_json_bool(p_Document["isDroppable"]);

	s_Object.isContainer = simdjson::from_json_bool(p_Document["isContainer"]);

	s_Object.containsItem = simdjson::from_json_bool(p_Document["containsItem"]);

	s_Object.nContainedItemHUDType = simdjson::from_json_int32(p_Document["nContainedItemHUDType"]);

	s_Object.bContainedItemIllegal = simdjson::from_json_bool(p_Document["bContainedItemIllegal"]);

	s_Object.bContainedItemSuspicious = simdjson::from_json_bool(p_Document["bContainedItemSuspicious"]);

	s_Object.bContainedItemDetectedDuringFrisk = simdjson::from_json_bool(p_Document["bContainedItemDetectedDuringFrisk"]);

	s_Object.detectedDuringFrisk = simdjson::from_json_bool(p_Document["detectedDuringFrisk"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["actionAndKillTypes"];
	s_Object.actionAndKillTypes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.actionAndKillTypes[s_Index0++] = std::string_view(s_Item0);
	}
	}

	s_Object.suspicious = simdjson::from_json_bool(p_Document["suspicious"]);

	s_Object.illegal = simdjson::from_json_bool(p_Document["illegal"]);

	s_Object.canReload = simdjson::from_json_bool(p_Document["canReload"]);

	s_Object.sPoisonType = std::string_view(p_Document["sPoisonType"]);

	s_Object.evergreenRarity = static_cast<eEvergreenItemRarity>(ZHMEnums::GetEnumValueByName("eEvergreenItemRarity", std::string_view(p_Document["evergreenRarity"])));

	*reinterpret_cast<SInventoryUISlot*>(p_Target) = s_Object;
}

void SInventoryUISlot::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlot*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, label));
	ZString::Serialize(&s_Object->containedLabel, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, containedLabel));
	ZString::Serialize(&s_Object->description, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, description));
	TArray<ZString>::Serialize(&s_Object->perks, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, perks));
	ZRepositoryID::Serialize(&s_Object->id, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, id));
	ZString::Serialize(&s_Object->weaponCategory, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, weaponCategory));
	ZString::Serialize(&s_Object->itemCategory, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, itemCategory));
	ZString::Serialize(&s_Object->itemCategoryLKey, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, itemCategoryLKey));
	ZString::Serialize(&s_Object->inventoryCategoryIcon, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, inventoryCategoryIcon));
	TArray<ZString>::Serialize(&s_Object->actionAndKillTypes, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, actionAndKillTypes));
	ZString::Serialize(&s_Object->sPoisonType, p_Serializer, p_OwnOffset + offsetof(SInventoryUISlot, sPoisonType));
}

bool SInventoryUISlot::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryUISlot*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryUISlot*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryUISlot::operator==(const SInventoryUISlot& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryUISlot>)
		return false;

	if (label != p_Other.label) return false;
	if (containedLabel != p_Other.containedLabel) return false;
	if (description != p_Other.description) return false;
	if (perks != p_Other.perks) return false;
	if (silencer != p_Other.silencer) return false;
	if (count != p_Other.count) return false;
	if (ammo != p_Other.ammo) return false;
	if (id != p_Other.id) return false;
	if (weaponCategory != p_Other.weaponCategory) return false;
	if (nAmmoRemaining != p_Other.nAmmoRemaining) return false;
	if (nAmmoTotal != p_Other.nAmmoTotal) return false;
	if (nAmmoInClip != p_Other.nAmmoInClip) return false;
	if (nWeaponType != p_Other.nWeaponType) return false;
	if (nItemHUDType != p_Other.nItemHUDType) return false;
	if (itemCategory != p_Other.itemCategory) return false;
	if (itemCategoryLKey != p_Other.itemCategoryLKey) return false;
	if (inventoryCategoryIcon != p_Other.inventoryCategoryIcon) return false;
	if (isDroppable != p_Other.isDroppable) return false;
	if (isContainer != p_Other.isContainer) return false;
	if (containsItem != p_Other.containsItem) return false;
	if (nContainedItemHUDType != p_Other.nContainedItemHUDType) return false;
	if (bContainedItemIllegal != p_Other.bContainedItemIllegal) return false;
	if (bContainedItemSuspicious != p_Other.bContainedItemSuspicious) return false;
	if (bContainedItemDetectedDuringFrisk != p_Other.bContainedItemDetectedDuringFrisk) return false;
	if (detectedDuringFrisk != p_Other.detectedDuringFrisk) return false;
	if (actionAndKillTypes != p_Other.actionAndKillTypes) return false;
	if (suspicious != p_Other.suspicious) return false;
	if (illegal != p_Other.illegal) return false;
	if (canReload != p_Other.canReload) return false;
	if (sPoisonType != p_Other.sPoisonType) return false;
	if (evergreenRarity != p_Other.evergreenRarity) return false;

	return true;
}

void SInventoryUISlot::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryUISlot*>(p_Object);
	s_Object->~SInventoryUISlot();
}

ZHMTypeInfo SInventoryUICache::TypeInfo = ZHMTypeInfo("SInventoryUICache", sizeof(SInventoryUICache), alignof(SInventoryUICache), SInventoryUICache::WriteSimpleJson, SInventoryUICache::FromSimpleJson, SInventoryUICache::Serialize, SInventoryUICache::Equals, SInventoryUICache::Destroy);

void SInventoryUICache::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInventoryUICache*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mainslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslots[i];
		SInventoryUISlot::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->mainslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->otherslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->otherslots[i];
		SInventoryUISlot::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->otherslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInventoryUICache::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInventoryUICache s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["mainslots"];
	s_Object.mainslots.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInventoryUISlot s_ArrayItem0;
		SInventoryUISlot::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.mainslots[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["otherslots"];
	s_Object.otherslots.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SInventoryUISlot s_ArrayItem0;
		SInventoryUISlot::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.otherslots[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SInventoryUICache*>(p_Target) = s_Object;
}

void SInventoryUICache::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInventoryUICache*>(p_Object);

	TArray<SInventoryUISlot>::Serialize(&s_Object->mainslots, p_Serializer, p_OwnOffset + offsetof(SInventoryUICache, mainslots));
	TArray<SInventoryUISlot>::Serialize(&s_Object->otherslots, p_Serializer, p_OwnOffset + offsetof(SInventoryUICache, otherslots));
}

bool SInventoryUICache::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInventoryUICache*>(p_Left);
	auto* s_Right = reinterpret_cast<SInventoryUICache*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInventoryUICache::operator==(const SInventoryUICache& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInventoryUICache>)
		return false;

	if (mainslots != p_Other.mainslots) return false;
	if (otherslots != p_Other.otherslots) return false;

	return true;
}

void SInventoryUICache::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInventoryUICache*>(p_Object);
	s_Object->~SInventoryUICache();
}

ZHMTypeInfo ZInvestigateDisguiseGroup_SDialogLines::TypeInfo = ZHMTypeInfo("ZInvestigateDisguiseGroup.SDialogLines", sizeof(ZInvestigateDisguiseGroup_SDialogLines), alignof(ZInvestigateDisguiseGroup_SDialogLines), ZInvestigateDisguiseGroup_SDialogLines::WriteSimpleJson, ZInvestigateDisguiseGroup_SDialogLines::FromSimpleJson, ZInvestigateDisguiseGroup_SDialogLines::Serialize, ZInvestigateDisguiseGroup_SDialogLines::Equals, ZInvestigateDisguiseGroup_SDialogLines::Destroy);

void ZInvestigateDisguiseGroup_SDialogLines::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFirstWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorSoundDefs", static_cast<int>(s_Object->m_eFirstWarning)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eSecondWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorSoundDefs", static_cast<int>(s_Object->m_eSecondWarning)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eThirdWarning") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorSoundDefs", static_cast<int>(s_Object->m_eThirdWarning)));

	p_Stream << "}";
}

void ZInvestigateDisguiseGroup_SDialogLines::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInvestigateDisguiseGroup_SDialogLines s_Object {};

	s_Object.m_eFirstWarning = static_cast<EActorSoundDefs>(ZHMEnums::GetEnumValueByName("EActorSoundDefs", std::string_view(p_Document["m_eFirstWarning"])));

	s_Object.m_eSecondWarning = static_cast<EActorSoundDefs>(ZHMEnums::GetEnumValueByName("EActorSoundDefs", std::string_view(p_Document["m_eSecondWarning"])));

	s_Object.m_eThirdWarning = static_cast<EActorSoundDefs>(ZHMEnums::GetEnumValueByName("EActorSoundDefs", std::string_view(p_Document["m_eThirdWarning"])));

	*reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Target) = s_Object;
}

void ZInvestigateDisguiseGroup_SDialogLines::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Object);

}

bool ZInvestigateDisguiseGroup_SDialogLines::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateDisguiseGroup_SDialogLines::operator==(const ZInvestigateDisguiseGroup_SDialogLines& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateDisguiseGroup_SDialogLines>)
		return false;

	if (m_eFirstWarning != p_Other.m_eFirstWarning) return false;
	if (m_eSecondWarning != p_Other.m_eSecondWarning) return false;
	if (m_eThirdWarning != p_Other.m_eThirdWarning) return false;

	return true;
}

void ZInvestigateDisguiseGroup_SDialogLines::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInvestigateDisguiseGroup_SDialogLines*>(p_Object);
	s_Object->~ZInvestigateDisguiseGroup_SDialogLines();
}

ZHMTypeInfo SInvestigateDisguiseGroupSaveData::TypeInfo = ZHMTypeInfo("SInvestigateDisguiseGroupSaveData", sizeof(SInvestigateDisguiseGroupSaveData), alignof(SInvestigateDisguiseGroupSaveData), SInvestigateDisguiseGroupSaveData::WriteSimpleJson, SInvestigateDisguiseGroupSaveData::FromSimpleJson, SInvestigateDisguiseGroupSaveData::Serialize, SInvestigateDisguiseGroupSaveData::Equals, SInvestigateDisguiseGroupSaveData::Destroy);

void SInvestigateDisguiseGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_state") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInvestigateDisguiseGroup.EState", static_cast<int>(s_Object->m_state)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pPendingLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pPendingLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStart") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStart, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_groupAge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_groupAge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDisguiseFollowTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDisguiseFollowTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastWarning") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastWarning, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eLeaderMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZMoveToOrder.EMoveSpeed", static_cast<int>(s_Object->m_eLeaderMoveSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDownOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastStandDownOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartFollow") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartFollow, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vOriginalPositionLeader") << ":";
	float4::WriteSimpleJson(&s_Object->m_vOriginalPositionLeader, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_dialogLines") << ":";
	ZInvestigateDisguiseGroup_SDialogLines::WriteSimpleJson(&s_Object->m_dialogLines, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSearchCompleted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSearchCompleted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeaderMovingBack") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeaderMovingBack);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitingForDistanceStanddown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitingForDistanceStanddown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFollow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFollow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMembersFollow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMembersFollow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunningWarningIssued") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunningWarningIssued);

	p_Stream << "}";
}

void SInvestigateDisguiseGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInvestigateDisguiseGroupSaveData s_Object {};

	s_Object.m_state = static_cast<ZInvestigateDisguiseGroup_EState>(ZHMEnums::GetEnumValueByName("ZInvestigateDisguiseGroup.EState", std::string_view(p_Document["m_state"])));

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_pPendingLeader = simdjson::from_json_uint32(p_Document["m_pPendingLeader"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStart"], &s_Item);
		s_Object.m_tStart = s_Item;
	}

	s_Object.m_groupAge = simdjson::from_json_float32(p_Document["m_groupAge"]);

	s_Object.m_fDisguiseFollowTime = simdjson::from_json_float32(p_Document["m_fDisguiseFollowTime"]);

	s_Object.m_fTargetRunningTime = simdjson::from_json_float32(p_Document["m_fTargetRunningTime"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastWarning"], &s_Item);
		s_Object.m_tLastWarning = s_Item;
	}

	s_Object.m_iWarningCount = simdjson::from_json_int32(p_Document["m_iWarningCount"]);

	s_Object.m_eLeaderMoveSpeed = static_cast<ZMoveToOrder_EMoveSpeed>(ZHMEnums::GetEnumValueByName("ZMoveToOrder.EMoveSpeed", std::string_view(p_Document["m_eLeaderMoveSpeed"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Item);
		s_Object.m_tLastEscalateOrder = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastStandDownOrder"], &s_Item);
		s_Object.m_tLastStandDownOrder = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStartFollow"], &s_Item);
		s_Object.m_tStartFollow = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vOriginalPositionLeader"], &s_Item);
		s_Object.m_vOriginalPositionLeader = s_Item;
	}

	{
		ZInvestigateDisguiseGroup_SDialogLines s_Item {};
		ZInvestigateDisguiseGroup_SDialogLines::FromSimpleJson(p_Document["m_dialogLines"], &s_Item);
		s_Object.m_dialogLines = s_Item;
	}

	s_Object.m_bLeaderOrderAssigned = simdjson::from_json_bool(p_Document["m_bLeaderOrderAssigned"]);

	s_Object.m_bSearchCompleted = simdjson::from_json_bool(p_Document["m_bSearchCompleted"]);

	s_Object.m_bLeaderMovingBack = simdjson::from_json_bool(p_Document["m_bLeaderMovingBack"]);

	s_Object.m_bWaitingForDistanceStanddown = simdjson::from_json_bool(p_Document["m_bWaitingForDistanceStanddown"]);

	s_Object.m_bFollow = simdjson::from_json_bool(p_Document["m_bFollow"]);

	s_Object.m_bMembersFollow = simdjson::from_json_bool(p_Document["m_bMembersFollow"]);

	s_Object.m_bRunningWarningIssued = simdjson::from_json_bool(p_Document["m_bRunningWarningIssued"]);

	*reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Target) = s_Object;
}

void SInvestigateDisguiseGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tStart, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tStart));
	ZGameTime::Serialize(&s_Object->m_tLastWarning, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastWarning));
	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastEscalateOrder));
	ZGameTime::Serialize(&s_Object->m_tLastStandDownOrder, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tLastStandDownOrder));
	ZGameTime::Serialize(&s_Object->m_tStartFollow, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_tStartFollow));
	float4::Serialize(&s_Object->m_vOriginalPositionLeader, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_vOriginalPositionLeader));
	ZInvestigateDisguiseGroup_SDialogLines::Serialize(&s_Object->m_dialogLines, p_Serializer, p_OwnOffset + offsetof(SInvestigateDisguiseGroupSaveData, m_dialogLines));
}

bool SInvestigateDisguiseGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInvestigateDisguiseGroupSaveData::operator==(const SInvestigateDisguiseGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInvestigateDisguiseGroupSaveData>)
		return false;

	if (m_state != p_Other.m_state) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_pPendingLeader != p_Other.m_pPendingLeader) return false;
	if (m_tStart != p_Other.m_tStart) return false;
	if (m_groupAge != p_Other.m_groupAge) return false;
	if (m_fDisguiseFollowTime != p_Other.m_fDisguiseFollowTime) return false;
	if (m_fTargetRunningTime != p_Other.m_fTargetRunningTime) return false;
	if (m_tLastWarning != p_Other.m_tLastWarning) return false;
	if (m_iWarningCount != p_Other.m_iWarningCount) return false;
	if (m_eLeaderMoveSpeed != p_Other.m_eLeaderMoveSpeed) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_tLastStandDownOrder != p_Other.m_tLastStandDownOrder) return false;
	if (m_tStartFollow != p_Other.m_tStartFollow) return false;
	if (m_vOriginalPositionLeader != p_Other.m_vOriginalPositionLeader) return false;
	if (m_dialogLines != p_Other.m_dialogLines) return false;
	if (m_bLeaderOrderAssigned != p_Other.m_bLeaderOrderAssigned) return false;
	if (m_bSearchCompleted != p_Other.m_bSearchCompleted) return false;
	if (m_bLeaderMovingBack != p_Other.m_bLeaderMovingBack) return false;
	if (m_bWaitingForDistanceStanddown != p_Other.m_bWaitingForDistanceStanddown) return false;
	if (m_bFollow != p_Other.m_bFollow) return false;
	if (m_bMembersFollow != p_Other.m_bMembersFollow) return false;
	if (m_bRunningWarningIssued != p_Other.m_bRunningWarningIssued) return false;

	return true;
}

void SInvestigateDisguiseGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInvestigateDisguiseGroupSaveData*>(p_Object);
	s_Object->~SInvestigateDisguiseGroupSaveData();
}

ZHMTypeInfo SInvestigateWeaponGroupSaveData::TypeInfo = ZHMTypeInfo("SInvestigateWeaponGroupSaveData", sizeof(SInvestigateWeaponGroupSaveData), alignof(SInvestigateWeaponGroupSaveData), SInvestigateWeaponGroupSaveData::WriteSimpleJson, SInvestigateWeaponGroupSaveData::FromSimpleJson, SInvestigateWeaponGroupSaveData::Serialize, SInvestigateWeaponGroupSaveData::Equals, SInvestigateWeaponGroupSaveData::Destroy);

void SInvestigateWeaponGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rReporter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rReporter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInvestigator") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInvestigator);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rGuard") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rGuard);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ReporterIsVIPWithAmbientEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_ReporterIsVIPWithAmbientEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastGuardSearch") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastGuardSearch, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aUnconsciousGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aUnconsciousGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aUnconsciousGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aUnconsciousGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SInvestigateWeaponGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SInvestigateWeaponGroupSaveData s_Object {};

	s_Object.m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object.m_rReporter = simdjson::from_json_uint32(p_Document["m_rReporter"]);

	s_Object.m_rInvestigator = simdjson::from_json_uint32(p_Document["m_rInvestigator"]);

	s_Object.m_rGuard = simdjson::from_json_uint32(p_Document["m_rGuard"]);

	s_Object.m_ReporterIsVIPWithAmbientEscort = simdjson::from_json_bool(p_Document["m_ReporterIsVIPWithAmbientEscort"]);

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastGuardSearch"], &s_Item);
		s_Object.m_tLastGuardSearch = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aUnconsciousGuards"];
	s_Object.m_aUnconsciousGuards.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aUnconsciousGuards[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Target) = s_Object;
}

void SInvestigateWeaponGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tLastGuardSearch, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_tLastGuardSearch));
	TArray<uint32>::Serialize(&s_Object->m_aUnconsciousGuards, p_Serializer, p_OwnOffset + offsetof(SInvestigateWeaponGroupSaveData, m_aUnconsciousGuards));
}

bool SInvestigateWeaponGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SInvestigateWeaponGroupSaveData::operator==(const SInvestigateWeaponGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SInvestigateWeaponGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_rReporter != p_Other.m_rReporter) return false;
	if (m_rInvestigator != p_Other.m_rInvestigator) return false;
	if (m_rGuard != p_Other.m_rGuard) return false;
	if (m_ReporterIsVIPWithAmbientEscort != p_Other.m_ReporterIsVIPWithAmbientEscort) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_tLastGuardSearch != p_Other.m_tLastGuardSearch) return false;
	if (m_aUnconsciousGuards != p_Other.m_aUnconsciousGuards) return false;

	return true;
}

void SInvestigateWeaponGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SInvestigateWeaponGroupSaveData*>(p_Object);
	s_Object->~SInvestigateWeaponGroupSaveData();
}

ZHMTypeInfo SItemActionSaveData::TypeInfo = ZHMTypeInfo("SItemActionSaveData", sizeof(SItemActionSaveData), alignof(SItemActionSaveData), SItemActionSaveData::WriteSimpleJson, SItemActionSaveData::FromSimpleJson, SItemActionSaveData::Serialize, SItemActionSaveData::Equals, SItemActionSaveData::Destroy);

void SItemActionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemActionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);

	p_Stream << "}";
}

void SItemActionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemActionSaveData s_Object {};

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	*reinterpret_cast<SItemActionSaveData*>(p_Target) = s_Object;
}

void SItemActionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemActionSaveData*>(p_Object);

}

bool SItemActionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemActionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemActionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemActionSaveData::operator==(const SItemActionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemActionSaveData>)
		return false;

	if (m_rItem != p_Other.m_rItem) return false;

	return true;
}

void SItemActionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemActionSaveData*>(p_Object);
	s_Object->~SItemActionSaveData();
}

ZHMTypeInfo SItemInstanceSaveData::TypeInfo = ZHMTypeInfo("SItemInstanceSaveData", sizeof(SItemInstanceSaveData), alignof(SItemInstanceSaveData), SItemInstanceSaveData::WriteSimpleJson, SItemInstanceSaveData::FromSimpleJson, SItemInstanceSaveData::Serialize, SItemInstanceSaveData::Equals, SItemInstanceSaveData::Destroy);

void SItemInstanceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemInstanceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_repositoryId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_repositoryId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nEntityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEntityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sOnlineInstanceId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sOnlineInstanceId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aItemModifierIds") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemModifierIds.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemModifierIds[i];
		ZRepositoryID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItemModifierIds.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemInstanceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemInstanceSaveData s_Object {};

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_repositoryId"], &s_Item);
		s_Object.m_repositoryId = s_Item;
	}

	s_Object.m_nEntityID = simdjson::from_json_uint64(p_Document["m_nEntityID"]);

	s_Object.m_sOnlineInstanceId = std::string_view(p_Document["m_sOnlineInstanceId"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aItemModifierIds"];
	s_Object.m_aItemModifierIds.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZRepositoryID s_ArrayItem0;
		ZRepositoryID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItemModifierIds[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SItemInstanceSaveData*>(p_Target) = s_Object;
}

void SItemInstanceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemInstanceSaveData*>(p_Object);

	ZRepositoryID::Serialize(&s_Object->m_repositoryId, p_Serializer, p_OwnOffset + offsetof(SItemInstanceSaveData, m_repositoryId));
	ZString::Serialize(&s_Object->m_sOnlineInstanceId, p_Serializer, p_OwnOffset + offsetof(SItemInstanceSaveData, m_sOnlineInstanceId));
	TArray<ZRepositoryID>::Serialize(&s_Object->m_aItemModifierIds, p_Serializer, p_OwnOffset + offsetof(SItemInstanceSaveData, m_aItemModifierIds));
}

bool SItemInstanceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemInstanceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemInstanceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemInstanceSaveData::operator==(const SItemInstanceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemInstanceSaveData>)
		return false;

	if (m_repositoryId != p_Other.m_repositoryId) return false;
	if (m_nEntityID != p_Other.m_nEntityID) return false;
	if (m_sOnlineInstanceId != p_Other.m_sOnlineInstanceId) return false;
	if (m_aItemModifierIds != p_Other.m_aItemModifierIds) return false;

	return true;
}

void SItemInstanceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemInstanceSaveData*>(p_Object);
	s_Object->~SItemInstanceSaveData();
}

ZHMTypeInfo SItemLeftHandUIData::TypeInfo = ZHMTypeInfo("SItemLeftHandUIData", sizeof(SItemLeftHandUIData), alignof(SItemLeftHandUIData), SItemLeftHandUIData::WriteSimpleJson, SItemLeftHandUIData::FromSimpleJson, SItemLeftHandUIData::Serialize, SItemLeftHandUIData::Equals, SItemLeftHandUIData::Destroy);

void SItemLeftHandUIData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemLeftHandUIData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nItemHUDType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nItemHUDType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHasItemToShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHasItemToShow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIllegal);

	p_Stream << "}";
}

void SItemLeftHandUIData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemLeftHandUIData s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	s_Object.nItemHUDType = simdjson::from_json_int32(p_Document["nItemHUDType"]);

	s_Object.bHasItemToShow = simdjson::from_json_bool(p_Document["bHasItemToShow"]);

	s_Object.bSuspicious = simdjson::from_json_bool(p_Document["bSuspicious"]);

	s_Object.bIllegal = simdjson::from_json_bool(p_Document["bIllegal"]);

	*reinterpret_cast<SItemLeftHandUIData*>(p_Target) = s_Object;
}

void SItemLeftHandUIData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemLeftHandUIData*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SItemLeftHandUIData, icon));
}

bool SItemLeftHandUIData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemLeftHandUIData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemLeftHandUIData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemLeftHandUIData::operator==(const SItemLeftHandUIData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemLeftHandUIData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (nItemHUDType != p_Other.nItemHUDType) return false;
	if (bHasItemToShow != p_Other.bHasItemToShow) return false;
	if (bSuspicious != p_Other.bSuspicious) return false;
	if (bIllegal != p_Other.bIllegal) return false;

	return true;
}

void SItemLeftHandUIData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemLeftHandUIData*>(p_Object);
	s_Object->~SItemLeftHandUIData();
}

ZHMTypeInfo SItemOnBackUIData::TypeInfo = ZHMTypeInfo("SItemOnBackUIData", sizeof(SItemOnBackUIData), alignof(SItemOnBackUIData), SItemOnBackUIData::WriteSimpleJson, SItemOnBackUIData::FromSimpleJson, SItemOnBackUIData::Serialize, SItemOnBackUIData::Equals, SItemOnBackUIData::Destroy);

void SItemOnBackUIData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nItemHUDType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nItemHUDType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHasItemToShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHasItemToShow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIllegal);

	p_Stream << "}";
}

void SItemOnBackUIData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemOnBackUIData s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	s_Object.nItemHUDType = simdjson::from_json_int32(p_Document["nItemHUDType"]);

	s_Object.bHasItemToShow = simdjson::from_json_bool(p_Document["bHasItemToShow"]);

	s_Object.bSuspicious = simdjson::from_json_bool(p_Document["bSuspicious"]);

	s_Object.bIllegal = simdjson::from_json_bool(p_Document["bIllegal"]);

	*reinterpret_cast<SItemOnBackUIData*>(p_Target) = s_Object;
}

void SItemOnBackUIData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SItemOnBackUIData, icon));
}

bool SItemOnBackUIData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemOnBackUIData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemOnBackUIData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemOnBackUIData::operator==(const SItemOnBackUIData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemOnBackUIData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (nItemHUDType != p_Other.nItemHUDType) return false;
	if (bHasItemToShow != p_Other.bHasItemToShow) return false;
	if (bSuspicious != p_Other.bSuspicious) return false;
	if (bIllegal != p_Other.bIllegal) return false;

	return true;
}

void SItemOnBackUIData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemOnBackUIData*>(p_Object);
	s_Object->~SItemOnBackUIData();
}

ZHMTypeInfo SItemSpawnerSaveData::TypeInfo = ZHMTypeInfo("SItemSpawnerSaveData", sizeof(SItemSpawnerSaveData), alignof(SItemSpawnerSaveData), SItemSpawnerSaveData::WriteSimpleJson, SItemSpawnerSaveData::FromSimpleJson, SItemSpawnerSaveData::Serialize, SItemSpawnerSaveData::Equals, SItemSpawnerSaveData::Destroy);

void SItemSpawnerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bItemUpdateTransformChange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemUpdateTransformChange);

	p_Stream << "}";
}

void SItemSpawnerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemSpawnerSaveData s_Object {};

	s_Object.m_bItemUpdateTransformChange = simdjson::from_json_bool(p_Document["m_bItemUpdateTransformChange"]);

	*reinterpret_cast<SItemSpawnerSaveData*>(p_Target) = s_Object;
}

void SItemSpawnerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);

}

bool SItemSpawnerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemSpawnerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemSpawnerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemSpawnerSaveData::operator==(const SItemSpawnerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemSpawnerSaveData>)
		return false;

	if (m_bItemUpdateTransformChange != p_Other.m_bItemUpdateTransformChange) return false;

	return true;
}

void SItemSpawnerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemSpawnerSaveData*>(p_Object);
	s_Object->~SItemSpawnerSaveData();
}

ZHMTypeInfo SItemStorageSaveData::TypeInfo = ZHMTypeInfo("SItemStorageSaveData", sizeof(SItemStorageSaveData), alignof(SItemStorageSaveData), SItemStorageSaveData::WriteSimpleJson, SItemStorageSaveData::FromSimpleJson, SItemStorageSaveData::Serialize, SItemStorageSaveData::Equals, SItemStorageSaveData::Destroy);

void SItemStorageSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Storage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_Storage);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ContainedItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_ContainedItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_ContainedItems[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_ContainedItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SItemStorageSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemStorageSaveData s_Object {};

	s_Object.m_Storage = simdjson::from_json_uint32(p_Document["m_Storage"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_ContainedItems"];
	s_Object.m_ContainedItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_ContainedItems[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SItemStorageSaveData*>(p_Target) = s_Object;
}

void SItemStorageSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_ContainedItems, p_Serializer, p_OwnOffset + offsetof(SItemStorageSaveData, m_ContainedItems));
}

bool SItemStorageSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemStorageSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemStorageSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemStorageSaveData::operator==(const SItemStorageSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemStorageSaveData>)
		return false;

	if (m_Storage != p_Other.m_Storage) return false;
	if (m_ContainedItems != p_Other.m_ContainedItems) return false;

	return true;
}

void SItemStorageSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemStorageSaveData*>(p_Object);
	s_Object->~SItemStorageSaveData();
}

ZHMTypeInfo SItemWeaponSaveData::TypeInfo = ZHMTypeInfo("SItemWeaponSaveData", sizeof(SItemWeaponSaveData), alignof(SItemWeaponSaveData), SItemWeaponSaveData::WriteSimpleJson, SItemWeaponSaveData::FromSimpleJson, SItemWeaponSaveData::Serialize, SItemWeaponSaveData::Equals, SItemWeaponSaveData::Destroy);

void SItemWeaponSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_magazineBulletsByAmmoType") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_magazineBulletsByAmmoType.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_magazineBulletsByAmmoType[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_magazineBulletsByAmmoType.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nExtraMagazineBullets") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nExtraMagazineBullets);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePendingDeathContext") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathContext", static_cast<int>(s_Object->m_ePendingDeathContext)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDeathContext") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDeathContext", static_cast<int>(s_Object->m_eDeathContext)));

	p_Stream << "}";
}

void SItemWeaponSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SItemWeaponSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_magazineBulletsByAmmoType"];
	s_Object.m_magazineBulletsByAmmoType.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_magazineBulletsByAmmoType[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_nExtraMagazineBullets = simdjson::from_json_uint32(p_Document["m_nExtraMagazineBullets"]);

	s_Object.m_ePendingDeathContext = static_cast<EDeathContext>(ZHMEnums::GetEnumValueByName("EDeathContext", std::string_view(p_Document["m_ePendingDeathContext"])));

	s_Object.m_eDeathContext = static_cast<EDeathContext>(ZHMEnums::GetEnumValueByName("EDeathContext", std::string_view(p_Document["m_eDeathContext"])));

	*reinterpret_cast<SItemWeaponSaveData*>(p_Target) = s_Object;
}

void SItemWeaponSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_magazineBulletsByAmmoType, p_Serializer, p_OwnOffset + offsetof(SItemWeaponSaveData, m_magazineBulletsByAmmoType));
}

bool SItemWeaponSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SItemWeaponSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SItemWeaponSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SItemWeaponSaveData::operator==(const SItemWeaponSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SItemWeaponSaveData>)
		return false;

	if (m_magazineBulletsByAmmoType != p_Other.m_magazineBulletsByAmmoType) return false;
	if (m_nExtraMagazineBullets != p_Other.m_nExtraMagazineBullets) return false;
	if (m_ePendingDeathContext != p_Other.m_ePendingDeathContext) return false;
	if (m_eDeathContext != p_Other.m_eDeathContext) return false;

	return true;
}

void SItemWeaponSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SItemWeaponSaveData*>(p_Object);
	s_Object->~SItemWeaponSaveData();
}

ZHMTypeInfo SLayerBehaviorConfiguration::TypeInfo = ZHMTypeInfo("SLayerBehaviorConfiguration", sizeof(SLayerBehaviorConfiguration), alignof(SLayerBehaviorConfiguration), SLayerBehaviorConfiguration::WriteSimpleJson, SLayerBehaviorConfiguration::FromSimpleJson, SLayerBehaviorConfiguration::Serialize, SLayerBehaviorConfiguration::Equals, SLayerBehaviorConfiguration::Destroy);

void SLayerBehaviorConfiguration::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bTrigger") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTrigger);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCollector") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCollector);

	p_Stream << "}";
}

void SLayerBehaviorConfiguration::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLayerBehaviorConfiguration s_Object {};

	s_Object.m_bTrigger = simdjson::from_json_bool(p_Document["m_bTrigger"]);

	s_Object.m_bCollector = simdjson::from_json_bool(p_Document["m_bCollector"]);

	*reinterpret_cast<SLayerBehaviorConfiguration*>(p_Target) = s_Object;
}

void SLayerBehaviorConfiguration::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);

}

bool SLayerBehaviorConfiguration::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Left);
	auto* s_Right = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLayerBehaviorConfiguration::operator==(const SLayerBehaviorConfiguration& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLayerBehaviorConfiguration>)
		return false;

	if (m_bTrigger != p_Other.m_bTrigger) return false;
	if (m_bCollector != p_Other.m_bCollector) return false;

	return true;
}

void SLayerBehaviorConfiguration::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLayerBehaviorConfiguration*>(p_Object);
	s_Object->~SLayerBehaviorConfiguration();
}

ZHMTypeInfo SLeadEscortSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SLeadEscortSituationActorStateSaveData", sizeof(SLeadEscortSituationActorStateSaveData), alignof(SLeadEscortSituationActorStateSaveData), SLeadEscortSituationActorStateSaveData::WriteSimpleJson, SLeadEscortSituationActorStateSaveData::FromSimpleJson, SLeadEscortSituationActorStateSaveData::Serialize, SLeadEscortSituationActorStateSaveData::Equals, SLeadEscortSituationActorStateSaveData::Destroy);

void SLeadEscortSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.EEscortState", static_cast<int>(s_Object->m_eStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDistanceToTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDistanceToTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentScreenplay);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rPreferredIntermediateScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rPreferredIntermediateScreenplay);

	p_Stream << "}";
}

void SLeadEscortSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLeadEscortSituationActorStateSaveData s_Object {};

	s_Object.m_nID = simdjson::from_json_uint32(p_Document["m_nID"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_eState = static_cast<ZLeadEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eState"])));

	s_Object.m_eStatePrevious = static_cast<ZLeadEscortSituationEntity_EEscortState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.EEscortState", std::string_view(p_Document["m_eStatePrevious"])));

	s_Object.m_fDistanceToTarget = simdjson::from_json_float32(p_Document["m_fDistanceToTarget"]);

	s_Object.m_rCurrentScreenplay = simdjson::from_json_uint32(p_Document["m_rCurrentScreenplay"]);

	s_Object.m_rPreferredIntermediateScreenplay = simdjson::from_json_uint32(p_Document["m_rPreferredIntermediateScreenplay"]);

	*reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Target) = s_Object;
}

void SLeadEscortSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);

}

bool SLeadEscortSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationActorStateSaveData::operator==(const SLeadEscortSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationActorStateSaveData>)
		return false;

	if (m_nID != p_Other.m_nID) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_eStatePrevious != p_Other.m_eStatePrevious) return false;
	if (m_fDistanceToTarget != p_Other.m_fDistanceToTarget) return false;
	if (m_rCurrentScreenplay != p_Other.m_rCurrentScreenplay) return false;
	if (m_rPreferredIntermediateScreenplay != p_Other.m_rPreferredIntermediateScreenplay) return false;

	return true;
}

void SLeadEscortSituationActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActorStateSaveData*>(p_Object);
	s_Object->~SLeadEscortSituationActorStateSaveData();
}

ZHMTypeInfo SLeadEscortSituationActors::TypeInfo = ZHMTypeInfo("SLeadEscortSituationActors", sizeof(SLeadEscortSituationActors), alignof(SLeadEscortSituationActors), SLeadEscortSituationActors::WriteSimpleJson, SLeadEscortSituationActors::FromSimpleJson, SLeadEscortSituationActors::Serialize, SLeadEscortSituationActors::Equals, SLeadEscortSituationActors::Destroy);

void SLeadEscortSituationActors::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);

	p_Stream << "}";
}

void SLeadEscortSituationActors::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLeadEscortSituationActors s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	*reinterpret_cast<SLeadEscortSituationActors*>(p_Target) = s_Object;
}

void SLeadEscortSituationActors::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);

}

bool SLeadEscortSituationActors::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationActors*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationActors*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationActors::operator==(const SLeadEscortSituationActors& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationActors>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;

	return true;
}

void SLeadEscortSituationActors::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationActors*>(p_Object);
	s_Object->~SLeadEscortSituationActors();
}

ZHMTypeInfo SLeadEscortSituationSaveData::TypeInfo = ZHMTypeInfo("SLeadEscortSituationSaveData", sizeof(SLeadEscortSituationSaveData), alignof(SLeadEscortSituationSaveData), SLeadEscortSituationSaveData::WriteSimpleJson, SLeadEscortSituationSaveData::FromSimpleJson, SLeadEscortSituationSaveData::Serialize, SLeadEscortSituationSaveData::Equals, SLeadEscortSituationSaveData::Destroy);

void SLeadEscortSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bMayEscort") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bMayEscort);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllEscortsAreDead") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllEscortsAreDead);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vLastPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetIsMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetIsMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZLeadEscortSituationEntity.ETargetState", static_cast<int>(s_Object->m_eTargetState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetEmotionState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorEmotionState", static_cast<int>(s_Object->m_eTargetEmotionState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eTargetActState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZActBehaviorEntity.EState", static_cast<int>(s_Object->m_eTargetActState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetNotMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetNotMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTargetAgitationCooldownTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTargetAgitationCooldownTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAddedActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAddedActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAddedActors[i];
		SLeadEscortSituationActors::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAddedActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aStates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aStates[i];
		SLeadEscortSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aStates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEscortActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEscortActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEscortActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEscortActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLeadEscortSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLeadEscortSituationSaveData s_Object {};

	s_Object.m_bActivated = simdjson::from_json_bool(p_Document["m_bActivated"]);

	s_Object.m_bMayEscort = simdjson::from_json_bool(p_Document["m_bMayEscort"]);

	s_Object.m_bTargetDead = simdjson::from_json_bool(p_Document["m_bTargetDead"]);

	s_Object.m_bTargetInRange = simdjson::from_json_bool(p_Document["m_bTargetInRange"]);

	s_Object.m_bAllEscortsAreDead = simdjson::from_json_bool(p_Document["m_bAllEscortsAreDead"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vLastPosition"], &s_Item);
		s_Object.m_vLastPosition = s_Item;
	}

	s_Object.m_bTargetIsMoving = simdjson::from_json_bool(p_Document["m_bTargetIsMoving"]);

	s_Object.m_eTargetState = static_cast<ZLeadEscortSituationEntity_ETargetState>(ZHMEnums::GetEnumValueByName("ZLeadEscortSituationEntity.ETargetState", std::string_view(p_Document["m_eTargetState"])));

	s_Object.m_eTargetEmotionState = static_cast<EActorEmotionState>(ZHMEnums::GetEnumValueByName("EActorEmotionState", std::string_view(p_Document["m_eTargetEmotionState"])));

	s_Object.m_eTargetActState = static_cast<ZActBehaviorEntity_EState>(ZHMEnums::GetEnumValueByName("ZActBehaviorEntity.EState", std::string_view(p_Document["m_eTargetActState"])));

	s_Object.m_fTargetNotMovingTime = simdjson::from_json_float32(p_Document["m_fTargetNotMovingTime"]);

	s_Object.m_fTargetAgitationCooldownTimer = simdjson::from_json_float32(p_Document["m_fTargetAgitationCooldownTimer"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAddedActors"];
	s_Object.m_aAddedActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLeadEscortSituationActors s_ArrayItem0;
		SLeadEscortSituationActors::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAddedActors[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aStates"];
	s_Object.m_aStates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLeadEscortSituationActorStateSaveData s_ArrayItem0;
		SLeadEscortSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aStates[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEscortActs"];
	s_Object.m_aEscortActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEscortActs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SLeadEscortSituationSaveData*>(p_Target) = s_Object;
}

void SLeadEscortSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vLastPosition, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_vLastPosition));
	TArray<SLeadEscortSituationActors>::Serialize(&s_Object->m_aAddedActors, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aAddedActors));
	TArray<SLeadEscortSituationActorStateSaveData>::Serialize(&s_Object->m_aStates, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aStates));
	TArray<uint32>::Serialize(&s_Object->m_aEscortActs, p_Serializer, p_OwnOffset + offsetof(SLeadEscortSituationSaveData, m_aEscortActs));
}

bool SLeadEscortSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLeadEscortSituationSaveData::operator==(const SLeadEscortSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLeadEscortSituationSaveData>)
		return false;

	if (m_bActivated != p_Other.m_bActivated) return false;
	if (m_bMayEscort != p_Other.m_bMayEscort) return false;
	if (m_bTargetDead != p_Other.m_bTargetDead) return false;
	if (m_bTargetInRange != p_Other.m_bTargetInRange) return false;
	if (m_bAllEscortsAreDead != p_Other.m_bAllEscortsAreDead) return false;
	if (m_vLastPosition != p_Other.m_vLastPosition) return false;
	if (m_bTargetIsMoving != p_Other.m_bTargetIsMoving) return false;
	if (m_eTargetState != p_Other.m_eTargetState) return false;
	if (m_eTargetEmotionState != p_Other.m_eTargetEmotionState) return false;
	if (m_eTargetActState != p_Other.m_eTargetActState) return false;
	if (m_fTargetNotMovingTime != p_Other.m_fTargetNotMovingTime) return false;
	if (m_fTargetAgitationCooldownTimer != p_Other.m_fTargetAgitationCooldownTimer) return false;
	if (m_aAddedActors != p_Other.m_aAddedActors) return false;
	if (m_aStates != p_Other.m_aStates) return false;
	if (m_aEscortActs != p_Other.m_aEscortActs) return false;

	return true;
}

void SLeadEscortSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLeadEscortSituationSaveData*>(p_Object);
	s_Object->~SLeadEscortSituationSaveData();
}

ZHMTypeInfo SLevelReferenceableEntitieSaveData::TypeInfo = ZHMTypeInfo("SLevelReferenceableEntitieSaveData", sizeof(SLevelReferenceableEntitieSaveData), alignof(SLevelReferenceableEntitieSaveData), SLevelReferenceableEntitieSaveData::WriteSimpleJson, SLevelReferenceableEntitieSaveData::FromSimpleJson, SLevelReferenceableEntitieSaveData::Serialize, SLevelReferenceableEntitieSaveData::Equals, SLevelReferenceableEntitieSaveData::Destroy);

void SLevelReferenceableEntitieSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sSceneResource") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sSceneResource);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAdditionalBrickResources") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAdditionalBrickResources.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAdditionalBrickResources[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAdditionalBrickResources.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLevelReferenceableEntitieSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLevelReferenceableEntitieSaveData s_Object {};

	s_Object.m_sSceneResource = std::string_view(p_Document["m_sSceneResource"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAdditionalBrickResources"];
	s_Object.m_aAdditionalBrickResources.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aAdditionalBrickResources[s_Index0++] = std::string_view(s_Item0);
	}
	}

	*reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Target) = s_Object;
}

void SLevelReferenceableEntitieSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sSceneResource, p_Serializer, p_OwnOffset + offsetof(SLevelReferenceableEntitieSaveData, m_sSceneResource));
	TArray<ZString>::Serialize(&s_Object->m_aAdditionalBrickResources, p_Serializer, p_OwnOffset + offsetof(SLevelReferenceableEntitieSaveData, m_aAdditionalBrickResources));
}

bool SLevelReferenceableEntitieSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLevelReferenceableEntitieSaveData::operator==(const SLevelReferenceableEntitieSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLevelReferenceableEntitieSaveData>)
		return false;

	if (m_sSceneResource != p_Other.m_sSceneResource) return false;
	if (m_aAdditionalBrickResources != p_Other.m_aAdditionalBrickResources) return false;

	return true;
}

void SLevelReferenceableEntitieSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLevelReferenceableEntitieSaveData*>(p_Object);
	s_Object->~SLevelReferenceableEntitieSaveData();
}

ZHMTypeInfo SObjetiveSaveData::TypeInfo = ZHMTypeInfo("SObjetiveSaveData", sizeof(SObjetiveSaveData), alignof(SObjetiveSaveData), SObjetiveSaveData::WriteSimpleJson, SObjetiveSaveData::FromSimpleJson, SObjetiveSaveData::Serialize, SObjetiveSaveData::Equals, SObjetiveSaveData::Destroy);

void SObjetiveSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("IContractObjective.Type", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SaveData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_SaveData, p_Stream);

	p_Stream << "}";
}

void SObjetiveSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SObjetiveSaveData s_Object {};

	s_Object.m_eType = static_cast<IContractObjective_Type>(ZHMEnums::GetEnumValueByName("IContractObjective.Type", std::string_view(p_Document["m_eType"])));

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_SaveData"], &s_Item);
		s_Object.m_SaveData = s_Item;
	}

	*reinterpret_cast<SObjetiveSaveData*>(p_Target) = s_Object;
}

void SObjetiveSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_SaveData, p_Serializer, p_OwnOffset + offsetof(SObjetiveSaveData, m_SaveData));
}

bool SObjetiveSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SObjetiveSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SObjetiveSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SObjetiveSaveData::operator==(const SObjetiveSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SObjetiveSaveData>)
		return false;

	if (m_eType != p_Other.m_eType) return false;
	if (m_SaveData != p_Other.m_SaveData) return false;

	return true;
}

void SObjetiveSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SObjetiveSaveData*>(p_Object);
	s_Object->~SObjetiveSaveData();
}

ZHMTypeInfo SSoundAmbienceSaveData::TypeInfo = ZHMTypeInfo("SSoundAmbienceSaveData", sizeof(SSoundAmbienceSaveData), alignof(SSoundAmbienceSaveData), SSoundAmbienceSaveData::WriteSimpleJson, SSoundAmbienceSaveData::FromSimpleJson, SSoundAmbienceSaveData::Serialize, SSoundAmbienceSaveData::Equals, SSoundAmbienceSaveData::Destroy);

void SSoundAmbienceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentAmbience") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentAmbience);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCurrentGate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentGate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTransitionAmount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTransitionAmount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnteredFromSide0") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnteredFromSide0);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInTransition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInTransition);

	p_Stream << "}";
}

void SSoundAmbienceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSoundAmbienceSaveData s_Object {};

	s_Object.m_rCurrentAmbience = simdjson::from_json_uint32(p_Document["m_rCurrentAmbience"]);

	s_Object.m_rCurrentGate = simdjson::from_json_uint32(p_Document["m_rCurrentGate"]);

	s_Object.m_fTransitionAmount = simdjson::from_json_float32(p_Document["m_fTransitionAmount"]);

	s_Object.m_bEnteredFromSide0 = simdjson::from_json_bool(p_Document["m_bEnteredFromSide0"]);

	s_Object.m_bInTransition = simdjson::from_json_bool(p_Document["m_bInTransition"]);

	*reinterpret_cast<SSoundAmbienceSaveData*>(p_Target) = s_Object;
}

void SSoundAmbienceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);

}

bool SSoundAmbienceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSoundAmbienceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSoundAmbienceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSoundAmbienceSaveData::operator==(const SSoundAmbienceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSoundAmbienceSaveData>)
		return false;

	if (m_rCurrentAmbience != p_Other.m_rCurrentAmbience) return false;
	if (m_rCurrentGate != p_Other.m_rCurrentGate) return false;
	if (m_fTransitionAmount != p_Other.m_fTransitionAmount) return false;
	if (m_bEnteredFromSide0 != p_Other.m_bEnteredFromSide0) return false;
	if (m_bInTransition != p_Other.m_bInTransition) return false;

	return true;
}

void SSoundAmbienceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSoundAmbienceSaveData*>(p_Object);
	s_Object->~SSoundAmbienceSaveData();
}

ZHMTypeInfo SLevelSaveData::TypeInfo = ZHMTypeInfo("SLevelSaveData", sizeof(SLevelSaveData), alignof(SLevelSaveData), SLevelSaveData::WriteSimpleJson, SLevelSaveData::FromSimpleJson, SLevelSaveData::Serialize, SLevelSaveData::Equals, SLevelSaveData::Destroy);

void SLevelSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nGameTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGameTimePrev") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTimePrev);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGameTimeDelta") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGameTimeDelta);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sScene") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sScene);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLocationId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLocationId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractSessionId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractSessionId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLastEventToken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLastEventToken);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_EnabledEntranceId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_EnabledEntranceId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StartupDisguiseId") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_StartupDisguiseId, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_contractData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_contractData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_trackedOpportunity") << ":";
	ZGuid::WriteSimpleJson(&s_Object->m_trackedOpportunity, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStartupInventory") << ":";
	SInventoryInfo::WriteSimpleJson(&s_Object->m_aStartupInventory, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aStartupAgencyPickupSelection") << ":";
	SAgencyPickupInfo::WriteSimpleJson(&s_Object->m_aStartupAgencyPickupSelection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aObjectives") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aObjectives.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aObjectives[i];
		SObjetiveSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aObjectives.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGameChangers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGameChangers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGameChangers[i];
		ZVariant::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGameChangers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_SoundAmbienceData") << ":";
	SSoundAmbienceSaveData::WriteSimpleJson(&s_Object->m_SoundAmbienceData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ChallengesSaveData") << ":";
	SChallengesSaveData::WriteSimpleJson(&s_Object->m_ChallengesSaveData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSaveGameLimit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSaveGameLimit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fLastKillTimestamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fLastKillTimestamp);

	p_Stream << "}";
}

void SLevelSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLevelSaveData s_Object {};

	s_Object.m_nGameTime = simdjson::from_json_int64(p_Document["m_nGameTime"]);

	s_Object.m_nGameTimePrev = simdjson::from_json_int64(p_Document["m_nGameTimePrev"]);

	s_Object.m_nGameTimeDelta = simdjson::from_json_int64(p_Document["m_nGameTimeDelta"]);

	s_Object.m_sScene = std::string_view(p_Document["m_sScene"]);

	s_Object.m_sLocationId = std::string_view(p_Document["m_sLocationId"]);

	s_Object.m_sContractId = std::string_view(p_Document["m_sContractId"]);

	s_Object.m_sContractSessionId = std::string_view(p_Document["m_sContractSessionId"]);

	s_Object.m_sLastEventToken = std::string_view(p_Document["m_sLastEventToken"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_EnabledEntranceId"], &s_Item);
		s_Object.m_EnabledEntranceId = s_Item;
	}

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_StartupDisguiseId"], &s_Item);
		s_Object.m_StartupDisguiseId = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_contractData"], &s_Item);
		s_Object.m_contractData = s_Item;
	}

	{
		ZGuid s_Item {};
		ZGuid::FromSimpleJson(p_Document["m_trackedOpportunity"], &s_Item);
		s_Object.m_trackedOpportunity = s_Item;
	}

	{
		SInventoryInfo s_Item {};
		SInventoryInfo::FromSimpleJson(p_Document["m_aStartupInventory"], &s_Item);
		s_Object.m_aStartupInventory = s_Item;
	}

	{
		SAgencyPickupInfo s_Item {};
		SAgencyPickupInfo::FromSimpleJson(p_Document["m_aStartupAgencyPickupSelection"], &s_Item);
		s_Object.m_aStartupAgencyPickupSelection = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aObjectives"];
	s_Object.m_aObjectives.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SObjetiveSaveData s_ArrayItem0;
		SObjetiveSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aObjectives[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGameChangers"];
	s_Object.m_aGameChangers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZVariant s_ArrayItem0;
		ZVariant::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGameChangers[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		SSoundAmbienceSaveData s_Item {};
		SSoundAmbienceSaveData::FromSimpleJson(p_Document["m_SoundAmbienceData"], &s_Item);
		s_Object.m_SoundAmbienceData = s_Item;
	}

	{
		SChallengesSaveData s_Item {};
		SChallengesSaveData::FromSimpleJson(p_Document["m_ChallengesSaveData"], &s_Item);
		s_Object.m_ChallengesSaveData = s_Item;
	}

	s_Object.m_nSaveGameLimit = simdjson::from_json_int32(p_Document["m_nSaveGameLimit"]);

	s_Object.m_fLastKillTimestamp = simdjson::from_json_float32(p_Document["m_fLastKillTimestamp"]);

	*reinterpret_cast<SLevelSaveData*>(p_Target) = s_Object;
}

void SLevelSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sScene, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sScene));
	ZString::Serialize(&s_Object->m_sLocationId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sLocationId));
	ZString::Serialize(&s_Object->m_sContractId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sContractId));
	ZString::Serialize(&s_Object->m_sContractSessionId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sContractSessionId));
	ZString::Serialize(&s_Object->m_sLastEventToken, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_sLastEventToken));
	ZRepositoryID::Serialize(&s_Object->m_EnabledEntranceId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_EnabledEntranceId));
	ZRepositoryID::Serialize(&s_Object->m_StartupDisguiseId, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_StartupDisguiseId));
	ZVariant::Serialize(&s_Object->m_contractData, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_contractData));
	ZGuid::Serialize(&s_Object->m_trackedOpportunity, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_trackedOpportunity));
	SInventoryInfo::Serialize(&s_Object->m_aStartupInventory, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_aStartupInventory));
	SAgencyPickupInfo::Serialize(&s_Object->m_aStartupAgencyPickupSelection, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_aStartupAgencyPickupSelection));
	TArray<SObjetiveSaveData>::Serialize(&s_Object->m_aObjectives, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_aObjectives));
	TArray<ZVariant>::Serialize(&s_Object->m_aGameChangers, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_aGameChangers));
	SSoundAmbienceSaveData::Serialize(&s_Object->m_SoundAmbienceData, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_SoundAmbienceData));
	SChallengesSaveData::Serialize(&s_Object->m_ChallengesSaveData, p_Serializer, p_OwnOffset + offsetof(SLevelSaveData, m_ChallengesSaveData));
}

bool SLevelSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLevelSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLevelSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLevelSaveData::operator==(const SLevelSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLevelSaveData>)
		return false;

	if (m_nGameTime != p_Other.m_nGameTime) return false;
	if (m_nGameTimePrev != p_Other.m_nGameTimePrev) return false;
	if (m_nGameTimeDelta != p_Other.m_nGameTimeDelta) return false;
	if (m_sScene != p_Other.m_sScene) return false;
	if (m_sLocationId != p_Other.m_sLocationId) return false;
	if (m_sContractId != p_Other.m_sContractId) return false;
	if (m_sContractSessionId != p_Other.m_sContractSessionId) return false;
	if (m_sLastEventToken != p_Other.m_sLastEventToken) return false;
	if (m_EnabledEntranceId != p_Other.m_EnabledEntranceId) return false;
	if (m_StartupDisguiseId != p_Other.m_StartupDisguiseId) return false;
	if (m_contractData != p_Other.m_contractData) return false;
	if (m_trackedOpportunity != p_Other.m_trackedOpportunity) return false;
	if (m_aStartupInventory != p_Other.m_aStartupInventory) return false;
	if (m_aStartupAgencyPickupSelection != p_Other.m_aStartupAgencyPickupSelection) return false;
	if (m_aObjectives != p_Other.m_aObjectives) return false;
	if (m_aGameChangers != p_Other.m_aGameChangers) return false;
	if (m_SoundAmbienceData != p_Other.m_SoundAmbienceData) return false;
	if (m_ChallengesSaveData != p_Other.m_ChallengesSaveData) return false;
	if (m_nSaveGameLimit != p_Other.m_nSaveGameLimit) return false;
	if (m_fLastKillTimestamp != p_Other.m_fLastKillTimestamp) return false;

	return true;
}

void SLevelSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLevelSaveData*>(p_Object);
	s_Object->~SLevelSaveData();
}

ZHMTypeInfo SLightFlickerEntitySaveData::TypeInfo = ZHMTypeInfo("SLightFlickerEntitySaveData", sizeof(SLightFlickerEntitySaveData), alignof(SLightFlickerEntitySaveData), SLightFlickerEntitySaveData::WriteSimpleJson, SLightFlickerEntitySaveData::FromSimpleJson, SLightFlickerEntitySaveData::Serialize, SLightFlickerEntitySaveData::Equals, SLightFlickerEntitySaveData::Destroy);

void SLightFlickerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bLightOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLightOn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFlickerOn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFlickerOn);

	p_Stream << "}";
}

void SLightFlickerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLightFlickerEntitySaveData s_Object {};

	s_Object.m_bLightOn = simdjson::from_json_bool(p_Document["m_bLightOn"]);

	s_Object.m_bFlickerOn = simdjson::from_json_bool(p_Document["m_bFlickerOn"]);

	*reinterpret_cast<SLightFlickerEntitySaveData*>(p_Target) = s_Object;
}

void SLightFlickerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);

}

bool SLightFlickerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLightFlickerEntitySaveData::operator==(const SLightFlickerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLightFlickerEntitySaveData>)
		return false;

	if (m_bLightOn != p_Other.m_bLightOn) return false;
	if (m_bFlickerOn != p_Other.m_bFlickerOn) return false;

	return true;
}

void SLightFlickerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLightFlickerEntitySaveData*>(p_Object);
	s_Object->~SLightFlickerEntitySaveData();
}

ZHMTypeInfo SLoadRuntimeResourceResult::TypeInfo = ZHMTypeInfo("SLoadRuntimeResourceResult", sizeof(SLoadRuntimeResourceResult), alignof(SLoadRuntimeResourceResult), SLoadRuntimeResourceResult::WriteSimpleJson, SLoadRuntimeResourceResult::FromSimpleJson, SLoadRuntimeResourceResult::Serialize, SLoadRuntimeResourceResult::Equals, SLoadRuntimeResourceResult::Destroy);

void SLoadRuntimeResourceResult::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sFilePath") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sFilePath);

	p_Stream << "}";
}

void SLoadRuntimeResourceResult::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLoadRuntimeResourceResult s_Object {};

	s_Object.sFilePath = std::string_view(p_Document["sFilePath"]);

	*reinterpret_cast<SLoadRuntimeResourceResult*>(p_Target) = s_Object;
}

void SLoadRuntimeResourceResult::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);

	ZString::Serialize(&s_Object->sFilePath, p_Serializer, p_OwnOffset + offsetof(SLoadRuntimeResourceResult, sFilePath));
}

bool SLoadRuntimeResourceResult::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Left);
	auto* s_Right = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLoadRuntimeResourceResult::operator==(const SLoadRuntimeResourceResult& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLoadRuntimeResourceResult>)
		return false;

	if (sFilePath != p_Other.sFilePath) return false;

	return true;
}

void SLoadRuntimeResourceResult::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLoadRuntimeResourceResult*>(p_Object);
	s_Object->~SLoadRuntimeResourceResult();
}

ZHMTypeInfo SLocalizedVideoData::TypeInfo = ZHMTypeInfo("SLocalizedVideoData", sizeof(SLocalizedVideoData), alignof(SLocalizedVideoData), SLocalizedVideoData::WriteSimpleJson, SLocalizedVideoData::FromSimpleJson, SLocalizedVideoData::Serialize, SLocalizedVideoData::Equals, SLocalizedVideoData::Destroy);

void SLocalizedVideoData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("AudioLanguages") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->AudioLanguages.size(); ++i)
	{
		auto& s_Item0 = s_Object->AudioLanguages[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->AudioLanguages.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("VideoRidsPerAudioLanguage") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->VideoRidsPerAudioLanguage.size(); ++i)
	{
		auto& s_Item0 = s_Object->VideoRidsPerAudioLanguage[i];
		ZRuntimeResourceID::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->VideoRidsPerAudioLanguage.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SubtitleLanguages") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->SubtitleLanguages.size(); ++i)
	{
		auto& s_Item0 = s_Object->SubtitleLanguages[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->SubtitleLanguages.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("SubtitleMarkupsPerLanguage") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->SubtitleMarkupsPerLanguage.size(); ++i)
	{
		auto& s_Item0 = s_Object->SubtitleMarkupsPerLanguage[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->SubtitleMarkupsPerLanguage.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLocalizedVideoData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLocalizedVideoData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["AudioLanguages"];
	s_Object.AudioLanguages.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.AudioLanguages[s_Index0++] = std::string_view(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["VideoRidsPerAudioLanguage"];
	s_Object.VideoRidsPerAudioLanguage.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZRuntimeResourceID s_ArrayItem0;
		ZRuntimeResourceID::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.VideoRidsPerAudioLanguage[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["SubtitleLanguages"];
	s_Object.SubtitleLanguages.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.SubtitleLanguages[s_Index0++] = std::string_view(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["SubtitleMarkupsPerLanguage"];
	s_Object.SubtitleMarkupsPerLanguage.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.SubtitleMarkupsPerLanguage[s_Index0++] = std::string_view(s_Item0);
	}
	}

	*reinterpret_cast<SLocalizedVideoData*>(p_Target) = s_Object;
}

void SLocalizedVideoData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);

	TArray<ZString>::Serialize(&s_Object->AudioLanguages, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, AudioLanguages));
	TArray<ZRuntimeResourceID>::Serialize(&s_Object->VideoRidsPerAudioLanguage, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, VideoRidsPerAudioLanguage));
	TArray<ZString>::Serialize(&s_Object->SubtitleLanguages, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, SubtitleLanguages));
	TArray<ZString>::Serialize(&s_Object->SubtitleMarkupsPerLanguage, p_Serializer, p_OwnOffset + offsetof(SLocalizedVideoData, SubtitleMarkupsPerLanguage));
}

bool SLocalizedVideoData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLocalizedVideoData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLocalizedVideoData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLocalizedVideoData::operator==(const SLocalizedVideoData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLocalizedVideoData>)
		return false;

	if (AudioLanguages != p_Other.AudioLanguages) return false;
	if (VideoRidsPerAudioLanguage != p_Other.VideoRidsPerAudioLanguage) return false;
	if (SubtitleLanguages != p_Other.SubtitleLanguages) return false;
	if (SubtitleMarkupsPerLanguage != p_Other.SubtitleMarkupsPerLanguage) return false;

	return true;
}

void SLocalizedVideoData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLocalizedVideoData*>(p_Object);
	s_Object->~SLocalizedVideoData();
}

ZHMTypeInfo SLockdownManagerAIZoneSaveData::TypeInfo = ZHMTypeInfo("SLockdownManagerAIZoneSaveData", sizeof(SLockdownManagerAIZoneSaveData), alignof(SLockdownManagerAIZoneSaveData), SLockdownManagerAIZoneSaveData::WriteSimpleJson, SLockdownManagerAIZoneSaveData::FromSimpleJson, SLockdownManagerAIZoneSaveData::Serialize, SLockdownManagerAIZoneSaveData::Equals, SLockdownManagerAIZoneSaveData::Destroy);

void SLockdownManagerAIZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tExpiry") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiry, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tExpiryHeroOutside") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tExpiryHeroOutside, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rZone);

	p_Stream << "}";
}

void SLockdownManagerAIZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLockdownManagerAIZoneSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tExpiry"], &s_Item);
		s_Object.m_tExpiry = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tExpiryHeroOutside"], &s_Item);
		s_Object.m_tExpiryHeroOutside = s_Item;
	}

	s_Object.m_rZone = simdjson::from_json_uint32(p_Document["m_rZone"]);

	*reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Target) = s_Object;
}

void SLockdownManagerAIZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tExpiry, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerAIZoneSaveData, m_tExpiry));
	ZGameTime::Serialize(&s_Object->m_tExpiryHeroOutside, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerAIZoneSaveData, m_tExpiryHeroOutside));
}

bool SLockdownManagerAIZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLockdownManagerAIZoneSaveData::operator==(const SLockdownManagerAIZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLockdownManagerAIZoneSaveData>)
		return false;

	if (m_tExpiry != p_Other.m_tExpiry) return false;
	if (m_tExpiryHeroOutside != p_Other.m_tExpiryHeroOutside) return false;
	if (m_rZone != p_Other.m_rZone) return false;

	return true;
}

void SLockdownManagerAIZoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerAIZoneSaveData*>(p_Object);
	s_Object->~SLockdownManagerAIZoneSaveData();
}

ZHMTypeInfo SLockdownManagerSaveData::TypeInfo = ZHMTypeInfo("SLockdownManagerSaveData", sizeof(SLockdownManagerSaveData), alignof(SLockdownManagerSaveData), SLockdownManagerSaveData::WriteSimpleJson, SLockdownManagerSaveData::FromSimpleJson, SLockdownManagerSaveData::Serialize, SLockdownManagerSaveData::Equals, SLockdownManagerSaveData::Destroy);

void SLockdownManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAIZones") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAIZones.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAIZones[i];
		SLockdownManagerAIZoneSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aAIZones.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SLockdownManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SLockdownManagerSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAIZones"];
	s_Object.m_aAIZones.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SLockdownManagerAIZoneSaveData s_ArrayItem0;
		SLockdownManagerAIZoneSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aAIZones[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SLockdownManagerSaveData*>(p_Target) = s_Object;
}

void SLockdownManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);

	TArray<SLockdownManagerAIZoneSaveData>::Serialize(&s_Object->m_aAIZones, p_Serializer, p_OwnOffset + offsetof(SLockdownManagerSaveData, m_aAIZones));
}

bool SLockdownManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SLockdownManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SLockdownManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SLockdownManagerSaveData::operator==(const SLockdownManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SLockdownManagerSaveData>)
		return false;

	if (m_aAIZones != p_Other.m_aAIZones) return false;

	return true;
}

void SLockdownManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SLockdownManagerSaveData*>(p_Object);
	s_Object->~SLockdownManagerSaveData();
}

ZHMTypeInfo SManHuntServiceSaveData::TypeInfo = ZHMTypeInfo("SManHuntServiceSaveData", sizeof(SManHuntServiceSaveData), alignof(SManHuntServiceSaveData), SManHuntServiceSaveData::WriteSimpleJson, SManHuntServiceSaveData::FromSimpleJson, SManHuntServiceSaveData::Serialize, SManHuntServiceSaveData::Equals, SManHuntServiceSaveData::Destroy);

void SManHuntServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rGuardNodes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_rGuardNodes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_rGuardNodes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_rGuardNodes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rInitialNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rInitialNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGuardSightRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGuardSightRange);

	p_Stream << "}";
}

void SManHuntServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SManHuntServiceSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_rGuardNodes"];
	s_Object.m_rGuardNodes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_rGuardNodes[s_Index0++] = simdjson::from_json_uint16(s_Item0);
	}
	}

	s_Object.m_rInitialNode = simdjson::from_json_uint16(p_Document["m_rInitialNode"]);

	s_Object.m_fGuardSightRange = simdjson::from_json_float32(p_Document["m_fGuardSightRange"]);

	*reinterpret_cast<SManHuntServiceSaveData*>(p_Target) = s_Object;
}

void SManHuntServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);

	TArray<uint16>::Serialize(&s_Object->m_rGuardNodes, p_Serializer, p_OwnOffset + offsetof(SManHuntServiceSaveData, m_rGuardNodes));
}

bool SManHuntServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SManHuntServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SManHuntServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SManHuntServiceSaveData::operator==(const SManHuntServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SManHuntServiceSaveData>)
		return false;

	if (m_rGuardNodes != p_Other.m_rGuardNodes) return false;
	if (m_rInitialNode != p_Other.m_rInitialNode) return false;
	if (m_fGuardSightRange != p_Other.m_fGuardSightRange) return false;

	return true;
}

void SManHuntServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SManHuntServiceSaveData*>(p_Object);
	s_Object->~SManHuntServiceSaveData();
}

ZHMTypeInfo SMapMarkerData::TypeInfo = ZHMTypeInfo("SMapMarkerData", sizeof(SMapMarkerData), alignof(SMapMarkerData), SMapMarkerData::WriteSimpleJson, SMapMarkerData::FromSimpleJson, SMapMarkerData::Serialize, SMapMarkerData::Equals, SMapMarkerData::Destroy);

void SMapMarkerData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("pathPoints") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pathPoints.size(); ++i)
	{
		auto& s_Item0 = s_Object->pathPoints[i];
		SVector2::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pathPoints.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SMapMarkerData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMapMarkerData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["pathPoints"];
	s_Object.pathPoints.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVector2 s_ArrayItem0;
		SVector2::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.pathPoints[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SMapMarkerData*>(p_Target) = s_Object;
}

void SMapMarkerData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);

	TArray<SVector2>::Serialize(&s_Object->pathPoints, p_Serializer, p_OwnOffset + offsetof(SMapMarkerData, pathPoints));
}

bool SMapMarkerData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMapMarkerData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMapMarkerData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMapMarkerData::operator==(const SMapMarkerData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMapMarkerData>)
		return false;

	if (pathPoints != p_Other.pathPoints) return false;

	return true;
}

void SMapMarkerData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMapMarkerData*>(p_Object);
	s_Object->~SMapMarkerData();
}

ZHMTypeInfo SMathDistanceSaveData_SVector2::TypeInfo = ZHMTypeInfo("SMathDistanceSaveData_SVector2", sizeof(SMathDistanceSaveData_SVector2), alignof(SMathDistanceSaveData_SVector2), SMathDistanceSaveData_SVector2::WriteSimpleJson, SMathDistanceSaveData_SVector2::FromSimpleJson, SMathDistanceSaveData_SVector2::Serialize, SMathDistanceSaveData_SVector2::Equals, SMathDistanceSaveData_SVector2::Destroy);

void SMathDistanceSaveData_SVector2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector2::WriteSimpleJson(&s_Object->m_fB, p_Stream);

	p_Stream << "}";
}

void SMathDistanceSaveData_SVector2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathDistanceSaveData_SVector2 s_Object {};

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector2 s_Item {};
		SVector2::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	*reinterpret_cast<SMathDistanceSaveData_SVector2*>(p_Target) = s_Object;
}

void SMathDistanceSaveData_SVector2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector2*>(p_Object);

	SVector2::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathDistanceSaveData_SVector2, m_fA));
	SVector2::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathDistanceSaveData_SVector2, m_fB));
}

bool SMathDistanceSaveData_SVector2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathDistanceSaveData_SVector2*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathDistanceSaveData_SVector2*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathDistanceSaveData_SVector2::operator==(const SMathDistanceSaveData_SVector2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathDistanceSaveData_SVector2>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;

	return true;
}

void SMathDistanceSaveData_SVector2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector2*>(p_Object);
	s_Object->~SMathDistanceSaveData_SVector2();
}

ZHMTypeInfo SMathDistanceSaveData_SVector3::TypeInfo = ZHMTypeInfo("SMathDistanceSaveData_SVector3", sizeof(SMathDistanceSaveData_SVector3), alignof(SMathDistanceSaveData_SVector3), SMathDistanceSaveData_SVector3::WriteSimpleJson, SMathDistanceSaveData_SVector3::FromSimpleJson, SMathDistanceSaveData_SVector3::Serialize, SMathDistanceSaveData_SVector3::Equals, SMathDistanceSaveData_SVector3::Destroy);

void SMathDistanceSaveData_SVector3::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector3*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_fB, p_Stream);

	p_Stream << "}";
}

void SMathDistanceSaveData_SVector3::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathDistanceSaveData_SVector3 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	*reinterpret_cast<SMathDistanceSaveData_SVector3*>(p_Target) = s_Object;
}

void SMathDistanceSaveData_SVector3::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector3*>(p_Object);

	SVector3::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathDistanceSaveData_SVector3, m_fA));
	SVector3::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathDistanceSaveData_SVector3, m_fB));
}

bool SMathDistanceSaveData_SVector3::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathDistanceSaveData_SVector3*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathDistanceSaveData_SVector3*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathDistanceSaveData_SVector3::operator==(const SMathDistanceSaveData_SVector3& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathDistanceSaveData_SVector3>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;

	return true;
}

void SMathDistanceSaveData_SVector3::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector3*>(p_Object);
	s_Object->~SMathDistanceSaveData_SVector3();
}

ZHMTypeInfo SMathDistanceSaveData_SVector4::TypeInfo = ZHMTypeInfo("SMathDistanceSaveData_SVector4", sizeof(SMathDistanceSaveData_SVector4), alignof(SMathDistanceSaveData_SVector4), SMathDistanceSaveData_SVector4::WriteSimpleJson, SMathDistanceSaveData_SVector4::FromSimpleJson, SMathDistanceSaveData_SVector4::Serialize, SMathDistanceSaveData_SVector4::Equals, SMathDistanceSaveData_SVector4::Destroy);

void SMathDistanceSaveData_SVector4::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector4*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fA") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_fA, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fB") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_fB, p_Stream);

	p_Stream << "}";
}

void SMathDistanceSaveData_SVector4::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMathDistanceSaveData_SVector4 s_Object {};

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_fA"], &s_Item);
		s_Object.m_fA = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_fB"], &s_Item);
		s_Object.m_fB = s_Item;
	}

	*reinterpret_cast<SMathDistanceSaveData_SVector4*>(p_Target) = s_Object;
}

void SMathDistanceSaveData_SVector4::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector4*>(p_Object);

	SVector4::Serialize(&s_Object->m_fA, p_Serializer, p_OwnOffset + offsetof(SMathDistanceSaveData_SVector4, m_fA));
	SVector4::Serialize(&s_Object->m_fB, p_Serializer, p_OwnOffset + offsetof(SMathDistanceSaveData_SVector4, m_fB));
}

bool SMathDistanceSaveData_SVector4::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMathDistanceSaveData_SVector4*>(p_Left);
	auto* s_Right = reinterpret_cast<SMathDistanceSaveData_SVector4*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMathDistanceSaveData_SVector4::operator==(const SMathDistanceSaveData_SVector4& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMathDistanceSaveData_SVector4>)
		return false;

	if (m_fA != p_Other.m_fA) return false;
	if (m_fB != p_Other.m_fB) return false;

	return true;
}

void SMathDistanceSaveData_SVector4::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMathDistanceSaveData_SVector4*>(p_Object);
	s_Object->~SMathDistanceSaveData_SVector4();
}

ZHMTypeInfo SMatrix33::TypeInfo = ZHMTypeInfo("SMatrix33", sizeof(SMatrix33), alignof(SMatrix33), SMatrix33::WriteSimpleJson, SMatrix33::FromSimpleJson, SMatrix33::Serialize, SMatrix33::Equals, SMatrix33::Destroy);

void SMatrix33::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->ZAxis, p_Stream);

	p_Stream << "}";
}

void SMatrix33::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix33 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	*reinterpret_cast<SMatrix33*>(p_Target) = s_Object;
}

void SMatrix33::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);

	SVector3::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, XAxis));
	SVector3::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, YAxis));
	SVector3::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix33, ZAxis));
}

bool SMatrix33::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix33*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix33*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix33::operator==(const SMatrix33& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix33>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;

	return true;
}

void SMatrix33::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMatrix33*>(p_Object);
	s_Object->~SMatrix33();
}

ZHMTypeInfo SMatrix43::TypeInfo = ZHMTypeInfo("SMatrix43", sizeof(SMatrix43), alignof(SMatrix43), SMatrix43::WriteSimpleJson, SMatrix43::FromSimpleJson, SMatrix43::Serialize, SMatrix43::Equals, SMatrix43::Destroy);

void SMatrix43::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("XAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->XAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("YAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->YAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ZAxis") << ":";
	SVector3::WriteSimpleJson(&s_Object->ZAxis, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("Trans") << ":";
	SVector3::WriteSimpleJson(&s_Object->Trans, p_Stream);

	p_Stream << "}";
}

void SMatrix43::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix43 s_Object {};

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["XAxis"], &s_Item);
		s_Object.XAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["YAxis"], &s_Item);
		s_Object.YAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["ZAxis"], &s_Item);
		s_Object.ZAxis = s_Item;
	}

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["Trans"], &s_Item);
		s_Object.Trans = s_Item;
	}

	*reinterpret_cast<SMatrix43*>(p_Target) = s_Object;
}

void SMatrix43::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);

	SVector3::Serialize(&s_Object->XAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, XAxis));
	SVector3::Serialize(&s_Object->YAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, YAxis));
	SVector3::Serialize(&s_Object->ZAxis, p_Serializer, p_OwnOffset + offsetof(SMatrix43, ZAxis));
	SVector3::Serialize(&s_Object->Trans, p_Serializer, p_OwnOffset + offsetof(SMatrix43, Trans));
}

bool SMatrix43::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix43*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix43*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix43::operator==(const SMatrix43& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix43>)
		return false;

	if (XAxis != p_Other.XAxis) return false;
	if (YAxis != p_Other.YAxis) return false;
	if (ZAxis != p_Other.ZAxis) return false;
	if (Trans != p_Other.Trans) return false;

	return true;
}

void SMatrix43::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMatrix43*>(p_Object);
	s_Object->~SMatrix43();
}

ZHMTypeInfo SMatrix44::TypeInfo = ZHMTypeInfo("SMatrix44", sizeof(SMatrix44), alignof(SMatrix44), SMatrix44::WriteSimpleJson, SMatrix44::FromSimpleJson, SMatrix44::Serialize, SMatrix44::Equals, SMatrix44::Destroy);

void SMatrix44::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m11") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m11);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m12") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m12);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m13") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m13);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m14") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m14);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m21") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m21);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m22") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m22);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m23") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m23);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m24") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m24);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m31") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m31);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m32") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m32);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m33") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m33);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m34") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m34);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m41") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m41);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m42") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m42);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m43") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m43);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m44") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m44);

	p_Stream << "}";
}

void SMatrix44::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMatrix44 s_Object {};

	s_Object.m11 = simdjson::from_json_float32(p_Document["m11"]);

	s_Object.m12 = simdjson::from_json_float32(p_Document["m12"]);

	s_Object.m13 = simdjson::from_json_float32(p_Document["m13"]);

	s_Object.m14 = simdjson::from_json_float32(p_Document["m14"]);

	s_Object.m21 = simdjson::from_json_float32(p_Document["m21"]);

	s_Object.m22 = simdjson::from_json_float32(p_Document["m22"]);

	s_Object.m23 = simdjson::from_json_float32(p_Document["m23"]);

	s_Object.m24 = simdjson::from_json_float32(p_Document["m24"]);

	s_Object.m31 = simdjson::from_json_float32(p_Document["m31"]);

	s_Object.m32 = simdjson::from_json_float32(p_Document["m32"]);

	s_Object.m33 = simdjson::from_json_float32(p_Document["m33"]);

	s_Object.m34 = simdjson::from_json_float32(p_Document["m34"]);

	s_Object.m41 = simdjson::from_json_float32(p_Document["m41"]);

	s_Object.m42 = simdjson::from_json_float32(p_Document["m42"]);

	s_Object.m43 = simdjson::from_json_float32(p_Document["m43"]);

	s_Object.m44 = simdjson::from_json_float32(p_Document["m44"]);

	*reinterpret_cast<SMatrix44*>(p_Target) = s_Object;
}

void SMatrix44::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);

}

bool SMatrix44::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMatrix44*>(p_Left);
	auto* s_Right = reinterpret_cast<SMatrix44*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMatrix44::operator==(const SMatrix44& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMatrix44>)
		return false;

	if (m11 != p_Other.m11) return false;
	if (m12 != p_Other.m12) return false;
	if (m13 != p_Other.m13) return false;
	if (m14 != p_Other.m14) return false;
	if (m21 != p_Other.m21) return false;
	if (m22 != p_Other.m22) return false;
	if (m23 != p_Other.m23) return false;
	if (m24 != p_Other.m24) return false;
	if (m31 != p_Other.m31) return false;
	if (m32 != p_Other.m32) return false;
	if (m33 != p_Other.m33) return false;
	if (m34 != p_Other.m34) return false;
	if (m41 != p_Other.m41) return false;
	if (m42 != p_Other.m42) return false;
	if (m43 != p_Other.m43) return false;
	if (m44 != p_Other.m44) return false;

	return true;
}

void SMatrix44::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMatrix44*>(p_Object);
	s_Object->~SMatrix44();
}

ZHMTypeInfo SMovementAgilitySaveData::TypeInfo = ZHMTypeInfo("SMovementAgilitySaveData", sizeof(SMovementAgilitySaveData), alignof(SMovementAgilitySaveData), SMovementAgilitySaveData::WriteSimpleJson, SMovementAgilitySaveData::FromSimpleJson, SMovementAgilitySaveData::Serialize, SMovementAgilitySaveData::Equals, SMovementAgilitySaveData::Destroy);

void SMovementAgilitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rLedgeGuide") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLedgeGuide);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFaceLeftRightTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFaceLeftRightTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ePrevAgilityState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAgilityState", static_cast<int>(s_Object->m_ePrevAgilityState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eAgilityState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAgilityState", static_cast<int>(s_Object->m_eAgilityState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nActiveAnimNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nActiveAnimNode);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eCameraOffset") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ECameraOffset_old", static_cast<int>(s_Object->m_eCameraOffset)));

	p_Stream << "}";
}

void SMovementAgilitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementAgilitySaveData s_Object {};

	s_Object.m_rLedgeGuide = simdjson::from_json_uint32(p_Document["m_rLedgeGuide"]);

	s_Object.m_fFaceLeftRightTarget = simdjson::from_json_float32(p_Document["m_fFaceLeftRightTarget"]);

	s_Object.m_ePrevAgilityState = static_cast<EAgilityState>(ZHMEnums::GetEnumValueByName("EAgilityState", std::string_view(p_Document["m_ePrevAgilityState"])));

	s_Object.m_eAgilityState = static_cast<EAgilityState>(ZHMEnums::GetEnumValueByName("EAgilityState", std::string_view(p_Document["m_eAgilityState"])));

	s_Object.m_nActiveAnimNode = simdjson::from_json_uint32(p_Document["m_nActiveAnimNode"]);

	s_Object.m_eCameraOffset = static_cast<ECameraOffset_old>(ZHMEnums::GetEnumValueByName("ECameraOffset_old", std::string_view(p_Document["m_eCameraOffset"])));

	*reinterpret_cast<SMovementAgilitySaveData*>(p_Target) = s_Object;
}

void SMovementAgilitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);

}

bool SMovementAgilitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementAgilitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementAgilitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementAgilitySaveData::operator==(const SMovementAgilitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementAgilitySaveData>)
		return false;

	if (m_rLedgeGuide != p_Other.m_rLedgeGuide) return false;
	if (m_fFaceLeftRightTarget != p_Other.m_fFaceLeftRightTarget) return false;
	if (m_ePrevAgilityState != p_Other.m_ePrevAgilityState) return false;
	if (m_eAgilityState != p_Other.m_eAgilityState) return false;
	if (m_nActiveAnimNode != p_Other.m_nActiveAnimNode) return false;
	if (m_eCameraOffset != p_Other.m_eCameraOffset) return false;

	return true;
}

void SMovementAgilitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementAgilitySaveData*>(p_Object);
	s_Object->~SMovementAgilitySaveData();
}

ZHMTypeInfo SMovementCoverSaveData::TypeInfo = ZHMTypeInfo("SMovementCoverSaveData", sizeof(SMovementCoverSaveData), alignof(SMovementCoverSaveData), SMovementCoverSaveData::WriteSimpleJson, SMovementCoverSaveData::FromSimpleJson, SMovementCoverSaveData::Serialize, SMovementCoverSaveData::Equals, SMovementCoverSaveData::Destroy);

void SMovementCoverSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCoverPlane") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCoverPlane);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCoverAnimNodeID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCoverAnimNodeID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLeftSideFacing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLeftSideFacing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCrouched") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCrouched);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mPositionInCover") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mPositionInCover, p_Stream);

	p_Stream << "}";
}

void SMovementCoverSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementCoverSaveData s_Object {};

	s_Object.m_rCoverPlane = simdjson::from_json_uint32(p_Document["m_rCoverPlane"]);

	s_Object.m_nCoverAnimNodeID = simdjson::from_json_uint32(p_Document["m_nCoverAnimNodeID"]);

	s_Object.m_bLeftSideFacing = simdjson::from_json_bool(p_Document["m_bLeftSideFacing"]);

	s_Object.m_bCrouched = simdjson::from_json_bool(p_Document["m_bCrouched"]);

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_mPositionInCover"], &s_Item);
		s_Object.m_mPositionInCover = s_Item;
	}

	*reinterpret_cast<SMovementCoverSaveData*>(p_Target) = s_Object;
}

void SMovementCoverSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);

	SMatrix::Serialize(&s_Object->m_mPositionInCover, p_Serializer, p_OwnOffset + offsetof(SMovementCoverSaveData, m_mPositionInCover));
}

bool SMovementCoverSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementCoverSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementCoverSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementCoverSaveData::operator==(const SMovementCoverSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementCoverSaveData>)
		return false;

	if (m_rCoverPlane != p_Other.m_rCoverPlane) return false;
	if (m_nCoverAnimNodeID != p_Other.m_nCoverAnimNodeID) return false;
	if (m_bLeftSideFacing != p_Other.m_bLeftSideFacing) return false;
	if (m_bCrouched != p_Other.m_bCrouched) return false;
	if (m_mPositionInCover != p_Other.m_mPositionInCover) return false;

	return true;
}

void SMovementCoverSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementCoverSaveData*>(p_Object);
	s_Object->~SMovementCoverSaveData();
}

ZHMTypeInfo SMovementDisguiseSafeZoneSaveData::TypeInfo = ZHMTypeInfo("SMovementDisguiseSafeZoneSaveData", sizeof(SMovementDisguiseSafeZoneSaveData), alignof(SMovementDisguiseSafeZoneSaveData), SMovementDisguiseSafeZoneSaveData::WriteSimpleJson, SMovementDisguiseSafeZoneSaveData::FromSimpleJson, SMovementDisguiseSafeZoneSaveData::Serialize, SMovementDisguiseSafeZoneSaveData::Equals, SMovementDisguiseSafeZoneSaveData::Destroy);

void SMovementDisguiseSafeZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSafeZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSafeZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSafeZoneAnimNode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSafeZoneAnimNode);

	p_Stream << "}";
}

void SMovementDisguiseSafeZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementDisguiseSafeZoneSaveData s_Object {};

	s_Object.m_rSafeZone = simdjson::from_json_uint32(p_Document["m_rSafeZone"]);

	s_Object.m_nSafeZoneAnimNode = simdjson::from_json_uint32(p_Document["m_nSafeZoneAnimNode"]);

	*reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Target) = s_Object;
}

void SMovementDisguiseSafeZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);

}

bool SMovementDisguiseSafeZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDisguiseSafeZoneSaveData::operator==(const SMovementDisguiseSafeZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDisguiseSafeZoneSaveData>)
		return false;

	if (m_rSafeZone != p_Other.m_rSafeZone) return false;
	if (m_nSafeZoneAnimNode != p_Other.m_nSafeZoneAnimNode) return false;

	return true;
}

void SMovementDisguiseSafeZoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementDisguiseSafeZoneSaveData*>(p_Object);
	s_Object->~SMovementDisguiseSafeZoneSaveData();
}

ZHMTypeInfo SMovementDragBodySaveData::TypeInfo = ZHMTypeInfo("SMovementDragBodySaveData", sizeof(SMovementDragBodySaveData), alignof(SMovementDragBodySaveData), SMovementDragBodySaveData::WriteSimpleJson, SMovementDragBodySaveData::FromSimpleJson, SMovementDragBodySaveData::Serialize, SMovementDragBodySaveData::Equals, SMovementDragBodySaveData::Destroy);

void SMovementDragBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rDraggedActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDraggedActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGrabBoneID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGrabBoneID);

	p_Stream << "}";
}

void SMovementDragBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementDragBodySaveData s_Object {};

	s_Object.m_rDraggedActor = simdjson::from_json_uint32(p_Document["m_rDraggedActor"]);

	s_Object.m_nGrabBoneID = simdjson::from_json_uint32(p_Document["m_nGrabBoneID"]);

	*reinterpret_cast<SMovementDragBodySaveData*>(p_Target) = s_Object;
}

void SMovementDragBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);

}

bool SMovementDragBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDragBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDragBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDragBodySaveData::operator==(const SMovementDragBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDragBodySaveData>)
		return false;

	if (m_rDraggedActor != p_Other.m_rDraggedActor) return false;
	if (m_nGrabBoneID != p_Other.m_nGrabBoneID) return false;

	return true;
}

void SMovementDragBodySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementDragBodySaveData*>(p_Object);
	s_Object->~SMovementDragBodySaveData();
}

ZHMTypeInfo SMovementDrainPipeSaveData::TypeInfo = ZHMTypeInfo("SMovementDrainPipeSaveData", sizeof(SMovementDrainPipeSaveData), alignof(SMovementDrainPipeSaveData), SMovementDrainPipeSaveData::WriteSimpleJson, SMovementDrainPipeSaveData::FromSimpleJson, SMovementDrainPipeSaveData::Serialize, SMovementDrainPipeSaveData::Equals, SMovementDrainPipeSaveData::Destroy);

void SMovementDrainPipeSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rDrainPipe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rDrainPipe);

	p_Stream << "}";
}

void SMovementDrainPipeSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementDrainPipeSaveData s_Object {};

	s_Object.m_rDrainPipe = simdjson::from_json_uint32(p_Document["m_rDrainPipe"]);

	*reinterpret_cast<SMovementDrainPipeSaveData*>(p_Target) = s_Object;
}

void SMovementDrainPipeSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);

}

bool SMovementDrainPipeSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementDrainPipeSaveData::operator==(const SMovementDrainPipeSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementDrainPipeSaveData>)
		return false;

	if (m_rDrainPipe != p_Other.m_rDrainPipe) return false;

	return true;
}

void SMovementDrainPipeSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementDrainPipeSaveData*>(p_Object);
	s_Object->~SMovementDrainPipeSaveData();
}

ZHMTypeInfo SMovementHideInClosetSaveData::TypeInfo = ZHMTypeInfo("SMovementHideInClosetSaveData", sizeof(SMovementHideInClosetSaveData), alignof(SMovementHideInClosetSaveData), SMovementHideInClosetSaveData::WriteSimpleJson, SMovementHideInClosetSaveData::FromSimpleJson, SMovementHideInClosetSaveData::Serialize, SMovementHideInClosetSaveData::Equals, SMovementHideInClosetSaveData::Destroy);

void SMovementHideInClosetSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eCurrentClosetType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ICloset.EClosetType", static_cast<int>(s_Object->m_eCurrentClosetType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rCloset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCloset);

	p_Stream << "}";
}

void SMovementHideInClosetSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementHideInClosetSaveData s_Object {};

	s_Object.m_eCurrentClosetType = static_cast<ICloset_EClosetType>(ZHMEnums::GetEnumValueByName("ICloset.EClosetType", std::string_view(p_Document["m_eCurrentClosetType"])));

	s_Object.m_rCloset = simdjson::from_json_uint32(p_Document["m_rCloset"]);

	*reinterpret_cast<SMovementHideInClosetSaveData*>(p_Target) = s_Object;
}

void SMovementHideInClosetSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);

}

bool SMovementHideInClosetSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementHideInClosetSaveData::operator==(const SMovementHideInClosetSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementHideInClosetSaveData>)
		return false;

	if (m_eCurrentClosetType != p_Other.m_eCurrentClosetType) return false;
	if (m_rCloset != p_Other.m_rCloset) return false;

	return true;
}

void SMovementHideInClosetSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementHideInClosetSaveData*>(p_Object);
	s_Object->~SMovementHideInClosetSaveData();
}

ZHMTypeInfo SMovementLadderSaveData::TypeInfo = ZHMTypeInfo("SMovementLadderSaveData", sizeof(SMovementLadderSaveData), alignof(SMovementLadderSaveData), SMovementLadderSaveData::WriteSimpleJson, SMovementLadderSaveData::FromSimpleJson, SMovementLadderSaveData::Serialize, SMovementLadderSaveData::Equals, SMovementLadderSaveData::Destroy);

void SMovementLadderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rLadder") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rLadder);

	p_Stream << "}";
}

void SMovementLadderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementLadderSaveData s_Object {};

	s_Object.m_rLadder = simdjson::from_json_uint32(p_Document["m_rLadder"]);

	*reinterpret_cast<SMovementLadderSaveData*>(p_Target) = s_Object;
}

void SMovementLadderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);

}

bool SMovementLadderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementLadderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementLadderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementLadderSaveData::operator==(const SMovementLadderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementLadderSaveData>)
		return false;

	if (m_rLadder != p_Other.m_rLadder) return false;

	return true;
}

void SMovementLadderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementLadderSaveData*>(p_Object);
	s_Object->~SMovementLadderSaveData();
}

ZHMTypeInfo SMovementLocomotionSaveData::TypeInfo = ZHMTypeInfo("SMovementLocomotionSaveData", sizeof(SMovementLocomotionSaveData), alignof(SMovementLocomotionSaveData), SMovementLocomotionSaveData::WriteSimpleJson, SMovementLocomotionSaveData::FromSimpleJson, SMovementLocomotionSaveData::Serialize, SMovementLocomotionSaveData::Equals, SMovementLocomotionSaveData::Destroy);

void SMovementLocomotionSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsSneaking") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsSneaking);

	p_Stream << "}";
}

void SMovementLocomotionSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMovementLocomotionSaveData s_Object {};

	s_Object.m_bIsSneaking = simdjson::from_json_bool(p_Document["m_bIsSneaking"]);

	*reinterpret_cast<SMovementLocomotionSaveData*>(p_Target) = s_Object;
}

void SMovementLocomotionSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);

}

bool SMovementLocomotionSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMovementLocomotionSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMovementLocomotionSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMovementLocomotionSaveData::operator==(const SMovementLocomotionSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMovementLocomotionSaveData>)
		return false;

	if (m_bIsSneaking != p_Other.m_bIsSneaking) return false;

	return true;
}

void SMovementLocomotionSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMovementLocomotionSaveData*>(p_Object);
	s_Object->~SMovementLocomotionSaveData();
}

ZHMTypeInfo SMusicGridData::TypeInfo = ZHMTypeInfo("SMusicGridData", sizeof(SMusicGridData), alignof(SMusicGridData), SMusicGridData::WriteSimpleJson, SMusicGridData::FromSimpleJson, SMusicGridData::Serialize, SMusicGridData::Equals, SMusicGridData::Destroy);

void SMusicGridData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fGridDurationSec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridDurationSec);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridOffsetSec") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridOffsetSec);

	p_Stream << "}";
}

void SMusicGridData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SMusicGridData s_Object {};

	s_Object.m_fGridDurationSec = simdjson::from_json_float32(p_Document["m_fGridDurationSec"]);

	s_Object.m_fGridOffsetSec = simdjson::from_json_float32(p_Document["m_fGridOffsetSec"]);

	*reinterpret_cast<SMusicGridData*>(p_Target) = s_Object;
}

void SMusicGridData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);

}

bool SMusicGridData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SMusicGridData*>(p_Left);
	auto* s_Right = reinterpret_cast<SMusicGridData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SMusicGridData::operator==(const SMusicGridData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SMusicGridData>)
		return false;

	if (m_fGridDurationSec != p_Other.m_fGridDurationSec) return false;
	if (m_fGridOffsetSec != p_Other.m_fGridOffsetSec) return false;

	return true;
}

void SMusicGridData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SMusicGridData*>(p_Object);
	s_Object->~SMusicGridData();
}

ZHMTypeInfo SObserversGroupSaveData::TypeInfo = ZHMTypeInfo("SObserversGroupSaveData", sizeof(SObserversGroupSaveData), alignof(SObserversGroupSaveData), SObserversGroupSaveData::WriteSimpleJson, SObserversGroupSaveData::FromSimpleJson, SObserversGroupSaveData::Serialize, SObserversGroupSaveData::Equals, SObserversGroupSaveData::Destroy);

void SObserversGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingObservers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingObservers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingObservers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aWaitingObservers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_observerDistanceMax") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_observerDistanceMax);

	p_Stream << "}";
}

void SObserversGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SObserversGroupSaveData s_Object {};

	s_Object.m_target = simdjson::from_json_uint32(p_Document["m_target"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aWaitingObservers"];
	s_Object.m_aWaitingObservers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aWaitingObservers[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_observerDistanceMax = simdjson::from_json_float32(p_Document["m_observerDistanceMax"]);

	*reinterpret_cast<SObserversGroupSaveData*>(p_Target) = s_Object;
}

void SObserversGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aWaitingObservers, p_Serializer, p_OwnOffset + offsetof(SObserversGroupSaveData, m_aWaitingObservers));
}

bool SObserversGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SObserversGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SObserversGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SObserversGroupSaveData::operator==(const SObserversGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SObserversGroupSaveData>)
		return false;

	if (m_target != p_Other.m_target) return false;
	if (m_aWaitingObservers != p_Other.m_aWaitingObservers) return false;
	if (m_observerDistanceMax != p_Other.m_observerDistanceMax) return false;

	return true;
}

void SObserversGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SObserversGroupSaveData*>(p_Object);
	s_Object->~SObserversGroupSaveData();
}

ZHMTypeInfo SOnlineEvent::TypeInfo = ZHMTypeInfo("SOnlineEvent", sizeof(SOnlineEvent), alignof(SOnlineEvent), SOnlineEvent::WriteSimpleJson, SOnlineEvent::FromSimpleJson, SOnlineEvent::Serialize, SOnlineEvent::Equals, SOnlineEvent::Destroy);

void SOnlineEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("data") << ":";
	ZDynamicObject::WriteSimpleJson(&s_Object->data, p_Stream);

	p_Stream << "}";
}

void SOnlineEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SOnlineEvent s_Object {};

	s_Object.sName = std::string_view(p_Document["sName"]);

	{
		ZDynamicObject s_Item {};
		ZDynamicObject::FromSimpleJson(p_Document["data"], &s_Item);
		s_Object.data = s_Item;
	}

	*reinterpret_cast<SOnlineEvent*>(p_Target) = s_Object;
}

void SOnlineEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);

	ZString::Serialize(&s_Object->sName, p_Serializer, p_OwnOffset + offsetof(SOnlineEvent, sName));
	ZDynamicObject::Serialize(&s_Object->data, p_Serializer, p_OwnOffset + offsetof(SOnlineEvent, data));
}

bool SOnlineEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SOnlineEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<SOnlineEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool SOnlineEvent::operator==(const SOnlineEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SOnlineEvent>)
		return false;

	if (sName != p_Other.sName) return false;
	if (data != p_Other.data) return false;

	return true;
}

void SOnlineEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SOnlineEvent*>(p_Object);
	s_Object->~SOnlineEvent();
}

ZHMTypeInfo SOnlineSaveData::TypeInfo = ZHMTypeInfo("SOnlineSaveData", sizeof(SOnlineSaveData), alignof(SOnlineSaveData), SOnlineSaveData::WriteSimpleJson, SOnlineSaveData::FromSimpleJson, SOnlineSaveData::Serialize, SOnlineSaveData::Equals, SOnlineSaveData::Destroy);

void SOnlineSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOnlineSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTimeStamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTimeStamp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsOnline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsOnline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sContractSessionId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sContractSessionId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sLastEventToken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sLastEventToken);

	p_Stream << "}";
}

void SOnlineSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SOnlineSaveData s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	s_Object.m_nTimeStamp = simdjson::from_json_int64(p_Document["m_nTimeStamp"]);

	s_Object.m_bIsOnline = simdjson::from_json_bool(p_Document["m_bIsOnline"]);

	s_Object.m_sContractSessionId = std::string_view(p_Document["m_sContractSessionId"]);

	s_Object.m_sLastEventToken = std::string_view(p_Document["m_sLastEventToken"]);

	*reinterpret_cast<SOnlineSaveData*>(p_Target) = s_Object;
}

void SOnlineSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SOnlineSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SOnlineSaveData, m_sName));
	ZString::Serialize(&s_Object->m_sContractSessionId, p_Serializer, p_OwnOffset + offsetof(SOnlineSaveData, m_sContractSessionId));
	ZString::Serialize(&s_Object->m_sLastEventToken, p_Serializer, p_OwnOffset + offsetof(SOnlineSaveData, m_sLastEventToken));
}

bool SOnlineSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SOnlineSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SOnlineSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SOnlineSaveData::operator==(const SOnlineSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SOnlineSaveData>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_nTimeStamp != p_Other.m_nTimeStamp) return false;
	if (m_bIsOnline != p_Other.m_bIsOnline) return false;
	if (m_sContractSessionId != p_Other.m_sContractSessionId) return false;
	if (m_sLastEventToken != p_Other.m_sLastEventToken) return false;

	return true;
}

void SOnlineSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SOnlineSaveData*>(p_Object);
	s_Object->~SOnlineSaveData();
}

ZHMTypeInfo SOptionValueSaveData::TypeInfo = ZHMTypeInfo("SOptionValueSaveData", sizeof(SOptionValueSaveData), alignof(SOptionValueSaveData), SOptionValueSaveData::WriteSimpleJson, SOptionValueSaveData::FromSimpleJson, SOptionValueSaveData::Serialize, SOptionValueSaveData::Equals, SOptionValueSaveData::Destroy);

void SOptionValueSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Value") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Value, p_Stream);

	p_Stream << "}";
}

void SOptionValueSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SOptionValueSaveData s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Value"], &s_Item);
		s_Object.m_Value = s_Item;
	}

	*reinterpret_cast<SOptionValueSaveData*>(p_Target) = s_Object;
}

void SOptionValueSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Value, p_Serializer, p_OwnOffset + offsetof(SOptionValueSaveData, m_Value));
}

bool SOptionValueSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SOptionValueSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SOptionValueSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SOptionValueSaveData::operator==(const SOptionValueSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SOptionValueSaveData>)
		return false;

	if (m_Value != p_Other.m_Value) return false;

	return true;
}

void SOptionValueSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SOptionValueSaveData*>(p_Object);
	s_Object->~SOptionValueSaveData();
}

ZHMTypeInfo SPFObstactleSaveData::TypeInfo = ZHMTypeInfo("SPFObstactleSaveData", sizeof(SPFObstactleSaveData), alignof(SPFObstactleSaveData), SPFObstactleSaveData::WriteSimpleJson, SPFObstactleSaveData::FromSimpleJson, SPFObstactleSaveData::Serialize, SPFObstactleSaveData::Equals, SPFObstactleSaveData::Destroy);

void SPFObstactleSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SPFObstactleSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPFObstactleSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SPFObstactleSaveData*>(p_Target) = s_Object;
}

void SPFObstactleSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);

}

bool SPFObstactleSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPFObstactleSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPFObstactleSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPFObstactleSaveData::operator==(const SPFObstactleSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPFObstactleSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SPFObstactleSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPFObstactleSaveData*>(p_Object);
	s_Object->~SPFObstactleSaveData();
}

ZHMTypeInfo SPIPMessageManagerProxySaveData::TypeInfo = ZHMTypeInfo("SPIPMessageManagerProxySaveData", sizeof(SPIPMessageManagerProxySaveData), alignof(SPIPMessageManagerProxySaveData), SPIPMessageManagerProxySaveData::WriteSimpleJson, SPIPMessageManagerProxySaveData::FromSimpleJson, SPIPMessageManagerProxySaveData::Serialize, SPIPMessageManagerProxySaveData::Equals, SPIPMessageManagerProxySaveData::Destroy);

void SPIPMessageManagerProxySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPIPMessageManagerProxySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SPIPMessageManagerProxySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPIPMessageManagerProxySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SPIPMessageManagerProxySaveData*>(p_Target) = s_Object;
}

void SPIPMessageManagerProxySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPIPMessageManagerProxySaveData*>(p_Object);

}

bool SPIPMessageManagerProxySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPIPMessageManagerProxySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPIPMessageManagerProxySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPIPMessageManagerProxySaveData::operator==(const SPIPMessageManagerProxySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPIPMessageManagerProxySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SPIPMessageManagerProxySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPIPMessageManagerProxySaveData*>(p_Object);
	s_Object->~SPIPMessageManagerProxySaveData();
}

ZHMTypeInfo SPatrolGroupSaveData::TypeInfo = ZHMTypeInfo("SPatrolGroupSaveData", sizeof(SPatrolGroupSaveData), alignof(SPatrolGroupSaveData), SPatrolGroupSaveData::WriteSimpleJson, SPatrolGroupSaveData::FromSimpleJson, SPatrolGroupSaveData::Serialize, SPatrolGroupSaveData::Equals, SPatrolGroupSaveData::Destroy);

void SPatrolGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nRouteID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRouteID);

	p_Stream << "}";
}

void SPatrolGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPatrolGroupSaveData s_Object {};

	s_Object.m_nRouteID = simdjson::from_json_int32(p_Document["m_nRouteID"]);

	*reinterpret_cast<SPatrolGroupSaveData*>(p_Target) = s_Object;
}

void SPatrolGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);

}

bool SPatrolGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPatrolGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPatrolGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPatrolGroupSaveData::operator==(const SPatrolGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPatrolGroupSaveData>)
		return false;

	if (m_nRouteID != p_Other.m_nRouteID) return false;

	return true;
}

void SPatrolGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPatrolGroupSaveData*>(p_Object);
	s_Object->~SPatrolGroupSaveData();
}

ZHMTypeInfo SPatrolOrderSaveData::TypeInfo = ZHMTypeInfo("SPatrolOrderSaveData", sizeof(SPatrolOrderSaveData), alignof(SPatrolOrderSaveData), SPatrolOrderSaveData::WriteSimpleJson, SPatrolOrderSaveData::FromSimpleJson, SPatrolOrderSaveData::Serialize, SPatrolOrderSaveData::Equals, SPatrolOrderSaveData::Destroy);

void SPatrolOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SPatrolOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPatrolOrderSaveData s_Object {};

	*reinterpret_cast<SPatrolOrderSaveData*>(p_Target) = s_Object;
}

void SPatrolOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);

}

bool SPatrolOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPatrolOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPatrolOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPatrolOrderSaveData::operator==(const SPatrolOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPatrolOrderSaveData>)
		return false;


	return true;
}

void SPatrolOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPatrolOrderSaveData*>(p_Object);
	s_Object->~SPatrolOrderSaveData();
}

ZHMTypeInfo SPerceptibleCrowdBodySaveData::TypeInfo = ZHMTypeInfo("SPerceptibleCrowdBodySaveData", sizeof(SPerceptibleCrowdBodySaveData), alignof(SPerceptibleCrowdBodySaveData), SPerceptibleCrowdBodySaveData::WriteSimpleJson, SPerceptibleCrowdBodySaveData::FromSimpleJson, SPerceptibleCrowdBodySaveData::Serialize, SPerceptibleCrowdBodySaveData::Equals, SPerceptibleCrowdBodySaveData::Destroy);

void SPerceptibleCrowdBodySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCombatZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCombatZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSharedKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSharedKnowledge);

	p_Stream << "}";
}

void SPerceptibleCrowdBodySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPerceptibleCrowdBodySaveData s_Object {};

	s_Object.m_rCombatZone = simdjson::from_json_uint32(p_Document["m_rCombatZone"]);

	s_Object.m_rSharedKnowledge = simdjson::from_json_int32(p_Document["m_rSharedKnowledge"]);

	*reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Target) = s_Object;
}

void SPerceptibleCrowdBodySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);

}

bool SPerceptibleCrowdBodySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPerceptibleCrowdBodySaveData::operator==(const SPerceptibleCrowdBodySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPerceptibleCrowdBodySaveData>)
		return false;

	if (m_rCombatZone != p_Other.m_rCombatZone) return false;
	if (m_rSharedKnowledge != p_Other.m_rSharedKnowledge) return false;

	return true;
}

void SPerceptibleCrowdBodySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPerceptibleCrowdBodySaveData*>(p_Object);
	s_Object->~SPerceptibleCrowdBodySaveData();
}

ZHMTypeInfo SPersistentEntitySaveData::TypeInfo = ZHMTypeInfo("SPersistentEntitySaveData", sizeof(SPersistentEntitySaveData), alignof(SPersistentEntitySaveData), SPersistentEntitySaveData::WriteSimpleJson, SPersistentEntitySaveData::FromSimpleJson, SPersistentEntitySaveData::Serialize, SPersistentEntitySaveData::Equals, SPersistentEntitySaveData::Destroy);

void SPersistentEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nResourceId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nResourceId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityIDs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityIDs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityIDs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityNames") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityNames.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityNames[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityNames.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPersistentEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPersistentEntitySaveData s_Object {};

	s_Object.m_nResourceId = simdjson::from_json_uint64(p_Document["m_nResourceId"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityIDs"];
	s_Object.m_aEntityIDs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntityIDs[s_Index0++] = simdjson::from_json_uint64(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityNames"];
	s_Object.m_aEntityNames.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntityNames[s_Index0++] = std::string_view(s_Item0);
	}
	}

	*reinterpret_cast<SPersistentEntitySaveData*>(p_Target) = s_Object;
}

void SPersistentEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);

	TArray<uint64>::Serialize(&s_Object->m_aEntityIDs, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveData, m_aEntityIDs));
	TArray<ZString>::Serialize(&s_Object->m_aEntityNames, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveData, m_aEntityNames));
}

bool SPersistentEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPersistentEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPersistentEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPersistentEntitySaveData::operator==(const SPersistentEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPersistentEntitySaveData>)
		return false;

	if (m_nResourceId != p_Other.m_nResourceId) return false;
	if (m_aEntityIDs != p_Other.m_aEntityIDs) return false;
	if (m_aEntityNames != p_Other.m_aEntityNames) return false;

	return true;
}

void SPersistentEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveData*>(p_Object);
	s_Object->~SPersistentEntitySaveData();
}

ZHMTypeInfo SPersistentEntitySaveDataList::TypeInfo = ZHMTypeInfo("SPersistentEntitySaveDataList", sizeof(SPersistentEntitySaveDataList), alignof(SPersistentEntitySaveDataList), SPersistentEntitySaveDataList::WriteSimpleJson, SPersistentEntitySaveDataList::FromSimpleJson, SPersistentEntitySaveDataList::Serialize, SPersistentEntitySaveDataList::Equals, SPersistentEntitySaveDataList::Destroy);

void SPersistentEntitySaveDataList::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntityDatas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityDatas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityDatas[i];
		SPersistentEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityDatas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mDynamicObjectIDGenerationKeys") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_mDynamicObjectIDGenerationKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_mDynamicObjectIDGenerationKeys[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_mDynamicObjectIDGenerationKeys.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mDynamicObjectIDGenerationValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_mDynamicObjectIDGenerationValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_mDynamicObjectIDGenerationValues[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_mDynamicObjectIDGenerationValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPersistentEntitySaveDataList::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPersistentEntitySaveDataList s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityDatas"];
	s_Object.m_aEntityDatas.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SPersistentEntitySaveData s_ArrayItem0;
		SPersistentEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEntityDatas[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_mDynamicObjectIDGenerationKeys"];
	s_Object.m_mDynamicObjectIDGenerationKeys.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_mDynamicObjectIDGenerationKeys[s_Index0++] = simdjson::from_json_uint64(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_mDynamicObjectIDGenerationValues"];
	s_Object.m_mDynamicObjectIDGenerationValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_mDynamicObjectIDGenerationValues[s_Index0++] = simdjson::from_json_uint64(s_Item0);
	}
	}

	*reinterpret_cast<SPersistentEntitySaveDataList*>(p_Target) = s_Object;
}

void SPersistentEntitySaveDataList::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);

	TArray<SPersistentEntitySaveData>::Serialize(&s_Object->m_aEntityDatas, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveDataList, m_aEntityDatas));
	TArray<uint64>::Serialize(&s_Object->m_mDynamicObjectIDGenerationKeys, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveDataList, m_mDynamicObjectIDGenerationKeys));
	TArray<uint64>::Serialize(&s_Object->m_mDynamicObjectIDGenerationValues, p_Serializer, p_OwnOffset + offsetof(SPersistentEntitySaveDataList, m_mDynamicObjectIDGenerationValues));
}

bool SPersistentEntitySaveDataList::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Left);
	auto* s_Right = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPersistentEntitySaveDataList::operator==(const SPersistentEntitySaveDataList& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPersistentEntitySaveDataList>)
		return false;

	if (m_aEntityDatas != p_Other.m_aEntityDatas) return false;
	if (m_mDynamicObjectIDGenerationKeys != p_Other.m_mDynamicObjectIDGenerationKeys) return false;
	if (m_mDynamicObjectIDGenerationValues != p_Other.m_mDynamicObjectIDGenerationValues) return false;

	return true;
}

void SPersistentEntitySaveDataList::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPersistentEntitySaveDataList*>(p_Object);
	s_Object->~SPersistentEntitySaveDataList();
}

ZHMTypeInfo SPhysicsSaveData::TypeInfo = ZHMTypeInfo("SPhysicsSaveData", sizeof(SPhysicsSaveData), alignof(SPhysicsSaveData), SPhysicsSaveData::WriteSimpleJson, SPhysicsSaveData::FromSimpleJson, SPhysicsSaveData::Serialize, SPhysicsSaveData::Equals, SPhysicsSaveData::Destroy);

void SPhysicsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInPhysicsWorld") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInPhysicsWorld);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsKinematicBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsKinematicBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);

	p_Stream << "}";
}

void SPhysicsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPhysicsSaveData s_Object {};

	s_Object.m_bIsInPhysicsWorld = simdjson::from_json_bool(p_Document["m_bIsInPhysicsWorld"]);

	s_Object.m_bIsKinematicBody = simdjson::from_json_bool(p_Document["m_bIsKinematicBody"]);

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	*reinterpret_cast<SPhysicsSaveData*>(p_Target) = s_Object;
}

void SPhysicsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);

}

bool SPhysicsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPhysicsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPhysicsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPhysicsSaveData::operator==(const SPhysicsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPhysicsSaveData>)
		return false;

	if (m_bIsInPhysicsWorld != p_Other.m_bIsInPhysicsWorld) return false;
	if (m_bIsKinematicBody != p_Other.m_bIsKinematicBody) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;

	return true;
}

void SPhysicsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPhysicsSaveData*>(p_Object);
	s_Object->~SPhysicsSaveData();
}

ZHMTypeInfo SPhysicsListSaveData::TypeInfo = ZHMTypeInfo("SPhysicsListSaveData", sizeof(SPhysicsListSaveData), alignof(SPhysicsListSaveData), SPhysicsListSaveData::WriteSimpleJson, SPhysicsListSaveData::FromSimpleJson, SPhysicsListSaveData::Serialize, SPhysicsListSaveData::Equals, SPhysicsListSaveData::Destroy);

void SPhysicsListSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntityRefs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityRefs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityRefs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntityRefs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityDatas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityDatas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityDatas[i];
		SPhysicsSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityDatas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPhysicsListSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPhysicsListSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityRefs"];
	s_Object.m_aEntityRefs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntityRefs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityDatas"];
	s_Object.m_aEntityDatas.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SPhysicsSaveData s_ArrayItem0;
		SPhysicsSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEntityDatas[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SPhysicsListSaveData*>(p_Target) = s_Object;
}

void SPhysicsListSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntityRefs, p_Serializer, p_OwnOffset + offsetof(SPhysicsListSaveData, m_aEntityRefs));
	TArray<SPhysicsSaveData>::Serialize(&s_Object->m_aEntityDatas, p_Serializer, p_OwnOffset + offsetof(SPhysicsListSaveData, m_aEntityDatas));
}

bool SPhysicsListSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPhysicsListSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPhysicsListSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPhysicsListSaveData::operator==(const SPhysicsListSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPhysicsListSaveData>)
		return false;

	if (m_aEntityRefs != p_Other.m_aEntityRefs) return false;
	if (m_aEntityDatas != p_Other.m_aEntityDatas) return false;

	return true;
}

void SPhysicsListSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPhysicsListSaveData*>(p_Object);
	s_Object->~SPhysicsListSaveData();
}

ZHMTypeInfo SPrivateAreaSaveData::TypeInfo = ZHMTypeInfo("SPrivateAreaSaveData", sizeof(SPrivateAreaSaveData), alignof(SPrivateAreaSaveData), SPrivateAreaSaveData::WriteSimpleJson, SPrivateAreaSaveData::FromSimpleJson, SPrivateAreaSaveData::Serialize, SPrivateAreaSaveData::Equals, SPrivateAreaSaveData::Destroy);

void SPrivateAreaSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsInside") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsInside);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpotted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpotted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActiveActors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActiveActors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActiveActors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aActiveActors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SPrivateAreaSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SPrivateAreaSaveData s_Object {};

	s_Object.m_bIsInside = simdjson::from_json_bool(p_Document["m_bIsInside"]);

	s_Object.m_bSpotted = simdjson::from_json_bool(p_Document["m_bSpotted"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActiveActors"];
	s_Object.m_aActiveActors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aActiveActors[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SPrivateAreaSaveData*>(p_Target) = s_Object;
}

void SPrivateAreaSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aActiveActors, p_Serializer, p_OwnOffset + offsetof(SPrivateAreaSaveData, m_aActiveActors));
}

bool SPrivateAreaSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SPrivateAreaSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SPrivateAreaSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SPrivateAreaSaveData::operator==(const SPrivateAreaSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SPrivateAreaSaveData>)
		return false;

	if (m_bIsInside != p_Other.m_bIsInside) return false;
	if (m_bSpotted != p_Other.m_bSpotted) return false;
	if (m_aActiveActors != p_Other.m_aActiveActors) return false;

	return true;
}

void SPrivateAreaSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SPrivateAreaSaveData*>(p_Object);
	s_Object->~SPrivateAreaSaveData();
}

ZHMTypeInfo SProgressTimerEntitySaveData::TypeInfo = ZHMTypeInfo("SProgressTimerEntitySaveData", sizeof(SProgressTimerEntitySaveData), alignof(SProgressTimerEntitySaveData), SProgressTimerEntitySaveData::WriteSimpleJson, SProgressTimerEntitySaveData::FromSimpleJson, SProgressTimerEntitySaveData::Serialize, SProgressTimerEntitySaveData::Equals, SProgressTimerEntitySaveData::Destroy);

void SProgressTimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SProgressTimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValue);

	p_Stream << "}";
}

void SProgressTimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SProgressTimerEntitySaveData s_Object {};

	s_Object.m_nInterval = simdjson::from_json_int32(p_Document["m_nInterval"]);

	s_Object.m_nRemaining = simdjson::from_json_int32(p_Document["m_nRemaining"]);

	s_Object.m_bValue = simdjson::from_json_bool(p_Document["m_bValue"]);

	*reinterpret_cast<SProgressTimerEntitySaveData*>(p_Target) = s_Object;
}

void SProgressTimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SProgressTimerEntitySaveData*>(p_Object);

}

bool SProgressTimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SProgressTimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SProgressTimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SProgressTimerEntitySaveData::operator==(const SProgressTimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SProgressTimerEntitySaveData>)
		return false;

	if (m_nInterval != p_Other.m_nInterval) return false;
	if (m_nRemaining != p_Other.m_nRemaining) return false;
	if (m_bValue != p_Other.m_bValue) return false;

	return true;
}

void SProgressTimerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SProgressTimerEntitySaveData*>(p_Object);
	s_Object->~SProgressTimerEntitySaveData();
}

ZHMTypeInfo SRandomTimerEntitySaveData::TypeInfo = ZHMTypeInfo("SRandomTimerEntitySaveData", sizeof(SRandomTimerEntitySaveData), alignof(SRandomTimerEntitySaveData), SRandomTimerEntitySaveData::WriteSimpleJson, SRandomTimerEntitySaveData::FromSimpleJson, SRandomTimerEntitySaveData::Serialize, SRandomTimerEntitySaveData::Equals, SRandomTimerEntitySaveData::Destroy);

void SRandomTimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRegistered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMinTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMinTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMaxTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMaxTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fProbability") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProbability);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nRemaining);

	p_Stream << "}";
}

void SRandomTimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRandomTimerEntitySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bRegistered = simdjson::from_json_bool(p_Document["m_bRegistered"]);

	s_Object.m_fMinTime = simdjson::from_json_float32(p_Document["m_fMinTime"]);

	s_Object.m_fMaxTime = simdjson::from_json_float32(p_Document["m_fMaxTime"]);

	s_Object.m_fProbability = simdjson::from_json_float32(p_Document["m_fProbability"]);

	s_Object.m_nRemaining = simdjson::from_json_int32(p_Document["m_nRemaining"]);

	*reinterpret_cast<SRandomTimerEntitySaveData*>(p_Target) = s_Object;
}

void SRandomTimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);

}

bool SRandomTimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRandomTimerEntitySaveData::operator==(const SRandomTimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRandomTimerEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bRegistered != p_Other.m_bRegistered) return false;
	if (m_fMinTime != p_Other.m_fMinTime) return false;
	if (m_fMaxTime != p_Other.m_fMaxTime) return false;
	if (m_fProbability != p_Other.m_fProbability) return false;
	if (m_nRemaining != p_Other.m_nRemaining) return false;

	return true;
}

void SRandomTimerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitySaveData*>(p_Object);
	s_Object->~SRandomTimerEntitySaveData();
}

ZHMTypeInfo SRandomTimerEntitiesSaveData::TypeInfo = ZHMTypeInfo("SRandomTimerEntitiesSaveData", sizeof(SRandomTimerEntitiesSaveData), alignof(SRandomTimerEntitiesSaveData), SRandomTimerEntitiesSaveData::WriteSimpleJson, SRandomTimerEntitiesSaveData::FromSimpleJson, SRandomTimerEntitiesSaveData::Serialize, SRandomTimerEntitiesSaveData::Equals, SRandomTimerEntitiesSaveData::Destroy);

void SRandomTimerEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SRandomTimerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SRandomTimerEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRandomTimerEntitiesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SRandomTimerEntitySaveData s_ArrayItem0;
		SRandomTimerEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Target) = s_Object;
}

void SRandomTimerEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SRandomTimerEntitiesSaveData, m_aEntities));
	TArray<SRandomTimerEntitySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SRandomTimerEntitiesSaveData, m_aData));
}

bool SRandomTimerEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRandomTimerEntitiesSaveData::operator==(const SRandomTimerEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRandomTimerEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SRandomTimerEntitiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRandomTimerEntitiesSaveData*>(p_Object);
	s_Object->~SRandomTimerEntitiesSaveData();
}

ZHMTypeInfo ZBitArray::TypeInfo = ZHMTypeInfo("ZBitArray", sizeof(ZBitArray), alignof(ZBitArray), ZBitArray::WriteSimpleJson, ZBitArray::FromSimpleJson, ZBitArray::Serialize, ZBitArray::Equals, ZBitArray::Destroy);

void ZBitArray::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aBytes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aBytes.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aBytes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aBytes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSize);

	p_Stream << "}";
}

void ZBitArray::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZBitArray s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aBytes"];
	s_Object.m_aBytes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aBytes[s_Index0++] = simdjson::from_json_uint8(s_Item0);
	}
	}

	s_Object.m_nSize = simdjson::from_json_uint32(p_Document["m_nSize"]);

	*reinterpret_cast<ZBitArray*>(p_Target) = s_Object;
}

void ZBitArray::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);

	TArray<uint8>::Serialize(&s_Object->m_aBytes, p_Serializer, p_OwnOffset + offsetof(ZBitArray, m_aBytes));
}

bool ZBitArray::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZBitArray*>(p_Left);
	auto* s_Right = reinterpret_cast<ZBitArray*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZBitArray::operator==(const ZBitArray& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZBitArray>)
		return false;

	if (m_aBytes != p_Other.m_aBytes) return false;
	if (m_nSize != p_Other.m_nSize) return false;

	return true;
}

void ZBitArray::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZBitArray*>(p_Object);
	s_Object->~ZBitArray();
}

ZHMTypeInfo SReasoningGrid::TypeInfo = ZHMTypeInfo("SReasoningGrid", sizeof(SReasoningGrid), alignof(SReasoningGrid), SReasoningGrid::WriteSimpleJson, SReasoningGrid::FromSimpleJson, SReasoningGrid::Serialize, SReasoningGrid::Equals, SReasoningGrid::Destroy);

void SReasoningGrid::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_WaypointList") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_WaypointList.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_WaypointList[i];
		SGWaypoint::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_WaypointList.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LowVisibilityBits") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_LowVisibilityBits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_HighVisibilityBits") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_HighVisibilityBits, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Properties") << ":";
	SGProperties::WriteSimpleJson(&s_Object->m_Properties, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNodeCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNodeCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pVisibilityData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_pVisibilityData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_pVisibilityData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_pVisibilityData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_deadEndData") << ":";
	ZBitArray::WriteSimpleJson(&s_Object->m_deadEndData, p_Stream);

	p_Stream << "}";
}

void SReasoningGrid::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SReasoningGrid s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_WaypointList"];
	s_Object.m_WaypointList.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SGWaypoint s_ArrayItem0;
		SGWaypoint::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_WaypointList[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		ZBitArray s_Item {};
		ZBitArray::FromSimpleJson(p_Document["m_LowVisibilityBits"], &s_Item);
		s_Object.m_LowVisibilityBits = s_Item;
	}

	{
		ZBitArray s_Item {};
		ZBitArray::FromSimpleJson(p_Document["m_HighVisibilityBits"], &s_Item);
		s_Object.m_HighVisibilityBits = s_Item;
	}

	{
		SGProperties s_Item {};
		SGProperties::FromSimpleJson(p_Document["m_Properties"], &s_Item);
		s_Object.m_Properties = s_Item;
	}

	s_Object.m_nNodeCount = simdjson::from_json_uint32(p_Document["m_nNodeCount"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_pVisibilityData"];
	s_Object.m_pVisibilityData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_pVisibilityData[s_Index0++] = simdjson::from_json_uint8(s_Item0);
	}
	}

	{
		ZBitArray s_Item {};
		ZBitArray::FromSimpleJson(p_Document["m_deadEndData"], &s_Item);
		s_Object.m_deadEndData = s_Item;
	}

	*reinterpret_cast<SReasoningGrid*>(p_Target) = s_Object;
}

void SReasoningGrid::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);

	TArray<SGWaypoint>::Serialize(&s_Object->m_WaypointList, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_WaypointList));
	ZBitArray::Serialize(&s_Object->m_LowVisibilityBits, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_LowVisibilityBits));
	ZBitArray::Serialize(&s_Object->m_HighVisibilityBits, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_HighVisibilityBits));
	SGProperties::Serialize(&s_Object->m_Properties, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_Properties));
	TArray<uint8>::Serialize(&s_Object->m_pVisibilityData, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_pVisibilityData));
	ZBitArray::Serialize(&s_Object->m_deadEndData, p_Serializer, p_OwnOffset + offsetof(SReasoningGrid, m_deadEndData));
}

bool SReasoningGrid::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SReasoningGrid*>(p_Left);
	auto* s_Right = reinterpret_cast<SReasoningGrid*>(p_Right);

	return *s_Left == *s_Right;
}

bool SReasoningGrid::operator==(const SReasoningGrid& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SReasoningGrid>)
		return false;

	if (m_WaypointList != p_Other.m_WaypointList) return false;
	if (m_LowVisibilityBits != p_Other.m_LowVisibilityBits) return false;
	if (m_HighVisibilityBits != p_Other.m_HighVisibilityBits) return false;
	if (m_Properties != p_Other.m_Properties) return false;
	if (m_nNodeCount != p_Other.m_nNodeCount) return false;
	if (m_pVisibilityData != p_Other.m_pVisibilityData) return false;
	if (m_deadEndData != p_Other.m_deadEndData) return false;

	return true;
}

void SReasoningGrid::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SReasoningGrid*>(p_Object);
	s_Object->~SReasoningGrid();
}

ZHMTypeInfo SRecoverUnconsciousGroupSaveData::TypeInfo = ZHMTypeInfo("SRecoverUnconsciousGroupSaveData", sizeof(SRecoverUnconsciousGroupSaveData), alignof(SRecoverUnconsciousGroupSaveData), SRecoverUnconsciousGroupSaveData::WriteSimpleJson, SRecoverUnconsciousGroupSaveData::FromSimpleJson, SRecoverUnconsciousGroupSaveData::Serialize, SRecoverUnconsciousGroupSaveData::Equals, SRecoverUnconsciousGroupSaveData::Destroy);

void SRecoverUnconsciousGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rWaker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rWaker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWokenUpInTheGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWokenUpInTheGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFastWakeUp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFastWakeUp);

	p_Stream << "}";
}

void SRecoverUnconsciousGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRecoverUnconsciousGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_rVictim = simdjson::from_json_uint32(p_Document["m_rVictim"]);

	s_Object.m_rWaker = simdjson::from_json_uint32(p_Document["m_rWaker"]);

	s_Object.m_fTimer = simdjson::from_json_float32(p_Document["m_fTimer"]);

	s_Object.m_bEscalate = simdjson::from_json_bool(p_Document["m_bEscalate"]);

	s_Object.m_bWokenUpInTheGroup = simdjson::from_json_bool(p_Document["m_bWokenUpInTheGroup"]);

	s_Object.m_bFastWakeUp = simdjson::from_json_bool(p_Document["m_bFastWakeUp"]);

	*reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Target) = s_Object;
}

void SRecoverUnconsciousGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SRecoverUnconsciousGroupSaveData, m_fsmState));
}

bool SRecoverUnconsciousGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRecoverUnconsciousGroupSaveData::operator==(const SRecoverUnconsciousGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRecoverUnconsciousGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_rVictim != p_Other.m_rVictim) return false;
	if (m_rWaker != p_Other.m_rWaker) return false;
	if (m_fTimer != p_Other.m_fTimer) return false;
	if (m_bEscalate != p_Other.m_bEscalate) return false;
	if (m_bWokenUpInTheGroup != p_Other.m_bWokenUpInTheGroup) return false;
	if (m_bFastWakeUp != p_Other.m_bFastWakeUp) return false;

	return true;
}

void SRecoverUnconsciousGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRecoverUnconsciousGroupSaveData*>(p_Object);
	s_Object->~SRecoverUnconsciousGroupSaveData();
}

ZHMTypeInfo SRememberActorSaveData::TypeInfo = ZHMTypeInfo("SRememberActorSaveData", sizeof(SRememberActorSaveData), alignof(SRememberActorSaveData), SRememberActorSaveData::WriteSimpleJson, SRememberActorSaveData::FromSimpleJson, SRememberActorSaveData::Serialize, SRememberActorSaveData::Equals, SRememberActorSaveData::Destroy);

void SRememberActorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRememberActorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Actors") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_Actors.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_Actors[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_Actors.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SRememberActorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRememberActorSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_Actors"];
	s_Object.m_Actors.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_Actors[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SRememberActorSaveData*>(p_Target) = s_Object;
}

void SRememberActorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRememberActorSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_Actors, p_Serializer, p_OwnOffset + offsetof(SRememberActorSaveData, m_Actors));
}

bool SRememberActorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRememberActorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRememberActorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRememberActorSaveData::operator==(const SRememberActorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRememberActorSaveData>)
		return false;

	if (m_Actors != p_Other.m_Actors) return false;

	return true;
}

void SRememberActorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRememberActorSaveData*>(p_Object);
	s_Object->~SRememberActorSaveData();
}

ZHMTypeInfo SRemoteControlReceiverSaveData::TypeInfo = ZHMTypeInfo("SRemoteControlReceiverSaveData", sizeof(SRemoteControlReceiverSaveData), alignof(SRemoteControlReceiverSaveData), SRemoteControlReceiverSaveData::WriteSimpleJson, SRemoteControlReceiverSaveData::FromSimpleJson, SRemoteControlReceiverSaveData::Serialize, SRemoteControlReceiverSaveData::Equals, SRemoteControlReceiverSaveData::Destroy);

void SRemoteControlReceiverSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bReceiverActivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bReceiverActivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);

	p_Stream << "}";
}

void SRemoteControlReceiverSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRemoteControlReceiverSaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bReceiverActivated = simdjson::from_json_bool(p_Document["m_bReceiverActivated"]);

	s_Object.m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

	*reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Target) = s_Object;
}

void SRemoteControlReceiverSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);

}

bool SRemoteControlReceiverSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRemoteControlReceiverSaveData::operator==(const SRemoteControlReceiverSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRemoteControlReceiverSaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bReceiverActivated != p_Other.m_bReceiverActivated) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;

	return true;
}

void SRemoteControlReceiverSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRemoteControlReceiverSaveData*>(p_Object);
	s_Object->~SRemoteControlReceiverSaveData();
}

ZHMTypeInfo SRenderVideoPlayerSaveData::TypeInfo = ZHMTypeInfo("SRenderVideoPlayerSaveData", sizeof(SRenderVideoPlayerSaveData), alignof(SRenderVideoPlayerSaveData), SRenderVideoPlayerSaveData::WriteSimpleJson, SRenderVideoPlayerSaveData::FromSimpleJson, SRenderVideoPlayerSaveData::Serialize, SRenderVideoPlayerSaveData::Equals, SRenderVideoPlayerSaveData::Destroy);

void SRenderVideoPlayerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bPlaying") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPlaying);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLooping") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLooping);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirstFrame") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirstFrame);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVideoError") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVideoError);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShouldBeStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShouldBeStopped);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_LastVisible") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_LastVisible, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_StartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RunTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_RunTime, p_Stream);

	p_Stream << "}";
}

void SRenderVideoPlayerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRenderVideoPlayerSaveData s_Object {};

	s_Object.m_bPlaying = simdjson::from_json_bool(p_Document["m_bPlaying"]);

	s_Object.m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	s_Object.m_bLooping = simdjson::from_json_bool(p_Document["m_bLooping"]);

	s_Object.m_bUseAlpha = simdjson::from_json_bool(p_Document["m_bUseAlpha"]);

	s_Object.m_bFirstFrame = simdjson::from_json_bool(p_Document["m_bFirstFrame"]);

	s_Object.m_bRunning = simdjson::from_json_bool(p_Document["m_bRunning"]);

	s_Object.m_bVideoError = simdjson::from_json_bool(p_Document["m_bVideoError"]);

	s_Object.m_bShouldBeStopped = simdjson::from_json_bool(p_Document["m_bShouldBeStopped"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_LastVisible"], &s_Item);
		s_Object.m_LastVisible = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_StartTime"], &s_Item);
		s_Object.m_StartTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_RunTime"], &s_Item);
		s_Object.m_RunTime = s_Item;
	}

	*reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Target) = s_Object;
}

void SRenderVideoPlayerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_LastVisible, p_Serializer, p_OwnOffset + offsetof(SRenderVideoPlayerSaveData, m_LastVisible));
	ZGameTime::Serialize(&s_Object->m_StartTime, p_Serializer, p_OwnOffset + offsetof(SRenderVideoPlayerSaveData, m_StartTime));
	ZGameTime::Serialize(&s_Object->m_RunTime, p_Serializer, p_OwnOffset + offsetof(SRenderVideoPlayerSaveData, m_RunTime));
}

bool SRenderVideoPlayerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRenderVideoPlayerSaveData::operator==(const SRenderVideoPlayerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRenderVideoPlayerSaveData>)
		return false;

	if (m_bPlaying != p_Other.m_bPlaying) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;
	if (m_bLooping != p_Other.m_bLooping) return false;
	if (m_bUseAlpha != p_Other.m_bUseAlpha) return false;
	if (m_bFirstFrame != p_Other.m_bFirstFrame) return false;
	if (m_bRunning != p_Other.m_bRunning) return false;
	if (m_bVideoError != p_Other.m_bVideoError) return false;
	if (m_bShouldBeStopped != p_Other.m_bShouldBeStopped) return false;
	if (m_LastVisible != p_Other.m_LastVisible) return false;
	if (m_StartTime != p_Other.m_StartTime) return false;
	if (m_RunTime != p_Other.m_RunTime) return false;

	return true;
}

void SRenderVideoPlayerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRenderVideoPlayerSaveData*>(p_Object);
	s_Object->~SRenderVideoPlayerSaveData();
}

ZHMTypeInfo SRepositionOrderSaveData::TypeInfo = ZHMTypeInfo("SRepositionOrderSaveData", sizeof(SRepositionOrderSaveData), alignof(SRepositionOrderSaveData), SRepositionOrderSaveData::WriteSimpleJson, SRepositionOrderSaveData::FromSimpleJson, SRepositionOrderSaveData::Serialize, SRepositionOrderSaveData::Equals, SRepositionOrderSaveData::Destroy);

void SRepositionOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStrafe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStrafe);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAimAtTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAimAtTarget);

	p_Stream << "}";
}

void SRepositionOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRepositionOrderSaveData s_Object {};

	s_Object.m_bStrafe = simdjson::from_json_bool(p_Document["m_bStrafe"]);

	s_Object.m_bAimAtTarget = simdjson::from_json_bool(p_Document["m_bAimAtTarget"]);

	*reinterpret_cast<SRepositionOrderSaveData*>(p_Target) = s_Object;
}

void SRepositionOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);

}

bool SRepositionOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRepositionOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRepositionOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRepositionOrderSaveData::operator==(const SRepositionOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRepositionOrderSaveData>)
		return false;

	if (m_bStrafe != p_Other.m_bStrafe) return false;
	if (m_bAimAtTarget != p_Other.m_bAimAtTarget) return false;

	return true;
}

void SRepositionOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRepositionOrderSaveData*>(p_Object);
	s_Object->~SRepositionOrderSaveData();
}

ZHMTypeInfo SRotateEntitySaveData::TypeInfo = ZHMTypeInfo("SRotateEntitySaveData", sizeof(SRotateEntitySaveData), alignof(SRotateEntitySaveData), SRotateEntitySaveData::WriteSimpleJson, SRotateEntitySaveData::FromSimpleJson, SRotateEntitySaveData::Serialize, SRotateEntitySaveData::Equals, SRotateEntitySaveData::Destroy);

void SRotateEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fXAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fXAxisSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fYAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fYAxisSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fZAxisSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fZAxisSpeed);

	p_Stream << "}";
}

void SRotateEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SRotateEntitySaveData s_Object {};

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_fXAxisSpeed = simdjson::from_json_float32(p_Document["m_fXAxisSpeed"]);

	s_Object.m_fYAxisSpeed = simdjson::from_json_float32(p_Document["m_fYAxisSpeed"]);

	s_Object.m_fZAxisSpeed = simdjson::from_json_float32(p_Document["m_fZAxisSpeed"]);

	*reinterpret_cast<SRotateEntitySaveData*>(p_Target) = s_Object;
}

void SRotateEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);

}

bool SRotateEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SRotateEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SRotateEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SRotateEntitySaveData::operator==(const SRotateEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SRotateEntitySaveData>)
		return false;

	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fXAxisSpeed != p_Other.m_fXAxisSpeed) return false;
	if (m_fYAxisSpeed != p_Other.m_fYAxisSpeed) return false;
	if (m_fZAxisSpeed != p_Other.m_fZAxisSpeed) return false;

	return true;
}

void SRotateEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SRotateEntitySaveData*>(p_Object);
	s_Object->~SRotateEntitySaveData();
}

ZHMTypeInfo SSCCuriousConfiguration::TypeInfo = ZHMTypeInfo("SSCCuriousConfiguration", sizeof(SSCCuriousConfiguration), alignof(SSCCuriousConfiguration), SSCCuriousConfiguration::WriteSimpleJson, SSCCuriousConfiguration::FromSimpleJson, SSCCuriousConfiguration::Serialize, SSCCuriousConfiguration::Equals, SSCCuriousConfiguration::Destroy);

void SSCCuriousConfiguration::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSCCuriousConfiguration*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_CanGuardsInvestigate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CanGuardsInvestigate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CanCiviliansInvestigate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CanCiviliansInvestigate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CanVIPsInvestigate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_CanVIPsInvestigate);

	p_Stream << "}";
}

void SSCCuriousConfiguration::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSCCuriousConfiguration s_Object {};

	s_Object.m_CanGuardsInvestigate = simdjson::from_json_bool(p_Document["m_CanGuardsInvestigate"]);

	s_Object.m_CanCiviliansInvestigate = simdjson::from_json_bool(p_Document["m_CanCiviliansInvestigate"]);

	s_Object.m_CanVIPsInvestigate = simdjson::from_json_bool(p_Document["m_CanVIPsInvestigate"]);

	*reinterpret_cast<SSCCuriousConfiguration*>(p_Target) = s_Object;
}

void SSCCuriousConfiguration::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSCCuriousConfiguration*>(p_Object);

}

bool SSCCuriousConfiguration::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSCCuriousConfiguration*>(p_Left);
	auto* s_Right = reinterpret_cast<SSCCuriousConfiguration*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSCCuriousConfiguration::operator==(const SSCCuriousConfiguration& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSCCuriousConfiguration>)
		return false;

	if (m_CanGuardsInvestigate != p_Other.m_CanGuardsInvestigate) return false;
	if (m_CanCiviliansInvestigate != p_Other.m_CanCiviliansInvestigate) return false;
	if (m_CanVIPsInvestigate != p_Other.m_CanVIPsInvestigate) return false;

	return true;
}

void SSCCuriousConfiguration::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSCCuriousConfiguration*>(p_Object);
	s_Object->~SSCCuriousConfiguration();
}

ZHMTypeInfo SSavableData::TypeInfo = ZHMTypeInfo("SSavableData", sizeof(SSavableData), alignof(SSavableData), SSavableData::WriteSimpleJson, SSavableData::FromSimpleJson, SSavableData::Serialize, SSavableData::Equals, SSavableData::Destroy);

void SSavableData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EntitiesData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_EntitiesData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nId);

	p_Stream << "}";
}

void SSavableData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSavableData s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_EntitiesData"], &s_Item);
		s_Object.m_EntitiesData = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Item);
		s_Object.m_Data = s_Item;
	}

	s_Object.m_nId = simdjson::from_json_uint32(p_Document["m_nId"]);

	*reinterpret_cast<SSavableData*>(p_Target) = s_Object;
}

void SSavableData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_EntitiesData, p_Serializer, p_OwnOffset + offsetof(SSavableData, m_EntitiesData));
	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SSavableData, m_Data));
}

bool SSavableData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSavableData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSavableData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSavableData::operator==(const SSavableData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSavableData>)
		return false;

	if (m_EntitiesData != p_Other.m_EntitiesData) return false;
	if (m_Data != p_Other.m_Data) return false;
	if (m_nId != p_Other.m_nId) return false;

	return true;
}

void SSavableData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSavableData*>(p_Object);
	s_Object->~SSavableData();
}

ZHMTypeInfo SVariantStruct::TypeInfo = ZHMTypeInfo("SVariantStruct", sizeof(SVariantStruct), alignof(SVariantStruct), SVariantStruct::WriteSimpleJson, SVariantStruct::FromSimpleJson, SVariantStruct::Serialize, SVariantStruct::Equals, SVariantStruct::Destroy);

void SVariantStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_Data") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_Data, p_Stream);

	p_Stream << "}";
}

void SVariantStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVariantStruct s_Object {};

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_Data"], &s_Item);
		s_Object.m_Data = s_Item;
	}

	*reinterpret_cast<SVariantStruct*>(p_Target) = s_Object;
}

void SVariantStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);

	ZVariant::Serialize(&s_Object->m_Data, p_Serializer, p_OwnOffset + offsetof(SVariantStruct, m_Data));
}

bool SVariantStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVariantStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SVariantStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVariantStruct::operator==(const SVariantStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVariantStruct>)
		return false;

	if (m_Data != p_Other.m_Data) return false;

	return true;
}

void SVariantStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVariantStruct*>(p_Object);
	s_Object->~SVariantStruct();
}

ZHMTypeInfo SSavableEntitiesSaveData::TypeInfo = ZHMTypeInfo("SSavableEntitiesSaveData", sizeof(SSavableEntitiesSaveData), alignof(SSavableEntitiesSaveData), SSavableEntitiesSaveData::WriteSimpleJson, SSavableEntitiesSaveData::FromSimpleJson, SSavableEntitiesSaveData::Serialize, SSavableEntitiesSaveData::Equals, SSavableEntitiesSaveData::Destroy);

void SSavableEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityData[i];
		SVariantStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSavableEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSavableEntitiesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityData"];
	s_Object.m_aEntityData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVariantStruct s_ArrayItem0;
		SVariantStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEntityData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SSavableEntitiesSaveData*>(p_Target) = s_Object;
}

void SSavableEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SSavableEntitiesSaveData, m_aEntities));
	TArray<SVariantStruct>::Serialize(&s_Object->m_aEntityData, p_Serializer, p_OwnOffset + offsetof(SSavableEntitiesSaveData, m_aEntityData));
}

bool SSavableEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSavableEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSavableEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSavableEntitiesSaveData::operator==(const SSavableEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSavableEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aEntityData != p_Other.m_aEntityData) return false;

	return true;
}

void SSavableEntitiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSavableEntitiesSaveData*>(p_Object);
	s_Object->~SSavableEntitiesSaveData();
}

ZHMTypeInfo SSaveGameData::TypeInfo = ZHMTypeInfo("SSaveGameData", sizeof(SSaveGameData), alignof(SSaveGameData), SSaveGameData::WriteSimpleJson, SSaveGameData::FromSimpleJson, SSaveGameData::Serialize, SSaveGameData::Equals, SSaveGameData::Destroy);

void SSaveGameData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSavableObjectsData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSavableObjectsData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSavableObjectsData[i];
		SSavableData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSavableObjectsData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aEntityPaths") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntityPaths.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntityPaths[i];
		SEntityPath::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aEntityPaths.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSaveGameData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSaveGameData s_Object {};

	s_Object.m_nVersion = simdjson::from_json_uint32(p_Document["m_nVersion"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSavableObjectsData"];
	s_Object.m_aSavableObjectsData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSavableData s_ArrayItem0;
		SSavableData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSavableObjectsData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntityPaths"];
	s_Object.m_aEntityPaths.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityPath s_ArrayItem0;
		SEntityPath::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aEntityPaths[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SSaveGameData*>(p_Target) = s_Object;
}

void SSaveGameData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);

	TArray<SSavableData>::Serialize(&s_Object->m_aSavableObjectsData, p_Serializer, p_OwnOffset + offsetof(SSaveGameData, m_aSavableObjectsData));
	TArray<SEntityPath>::Serialize(&s_Object->m_aEntityPaths, p_Serializer, p_OwnOffset + offsetof(SSaveGameData, m_aEntityPaths));
}

bool SSaveGameData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameData::operator==(const SSaveGameData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameData>)
		return false;

	if (m_nVersion != p_Other.m_nVersion) return false;
	if (m_aSavableObjectsData != p_Other.m_aSavableObjectsData) return false;
	if (m_aEntityPaths != p_Other.m_aEntityPaths) return false;

	return true;
}

void SSaveGameData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSaveGameData*>(p_Object);
	s_Object->~SSaveGameData();
}

ZHMTypeInfo SSaveGameMetaData::TypeInfo = ZHMTypeInfo("SSaveGameMetaData", sizeof(SSaveGameMetaData), alignof(SSaveGameMetaData), SSaveGameMetaData::WriteSimpleJson, SSaveGameMetaData::FromSimpleJson, SSaveGameMetaData::Serialize, SSaveGameMetaData::Equals, SSaveGameMetaData::Destroy);

void SSaveGameMetaData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nSlot") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSlot);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eSaveType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESaveType", static_cast<int>(s_Object->eSaveType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eDifficultyLevel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->eDifficultyLevel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractTitle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLocationId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sLocationId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContractSessionId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContractSessionId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLastEventToken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sLastEventToken);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsOnline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsOnline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsVR") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsVR);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aScreenShot") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aScreenShot.size(); ++i)
	{
		auto& s_Item0 = s_Object->aScreenShot[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aScreenShot.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aRequirements") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aRequirements.size(); ++i)
	{
		auto& s_Item0 = s_Object->aRequirements[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ERequirementId", static_cast<int>(s_Item0)));

		if (i < s_Object->aRequirements.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSaveGameMetaData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSaveGameMetaData s_Object {};

	s_Object.nSlot = simdjson::from_json_uint8(p_Document["nSlot"]);

	s_Object.eSaveType = static_cast<ESaveType>(ZHMEnums::GetEnumValueByName("ESaveType", std::string_view(p_Document["eSaveType"])));

	s_Object.eDifficultyLevel = simdjson::from_json_int32(p_Document["eDifficultyLevel"]);

	s_Object.sContractId = std::string_view(p_Document["sContractId"]);

	s_Object.sContractTitle = std::string_view(p_Document["sContractTitle"]);

	s_Object.sContractType = std::string_view(p_Document["sContractType"]);

	s_Object.sLocationId = std::string_view(p_Document["sLocationId"]);

	s_Object.sContractSessionId = std::string_view(p_Document["sContractSessionId"]);

	s_Object.sLastEventToken = std::string_view(p_Document["sLastEventToken"]);

	s_Object.bIsOnline = simdjson::from_json_bool(p_Document["bIsOnline"]);

	s_Object.bIsVR = simdjson::from_json_bool(p_Document["bIsVR"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aScreenShot"];
	s_Object.aScreenShot.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.aScreenShot[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aRequirements"];
	s_Object.aRequirements.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.aRequirements[s_Index0++] = static_cast<ERequirementId>(ZHMEnums::GetEnumValueByName("ERequirementId", std::string_view(s_Item0)));
	}
	}

	*reinterpret_cast<SSaveGameMetaData*>(p_Target) = s_Object;
}

void SSaveGameMetaData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);

	ZString::Serialize(&s_Object->sContractId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractId));
	ZString::Serialize(&s_Object->sContractTitle, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractTitle));
	ZString::Serialize(&s_Object->sContractType, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractType));
	ZString::Serialize(&s_Object->sLocationId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sLocationId));
	ZString::Serialize(&s_Object->sContractSessionId, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sContractSessionId));
	ZString::Serialize(&s_Object->sLastEventToken, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, sLastEventToken));
	TArray<uint32>::Serialize(&s_Object->aScreenShot, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, aScreenShot));
	TArray<ERequirementId>::Serialize(&s_Object->aRequirements, p_Serializer, p_OwnOffset + offsetof(SSaveGameMetaData, aRequirements));
}

bool SSaveGameMetaData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameMetaData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameMetaData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameMetaData::operator==(const SSaveGameMetaData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameMetaData>)
		return false;

	if (nSlot != p_Other.nSlot) return false;
	if (eSaveType != p_Other.eSaveType) return false;
	if (eDifficultyLevel != p_Other.eDifficultyLevel) return false;
	if (sContractId != p_Other.sContractId) return false;
	if (sContractTitle != p_Other.sContractTitle) return false;
	if (sContractType != p_Other.sContractType) return false;
	if (sLocationId != p_Other.sLocationId) return false;
	if (sContractSessionId != p_Other.sContractSessionId) return false;
	if (sLastEventToken != p_Other.sLastEventToken) return false;
	if (bIsOnline != p_Other.bIsOnline) return false;
	if (bIsVR != p_Other.bIsVR) return false;
	if (aScreenShot != p_Other.aScreenShot) return false;
	if (aRequirements != p_Other.aRequirements) return false;

	return true;
}

void SSaveGameMetaData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSaveGameMetaData*>(p_Object);
	s_Object->~SSaveGameMetaData();
}

ZHMTypeInfo SSaveGameHeader::TypeInfo = ZHMTypeInfo("SSaveGameHeader", sizeof(SSaveGameHeader), alignof(SSaveGameHeader), SSaveGameHeader::WriteSimpleJson, SSaveGameHeader::FromSimpleJson, SSaveGameHeader::Serialize, SSaveGameHeader::Equals, SSaveGameHeader::Destroy);

void SSaveGameHeader::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nFourCC") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nFourCC);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nVersion") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nVersion);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nCrc32") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nCrc32);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nTimeStamp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nTimeStamp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("MetaData") << ":";
	SSaveGameMetaData::WriteSimpleJson(&s_Object->MetaData, p_Stream);

	p_Stream << "}";
}

void SSaveGameHeader::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSaveGameHeader s_Object {};

	s_Object.nFourCC = simdjson::from_json_uint32(p_Document["nFourCC"]);

	s_Object.nVersion = simdjson::from_json_uint32(p_Document["nVersion"]);

	s_Object.nCrc32 = simdjson::from_json_uint32(p_Document["nCrc32"]);

	s_Object.nSize = simdjson::from_json_uint32(p_Document["nSize"]);

	s_Object.nTimeStamp = simdjson::from_json_int64(p_Document["nTimeStamp"]);

	{
		SSaveGameMetaData s_Item {};
		SSaveGameMetaData::FromSimpleJson(p_Document["MetaData"], &s_Item);
		s_Object.MetaData = s_Item;
	}

	*reinterpret_cast<SSaveGameHeader*>(p_Target) = s_Object;
}

void SSaveGameHeader::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);

	SSaveGameMetaData::Serialize(&s_Object->MetaData, p_Serializer, p_OwnOffset + offsetof(SSaveGameHeader, MetaData));
}

bool SSaveGameHeader::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSaveGameHeader*>(p_Left);
	auto* s_Right = reinterpret_cast<SSaveGameHeader*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSaveGameHeader::operator==(const SSaveGameHeader& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSaveGameHeader>)
		return false;

	if (nFourCC != p_Other.nFourCC) return false;
	if (nVersion != p_Other.nVersion) return false;
	if (nCrc32 != p_Other.nCrc32) return false;
	if (nSize != p_Other.nSize) return false;
	if (nTimeStamp != p_Other.nTimeStamp) return false;
	if (MetaData != p_Other.MetaData) return false;

	return true;
}

void SSaveGameHeader::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSaveGameHeader*>(p_Object);
	s_Object->~SSaveGameHeader();
}

ZHMTypeInfo SScreenplay2ManagerSaveData::TypeInfo = ZHMTypeInfo("SScreenplay2ManagerSaveData", sizeof(SScreenplay2ManagerSaveData), alignof(SScreenplay2ManagerSaveData), SScreenplay2ManagerSaveData::WriteSimpleJson, SScreenplay2ManagerSaveData::FromSimpleJson, SScreenplay2ManagerSaveData::Serialize, SScreenplay2ManagerSaveData::Equals, SScreenplay2ManagerSaveData::Destroy);

void SScreenplay2ManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SScreenplay2ManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_DramaActorData") << ":";
	SDramaActorCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaActorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSituationData") << ":";
	SDramaSituationCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaSituationData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSetupData") << ":";
	SDramaSetupCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaSetupData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Drama2ActorData") << ":";
	SDrama2ActorCollectionSaveData::WriteSimpleJson(&s_Object->m_Drama2ActorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Drama2SituationData") << ":";
	SDrama2SituationCollectionSaveData::WriteSimpleJson(&s_Object->m_Drama2SituationData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Drama2SetupData") << ":";
	SDrama2SetupCollectionSaveData::WriteSimpleJson(&s_Object->m_Drama2SetupData, p_Stream);

	p_Stream << "}";
}

void SScreenplay2ManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SScreenplay2ManagerSaveData s_Object {};

	{
		SDramaActorCollectionSaveData s_Item {};
		SDramaActorCollectionSaveData::FromSimpleJson(p_Document["m_DramaActorData"], &s_Item);
		s_Object.m_DramaActorData = s_Item;
	}

	{
		SDramaSituationCollectionSaveData s_Item {};
		SDramaSituationCollectionSaveData::FromSimpleJson(p_Document["m_DramaSituationData"], &s_Item);
		s_Object.m_DramaSituationData = s_Item;
	}

	{
		SDramaSetupCollectionSaveData s_Item {};
		SDramaSetupCollectionSaveData::FromSimpleJson(p_Document["m_DramaSetupData"], &s_Item);
		s_Object.m_DramaSetupData = s_Item;
	}

	{
		SDrama2ActorCollectionSaveData s_Item {};
		SDrama2ActorCollectionSaveData::FromSimpleJson(p_Document["m_Drama2ActorData"], &s_Item);
		s_Object.m_Drama2ActorData = s_Item;
	}

	{
		SDrama2SituationCollectionSaveData s_Item {};
		SDrama2SituationCollectionSaveData::FromSimpleJson(p_Document["m_Drama2SituationData"], &s_Item);
		s_Object.m_Drama2SituationData = s_Item;
	}

	{
		SDrama2SetupCollectionSaveData s_Item {};
		SDrama2SetupCollectionSaveData::FromSimpleJson(p_Document["m_Drama2SetupData"], &s_Item);
		s_Object.m_Drama2SetupData = s_Item;
	}

	*reinterpret_cast<SScreenplay2ManagerSaveData*>(p_Target) = s_Object;
}

void SScreenplay2ManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SScreenplay2ManagerSaveData*>(p_Object);

	SDramaActorCollectionSaveData::Serialize(&s_Object->m_DramaActorData, p_Serializer, p_OwnOffset + offsetof(SScreenplay2ManagerSaveData, m_DramaActorData));
	SDramaSituationCollectionSaveData::Serialize(&s_Object->m_DramaSituationData, p_Serializer, p_OwnOffset + offsetof(SScreenplay2ManagerSaveData, m_DramaSituationData));
	SDramaSetupCollectionSaveData::Serialize(&s_Object->m_DramaSetupData, p_Serializer, p_OwnOffset + offsetof(SScreenplay2ManagerSaveData, m_DramaSetupData));
	SDrama2ActorCollectionSaveData::Serialize(&s_Object->m_Drama2ActorData, p_Serializer, p_OwnOffset + offsetof(SScreenplay2ManagerSaveData, m_Drama2ActorData));
	SDrama2SituationCollectionSaveData::Serialize(&s_Object->m_Drama2SituationData, p_Serializer, p_OwnOffset + offsetof(SScreenplay2ManagerSaveData, m_Drama2SituationData));
	SDrama2SetupCollectionSaveData::Serialize(&s_Object->m_Drama2SetupData, p_Serializer, p_OwnOffset + offsetof(SScreenplay2ManagerSaveData, m_Drama2SetupData));
}

bool SScreenplay2ManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SScreenplay2ManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SScreenplay2ManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SScreenplay2ManagerSaveData::operator==(const SScreenplay2ManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SScreenplay2ManagerSaveData>)
		return false;

	if (m_DramaActorData != p_Other.m_DramaActorData) return false;
	if (m_DramaSituationData != p_Other.m_DramaSituationData) return false;
	if (m_DramaSetupData != p_Other.m_DramaSetupData) return false;
	if (m_Drama2ActorData != p_Other.m_Drama2ActorData) return false;
	if (m_Drama2SituationData != p_Other.m_Drama2SituationData) return false;
	if (m_Drama2SetupData != p_Other.m_Drama2SetupData) return false;

	return true;
}

void SScreenplay2ManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SScreenplay2ManagerSaveData*>(p_Object);
	s_Object->~SScreenplay2ManagerSaveData();
}

ZHMTypeInfo SScreenplayManagerSaveData::TypeInfo = ZHMTypeInfo("SScreenplayManagerSaveData", sizeof(SScreenplayManagerSaveData), alignof(SScreenplayManagerSaveData), SScreenplayManagerSaveData::WriteSimpleJson, SScreenplayManagerSaveData::FromSimpleJson, SScreenplayManagerSaveData::Serialize, SScreenplayManagerSaveData::Equals, SScreenplayManagerSaveData::Destroy);

void SScreenplayManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_DramaActorData") << ":";
	SDramaActorCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaActorData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSituationData") << ":";
	SDramaSituationCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaSituationData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DramaSetupData") << ":";
	SDramaSetupCollectionSaveData::WriteSimpleJson(&s_Object->m_DramaSetupData, p_Stream);

	p_Stream << "}";
}

void SScreenplayManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SScreenplayManagerSaveData s_Object {};

	{
		SDramaActorCollectionSaveData s_Item {};
		SDramaActorCollectionSaveData::FromSimpleJson(p_Document["m_DramaActorData"], &s_Item);
		s_Object.m_DramaActorData = s_Item;
	}

	{
		SDramaSituationCollectionSaveData s_Item {};
		SDramaSituationCollectionSaveData::FromSimpleJson(p_Document["m_DramaSituationData"], &s_Item);
		s_Object.m_DramaSituationData = s_Item;
	}

	{
		SDramaSetupCollectionSaveData s_Item {};
		SDramaSetupCollectionSaveData::FromSimpleJson(p_Document["m_DramaSetupData"], &s_Item);
		s_Object.m_DramaSetupData = s_Item;
	}

	*reinterpret_cast<SScreenplayManagerSaveData*>(p_Target) = s_Object;
}

void SScreenplayManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);

	SDramaActorCollectionSaveData::Serialize(&s_Object->m_DramaActorData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaActorData));
	SDramaSituationCollectionSaveData::Serialize(&s_Object->m_DramaSituationData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaSituationData));
	SDramaSetupCollectionSaveData::Serialize(&s_Object->m_DramaSetupData, p_Serializer, p_OwnOffset + offsetof(SScreenplayManagerSaveData, m_DramaSetupData));
}

bool SScreenplayManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SScreenplayManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SScreenplayManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SScreenplayManagerSaveData::operator==(const SScreenplayManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SScreenplayManagerSaveData>)
		return false;

	if (m_DramaActorData != p_Other.m_DramaActorData) return false;
	if (m_DramaSituationData != p_Other.m_DramaSituationData) return false;
	if (m_DramaSetupData != p_Other.m_DramaSetupData) return false;

	return true;
}

void SScreenplayManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SScreenplayManagerSaveData*>(p_Object);
	s_Object->~SScreenplayManagerSaveData();
}

ZHMTypeInfo SScreenplayRole2HeroSaveState::TypeInfo = ZHMTypeInfo("SScreenplayRole2HeroSaveState", sizeof(SScreenplayRole2HeroSaveState), alignof(SScreenplayRole2HeroSaveState), SScreenplayRole2HeroSaveState::WriteSimpleJson, SScreenplayRole2HeroSaveState::FromSimpleJson, SScreenplayRole2HeroSaveState::Serialize, SScreenplayRole2HeroSaveState::Equals, SScreenplayRole2HeroSaveState::Destroy);

void SScreenplayRole2HeroSaveState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SScreenplayRole2HeroSaveState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rCurrentSpeakEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rCurrentSpeakEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPaused") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPaused);

	p_Stream << "}";
}

void SScreenplayRole2HeroSaveState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SScreenplayRole2HeroSaveState s_Object {};

	s_Object.m_rCurrentSpeakEntity = simdjson::from_json_uint32(p_Document["m_rCurrentSpeakEntity"]);

	s_Object.m_bPaused = simdjson::from_json_bool(p_Document["m_bPaused"]);

	*reinterpret_cast<SScreenplayRole2HeroSaveState*>(p_Target) = s_Object;
}

void SScreenplayRole2HeroSaveState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SScreenplayRole2HeroSaveState*>(p_Object);

}

bool SScreenplayRole2HeroSaveState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SScreenplayRole2HeroSaveState*>(p_Left);
	auto* s_Right = reinterpret_cast<SScreenplayRole2HeroSaveState*>(p_Right);

	return *s_Left == *s_Right;
}

bool SScreenplayRole2HeroSaveState::operator==(const SScreenplayRole2HeroSaveState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SScreenplayRole2HeroSaveState>)
		return false;

	if (m_rCurrentSpeakEntity != p_Other.m_rCurrentSpeakEntity) return false;
	if (m_bPaused != p_Other.m_bPaused) return false;

	return true;
}

void SScreenplayRole2HeroSaveState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SScreenplayRole2HeroSaveState*>(p_Object);
	s_Object->~SScreenplayRole2HeroSaveState();
}

ZHMTypeInfo SSecuritySystemCameraSaveData::TypeInfo = ZHMTypeInfo("SSecuritySystemCameraSaveData", sizeof(SSecuritySystemCameraSaveData), alignof(SSecuritySystemCameraSaveData), SSecuritySystemCameraSaveData::WriteSimpleJson, SSecuritySystemCameraSaveData::FromSimpleJson, SSecuritySystemCameraSaveData::Serialize, SSecuritySystemCameraSaveData::Equals, SSecuritySystemCameraSaveData::Destroy);

void SSecuritySystemCameraSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEscalation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEscalation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFunctional") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFunctional);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasEnteredOnce") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasEnteredOnce);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWasInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWasInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bDestroyed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bDestroyed);

	p_Stream << "}";
}

void SSecuritySystemCameraSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSecuritySystemCameraSaveData s_Object {};

	s_Object.m_nEscalation = simdjson::from_json_uint16(p_Document["m_nEscalation"]);

	s_Object.m_bIsFunctional = simdjson::from_json_bool(p_Document["m_bIsFunctional"]);

	s_Object.m_bHasEnteredOnce = simdjson::from_json_bool(p_Document["m_bHasEnteredOnce"]);

	s_Object.m_bWasInvestigated = simdjson::from_json_bool(p_Document["m_bWasInvestigated"]);

	s_Object.m_bDestroyed = simdjson::from_json_bool(p_Document["m_bDestroyed"]);

	*reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Target) = s_Object;
}

void SSecuritySystemCameraSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);

}

bool SSecuritySystemCameraSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSecuritySystemCameraSaveData::operator==(const SSecuritySystemCameraSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSecuritySystemCameraSaveData>)
		return false;

	if (m_nEscalation != p_Other.m_nEscalation) return false;
	if (m_bIsFunctional != p_Other.m_bIsFunctional) return false;
	if (m_bHasEnteredOnce != p_Other.m_bHasEnteredOnce) return false;
	if (m_bWasInvestigated != p_Other.m_bWasInvestigated) return false;
	if (m_bDestroyed != p_Other.m_bDestroyed) return false;

	return true;
}

void SSecuritySystemCameraSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemCameraSaveData*>(p_Object);
	s_Object->~SSecuritySystemCameraSaveData();
}

ZHMTypeInfo SSecuritySystemRecorderSaveData::TypeInfo = ZHMTypeInfo("SSecuritySystemRecorderSaveData", sizeof(SSecuritySystemRecorderSaveData), alignof(SSecuritySystemRecorderSaveData), SSecuritySystemRecorderSaveData::WriteSimpleJson, SSecuritySystemRecorderSaveData::FromSimpleJson, SSecuritySystemRecorderSaveData::Serialize, SSecuritySystemRecorderSaveData::Equals, SSecuritySystemRecorderSaveData::Destroy);

void SSecuritySystemRecorderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bHasRecordings") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRecordings);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFunctional") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFunctional);

	p_Stream << "}";
}

void SSecuritySystemRecorderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSecuritySystemRecorderSaveData s_Object {};

	s_Object.m_bHasRecordings = simdjson::from_json_bool(p_Document["m_bHasRecordings"]);

	s_Object.m_bIsFunctional = simdjson::from_json_bool(p_Document["m_bIsFunctional"]);

	*reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Target) = s_Object;
}

void SSecuritySystemRecorderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);

}

bool SSecuritySystemRecorderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSecuritySystemRecorderSaveData::operator==(const SSecuritySystemRecorderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSecuritySystemRecorderSaveData>)
		return false;

	if (m_bHasRecordings != p_Other.m_bHasRecordings) return false;
	if (m_bIsFunctional != p_Other.m_bIsFunctional) return false;

	return true;
}

void SSecuritySystemRecorderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSecuritySystemRecorderSaveData*>(p_Object);
	s_Object->~SSecuritySystemRecorderSaveData();
}

ZHMTypeInfo SSentryGroupSaveData::TypeInfo = ZHMTypeInfo("SSentryGroupSaveData", sizeof(SSentryGroupSaveData), alignof(SSentryGroupSaveData), SSentryGroupSaveData::WriteSimpleJson, SSentryGroupSaveData::FromSimpleJson, SSentryGroupSaveData::Serialize, SSentryGroupSaveData::Equals, SSentryGroupSaveData::Destroy);

void SSentryGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rSentryZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSentryZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eActionPrompt") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ESentryActionPrompt", static_cast<int>(s_Object->m_eActionPrompt)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bRequestedAction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bRequestedAction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowingWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowingWarning);

	p_Stream << "}";
}

void SSentryGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSentryGroupSaveData s_Object {};

	s_Object.m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	s_Object.m_rSentryZone = simdjson::from_json_uint32(p_Document["m_rSentryZone"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Item);
		s_Object.m_tLastEscalateOrder = s_Item;
	}

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_eActionPrompt = static_cast<ESentryActionPrompt>(ZHMEnums::GetEnumValueByName("ESentryActionPrompt", std::string_view(p_Document["m_eActionPrompt"])));

	s_Object.m_bRequestedAction = simdjson::from_json_bool(p_Document["m_bRequestedAction"]);

	s_Object.m_bShowingWarning = simdjson::from_json_bool(p_Document["m_bShowingWarning"]);

	*reinterpret_cast<SSentryGroupSaveData*>(p_Target) = s_Object;
}

void SSentryGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(SSentryGroupSaveData, m_tLastEscalateOrder));
	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SSentryGroupSaveData, m_fsmState));
}

bool SSentryGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryGroupSaveData::operator==(const SSentryGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_rSentryZone != p_Other.m_rSentryZone) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_eActionPrompt != p_Other.m_eActionPrompt) return false;
	if (m_bRequestedAction != p_Other.m_bRequestedAction) return false;
	if (m_bShowingWarning != p_Other.m_bShowingWarning) return false;

	return true;
}

void SSentryGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSentryGroupSaveData*>(p_Object);
	s_Object->~SSentryGroupSaveData();
}

ZHMTypeInfo SSentryOrderSaveData::TypeInfo = ZHMTypeInfo("SSentryOrderSaveData", sizeof(SSentryOrderSaveData), alignof(SSentryOrderSaveData), SSentryOrderSaveData::WriteSimpleJson, SSentryOrderSaveData::FromSimpleJson, SSentryOrderSaveData::Serialize, SSentryOrderSaveData::Equals, SSentryOrderSaveData::Destroy);

void SSentryOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSentryZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSentryZone);

	p_Stream << "}";
}

void SSentryOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSentryOrderSaveData s_Object {};

	s_Object.m_rSentryZone = simdjson::from_json_uint32(p_Document["m_rSentryZone"]);

	*reinterpret_cast<SSentryOrderSaveData*>(p_Target) = s_Object;
}

void SSentryOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);

}

bool SSentryOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryOrderSaveData::operator==(const SSentryOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryOrderSaveData>)
		return false;

	if (m_rSentryZone != p_Other.m_rSentryZone) return false;

	return true;
}

void SSentryOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSentryOrderSaveData*>(p_Object);
	s_Object->~SSentryOrderSaveData();
}

ZHMTypeInfo SSentryZoneSaveData::TypeInfo = ZHMTypeInfo("SSentryZoneSaveData", sizeof(SSentryZoneSaveData), alignof(SSentryZoneSaveData), SSentryZoneSaveData::WriteSimpleJson, SSentryZoneSaveData::FromSimpleJson, SSentryZoneSaveData::Serialize, SSentryZoneSaveData::Equals, SSentryZoneSaveData::Destroy);

void SSentryZoneSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_tGreetingCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tGreetingCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLoiteringCooldown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLoiteringCooldown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bShowingWarning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bShowingWarning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bLeftThroughWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bLeftThroughWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bEnteredThroughEntranceZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bEnteredThroughEntranceZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInEntranceZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInEntranceZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInGreetingZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInGreetingZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInReFriskZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInReFriskZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInRequiredDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInRequiredDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInFriskExemptDisguise") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInFriskExemptDisguise);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasRequiredItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRequiredItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCanShowActionPrompt") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCanShowActionPrompt);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetInAnyZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetInAnyZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSituationActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSituationActive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFrisked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFrisked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bItemChecked") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bItemChecked);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreeted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreeted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedInstruction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedInstruction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedLoitering") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedLoitering);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGreetedUnexpected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGreetedUnexpected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInFriskWarningZone") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInFriskWarningZone);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesAllowedDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesAllowedDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesAllowedDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesAllowedDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesFriskExemptDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesFriskExemptDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesFriskExemptDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesFriskExemptDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aDisguisesDontEscalateOnLineCrossingDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ItemsDroppedInZone") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_ItemsDroppedInZone.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_ItemsDroppedInZone[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_ItemsDroppedInZone.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSentryZoneSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSentryZoneSaveData s_Object {};

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tGreetingCooldown"], &s_Item);
		s_Object.m_tGreetingCooldown = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLoiteringCooldown"], &s_Item);
		s_Object.m_tLoiteringCooldown = s_Item;
	}

	s_Object.m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	s_Object.m_bShowingWarning = simdjson::from_json_bool(p_Document["m_bShowingWarning"]);

	s_Object.bLeftThroughWarningZone = simdjson::from_json_bool(p_Document["bLeftThroughWarningZone"]);

	s_Object.bEnteredThroughEntranceZone = simdjson::from_json_bool(p_Document["bEnteredThroughEntranceZone"]);

	s_Object.bInEntranceZone = simdjson::from_json_bool(p_Document["bInEntranceZone"]);

	s_Object.bInWarningZone = simdjson::from_json_bool(p_Document["bInWarningZone"]);

	s_Object.bInGreetingZone = simdjson::from_json_bool(p_Document["bInGreetingZone"]);

	s_Object.bInReFriskZone = simdjson::from_json_bool(p_Document["bInReFriskZone"]);

	s_Object.m_bInRequiredDisguise = simdjson::from_json_bool(p_Document["m_bInRequiredDisguise"]);

	s_Object.m_bInFriskExemptDisguise = simdjson::from_json_bool(p_Document["m_bInFriskExemptDisguise"]);

	s_Object.m_bHasRequiredItem = simdjson::from_json_bool(p_Document["m_bHasRequiredItem"]);

	s_Object.m_bCanShowActionPrompt = simdjson::from_json_bool(p_Document["m_bCanShowActionPrompt"]);

	s_Object.m_bTargetInAnyZone = simdjson::from_json_bool(p_Document["m_bTargetInAnyZone"]);

	s_Object.m_bSituationActive = simdjson::from_json_bool(p_Document["m_bSituationActive"]);

	s_Object.m_bFrisked = simdjson::from_json_bool(p_Document["m_bFrisked"]);

	s_Object.m_bItemChecked = simdjson::from_json_bool(p_Document["m_bItemChecked"]);

	s_Object.m_bGreeted = simdjson::from_json_bool(p_Document["m_bGreeted"]);

	s_Object.m_bGreetedInstruction = simdjson::from_json_bool(p_Document["m_bGreetedInstruction"]);

	s_Object.m_bGreetedLoitering = simdjson::from_json_bool(p_Document["m_bGreetedLoitering"]);

	s_Object.m_bGreetedUnexpected = simdjson::from_json_bool(p_Document["m_bGreetedUnexpected"]);

	s_Object.m_bInFriskWarningZone = simdjson::from_json_bool(p_Document["m_bInFriskWarningZone"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDisguisesAllowedDisabled"];
	s_Object.m_aDisguisesAllowedDisabled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aDisguisesAllowedDisabled[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDisguisesFriskExemptDisabled"];
	s_Object.m_aDisguisesFriskExemptDisabled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aDisguisesFriskExemptDisabled[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aDisguisesDontEscalateOnLineCrossingDisabled"];
	s_Object.m_aDisguisesDontEscalateOnLineCrossingDisabled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aDisguisesDontEscalateOnLineCrossingDisabled[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_ItemsDroppedInZone"];
	s_Object.m_ItemsDroppedInZone.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_ItemsDroppedInZone[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SSentryZoneSaveData*>(p_Target) = s_Object;
}

void SSentryZoneSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tGreetingCooldown, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_tGreetingCooldown));
	ZGameTime::Serialize(&s_Object->m_tLoiteringCooldown, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_tLoiteringCooldown));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesAllowedDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesAllowedDisabled));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesFriskExemptDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesFriskExemptDisabled));
	TArray<bool>::Serialize(&s_Object->m_aDisguisesDontEscalateOnLineCrossingDisabled, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_aDisguisesDontEscalateOnLineCrossingDisabled));
	TArray<uint32>::Serialize(&s_Object->m_ItemsDroppedInZone, p_Serializer, p_OwnOffset + offsetof(SSentryZoneSaveData, m_ItemsDroppedInZone));
}

bool SSentryZoneSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSentryZoneSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSentryZoneSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSentryZoneSaveData::operator==(const SSentryZoneSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSentryZoneSaveData>)
		return false;

	if (m_tGreetingCooldown != p_Other.m_tGreetingCooldown) return false;
	if (m_tLoiteringCooldown != p_Other.m_tLoiteringCooldown) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_bShowingWarning != p_Other.m_bShowingWarning) return false;
	if (bLeftThroughWarningZone != p_Other.bLeftThroughWarningZone) return false;
	if (bEnteredThroughEntranceZone != p_Other.bEnteredThroughEntranceZone) return false;
	if (bInEntranceZone != p_Other.bInEntranceZone) return false;
	if (bInWarningZone != p_Other.bInWarningZone) return false;
	if (bInGreetingZone != p_Other.bInGreetingZone) return false;
	if (bInReFriskZone != p_Other.bInReFriskZone) return false;
	if (m_bInRequiredDisguise != p_Other.m_bInRequiredDisguise) return false;
	if (m_bInFriskExemptDisguise != p_Other.m_bInFriskExemptDisguise) return false;
	if (m_bHasRequiredItem != p_Other.m_bHasRequiredItem) return false;
	if (m_bCanShowActionPrompt != p_Other.m_bCanShowActionPrompt) return false;
	if (m_bTargetInAnyZone != p_Other.m_bTargetInAnyZone) return false;
	if (m_bSituationActive != p_Other.m_bSituationActive) return false;
	if (m_bFrisked != p_Other.m_bFrisked) return false;
	if (m_bItemChecked != p_Other.m_bItemChecked) return false;
	if (m_bGreeted != p_Other.m_bGreeted) return false;
	if (m_bGreetedInstruction != p_Other.m_bGreetedInstruction) return false;
	if (m_bGreetedLoitering != p_Other.m_bGreetedLoitering) return false;
	if (m_bGreetedUnexpected != p_Other.m_bGreetedUnexpected) return false;
	if (m_bInFriskWarningZone != p_Other.m_bInFriskWarningZone) return false;
	if (m_aDisguisesAllowedDisabled != p_Other.m_aDisguisesAllowedDisabled) return false;
	if (m_aDisguisesFriskExemptDisabled != p_Other.m_aDisguisesFriskExemptDisabled) return false;
	if (m_aDisguisesDontEscalateOnLineCrossingDisabled != p_Other.m_aDisguisesDontEscalateOnLineCrossingDisabled) return false;
	if (m_ItemsDroppedInZone != p_Other.m_ItemsDroppedInZone) return false;

	return true;
}

void SSentryZoneSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSentryZoneSaveData*>(p_Object);
	s_Object->~SSentryZoneSaveData();
}

ZHMTypeInfo SSequenceTrackSaveData::TypeInfo = ZHMTypeInfo("SSequenceTrackSaveData", sizeof(SSequenceTrackSaveData), alignof(SSequenceTrackSaveData), SSequenceTrackSaveData::WriteSimpleJson, SSequenceTrackSaveData::FromSimpleJson, SSequenceTrackSaveData::Serialize, SSequenceTrackSaveData::Equals, SSequenceTrackSaveData::Destroy);

void SSequenceTrackSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTrackEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTrackEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomTrackData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomTrackData, p_Stream);

	p_Stream << "}";
}

void SSequenceTrackSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSequenceTrackSaveData s_Object {};

	s_Object.m_rTrackEntity = simdjson::from_json_uint32(p_Document["m_rTrackEntity"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CustomTrackData"], &s_Item);
		s_Object.m_CustomTrackData = s_Item;
	}

	*reinterpret_cast<SSequenceTrackSaveData*>(p_Target) = s_Object;
}

void SSequenceTrackSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);

	ZVariant::Serialize(&s_Object->m_CustomTrackData, p_Serializer, p_OwnOffset + offsetof(SSequenceTrackSaveData, m_CustomTrackData));
}

bool SSequenceTrackSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceTrackSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceTrackSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceTrackSaveData::operator==(const SSequenceTrackSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceTrackSaveData>)
		return false;

	if (m_rTrackEntity != p_Other.m_rTrackEntity) return false;
	if (m_CustomTrackData != p_Other.m_CustomTrackData) return false;

	return true;
}

void SSequenceTrackSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSequenceTrackSaveData*>(p_Object);
	s_Object->~SSequenceTrackSaveData();
}

ZHMTypeInfo SSequenceSaveData::TypeInfo = ZHMTypeInfo("SSequenceSaveData", sizeof(SSequenceSaveData), alignof(SSequenceSaveData), SSequenceSaveData::WriteSimpleJson, SSequenceSaveData::FromSimpleJson, SSequenceSaveData::Serialize, SSequenceSaveData::Equals, SSequenceSaveData::Destroy);

void SSequenceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_commandQueue") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_commandQueue.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_commandQueue[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSequenceEntity.ECommand", static_cast<int>(s_Item0)));

		if (i < s_Object->m_commandQueue.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sequenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_sequenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sequenceOrigin") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sequenceOrigin);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasRunData") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasRunData);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aTrackSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackSaveData[i];
		SSequenceTrackSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_effectiveSequenceTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_effectiveSequenceTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCurrentLoop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentLoop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eStateFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_eStateFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPausedOnStart") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPausedOnStart);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bActivatedByIActivatable") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bActivatedByIActivatable);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGettingDeactivated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGettingDeactivated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bOnGameStopped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bOnGameStopped);

	p_Stream << "}";
}

void SSequenceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSequenceSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_commandQueue"];
	s_Object.m_commandQueue.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_commandQueue[s_Index0++] = static_cast<ZSequenceEntity_ECommand>(ZHMEnums::GetEnumValueByName("ZSequenceEntity.ECommand", std::string_view(s_Item0)));
	}
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_sequenceTime"], &s_Item);
		s_Object.m_sequenceTime = s_Item;
	}

	s_Object.m_sequenceOrigin = simdjson::from_json_uint32(p_Document["m_sequenceOrigin"]);

	s_Object.m_bHasRunData = simdjson::from_json_bool(p_Document["m_bHasRunData"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTrackSaveData"];
	s_Object.m_aTrackSaveData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSequenceTrackSaveData s_ArrayItem0;
		SSequenceTrackSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTrackSaveData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_effectiveSequenceTime"], &s_Item);
		s_Object.m_effectiveSequenceTime = s_Item;
	}

	s_Object.m_nCurrentLoop = simdjson::from_json_int32(p_Document["m_nCurrentLoop"]);

	s_Object.m_eStateFlags = simdjson::from_json_uint16(p_Document["m_eStateFlags"]);

	s_Object.m_bPausedOnStart = simdjson::from_json_bool(p_Document["m_bPausedOnStart"]);

	s_Object.m_bActivatedByIActivatable = simdjson::from_json_bool(p_Document["m_bActivatedByIActivatable"]);

	s_Object.m_bGettingDeactivated = simdjson::from_json_bool(p_Document["m_bGettingDeactivated"]);

	s_Object.m_bOnGameStopped = simdjson::from_json_bool(p_Document["m_bOnGameStopped"]);

	*reinterpret_cast<SSequenceSaveData*>(p_Target) = s_Object;
}

void SSequenceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);

	TArray<ZSequenceEntity_ECommand>::Serialize(&s_Object->m_commandQueue, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_commandQueue));
	ZGameTime::Serialize(&s_Object->m_sequenceTime, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_sequenceTime));
	TArray<SSequenceTrackSaveData>::Serialize(&s_Object->m_aTrackSaveData, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_aTrackSaveData));
	ZGameTime::Serialize(&s_Object->m_effectiveSequenceTime, p_Serializer, p_OwnOffset + offsetof(SSequenceSaveData, m_effectiveSequenceTime));
}

bool SSequenceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceSaveData::operator==(const SSequenceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceSaveData>)
		return false;

	if (m_commandQueue != p_Other.m_commandQueue) return false;
	if (m_sequenceTime != p_Other.m_sequenceTime) return false;
	if (m_sequenceOrigin != p_Other.m_sequenceOrigin) return false;
	if (m_bHasRunData != p_Other.m_bHasRunData) return false;
	if (m_aTrackSaveData != p_Other.m_aTrackSaveData) return false;
	if (m_effectiveSequenceTime != p_Other.m_effectiveSequenceTime) return false;
	if (m_nCurrentLoop != p_Other.m_nCurrentLoop) return false;
	if (m_eStateFlags != p_Other.m_eStateFlags) return false;
	if (m_bPausedOnStart != p_Other.m_bPausedOnStart) return false;
	if (m_bActivatedByIActivatable != p_Other.m_bActivatedByIActivatable) return false;
	if (m_bGettingDeactivated != p_Other.m_bGettingDeactivated) return false;
	if (m_bOnGameStopped != p_Other.m_bOnGameStopped) return false;

	return true;
}

void SSequenceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSequenceSaveData*>(p_Object);
	s_Object->~SSequenceSaveData();
}

ZHMTypeInfo SSequenceManagerSaveData::TypeInfo = ZHMTypeInfo("SSequenceManagerSaveData", sizeof(SSequenceManagerSaveData), alignof(SSequenceManagerSaveData), SSequenceManagerSaveData::WriteSimpleJson, SSequenceManagerSaveData::FromSimpleJson, SSequenceManagerSaveData::Serialize, SSequenceManagerSaveData::Equals, SSequenceManagerSaveData::Destroy);

void SSequenceManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSequenceSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSequenceSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSequenceSaveData[i];
		SSequenceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSequenceSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSequenceManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSequenceManagerSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSequenceSaveData"];
	s_Object.m_aSequenceSaveData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSequenceSaveData s_ArrayItem0;
		SSequenceSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSequenceSaveData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SSequenceManagerSaveData*>(p_Target) = s_Object;
}

void SSequenceManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SSequenceManagerSaveData, m_aEntities));
	TArray<SSequenceSaveData>::Serialize(&s_Object->m_aSequenceSaveData, p_Serializer, p_OwnOffset + offsetof(SSequenceManagerSaveData, m_aSequenceSaveData));
}

bool SSequenceManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSequenceManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSequenceManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSequenceManagerSaveData::operator==(const SSequenceManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSequenceManagerSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aSequenceSaveData != p_Other.m_aSequenceSaveData) return false;

	return true;
}

void SSequenceManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSequenceManagerSaveData*>(p_Object);
	s_Object->~SSequenceManagerSaveData();
}

ZHMTypeInfo SSerializedValue::TypeInfo = ZHMTypeInfo("SSerializedValue", sizeof(SSerializedValue), alignof(SSerializedValue), SSerializedValue::WriteSimpleJson, SSerializedValue::FromSimpleJson, SSerializedValue::Serialize, SSerializedValue::Equals, SSerializedValue::Destroy);

void SSerializedValue::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void SSerializedValue::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSerializedValue s_Object {};

	*reinterpret_cast<SSerializedValue*>(p_Target) = s_Object;
}

void SSerializedValue::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);

}

bool SSerializedValue::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSerializedValue*>(p_Left);
	auto* s_Right = reinterpret_cast<SSerializedValue*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSerializedValue::operator==(const SSerializedValue& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSerializedValue>)
		return false;


	return true;
}

void SSerializedValue::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSerializedValue*>(p_Object);
	s_Object->~SSerializedValue();
}

ZHMTypeInfo SSituationConversationGroupSaveData::TypeInfo = ZHMTypeInfo("SSituationConversationGroupSaveData", sizeof(SSituationConversationGroupSaveData), alignof(SSituationConversationGroupSaveData), SSituationConversationGroupSaveData::WriteSimpleJson, SSituationConversationGroupSaveData::FromSimpleJson, SSituationConversationGroupSaveData::Serialize, SSituationConversationGroupSaveData::Equals, SSituationConversationGroupSaveData::Destroy);

void SSituationConversationGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_members") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_members.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_members[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_members.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSituationConversationGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationConversationGroupSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_members"];
	s_Object.m_members.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_members[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SSituationConversationGroupSaveData*>(p_Target) = s_Object;
}

void SSituationConversationGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_members, p_Serializer, p_OwnOffset + offsetof(SSituationConversationGroupSaveData, m_members));
}

bool SSituationConversationGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationConversationGroupSaveData::operator==(const SSituationConversationGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationConversationGroupSaveData>)
		return false;

	if (m_members != p_Other.m_members) return false;

	return true;
}

void SSituationConversationGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationConversationGroupSaveData*>(p_Object);
	s_Object->~SSituationConversationGroupSaveData();
}

ZHMTypeInfo SSituationOrderSaveData::TypeInfo = ZHMTypeInfo("SSituationOrderSaveData", sizeof(SSituationOrderSaveData), alignof(SSituationOrderSaveData), SSituationOrderSaveData::WriteSimpleJson, SSituationOrderSaveData::FromSimpleJson, SSituationOrderSaveData::Serialize, SSituationOrderSaveData::Equals, SSituationOrderSaveData::Destroy);

void SSituationOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sClassTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sClassTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CustomData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_CustomData, p_Stream);

	p_Stream << "}";
}

void SSituationOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSituationOrderSaveData s_Object {};

	s_Object.m_sClassTypeName = std::string_view(p_Document["m_sClassTypeName"]);

	s_Object.m_eType = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eType"])));

	s_Object.m_nTarget = simdjson::from_json_int32(p_Document["m_nTarget"]);

	s_Object.m_bHasPosition = simdjson::from_json_bool(p_Document["m_bHasPosition"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_CustomData"], &s_Item);
		s_Object.m_CustomData = s_Item;
	}

	*reinterpret_cast<SSituationOrderSaveData*>(p_Target) = s_Object;
}

void SSituationOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);

	ZString::Serialize(&s_Object->m_sClassTypeName, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_sClassTypeName));
	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_vPosition));
	ZVariant::Serialize(&s_Object->m_CustomData, p_Serializer, p_OwnOffset + offsetof(SSituationOrderSaveData, m_CustomData));
}

bool SSituationOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSituationOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSituationOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSituationOrderSaveData::operator==(const SSituationOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSituationOrderSaveData>)
		return false;

	if (m_sClassTypeName != p_Other.m_sClassTypeName) return false;
	if (m_eType != p_Other.m_eType) return false;
	if (m_nTarget != p_Other.m_nTarget) return false;
	if (m_bHasPosition != p_Other.m_bHasPosition) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_CustomData != p_Other.m_CustomData) return false;

	return true;
}

void SSituationOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSituationOrderSaveData*>(p_Object);
	s_Object->~SSituationOrderSaveData();
}

ZHMTypeInfo SSmuggleSituationActorStateSaveData::TypeInfo = ZHMTypeInfo("SSmuggleSituationActorStateSaveData", sizeof(SSmuggleSituationActorStateSaveData), alignof(SSmuggleSituationActorStateSaveData), SSmuggleSituationActorStateSaveData::WriteSimpleJson, SSmuggleSituationActorStateSaveData::FromSimpleJson, SSmuggleSituationActorStateSaveData::Serialize, SSmuggleSituationActorStateSaveData::Equals, SSmuggleSituationActorStateSaveData::Destroy);

void SSmuggleSituationActorStateSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAllocatedForSituation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAllocatedForSituation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSmuggleSituationEntity.ESmuggleState", static_cast<int>(s_Object->m_nState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStatePrevious") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSmuggleSituationEntity.ESmuggleState", static_cast<int>(s_Object->m_nStatePrevious)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStateTimer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStateTimer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nTargetLocationIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nTargetLocationIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rScreenplay") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rScreenplay);

	p_Stream << "}";
}

void SSmuggleSituationActorStateSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSmuggleSituationActorStateSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_bAllocatedForSituation = simdjson::from_json_bool(p_Document["m_bAllocatedForSituation"]);

	s_Object.m_nState = static_cast<ZSmuggleSituationEntity_ESmuggleState>(ZHMEnums::GetEnumValueByName("ZSmuggleSituationEntity.ESmuggleState", std::string_view(p_Document["m_nState"])));

	s_Object.m_nStatePrevious = static_cast<ZSmuggleSituationEntity_ESmuggleState>(ZHMEnums::GetEnumValueByName("ZSmuggleSituationEntity.ESmuggleState", std::string_view(p_Document["m_nStatePrevious"])));

	s_Object.m_fStateTimer = simdjson::from_json_float32(p_Document["m_fStateTimer"]);

	s_Object.m_nTargetLocationIndex = simdjson::from_json_int32(p_Document["m_nTargetLocationIndex"]);

	s_Object.m_rScreenplay = simdjson::from_json_uint32(p_Document["m_rScreenplay"]);

	*reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Target) = s_Object;
}

void SSmuggleSituationActorStateSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);

}

bool SSmuggleSituationActorStateSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSmuggleSituationActorStateSaveData::operator==(const SSmuggleSituationActorStateSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSmuggleSituationActorStateSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_bAllocatedForSituation != p_Other.m_bAllocatedForSituation) return false;
	if (m_nState != p_Other.m_nState) return false;
	if (m_nStatePrevious != p_Other.m_nStatePrevious) return false;
	if (m_fStateTimer != p_Other.m_fStateTimer) return false;
	if (m_nTargetLocationIndex != p_Other.m_nTargetLocationIndex) return false;
	if (m_rScreenplay != p_Other.m_rScreenplay) return false;

	return true;
}

void SSmuggleSituationActorStateSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationActorStateSaveData*>(p_Object);
	s_Object->~SSmuggleSituationActorStateSaveData();
}

ZHMTypeInfo SSmuggleSituationSaveData::TypeInfo = ZHMTypeInfo("SSmuggleSituationSaveData", sizeof(SSmuggleSituationSaveData), alignof(SSmuggleSituationSaveData), SSmuggleSituationSaveData::WriteSimpleJson, SSmuggleSituationSaveData::FromSimpleJson, SSmuggleSituationSaveData::Serialize, SSmuggleSituationSaveData::Equals, SSmuggleSituationSaveData::Destroy);

void SSmuggleSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsRunning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsRunning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nNumberOfPickups") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nNumberOfPickups);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aActorsSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aActorsSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aActorsSaveData[i];
		SSmuggleSituationActorStateSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aActorsSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aMoveToActs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aMoveToActs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aMoveToActs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aMoveToActs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SSmuggleSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSmuggleSituationSaveData s_Object {};

	s_Object.m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object.m_bIsRunning = simdjson::from_json_bool(p_Document["m_bIsRunning"]);

	s_Object.m_nNumberOfPickups = simdjson::from_json_int32(p_Document["m_nNumberOfPickups"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aActorsSaveData"];
	s_Object.m_aActorsSaveData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SSmuggleSituationActorStateSaveData s_ArrayItem0;
		SSmuggleSituationActorStateSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aActorsSaveData[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aMoveToActs"];
	s_Object.m_aMoveToActs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aMoveToActs[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<SSmuggleSituationSaveData*>(p_Target) = s_Object;
}

void SSmuggleSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);

	TArray<SSmuggleSituationActorStateSaveData>::Serialize(&s_Object->m_aActorsSaveData, p_Serializer, p_OwnOffset + offsetof(SSmuggleSituationSaveData, m_aActorsSaveData));
	TArray<uint32>::Serialize(&s_Object->m_aMoveToActs, p_Serializer, p_OwnOffset + offsetof(SSmuggleSituationSaveData, m_aMoveToActs));
}

bool SSmuggleSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSmuggleSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSmuggleSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSmuggleSituationSaveData::operator==(const SSmuggleSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSmuggleSituationSaveData>)
		return false;

	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_bIsRunning != p_Other.m_bIsRunning) return false;
	if (m_nNumberOfPickups != p_Other.m_nNumberOfPickups) return false;
	if (m_aActorsSaveData != p_Other.m_aActorsSaveData) return false;
	if (m_aMoveToActs != p_Other.m_aMoveToActs) return false;

	return true;
}

void SSmuggleSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSmuggleSituationSaveData*>(p_Object);
	s_Object->~SSmuggleSituationSaveData();
}

ZHMTypeInfo SSniperCombatGroupSaveData::TypeInfo = ZHMTypeInfo("SSniperCombatGroupSaveData", sizeof(SSniperCombatGroupSaveData), alignof(SSniperCombatGroupSaveData), SSniperCombatGroupSaveData::WriteSimpleJson, SSniperCombatGroupSaveData::FromSimpleJson, SSniperCombatGroupSaveData::Serialize, SSniperCombatGroupSaveData::Equals, SSniperCombatGroupSaveData::Destroy);

void SSniperCombatGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_target") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_target);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tEscapeTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tEscapeTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTauntTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTauntTime, p_Stream);

	p_Stream << "}";
}

void SSniperCombatGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSniperCombatGroupSaveData s_Object {};

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_target = simdjson::from_json_int32(p_Document["m_target"]);

	s_Object.m_bFailed = simdjson::from_json_bool(p_Document["m_bFailed"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tEscapeTime"], &s_Item);
		s_Object.m_tEscapeTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTauntTime"], &s_Item);
		s_Object.m_tLastTauntTime = s_Item;
	}

	*reinterpret_cast<SSniperCombatGroupSaveData*>(p_Target) = s_Object;
}

void SSniperCombatGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_fsmState));
	ZGameTime::Serialize(&s_Object->m_tEscapeTime, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_tEscapeTime));
	ZGameTime::Serialize(&s_Object->m_tLastTauntTime, p_Serializer, p_OwnOffset + offsetof(SSniperCombatGroupSaveData, m_tLastTauntTime));
}

bool SSniperCombatGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSniperCombatGroupSaveData::operator==(const SSniperCombatGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSniperCombatGroupSaveData>)
		return false;

	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_target != p_Other.m_target) return false;
	if (m_bFailed != p_Other.m_bFailed) return false;
	if (m_tEscapeTime != p_Other.m_tEscapeTime) return false;
	if (m_tLastTauntTime != p_Other.m_tLastTauntTime) return false;

	return true;
}

void SSniperCombatGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSniperCombatGroupSaveData*>(p_Object);
	s_Object->~SSniperCombatGroupSaveData();
}

ZHMTypeInfo SSniperScoringEvent::TypeInfo = ZHMTypeInfo("SSniperScoringEvent", sizeof(SSniperScoringEvent), alignof(SSniperScoringEvent), SSniperScoringEvent::WriteSimpleJson, SSniperScoringEvent::FromSimpleJson, SSniperScoringEvent::Serialize, SSniperScoringEvent::Equals, SSniperScoringEvent::Destroy);

void SSniperScoringEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSniperScoringEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iPoints") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iPoints);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iPlayer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iPlayer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_iScoringMachine") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iScoringMachine);

	p_Stream << "}";
}

void SSniperScoringEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSniperScoringEvent s_Object {};

	s_Object.m_iPoints = simdjson::from_json_int32(p_Document["m_iPoints"]);

	s_Object.m_iPlayer = simdjson::from_json_int32(p_Document["m_iPlayer"]);

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	s_Object.m_sText = std::string_view(p_Document["m_sText"]);

	s_Object.m_iType = simdjson::from_json_int32(p_Document["m_iType"]);

	s_Object.m_iScoringMachine = simdjson::from_json_uint8(p_Document["m_iScoringMachine"]);

	*reinterpret_cast<SSniperScoringEvent*>(p_Target) = s_Object;
}

void SSniperScoringEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSniperScoringEvent*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(SSniperScoringEvent, m_sName));
	ZString::Serialize(&s_Object->m_sText, p_Serializer, p_OwnOffset + offsetof(SSniperScoringEvent, m_sText));
}

bool SSniperScoringEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSniperScoringEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<SSniperScoringEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSniperScoringEvent::operator==(const SSniperScoringEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSniperScoringEvent>)
		return false;

	if (m_iPoints != p_Other.m_iPoints) return false;
	if (m_iPlayer != p_Other.m_iPlayer) return false;
	if (m_sName != p_Other.m_sName) return false;
	if (m_sText != p_Other.m_sText) return false;
	if (m_iType != p_Other.m_iType) return false;
	if (m_iScoringMachine != p_Other.m_iScoringMachine) return false;

	return true;
}

void SSniperScoringEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSniperScoringEvent*>(p_Object);
	s_Object->~SSniperScoringEvent();
}

ZHMTypeInfo SSpaceCollectionBehaviorConfiguration::TypeInfo = ZHMTypeInfo("SSpaceCollectionBehaviorConfiguration", sizeof(SSpaceCollectionBehaviorConfiguration), alignof(SSpaceCollectionBehaviorConfiguration), SSpaceCollectionBehaviorConfiguration::WriteSimpleJson, SSpaceCollectionBehaviorConfiguration::FromSimpleJson, SSpaceCollectionBehaviorConfiguration::Serialize, SSpaceCollectionBehaviorConfiguration::Equals, SSpaceCollectionBehaviorConfiguration::Destroy);

void SSpaceCollectionBehaviorConfiguration::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bInclusive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInclusive);

	p_Stream << "}";
}

void SSpaceCollectionBehaviorConfiguration::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSpaceCollectionBehaviorConfiguration s_Object {};

	s_Object.m_bInclusive = simdjson::from_json_bool(p_Document["m_bInclusive"]);

	*reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Target) = s_Object;
}

void SSpaceCollectionBehaviorConfiguration::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);

}

bool SSpaceCollectionBehaviorConfiguration::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpaceCollectionBehaviorConfiguration::operator==(const SSpaceCollectionBehaviorConfiguration& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpaceCollectionBehaviorConfiguration>)
		return false;

	if (m_bInclusive != p_Other.m_bInclusive) return false;

	return true;
}

void SSpaceCollectionBehaviorConfiguration::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSpaceCollectionBehaviorConfiguration*>(p_Object);
	s_Object->~SSpaceCollectionBehaviorConfiguration();
}

ZHMTypeInfo SSpatialMoverEntitySaveData::TypeInfo = ZHMTypeInfo("SSpatialMoverEntitySaveData", sizeof(SSpatialMoverEntitySaveData), alignof(SSpatialMoverEntitySaveData), SSpatialMoverEntitySaveData::WriteSimpleJson, SSpatialMoverEntitySaveData::FromSimpleJson, SSpatialMoverEntitySaveData::Serialize, SSpatialMoverEntitySaveData::Equals, SSpatialMoverEntitySaveData::Destroy);

void SSpatialMoverEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSpeed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSpeed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bBackwards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bBackwards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsFrameUpdateRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsFrameUpdateRegistered);

	p_Stream << "}";
}

void SSpatialMoverEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSpatialMoverEntitySaveData s_Object {};

	s_Object.m_fSpeed = simdjson::from_json_float32(p_Document["m_fSpeed"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_bBackwards = simdjson::from_json_bool(p_Document["m_bBackwards"]);

	s_Object.m_bIsFrameUpdateRegistered = simdjson::from_json_bool(p_Document["m_bIsFrameUpdateRegistered"]);

	*reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Target) = s_Object;
}

void SSpatialMoverEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSpatialMoverEntitySaveData, m_vPosition));
}

bool SSpatialMoverEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpatialMoverEntitySaveData::operator==(const SSpatialMoverEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpatialMoverEntitySaveData>)
		return false;

	if (m_fSpeed != p_Other.m_fSpeed) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_bBackwards != p_Other.m_bBackwards) return false;
	if (m_bIsFrameUpdateRegistered != p_Other.m_bIsFrameUpdateRegistered) return false;

	return true;
}

void SSpatialMoverEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSpatialMoverEntitySaveData*>(p_Object);
	s_Object->~SSpatialMoverEntitySaveData();
}

ZHMTypeInfo SSpatialSaveData::TypeInfo = ZHMTypeInfo("SSpatialSaveData", sizeof(SSpatialSaveData), alignof(SSpatialSaveData), SSpatialSaveData::WriteSimpleJson, SSpatialSaveData::FromSimpleJson, SSpatialSaveData::Serialize, SSpatialSaveData::Equals, SSpatialSaveData::Destroy);

void SSpatialSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vQuaternionRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vQuaternionRotation, p_Stream);

	p_Stream << "}";
}

void SSpatialSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSpatialSaveData s_Object {};

	s_Object.m_bVisible = simdjson::from_json_bool(p_Document["m_bVisible"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vQuaternionRotation"], &s_Item);
		s_Object.m_vQuaternionRotation = s_Item;
	}

	*reinterpret_cast<SSpatialSaveData*>(p_Target) = s_Object;
}

void SSpatialSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(SSpatialSaveData, m_vPosition));
	SVector4::Serialize(&s_Object->m_vQuaternionRotation, p_Serializer, p_OwnOffset + offsetof(SSpatialSaveData, m_vQuaternionRotation));
}

bool SSpatialSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpatialSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpatialSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpatialSaveData::operator==(const SSpatialSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpatialSaveData>)
		return false;

	if (m_bVisible != p_Other.m_bVisible) return false;
	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_vQuaternionRotation != p_Other.m_vQuaternionRotation) return false;

	return true;
}

void SSpatialSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSpatialSaveData*>(p_Object);
	s_Object->~SSpatialSaveData();
}

ZHMTypeInfo SSpeakEntitySaveData::TypeInfo = ZHMTypeInfo("SSpeakEntitySaveData", sizeof(SSpeakEntitySaveData), alignof(SSpeakEntitySaveData), SSpeakEntitySaveData::WriteSimpleJson, SSpeakEntitySaveData::FromSimpleJson, SSpeakEntitySaveData::Serialize, SSpeakEntitySaveData::Equals, SSpeakEntitySaveData::Destroy);

void SSpeakEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fSeekPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fSeekPosition);

	p_Stream << "}";
}

void SSpeakEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SSpeakEntitySaveData s_Object {};

	s_Object.m_fSeekPosition = simdjson::from_json_float32(p_Document["m_fSeekPosition"]);

	*reinterpret_cast<SSpeakEntitySaveData*>(p_Target) = s_Object;
}

void SSpeakEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);

}

bool SSpeakEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SSpeakEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SSpeakEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SSpeakEntitySaveData::operator==(const SSpeakEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SSpeakEntitySaveData>)
		return false;

	if (m_fSeekPosition != p_Other.m_fSeekPosition) return false;

	return true;
}

void SSpeakEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SSpeakEntitySaveData*>(p_Object);
	s_Object->~SSpeakEntitySaveData();
}

ZHMTypeInfo SStashPointSaveData::TypeInfo = ZHMTypeInfo("SStashPointSaveData", sizeof(SStashPointSaveData), alignof(SStashPointSaveData), SStashPointSaveData::WriteSimpleJson, SStashPointSaveData::FromSimpleJson, SStashPointSaveData::Serialize, SStashPointSaveData::Equals, SStashPointSaveData::Destroy);

void SStashPointSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStashPointSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_arItems") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_arItems.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_arItems[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_arItems.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pSuitcase") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pSuitcase);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pMainItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pMainItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eContainedType") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EStashpointContainedEntityType", static_cast<int>(s_Object->m_eContainedType)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_MainItemID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->m_MainItemID, p_Stream);

	p_Stream << "}";
}

void SStashPointSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStashPointSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_arItems"];
	s_Object.m_arItems.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_arItems[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_pSuitcase = simdjson::from_json_uint32(p_Document["m_pSuitcase"]);

	s_Object.m_pMainItem = simdjson::from_json_uint32(p_Document["m_pMainItem"]);

	s_Object.m_eContainedType = static_cast<EStashpointContainedEntityType>(ZHMEnums::GetEnumValueByName("EStashpointContainedEntityType", std::string_view(p_Document["m_eContainedType"])));

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["m_MainItemID"], &s_Item);
		s_Object.m_MainItemID = s_Item;
	}

	*reinterpret_cast<SStashPointSaveData*>(p_Target) = s_Object;
}

void SStashPointSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStashPointSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_arItems, p_Serializer, p_OwnOffset + offsetof(SStashPointSaveData, m_arItems));
	ZRepositoryID::Serialize(&s_Object->m_MainItemID, p_Serializer, p_OwnOffset + offsetof(SStashPointSaveData, m_MainItemID));
}

bool SStashPointSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStashPointSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStashPointSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStashPointSaveData::operator==(const SStashPointSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStashPointSaveData>)
		return false;

	if (m_arItems != p_Other.m_arItems) return false;
	if (m_pSuitcase != p_Other.m_pSuitcase) return false;
	if (m_pMainItem != p_Other.m_pMainItem) return false;
	if (m_eContainedType != p_Other.m_eContainedType) return false;
	if (m_MainItemID != p_Other.m_MainItemID) return false;

	return true;
}

void SStashPointSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SStashPointSaveData*>(p_Object);
	s_Object->~SStashPointSaveData();
}

ZHMTypeInfo SStateControllerSaveDataStruct::TypeInfo = ZHMTypeInfo("SStateControllerSaveDataStruct", sizeof(SStateControllerSaveDataStruct), alignof(SStateControllerSaveDataStruct), SStateControllerSaveDataStruct::WriteSimpleJson, SStateControllerSaveDataStruct::FromSimpleJson, SStateControllerSaveDataStruct::Serialize, SStateControllerSaveDataStruct::Equals, SStateControllerSaveDataStruct::Destroy);

void SStateControllerSaveDataStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveDataStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);

	p_Stream << "}";
}

void SStateControllerSaveDataStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStateControllerSaveDataStruct s_Object {};

	s_Object.m_nIndex = simdjson::from_json_int32(p_Document["m_nIndex"]);

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	*reinterpret_cast<SStateControllerSaveDataStruct*>(p_Target) = s_Object;
}

void SStateControllerSaveDataStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveDataStruct*>(p_Object);

}

bool SStateControllerSaveDataStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStateControllerSaveDataStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SStateControllerSaveDataStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStateControllerSaveDataStruct::operator==(const SStateControllerSaveDataStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStateControllerSaveDataStruct>)
		return false;

	if (m_nIndex != p_Other.m_nIndex) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;

	return true;
}

void SStateControllerSaveDataStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveDataStruct*>(p_Object);
	s_Object->~SStateControllerSaveDataStruct();
}

ZHMTypeInfo SStateControllerSaveData::TypeInfo = ZHMTypeInfo("SStateControllerSaveData", sizeof(SStateControllerSaveData), alignof(SStateControllerSaveData), SStateControllerSaveData::WriteSimpleJson, SStateControllerSaveData::FromSimpleJson, SStateControllerSaveData::Serialize, SStateControllerSaveData::Equals, SStateControllerSaveData::Destroy);

void SStateControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		SStateControllerSaveDataStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SStateControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStateControllerSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SStateControllerSaveDataStruct s_ArrayItem0;
		SStateControllerSaveDataStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SStateControllerSaveData*>(p_Target) = s_Object;
}

void SStateControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SStateControllerSaveData, m_aEntities));
	TArray<SStateControllerSaveDataStruct>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SStateControllerSaveData, m_aData));
}

bool SStateControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStateControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStateControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStateControllerSaveData::operator==(const SStateControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStateControllerSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SStateControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SStateControllerSaveData*>(p_Object);
	s_Object->~SStateControllerSaveData();
}

ZHMTypeInfo SStepCounterEntitySaveData::TypeInfo = ZHMTypeInfo("SStepCounterEntitySaveData", sizeof(SStepCounterEntitySaveData), alignof(SStepCounterEntitySaveData), SStepCounterEntitySaveData::WriteSimpleJson, SStepCounterEntitySaveData::FromSimpleJson, SStepCounterEntitySaveData::Serialize, SStepCounterEntitySaveData::Equals, SStepCounterEntitySaveData::Destroy);

void SStepCounterEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nLoopIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nLoopIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bFirst") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bFirst);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCountFrom") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCountFrom);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCountTo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCountTo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nStepSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nStepSize);

	p_Stream << "}";
}

void SStepCounterEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SStepCounterEntitySaveData s_Object {};

	s_Object.m_nIndex = simdjson::from_json_float32(p_Document["m_nIndex"]);

	s_Object.m_nLoopIndex = simdjson::from_json_int32(p_Document["m_nLoopIndex"]);

	s_Object.m_bFirst = simdjson::from_json_bool(p_Document["m_bFirst"]);

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_nCountFrom = simdjson::from_json_float32(p_Document["m_nCountFrom"]);

	s_Object.m_nCountTo = simdjson::from_json_float32(p_Document["m_nCountTo"]);

	s_Object.m_nStepSize = simdjson::from_json_float32(p_Document["m_nStepSize"]);

	*reinterpret_cast<SStepCounterEntitySaveData*>(p_Target) = s_Object;
}

void SStepCounterEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);

}

bool SStepCounterEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SStepCounterEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SStepCounterEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SStepCounterEntitySaveData::operator==(const SStepCounterEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SStepCounterEntitySaveData>)
		return false;

	if (m_nIndex != p_Other.m_nIndex) return false;
	if (m_nLoopIndex != p_Other.m_nLoopIndex) return false;
	if (m_bFirst != p_Other.m_bFirst) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_nCountFrom != p_Other.m_nCountFrom) return false;
	if (m_nCountTo != p_Other.m_nCountTo) return false;
	if (m_nStepSize != p_Other.m_nStepSize) return false;

	return true;
}

void SStepCounterEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SStepCounterEntitySaveData*>(p_Object);
	s_Object->~SStepCounterEntitySaveData();
}

ZHMTypeInfo STargetInfoObjectiveCondition::TypeInfo = ZHMTypeInfo("STargetInfoObjectiveCondition", sizeof(STargetInfoObjectiveCondition), alignof(STargetInfoObjectiveCondition), STargetInfoObjectiveCondition::WriteSimpleJson, STargetInfoObjectiveCondition::FromSimpleJson, STargetInfoObjectiveCondition::Serialize, STargetInfoObjectiveCondition::Equals, STargetInfoObjectiveCondition::Destroy);

void STargetInfoObjectiveCondition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("header") << ":";
	p_Stream << simdjson::as_json_string(s_Object->header);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("title") << ":";
	p_Stream << simdjson::as_json_string(s_Object->title);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("type") << ":";
	p_Stream << simdjson::as_json_string(s_Object->type);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("hardCondition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->hardCondition);

	p_Stream << "}";
}

void STargetInfoObjectiveCondition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetInfoObjectiveCondition s_Object {};

	s_Object.header = std::string_view(p_Document["header"]);

	s_Object.title = std::string_view(p_Document["title"]);

	s_Object.icon = std::string_view(p_Document["icon"]);

	s_Object.type = std::string_view(p_Document["type"]);

	s_Object.hardCondition = simdjson::from_json_bool(p_Document["hardCondition"]);

	*reinterpret_cast<STargetInfoObjectiveCondition*>(p_Target) = s_Object;
}

void STargetInfoObjectiveCondition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);

	ZString::Serialize(&s_Object->header, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, header));
	ZString::Serialize(&s_Object->title, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, title));
	ZString::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, icon));
	ZString::Serialize(&s_Object->type, p_Serializer, p_OwnOffset + offsetof(STargetInfoObjectiveCondition, type));
}

bool STargetInfoObjectiveCondition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoObjectiveCondition::operator==(const STargetInfoObjectiveCondition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoObjectiveCondition>)
		return false;

	if (header != p_Other.header) return false;
	if (title != p_Other.title) return false;
	if (icon != p_Other.icon) return false;
	if (type != p_Other.type) return false;
	if (hardCondition != p_Other.hardCondition) return false;

	return true;
}

void STargetInfoObjectiveCondition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetInfoObjectiveCondition*>(p_Object);
	s_Object->~STargetInfoObjectiveCondition();
}

ZHMTypeInfo STargetInfoDisplayData::TypeInfo = ZHMTypeInfo("STargetInfoDisplayData", sizeof(STargetInfoDisplayData), alignof(STargetInfoDisplayData), STargetInfoDisplayData::WriteSimpleJson, STargetInfoDisplayData::FromSimpleJson, STargetInfoDisplayData::Serialize, STargetInfoDisplayData::Equals, STargetInfoDisplayData::Destroy);

void STargetInfoDisplayData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("npcName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->npcName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("disguiseName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->disguiseName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->objectiveType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("objectiveConditions") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->objectiveConditions.size(); ++i)
	{
		auto& s_Item0 = s_Object->objectiveConditions[i];
		STargetInfoObjectiveCondition::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->objectiveConditions.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fX") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fX);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fY") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fY);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fAlpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fAlpha);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsTarget);

	p_Stream << "}";
}

void STargetInfoDisplayData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetInfoDisplayData s_Object {};

	s_Object.npcName = std::string_view(p_Document["npcName"]);

	s_Object.disguiseName = std::string_view(p_Document["disguiseName"]);

	s_Object.objectiveType = std::string_view(p_Document["objectiveType"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["objectiveConditions"];
	s_Object.objectiveConditions.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STargetInfoObjectiveCondition s_ArrayItem0;
		STargetInfoObjectiveCondition::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.objectiveConditions[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.fX = simdjson::from_json_int32(p_Document["fX"]);

	s_Object.fY = simdjson::from_json_int32(p_Document["fY"]);

	s_Object.fAlpha = simdjson::from_json_float32(p_Document["fAlpha"]);

	s_Object.bIsTarget = simdjson::from_json_bool(p_Document["bIsTarget"]);

	*reinterpret_cast<STargetInfoDisplayData*>(p_Target) = s_Object;
}

void STargetInfoDisplayData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);

	ZString::Serialize(&s_Object->npcName, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, npcName));
	ZString::Serialize(&s_Object->disguiseName, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, disguiseName));
	ZString::Serialize(&s_Object->objectiveType, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, objectiveType));
	TArray<STargetInfoObjectiveCondition>::Serialize(&s_Object->objectiveConditions, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData, objectiveConditions));
}

bool STargetInfoDisplayData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoDisplayData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoDisplayData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoDisplayData::operator==(const STargetInfoDisplayData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoDisplayData>)
		return false;

	if (npcName != p_Other.npcName) return false;
	if (disguiseName != p_Other.disguiseName) return false;
	if (objectiveType != p_Other.objectiveType) return false;
	if (objectiveConditions != p_Other.objectiveConditions) return false;
	if (fX != p_Other.fX) return false;
	if (fY != p_Other.fY) return false;
	if (fAlpha != p_Other.fAlpha) return false;
	if (bIsTarget != p_Other.bIsTarget) return false;

	return true;
}

void STargetInfoDisplayData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData*>(p_Object);
	s_Object->~STargetInfoDisplayData();
}

ZHMTypeInfo STargetInfoDisplayData_Dummy::TypeInfo = ZHMTypeInfo("STargetInfoDisplayData_Dummy", sizeof(STargetInfoDisplayData_Dummy), alignof(STargetInfoDisplayData_Dummy), STargetInfoDisplayData_Dummy::WriteSimpleJson, STargetInfoDisplayData_Dummy::FromSimpleJson, STargetInfoDisplayData_Dummy::Serialize, STargetInfoDisplayData_Dummy::Equals, STargetInfoDisplayData_Dummy::Destroy);

void STargetInfoDisplayData_Dummy::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("__dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->__dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->__dummy[i];
		STargetInfoDisplayData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->__dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STargetInfoDisplayData_Dummy::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetInfoDisplayData_Dummy s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["__dummy"];
	s_Object.__dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STargetInfoDisplayData s_ArrayItem0;
		STargetInfoDisplayData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.__dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Target) = s_Object;
}

void STargetInfoDisplayData_Dummy::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);

	TArray<STargetInfoDisplayData>::Serialize(&s_Object->__dummy, p_Serializer, p_OwnOffset + offsetof(STargetInfoDisplayData_Dummy, __dummy));
}

bool STargetInfoDisplayData_Dummy::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetInfoDisplayData_Dummy::operator==(const STargetInfoDisplayData_Dummy& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetInfoDisplayData_Dummy>)
		return false;

	if (__dummy != p_Other.__dummy) return false;

	return true;
}

void STargetInfoDisplayData_Dummy::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetInfoDisplayData_Dummy*>(p_Object);
	s_Object->~STargetInfoDisplayData_Dummy();
}

ZHMTypeInfo STargetTrackingSaveData::TypeInfo = ZHMTypeInfo("STargetTrackingSaveData", sizeof(STargetTrackingSaveData), alignof(STargetTrackingSaveData), STargetTrackingSaveData::WriteSimpleJson, STargetTrackingSaveData::FromSimpleJson, STargetTrackingSaveData::Serialize, STargetTrackingSaveData::Equals, STargetTrackingSaveData::Destroy);

void STargetTrackingSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sharedTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sharedTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_position") << ":";
	float4::WriteSimpleJson(&s_Object->m_position, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_time") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_time, p_Stream);

	p_Stream << "}";
}

void STargetTrackingSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetTrackingSaveData s_Object {};

	s_Object.m_sharedTarget = simdjson::from_json_int32(p_Document["m_sharedTarget"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_position"], &s_Item);
		s_Object.m_position = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_time"], &s_Item);
		s_Object.m_time = s_Item;
	}

	*reinterpret_cast<STargetTrackingSaveData*>(p_Target) = s_Object;
}

void STargetTrackingSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_position, p_Serializer, p_OwnOffset + offsetof(STargetTrackingSaveData, m_position));
	ZGameTime::Serialize(&s_Object->m_time, p_Serializer, p_OwnOffset + offsetof(STargetTrackingSaveData, m_time));
}

bool STargetTrackingSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetTrackingSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetTrackingSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetTrackingSaveData::operator==(const STargetTrackingSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetTrackingSaveData>)
		return false;

	if (m_sharedTarget != p_Other.m_sharedTarget) return false;
	if (m_position != p_Other.m_position) return false;
	if (m_time != p_Other.m_time) return false;

	return true;
}

void STargetTrackingSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetTrackingSaveData*>(p_Object);
	s_Object->~STargetTrackingSaveData();
}

ZHMTypeInfo STargetTrackingServiceSaveData::TypeInfo = ZHMTypeInfo("STargetTrackingServiceSaveData", sizeof(STargetTrackingServiceSaveData), alignof(STargetTrackingServiceSaveData), STargetTrackingServiceSaveData::WriteSimpleJson, STargetTrackingServiceSaveData::FromSimpleJson, STargetTrackingServiceSaveData::Serialize, STargetTrackingServiceSaveData::Equals, STargetTrackingServiceSaveData::Destroy);

void STargetTrackingServiceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTrackedTargets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackedTargets.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackedTargets[i];
		STargetTrackingSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackedTargets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STargetTrackingServiceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetTrackingServiceSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTrackedTargets"];
	s_Object.m_aTrackedTargets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STargetTrackingSaveData s_ArrayItem0;
		STargetTrackingSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTrackedTargets[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STargetTrackingServiceSaveData*>(p_Target) = s_Object;
}

void STargetTrackingServiceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);

	TArray<STargetTrackingSaveData>::Serialize(&s_Object->m_aTrackedTargets, p_Serializer, p_OwnOffset + offsetof(STargetTrackingServiceSaveData, m_aTrackedTargets));
}

bool STargetTrackingServiceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetTrackingServiceSaveData::operator==(const STargetTrackingServiceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetTrackingServiceSaveData>)
		return false;

	if (m_aTrackedTargets != p_Other.m_aTrackedTargets) return false;

	return true;
}

void STargetTrackingServiceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetTrackingServiceSaveData*>(p_Object);
	s_Object->~STargetTrackingServiceSaveData();
}

ZHMTypeInfo STargetableBoneConfiguration::TypeInfo = ZHMTypeInfo("STargetableBoneConfiguration", sizeof(STargetableBoneConfiguration), alignof(STargetableBoneConfiguration), STargetableBoneConfiguration::WriteSimpleJson, STargetableBoneConfiguration::FromSimpleJson, STargetableBoneConfiguration::Serialize, STargetableBoneConfiguration::Equals, STargetableBoneConfiguration::Destroy);

void STargetableBoneConfiguration::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STargetableBoneConfiguration*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eBone") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("BoneId.Enum", static_cast<int>(s_Object->m_eBone)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fBoneRadiusOverride") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fBoneRadiusOverride);

	p_Stream << "}";
}

void STargetableBoneConfiguration::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STargetableBoneConfiguration s_Object {};

	s_Object.m_eBone = static_cast<BoneId_Enum>(ZHMEnums::GetEnumValueByName("BoneId.Enum", std::string_view(p_Document["m_eBone"])));

	s_Object.m_fBoneRadiusOverride = simdjson::from_json_float32(p_Document["m_fBoneRadiusOverride"]);

	*reinterpret_cast<STargetableBoneConfiguration*>(p_Target) = s_Object;
}

void STargetableBoneConfiguration::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STargetableBoneConfiguration*>(p_Object);

}

bool STargetableBoneConfiguration::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STargetableBoneConfiguration*>(p_Left);
	auto* s_Right = reinterpret_cast<STargetableBoneConfiguration*>(p_Right);

	return *s_Left == *s_Right;
}

bool STargetableBoneConfiguration::operator==(const STargetableBoneConfiguration& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STargetableBoneConfiguration>)
		return false;

	if (m_eBone != p_Other.m_eBone) return false;
	if (m_fBoneRadiusOverride != p_Other.m_fBoneRadiusOverride) return false;

	return true;
}

void STargetableBoneConfiguration::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STargetableBoneConfiguration*>(p_Object);
	s_Object->~STargetableBoneConfiguration();
}

ZHMTypeInfo STemplateBlueprintSubEntity::TypeInfo = ZHMTypeInfo("STemplateBlueprintSubEntity", sizeof(STemplateBlueprintSubEntity), alignof(STemplateBlueprintSubEntity), STemplateBlueprintSubEntity::WriteSimpleJson, STemplateBlueprintSubEntity::FromSimpleJson, STemplateBlueprintSubEntity::Serialize, STemplateBlueprintSubEntity::Equals, STemplateBlueprintSubEntity::Destroy);

void STemplateBlueprintSubEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateBlueprintSubEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("logicalParent") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->logicalParent, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("editorOnly") << ":";
	p_Stream << simdjson::as_json_string(s_Object->editorOnly);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyAliases") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyAliases.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyAliases[i];
		SEntityTemplatePropertyAlias::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyAliases.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedEntities[i];
		SEntityTemplateExposedEntity::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("exposedInterfaces") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->exposedInterfaces.size(); ++i)
	{
		auto& s_Item0 = s_Object->exposedInterfaces[i];
		TPair<ZString,int32>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->exposedInterfaces.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entitySubsets") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->entitySubsets.size(); ++i)
	{
		auto& s_Item0 = s_Object->entitySubsets[i];
		TPair<ZString,SEntityTemplateEntitySubset>::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->entitySubsets.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateBlueprintSubEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateBlueprintSubEntity s_Object {};

	{
		SEntityTemplateReference s_Item {};
		SEntityTemplateReference::FromSimpleJson(p_Document["logicalParent"], &s_Item);
		s_Object.logicalParent = s_Item;
	}

	s_Object.entityTypeResourceIndex = simdjson::from_json_int32(p_Document["entityTypeResourceIndex"]);

	s_Object.entityId = simdjson::from_json_uint64(p_Document["entityId"]);

	s_Object.editorOnly = simdjson::from_json_bool(p_Document["editorOnly"]);

	s_Object.entityName = std::string_view(p_Document["entityName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyAliases"];
	s_Object.propertyAliases.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePropertyAlias s_ArrayItem0;
		SEntityTemplatePropertyAlias::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyAliases[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["exposedEntities"];
	s_Object.exposedEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateExposedEntity s_ArrayItem0;
		SEntityTemplateExposedEntity::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.exposedEntities[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["exposedInterfaces"];
	s_Object.exposedInterfaces.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TPair<ZString,int32> s_ArrayItem0;
		TPair<ZString,int32>::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.exposedInterfaces[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["entitySubsets"];
	s_Object.entitySubsets.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TPair<ZString,SEntityTemplateEntitySubset> s_ArrayItem0;
		TPair<ZString,SEntityTemplateEntitySubset>::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.entitySubsets[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STemplateBlueprintSubEntity*>(p_Target) = s_Object;
}

void STemplateBlueprintSubEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateBlueprintSubEntity*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->logicalParent, p_Serializer, p_OwnOffset + offsetof(STemplateBlueprintSubEntity, logicalParent));
	ZString::Serialize(&s_Object->entityName, p_Serializer, p_OwnOffset + offsetof(STemplateBlueprintSubEntity, entityName));
	TArray<SEntityTemplatePropertyAlias>::Serialize(&s_Object->propertyAliases, p_Serializer, p_OwnOffset + offsetof(STemplateBlueprintSubEntity, propertyAliases));
	TArray<SEntityTemplateExposedEntity>::Serialize(&s_Object->exposedEntities, p_Serializer, p_OwnOffset + offsetof(STemplateBlueprintSubEntity, exposedEntities));
	TArray<TPair<ZString,int32>>::Serialize(&s_Object->exposedInterfaces, p_Serializer, p_OwnOffset + offsetof(STemplateBlueprintSubEntity, exposedInterfaces));
	TArray<TPair<ZString,SEntityTemplateEntitySubset>>::Serialize(&s_Object->entitySubsets, p_Serializer, p_OwnOffset + offsetof(STemplateBlueprintSubEntity, entitySubsets));
}

bool STemplateBlueprintSubEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateBlueprintSubEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateBlueprintSubEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateBlueprintSubEntity::operator==(const STemplateBlueprintSubEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateBlueprintSubEntity>)
		return false;

	if (logicalParent != p_Other.logicalParent) return false;
	if (entityTypeResourceIndex != p_Other.entityTypeResourceIndex) return false;
	if (entityId != p_Other.entityId) return false;
	if (editorOnly != p_Other.editorOnly) return false;
	if (entityName != p_Other.entityName) return false;
	if (propertyAliases != p_Other.propertyAliases) return false;
	if (exposedEntities != p_Other.exposedEntities) return false;
	if (exposedInterfaces != p_Other.exposedInterfaces) return false;
	if (entitySubsets != p_Other.entitySubsets) return false;

	return true;
}

void STemplateBlueprintSubEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STemplateBlueprintSubEntity*>(p_Object);
	s_Object->~STemplateBlueprintSubEntity();
}

ZHMTypeInfo STemplateEntityBlueprint::TypeInfo = ZHMTypeInfo("STemplateEntityBlueprint", sizeof(STemplateEntityBlueprint), alignof(STemplateEntityBlueprint), STemplateEntityBlueprint::WriteSimpleJson, STemplateEntityBlueprint::FromSimpleJson, STemplateEntityBlueprint::Serialize, STemplateEntityBlueprint::Equals, STemplateEntityBlueprint::Destroy);

void STemplateEntityBlueprint::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("subType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->subType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->subEntities[i];
		STemplateBlueprintSubEntity::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->subEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneTypeIndicesInResourceHeader") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->externalSceneTypeIndicesInResourceHeader.size(); ++i)
	{
		auto& s_Item0 = s_Object->externalSceneTypeIndicesInResourceHeader[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->externalSceneTypeIndicesInResourceHeader.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("pinConnections") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pinConnections.size(); ++i)
	{
		auto& s_Item0 = s_Object->pinConnections[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pinConnections.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inputPinForwardings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->inputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->inputPinForwardings[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->inputPinForwardings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("outputPinForwardings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->outputPinForwardings.size(); ++i)
	{
		auto& s_Item0 = s_Object->outputPinForwardings[i];
		SEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->outputPinForwardings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("overrideDeletes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->overrideDeletes.size(); ++i)
	{
		auto& s_Item0 = s_Object->overrideDeletes[i];
		SEntityTemplateReference::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->overrideDeletes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("pinConnectionOverrides") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pinConnectionOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->pinConnectionOverrides[i];
		SExternalEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pinConnectionOverrides.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("pinConnectionOverrideDeletes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->pinConnectionOverrideDeletes.size(); ++i)
	{
		auto& s_Item0 = s_Object->pinConnectionOverrideDeletes[i];
		SExternalEntityTemplatePinConnection::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->pinConnectionOverrideDeletes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateEntityBlueprint::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateEntityBlueprint s_Object {};

	s_Object.subType = simdjson::from_json_int32(p_Document["subType"]);

	s_Object.rootEntityIndex = simdjson::from_json_int32(p_Document["rootEntityIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["subEntities"];
	s_Object.subEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STemplateBlueprintSubEntity s_ArrayItem0;
		STemplateBlueprintSubEntity::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.subEntities[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["externalSceneTypeIndicesInResourceHeader"];
	s_Object.externalSceneTypeIndicesInResourceHeader.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.externalSceneTypeIndicesInResourceHeader[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["pinConnections"];
	s_Object.pinConnections.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.pinConnections[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["inputPinForwardings"];
	s_Object.inputPinForwardings.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.inputPinForwardings[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["outputPinForwardings"];
	s_Object.outputPinForwardings.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePinConnection s_ArrayItem0;
		SEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.outputPinForwardings[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["overrideDeletes"];
	s_Object.overrideDeletes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateReference s_ArrayItem0;
		SEntityTemplateReference::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.overrideDeletes[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["pinConnectionOverrides"];
	s_Object.pinConnectionOverrides.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SExternalEntityTemplatePinConnection s_ArrayItem0;
		SExternalEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.pinConnectionOverrides[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["pinConnectionOverrideDeletes"];
	s_Object.pinConnectionOverrideDeletes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SExternalEntityTemplatePinConnection s_ArrayItem0;
		SExternalEntityTemplatePinConnection::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.pinConnectionOverrideDeletes[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STemplateEntityBlueprint*>(p_Target) = s_Object;
}

void STemplateEntityBlueprint::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);

	TArray<STemplateBlueprintSubEntity>::Serialize(&s_Object->subEntities, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, subEntities));
	TArray<int32>::Serialize(&s_Object->externalSceneTypeIndicesInResourceHeader, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, externalSceneTypeIndicesInResourceHeader));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->pinConnections, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, pinConnections));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->inputPinForwardings, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, inputPinForwardings));
	TArray<SEntityTemplatePinConnection>::Serialize(&s_Object->outputPinForwardings, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, outputPinForwardings));
	TArray<SEntityTemplateReference>::Serialize(&s_Object->overrideDeletes, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, overrideDeletes));
	TArray<SExternalEntityTemplatePinConnection>::Serialize(&s_Object->pinConnectionOverrides, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, pinConnectionOverrides));
	TArray<SExternalEntityTemplatePinConnection>::Serialize(&s_Object->pinConnectionOverrideDeletes, p_Serializer, p_OwnOffset + offsetof(STemplateEntityBlueprint, pinConnectionOverrideDeletes));
}

bool STemplateEntityBlueprint::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateEntityBlueprint*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateEntityBlueprint*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateEntityBlueprint::operator==(const STemplateEntityBlueprint& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateEntityBlueprint>)
		return false;

	if (subType != p_Other.subType) return false;
	if (rootEntityIndex != p_Other.rootEntityIndex) return false;
	if (subEntities != p_Other.subEntities) return false;
	if (externalSceneTypeIndicesInResourceHeader != p_Other.externalSceneTypeIndicesInResourceHeader) return false;
	if (pinConnections != p_Other.pinConnections) return false;
	if (inputPinForwardings != p_Other.inputPinForwardings) return false;
	if (outputPinForwardings != p_Other.outputPinForwardings) return false;
	if (overrideDeletes != p_Other.overrideDeletes) return false;
	if (pinConnectionOverrides != p_Other.pinConnectionOverrides) return false;
	if (pinConnectionOverrideDeletes != p_Other.pinConnectionOverrideDeletes) return false;

	return true;
}

void STemplateEntityBlueprint::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STemplateEntityBlueprint*>(p_Object);
	s_Object->~STemplateEntityBlueprint();
}

ZHMTypeInfo STemplateFactorySubEntity::TypeInfo = ZHMTypeInfo("STemplateFactorySubEntity", sizeof(STemplateFactorySubEntity), alignof(STemplateFactorySubEntity), STemplateFactorySubEntity::WriteSimpleJson, STemplateFactorySubEntity::FromSimpleJson, STemplateFactorySubEntity::Serialize, STemplateFactorySubEntity::Equals, STemplateFactorySubEntity::Destroy);

void STemplateFactorySubEntity::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateFactorySubEntity*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("logicalParent") << ":";
	SEntityTemplateReference::WriteSimpleJson(&s_Object->logicalParent, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("entityTypeResourceIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->entityTypeResourceIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("postInitPropertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->postInitPropertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->postInitPropertyValues[i];
		SEntityTemplateProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->postInitPropertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("platformSpecificPropertyValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->platformSpecificPropertyValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->platformSpecificPropertyValues[i];
		SEntityTemplatePlatformSpecificProperty::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->platformSpecificPropertyValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateFactorySubEntity::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateFactorySubEntity s_Object {};

	{
		SEntityTemplateReference s_Item {};
		SEntityTemplateReference::FromSimpleJson(p_Document["logicalParent"], &s_Item);
		s_Object.logicalParent = s_Item;
	}

	s_Object.entityTypeResourceIndex = simdjson::from_json_int32(p_Document["entityTypeResourceIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyValues"];
	s_Object.propertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyValues[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["postInitPropertyValues"];
	s_Object.postInitPropertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplateProperty s_ArrayItem0;
		SEntityTemplateProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.postInitPropertyValues[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["platformSpecificPropertyValues"];
	s_Object.platformSpecificPropertyValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePlatformSpecificProperty s_ArrayItem0;
		SEntityTemplatePlatformSpecificProperty::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.platformSpecificPropertyValues[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STemplateFactorySubEntity*>(p_Target) = s_Object;
}

void STemplateFactorySubEntity::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateFactorySubEntity*>(p_Object);

	SEntityTemplateReference::Serialize(&s_Object->logicalParent, p_Serializer, p_OwnOffset + offsetof(STemplateFactorySubEntity, logicalParent));
	TArray<SEntityTemplateProperty>::Serialize(&s_Object->propertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateFactorySubEntity, propertyValues));
	TArray<SEntityTemplateProperty>::Serialize(&s_Object->postInitPropertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateFactorySubEntity, postInitPropertyValues));
	TArray<SEntityTemplatePlatformSpecificProperty>::Serialize(&s_Object->platformSpecificPropertyValues, p_Serializer, p_OwnOffset + offsetof(STemplateFactorySubEntity, platformSpecificPropertyValues));
}

bool STemplateFactorySubEntity::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateFactorySubEntity*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateFactorySubEntity*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateFactorySubEntity::operator==(const STemplateFactorySubEntity& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateFactorySubEntity>)
		return false;

	if (logicalParent != p_Other.logicalParent) return false;
	if (entityTypeResourceIndex != p_Other.entityTypeResourceIndex) return false;
	if (propertyValues != p_Other.propertyValues) return false;
	if (postInitPropertyValues != p_Other.postInitPropertyValues) return false;
	if (platformSpecificPropertyValues != p_Other.platformSpecificPropertyValues) return false;

	return true;
}

void STemplateFactorySubEntity::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STemplateFactorySubEntity*>(p_Object);
	s_Object->~STemplateFactorySubEntity();
}

ZHMTypeInfo STemplateEntityFactory::TypeInfo = ZHMTypeInfo("STemplateEntityFactory", sizeof(STemplateEntityFactory), alignof(STemplateEntityFactory), STemplateEntityFactory::WriteSimpleJson, STemplateEntityFactory::FromSimpleJson, STemplateEntityFactory::Serialize, STemplateEntityFactory::Equals, STemplateEntityFactory::Destroy);

void STemplateEntityFactory::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STemplateEntityFactory*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("subType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->subType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("blueprintIndexInResourceHeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->blueprintIndexInResourceHeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("rootEntityIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->rootEntityIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("subEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->subEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->subEntities[i];
		STemplateFactorySubEntity::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->subEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("propertyOverrides") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->propertyOverrides.size(); ++i)
	{
		auto& s_Item0 = s_Object->propertyOverrides[i];
		SEntityTemplatePropertyOverride::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->propertyOverrides.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("externalSceneTypeIndicesInResourceHeader") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->externalSceneTypeIndicesInResourceHeader.size(); ++i)
	{
		auto& s_Item0 = s_Object->externalSceneTypeIndicesInResourceHeader[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->externalSceneTypeIndicesInResourceHeader.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STemplateEntityFactory::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STemplateEntityFactory s_Object {};

	s_Object.subType = simdjson::from_json_int32(p_Document["subType"]);

	s_Object.blueprintIndexInResourceHeader = simdjson::from_json_int32(p_Document["blueprintIndexInResourceHeader"]);

	s_Object.rootEntityIndex = simdjson::from_json_int32(p_Document["rootEntityIndex"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["subEntities"];
	s_Object.subEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STemplateFactorySubEntity s_ArrayItem0;
		STemplateFactorySubEntity::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.subEntities[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["propertyOverrides"];
	s_Object.propertyOverrides.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEntityTemplatePropertyOverride s_ArrayItem0;
		SEntityTemplatePropertyOverride::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.propertyOverrides[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["externalSceneTypeIndicesInResourceHeader"];
	s_Object.externalSceneTypeIndicesInResourceHeader.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.externalSceneTypeIndicesInResourceHeader[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<STemplateEntityFactory*>(p_Target) = s_Object;
}

void STemplateEntityFactory::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STemplateEntityFactory*>(p_Object);

	TArray<STemplateFactorySubEntity>::Serialize(&s_Object->subEntities, p_Serializer, p_OwnOffset + offsetof(STemplateEntityFactory, subEntities));
	TArray<SEntityTemplatePropertyOverride>::Serialize(&s_Object->propertyOverrides, p_Serializer, p_OwnOffset + offsetof(STemplateEntityFactory, propertyOverrides));
	TArray<int32>::Serialize(&s_Object->externalSceneTypeIndicesInResourceHeader, p_Serializer, p_OwnOffset + offsetof(STemplateEntityFactory, externalSceneTypeIndicesInResourceHeader));
}

bool STemplateEntityFactory::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STemplateEntityFactory*>(p_Left);
	auto* s_Right = reinterpret_cast<STemplateEntityFactory*>(p_Right);

	return *s_Left == *s_Right;
}

bool STemplateEntityFactory::operator==(const STemplateEntityFactory& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STemplateEntityFactory>)
		return false;

	if (subType != p_Other.subType) return false;
	if (blueprintIndexInResourceHeader != p_Other.blueprintIndexInResourceHeader) return false;
	if (rootEntityIndex != p_Other.rootEntityIndex) return false;
	if (subEntities != p_Other.subEntities) return false;
	if (propertyOverrides != p_Other.propertyOverrides) return false;
	if (externalSceneTypeIndicesInResourceHeader != p_Other.externalSceneTypeIndicesInResourceHeader) return false;

	return true;
}

void STemplateEntityFactory::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STemplateEntityFactory*>(p_Object);
	s_Object->~STemplateEntityFactory();
}

ZHMTypeInfo STestStruct::TypeInfo = ZHMTypeInfo("STestStruct", sizeof(STestStruct), alignof(STestStruct), STestStruct::WriteSimpleJson, STestStruct::FromSimpleJson, STestStruct::Serialize, STestStruct::Equals, STestStruct::Destroy);

void STestStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("stringField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->stringField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->intField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("floatField") << ":";
	p_Stream << simdjson::as_json_string(s_Object->floatField);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("enumField") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("STestStruct.ETestEnum", static_cast<int>(s_Object->enumField)));

	p_Stream << "}";
}

void STestStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STestStruct s_Object {};

	s_Object.stringField = std::string_view(p_Document["stringField"]);

	s_Object.intField = simdjson::from_json_uint32(p_Document["intField"]);

	s_Object.floatField = simdjson::from_json_float32(p_Document["floatField"]);

	s_Object.enumField = static_cast<STestStruct_ETestEnum>(ZHMEnums::GetEnumValueByName("STestStruct.ETestEnum", std::string_view(p_Document["enumField"])));

	*reinterpret_cast<STestStruct*>(p_Target) = s_Object;
}

void STestStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);

	ZString::Serialize(&s_Object->stringField, p_Serializer, p_OwnOffset + offsetof(STestStruct, stringField));
}

bool STestStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStruct::operator==(const STestStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStruct>)
		return false;

	if (stringField != p_Other.stringField) return false;
	if (intField != p_Other.intField) return false;
	if (floatField != p_Other.floatField) return false;
	if (enumField != p_Other.enumField) return false;

	return true;
}

void STestStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STestStruct*>(p_Object);
	s_Object->~STestStruct();
}

ZHMTypeInfo STestStruct2::TypeInfo = ZHMTypeInfo("STestStruct2", sizeof(STestStruct2), alignof(STestStruct2), STestStruct2::WriteSimpleJson, STestStruct2::FromSimpleJson, STestStruct2::Serialize, STestStruct2::Equals, STestStruct2::Destroy);

void STestStruct2::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("arrayField") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->arrayField.size(); ++i)
	{
		auto& s_Item0 = s_Object->arrayField[i];
		STestStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->arrayField.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("variantField") << ":";
	ZVariant::WriteSimpleJson(&s_Object->variantField, p_Stream);

	p_Stream << "}";
}

void STestStruct2::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STestStruct2 s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["arrayField"];
	s_Object.arrayField.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STestStruct s_ArrayItem0;
		STestStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.arrayField[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["variantField"], &s_Item);
		s_Object.variantField = s_Item;
	}

	*reinterpret_cast<STestStruct2*>(p_Target) = s_Object;
}

void STestStruct2::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);

	TArray<STestStruct>::Serialize(&s_Object->arrayField, p_Serializer, p_OwnOffset + offsetof(STestStruct2, arrayField));
	ZVariant::Serialize(&s_Object->variantField, p_Serializer, p_OwnOffset + offsetof(STestStruct2, variantField));
}

bool STestStruct2::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STestStruct2*>(p_Left);
	auto* s_Right = reinterpret_cast<STestStruct2*>(p_Right);

	return *s_Left == *s_Right;
}

bool STestStruct2::operator==(const STestStruct2& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STestStruct2>)
		return false;

	if (arrayField != p_Other.arrayField) return false;
	if (variantField != p_Other.variantField) return false;

	return true;
}

void STestStruct2::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STestStruct2*>(p_Object);
	s_Object->~STestStruct2();
}

ZHMTypeInfo STimerEntitySaveData::TypeInfo = ZHMTypeInfo("STimerEntitySaveData", sizeof(STimerEntitySaveData), alignof(STimerEntitySaveData), STimerEntitySaveData::WriteSimpleJson, STimerEntitySaveData::FromSimpleJson, STimerEntitySaveData::Serialize, STimerEntitySaveData::Equals, STimerEntitySaveData::Destroy);

void STimerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nInterval") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nInterval);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeToNextEvent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeToNextEvent);

	p_Stream << "}";
}

void STimerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerEntitySaveData s_Object {};

	s_Object.m_nInterval = simdjson::from_json_int32(p_Document["m_nInterval"]);

	s_Object.m_bEnabled = simdjson::from_json_bool(p_Document["m_bEnabled"]);

	s_Object.m_fTimeToNextEvent = simdjson::from_json_float32(p_Document["m_fTimeToNextEvent"]);

	*reinterpret_cast<STimerEntitySaveData*>(p_Target) = s_Object;
}

void STimerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);

}

bool STimerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntitySaveData::operator==(const STimerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntitySaveData>)
		return false;

	if (m_nInterval != p_Other.m_nInterval) return false;
	if (m_bEnabled != p_Other.m_bEnabled) return false;
	if (m_fTimeToNextEvent != p_Other.m_fTimeToNextEvent) return false;

	return true;
}

void STimerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerEntitySaveData*>(p_Object);
	s_Object->~STimerEntitySaveData();
}

ZHMTypeInfo STimerEntitiesSaveData::TypeInfo = ZHMTypeInfo("STimerEntitiesSaveData", sizeof(STimerEntitiesSaveData), alignof(STimerEntitiesSaveData), STimerEntitiesSaveData::WriteSimpleJson, STimerEntitiesSaveData::FromSimpleJson, STimerEntitiesSaveData::Serialize, STimerEntitiesSaveData::Equals, STimerEntitiesSaveData::Destroy);

void STimerEntitiesSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		STimerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STimerEntitiesSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerEntitiesSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STimerEntitySaveData s_ArrayItem0;
		STimerEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STimerEntitiesSaveData*>(p_Target) = s_Object;
}

void STimerEntitiesSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(STimerEntitiesSaveData, m_aEntities));
	TArray<STimerEntitySaveData>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(STimerEntitiesSaveData, m_aData));
}

bool STimerEntitiesSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerEntitiesSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerEntitiesSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerEntitiesSaveData::operator==(const STimerEntitiesSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerEntitiesSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void STimerEntitiesSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerEntitiesSaveData*>(p_Object);
	s_Object->~STimerEntitiesSaveData();
}

ZHMTypeInfo STimerManagerSaveData::TypeInfo = ZHMTypeInfo("STimerManagerSaveData", sizeof(STimerManagerSaveData), alignof(STimerManagerSaveData), STimerManagerSaveData::WriteSimpleJson, STimerManagerSaveData::FromSimpleJson, STimerManagerSaveData::Serialize, STimerManagerSaveData::Equals, STimerManagerSaveData::Destroy);

void STimerManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_TimersData") << ":";
	STimerEntitiesSaveData::WriteSimpleJson(&s_Object->m_TimersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_RandomTimersData") << ":";
	SRandomTimerEntitiesSaveData::WriteSimpleJson(&s_Object->m_RandomTimersData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_GameTimersData") << ":";
	SGameTimersSaveData::WriteSimpleJson(&s_Object->m_GameTimersData, p_Stream);

	p_Stream << "}";
}

void STimerManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STimerManagerSaveData s_Object {};

	{
		STimerEntitiesSaveData s_Item {};
		STimerEntitiesSaveData::FromSimpleJson(p_Document["m_TimersData"], &s_Item);
		s_Object.m_TimersData = s_Item;
	}

	{
		SRandomTimerEntitiesSaveData s_Item {};
		SRandomTimerEntitiesSaveData::FromSimpleJson(p_Document["m_RandomTimersData"], &s_Item);
		s_Object.m_RandomTimersData = s_Item;
	}

	{
		SGameTimersSaveData s_Item {};
		SGameTimersSaveData::FromSimpleJson(p_Document["m_GameTimersData"], &s_Item);
		s_Object.m_GameTimersData = s_Item;
	}

	*reinterpret_cast<STimerManagerSaveData*>(p_Target) = s_Object;
}

void STimerManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);

	STimerEntitiesSaveData::Serialize(&s_Object->m_TimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_TimersData));
	SRandomTimerEntitiesSaveData::Serialize(&s_Object->m_RandomTimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_RandomTimersData));
	SGameTimersSaveData::Serialize(&s_Object->m_GameTimersData, p_Serializer, p_OwnOffset + offsetof(STimerManagerSaveData, m_GameTimersData));
}

bool STimerManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STimerManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STimerManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STimerManagerSaveData::operator==(const STimerManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STimerManagerSaveData>)
		return false;

	if (m_TimersData != p_Other.m_TimersData) return false;
	if (m_RandomTimersData != p_Other.m_RandomTimersData) return false;
	if (m_GameTimersData != p_Other.m_GameTimersData) return false;

	return true;
}

void STimerManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STimerManagerSaveData*>(p_Object);
	s_Object->~STimerManagerSaveData();
}

ZHMTypeInfo STokenID::TypeInfo = ZHMTypeInfo("STokenID", sizeof(STokenID), alignof(STokenID), STokenID::WriteSimpleJson, STokenID::FromSimpleJson, STokenID::Serialize, STokenID::Equals, STokenID::Destroy);

void STokenID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_iValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_iValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bValid") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValid);

	p_Stream << "}";
}

void STokenID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STokenID s_Object {};

	s_Object.m_iValue = simdjson::from_json_uint32(p_Document["m_iValue"]);

	s_Object.m_bValid = simdjson::from_json_bool(p_Document["m_bValid"]);

	*reinterpret_cast<STokenID*>(p_Target) = s_Object;
}

void STokenID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);

}

bool STokenID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STokenID*>(p_Left);
	auto* s_Right = reinterpret_cast<STokenID*>(p_Right);

	return *s_Left == *s_Right;
}

bool STokenID::operator==(const STokenID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STokenID>)
		return false;

	if (m_iValue != p_Other.m_iValue) return false;
	if (m_bValid != p_Other.m_bValid) return false;

	return true;
}

void STokenID::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STokenID*>(p_Object);
	s_Object->~STokenID();
}

ZHMTypeInfo STrackDollyControllerSaveData::TypeInfo = ZHMTypeInfo("STrackDollyControllerSaveData", sizeof(STrackDollyControllerSaveData), alignof(STrackDollyControllerSaveData), STrackDollyControllerSaveData::WriteSimpleJson, STrackDollyControllerSaveData::FromSimpleJson, STrackDollyControllerSaveData::Serialize, STrackDollyControllerSaveData::Equals, STrackDollyControllerSaveData::Destroy);

void STrackDollyControllerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTrackEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTrackEntity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTrackPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTrackPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsDollyAttached") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsDollyAttached);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDollyPosition") << ":";
	SVector3::WriteSimpleJson(&s_Object->m_vDollyPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vDollyRotation") << ":";
	SVector4::WriteSimpleJson(&s_Object->m_vDollyRotation, p_Stream);

	p_Stream << "}";
}

void STrackDollyControllerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrackDollyControllerSaveData s_Object {};

	s_Object.m_rTrackEntity = simdjson::from_json_uint32(p_Document["m_rTrackEntity"]);

	s_Object.m_fTrackPosition = simdjson::from_json_float32(p_Document["m_fTrackPosition"]);

	s_Object.m_bIsDollyAttached = simdjson::from_json_bool(p_Document["m_bIsDollyAttached"]);

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["m_vDollyPosition"], &s_Item);
		s_Object.m_vDollyPosition = s_Item;
	}

	{
		SVector4 s_Item {};
		SVector4::FromSimpleJson(p_Document["m_vDollyRotation"], &s_Item);
		s_Object.m_vDollyRotation = s_Item;
	}

	*reinterpret_cast<STrackDollyControllerSaveData*>(p_Target) = s_Object;
}

void STrackDollyControllerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);

	SVector3::Serialize(&s_Object->m_vDollyPosition, p_Serializer, p_OwnOffset + offsetof(STrackDollyControllerSaveData, m_vDollyPosition));
	SVector4::Serialize(&s_Object->m_vDollyRotation, p_Serializer, p_OwnOffset + offsetof(STrackDollyControllerSaveData, m_vDollyRotation));
}

bool STrackDollyControllerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackDollyControllerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackDollyControllerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackDollyControllerSaveData::operator==(const STrackDollyControllerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackDollyControllerSaveData>)
		return false;

	if (m_rTrackEntity != p_Other.m_rTrackEntity) return false;
	if (m_fTrackPosition != p_Other.m_fTrackPosition) return false;
	if (m_bIsDollyAttached != p_Other.m_bIsDollyAttached) return false;
	if (m_vDollyPosition != p_Other.m_vDollyPosition) return false;
	if (m_vDollyRotation != p_Other.m_vDollyRotation) return false;

	return true;
}

void STrackDollyControllerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrackDollyControllerSaveData*>(p_Object);
	s_Object->~STrackDollyControllerSaveData();
}

ZHMTypeInfo STrackerEntitySaveData::TypeInfo = ZHMTypeInfo("STrackerEntitySaveData", sizeof(STrackerEntitySaveData), alignof(STrackerEntitySaveData), STrackerEntitySaveData::WriteSimpleJson, STrackerEntitySaveData::FromSimpleJson, STrackerEntitySaveData::Serialize, STrackerEntitySaveData::Equals, STrackerEntitySaveData::Destroy);

void STrackerEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTracker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTracker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bSpatialVisibility") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSpatialVisibility);

	p_Stream << "}";
}

void STrackerEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrackerEntitySaveData s_Object {};

	s_Object.m_rTracker = simdjson::from_json_uint32(p_Document["m_rTracker"]);

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	s_Object.m_bIsEnabled = simdjson::from_json_bool(p_Document["m_bIsEnabled"]);

	s_Object.m_bSpatialVisibility = simdjson::from_json_bool(p_Document["m_bSpatialVisibility"]);

	*reinterpret_cast<STrackerEntitySaveData*>(p_Target) = s_Object;
}

void STrackerEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);

}

bool STrackerEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackerEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackerEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackerEntitySaveData::operator==(const STrackerEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackerEntitySaveData>)
		return false;

	if (m_rTracker != p_Other.m_rTracker) return false;
	if (m_bIsVisible != p_Other.m_bIsVisible) return false;
	if (m_bIsEnabled != p_Other.m_bIsEnabled) return false;
	if (m_bSpatialVisibility != p_Other.m_bSpatialVisibility) return false;

	return true;
}

void STrackerEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrackerEntitySaveData*>(p_Object);
	s_Object->~STrackerEntitySaveData();
}

ZHMTypeInfo STrackerManagerSaveData::TypeInfo = ZHMTypeInfo("STrackerManagerSaveData", sizeof(STrackerManagerSaveData), alignof(STrackerManagerSaveData), STrackerManagerSaveData::WriteSimpleJson, STrackerManagerSaveData::FromSimpleJson, STrackerManagerSaveData::Serialize, STrackerManagerSaveData::Equals, STrackerManagerSaveData::Destroy);

void STrackerManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aTrackerData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aTrackerData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aTrackerData[i];
		STrackerEntitySaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aTrackerData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrackerManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrackerManagerSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aTrackerData"];
	s_Object.m_aTrackerData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		STrackerEntitySaveData s_ArrayItem0;
		STrackerEntitySaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aTrackerData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<STrackerManagerSaveData*>(p_Target) = s_Object;
}

void STrackerManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);

	TArray<STrackerEntitySaveData>::Serialize(&s_Object->m_aTrackerData, p_Serializer, p_OwnOffset + offsetof(STrackerManagerSaveData, m_aTrackerData));
}

bool STrackerManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrackerManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrackerManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrackerManagerSaveData::operator==(const STrackerManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrackerManagerSaveData>)
		return false;

	if (m_aTrackerData != p_Other.m_aTrackerData) return false;

	return true;
}

void STrackerManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrackerManagerSaveData*>(p_Object);
	s_Object->~STrackerManagerSaveData();
}

ZHMTypeInfo STrajectoryTrackSaveData::TypeInfo = ZHMTypeInfo("STrajectoryTrackSaveData", sizeof(STrajectoryTrackSaveData), alignof(STrajectoryTrackSaveData), STrajectoryTrackSaveData::WriteSimpleJson, STrajectoryTrackSaveData::FromSimpleJson, STrajectoryTrackSaveData::Serialize, STrajectoryTrackSaveData::Equals, STrajectoryTrackSaveData::Destroy);

void STrajectoryTrackSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vOriginalEntityTransform") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_vOriginalEntityTransform, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTargetStartTransform") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_vTargetStartTransform, p_Stream);

	p_Stream << "}";
}

void STrajectoryTrackSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrajectoryTrackSaveData s_Object {};

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_vOriginalEntityTransform"], &s_Item);
		s_Object.m_vOriginalEntityTransform = s_Item;
	}

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_vTargetStartTransform"], &s_Item);
		s_Object.m_vTargetStartTransform = s_Item;
	}

	*reinterpret_cast<STrajectoryTrackSaveData*>(p_Target) = s_Object;
}

void STrajectoryTrackSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);

	SMatrix::Serialize(&s_Object->m_vOriginalEntityTransform, p_Serializer, p_OwnOffset + offsetof(STrajectoryTrackSaveData, m_vOriginalEntityTransform));
	SMatrix::Serialize(&s_Object->m_vTargetStartTransform, p_Serializer, p_OwnOffset + offsetof(STrajectoryTrackSaveData, m_vTargetStartTransform));
}

bool STrajectoryTrackSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrajectoryTrackSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrajectoryTrackSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrajectoryTrackSaveData::operator==(const STrajectoryTrackSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrajectoryTrackSaveData>)
		return false;

	if (m_vOriginalEntityTransform != p_Other.m_vOriginalEntityTransform) return false;
	if (m_vTargetStartTransform != p_Other.m_vTargetStartTransform) return false;

	return true;
}

void STrajectoryTrackSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrajectoryTrackSaveData*>(p_Object);
	s_Object->~STrajectoryTrackSaveData();
}

ZHMTypeInfo STrespassingRuleEntitySaveData::TypeInfo = ZHMTypeInfo("STrespassingRuleEntitySaveData", sizeof(STrespassingRuleEntitySaveData), alignof(STrespassingRuleEntitySaveData), STrespassingRuleEntitySaveData::WriteSimpleJson, STrespassingRuleEntitySaveData::FromSimpleJson, STrespassingRuleEntitySaveData::Serialize, STrespassingRuleEntitySaveData::Equals, STrespassingRuleEntitySaveData::Destroy);

void STrespassingRuleEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAllowedProfessionsDisabled") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAllowedProfessionsDisabled.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAllowedProfessionsDisabled[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAllowedProfessionsDisabled.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void STrespassingRuleEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STrespassingRuleEntitySaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAllowedProfessionsDisabled"];
	s_Object.m_aAllowedProfessionsDisabled.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aAllowedProfessionsDisabled[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	*reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Target) = s_Object;
}

void STrespassingRuleEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);

	TArray<bool>::Serialize(&s_Object->m_aAllowedProfessionsDisabled, p_Serializer, p_OwnOffset + offsetof(STrespassingRuleEntitySaveData, m_aAllowedProfessionsDisabled));
}

bool STrespassingRuleEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STrespassingRuleEntitySaveData::operator==(const STrespassingRuleEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STrespassingRuleEntitySaveData>)
		return false;

	if (m_aAllowedProfessionsDisabled != p_Other.m_aAllowedProfessionsDisabled) return false;

	return true;
}

void STrespassingRuleEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STrespassingRuleEntitySaveData*>(p_Object);
	s_Object->~STrespassingRuleEntitySaveData();
}

ZHMTypeInfo STriggerAlarmGroupSaveData::TypeInfo = ZHMTypeInfo("STriggerAlarmGroupSaveData", sizeof(STriggerAlarmGroupSaveData), alignof(STriggerAlarmGroupSaveData), STriggerAlarmGroupSaveData::WriteSimpleJson, STriggerAlarmGroupSaveData::FromSimpleJson, STriggerAlarmGroupSaveData::Serialize, STriggerAlarmGroupSaveData::Equals, STriggerAlarmGroupSaveData::Destroy);

void STriggerAlarmGroupSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rAlarm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fsmState") << ":";
	SFSMSaveData::WriteSimpleJson(&s_Object->m_fsmState, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggeredAlarm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggeredAlarm);

	p_Stream << "}";
}

void STriggerAlarmGroupSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	STriggerAlarmGroupSaveData s_Object {};

	s_Object.m_rTarget = simdjson::from_json_uint32(p_Document["m_rTarget"]);

	s_Object.m_rAlarm = simdjson::from_json_uint32(p_Document["m_rAlarm"]);

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	{
		SFSMSaveData s_Item {};
		SFSMSaveData::FromSimpleJson(p_Document["m_fsmState"], &s_Item);
		s_Object.m_fsmState = s_Item;
	}

	s_Object.m_bTriggeredAlarm = simdjson::from_json_bool(p_Document["m_bTriggeredAlarm"]);

	*reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Target) = s_Object;
}

void STriggerAlarmGroupSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);

	SFSMSaveData::Serialize(&s_Object->m_fsmState, p_Serializer, p_OwnOffset + offsetof(STriggerAlarmGroupSaveData, m_fsmState));
}

bool STriggerAlarmGroupSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool STriggerAlarmGroupSaveData::operator==(const STriggerAlarmGroupSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<STriggerAlarmGroupSaveData>)
		return false;

	if (m_rTarget != p_Other.m_rTarget) return false;
	if (m_rAlarm != p_Other.m_rAlarm) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_fsmState != p_Other.m_fsmState) return false;
	if (m_bTriggeredAlarm != p_Other.m_bTriggeredAlarm) return false;

	return true;
}

void STriggerAlarmGroupSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<STriggerAlarmGroupSaveData*>(p_Object);
	s_Object->~STriggerAlarmGroupSaveData();
}

ZHMTypeInfo SUIBreadcrumbDataSaveData::TypeInfo = ZHMTypeInfo("SUIBreadcrumbDataSaveData", sizeof(SUIBreadcrumbDataSaveData), alignof(SUIBreadcrumbDataSaveData), SUIBreadcrumbDataSaveData::WriteSimpleJson, SUIBreadcrumbDataSaveData::FromSimpleJson, SUIBreadcrumbDataSaveData::Serialize, SUIBreadcrumbDataSaveData::Equals, SUIBreadcrumbDataSaveData::Destroy);

void SUIBreadcrumbDataSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIBreadcrumbDataSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fProgress") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fProgress);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nState);

	p_Stream << "}";
}

void SUIBreadcrumbDataSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIBreadcrumbDataSaveData s_Object {};

	s_Object.m_fProgress = simdjson::from_json_float32(p_Document["m_fProgress"]);

	s_Object.m_nState = simdjson::from_json_int32(p_Document["m_nState"]);

	*reinterpret_cast<SUIBreadcrumbDataSaveData*>(p_Target) = s_Object;
}

void SUIBreadcrumbDataSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIBreadcrumbDataSaveData*>(p_Object);

}

bool SUIBreadcrumbDataSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIBreadcrumbDataSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIBreadcrumbDataSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIBreadcrumbDataSaveData::operator==(const SUIBreadcrumbDataSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIBreadcrumbDataSaveData>)
		return false;

	if (m_fProgress != p_Other.m_fProgress) return false;
	if (m_nState != p_Other.m_nState) return false;

	return true;
}

void SUIBreadcrumbDataSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUIBreadcrumbDataSaveData*>(p_Object);
	s_Object->~SUIBreadcrumbDataSaveData();
}

ZHMTypeInfo SUIGridCellPosition::TypeInfo = ZHMTypeInfo("SUIGridCellPosition", sizeof(SUIGridCellPosition), alignof(SUIGridCellPosition), SUIGridCellPosition::WriteSimpleJson, SUIGridCellPosition::FromSimpleJson, SUIGridCellPosition::Serialize, SUIGridCellPosition::Equals, SUIGridCellPosition::Destroy);

void SUIGridCellPosition::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nColumnIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColumnIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nRowIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nRowIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nColumnSpan") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nColumnSpan);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nRowSpan") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nRowSpan);

	p_Stream << "}";
}

void SUIGridCellPosition::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIGridCellPosition s_Object {};

	s_Object.nColumnIndex = simdjson::from_json_int32(p_Document["nColumnIndex"]);

	s_Object.nRowIndex = simdjson::from_json_int32(p_Document["nRowIndex"]);

	s_Object.nColumnSpan = simdjson::from_json_int32(p_Document["nColumnSpan"]);

	s_Object.nRowSpan = simdjson::from_json_int32(p_Document["nRowSpan"]);

	*reinterpret_cast<SUIGridCellPosition*>(p_Target) = s_Object;
}

void SUIGridCellPosition::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);

}

bool SUIGridCellPosition::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIGridCellPosition*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIGridCellPosition*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIGridCellPosition::operator==(const SUIGridCellPosition& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIGridCellPosition>)
		return false;

	if (nColumnIndex != p_Other.nColumnIndex) return false;
	if (nRowIndex != p_Other.nRowIndex) return false;
	if (nColumnSpan != p_Other.nColumnSpan) return false;
	if (nRowSpan != p_Other.nRowSpan) return false;

	return true;
}

void SUIGridCellPosition::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUIGridCellPosition*>(p_Object);
	s_Object->~SUIGridCellPosition();
}

ZHMTypeInfo SUIOpenVRComponent::TypeInfo = ZHMTypeInfo("SUIOpenVRComponent", sizeof(SUIOpenVRComponent), alignof(SUIOpenVRComponent), SUIOpenVRComponent::WriteSimpleJson, SUIOpenVRComponent::FromSimpleJson, SUIOpenVRComponent::Serialize, SUIOpenVRComponent::Equals, SUIOpenVRComponent::Destroy);

void SUIOpenVRComponent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOpenVRComponent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("idArchetype") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EUIOpenVRComponentArchetypeID", static_cast<int>(s_Object->idArchetype)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("direction") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EUIOpenVRPressDirection", static_cast<int>(s_Object->direction)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);

	p_Stream << "}";
}

void SUIOpenVRComponent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIOpenVRComponent s_Object {};

	s_Object.idArchetype = static_cast<EUIOpenVRComponentArchetypeID>(ZHMEnums::GetEnumValueByName("EUIOpenVRComponentArchetypeID", std::string_view(p_Document["idArchetype"])));

	s_Object.direction = static_cast<EUIOpenVRPressDirection>(ZHMEnums::GetEnumValueByName("EUIOpenVRPressDirection", std::string_view(p_Document["direction"])));

	s_Object.label = std::string_view(p_Document["label"]);

	*reinterpret_cast<SUIOpenVRComponent*>(p_Target) = s_Object;
}

void SUIOpenVRComponent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIOpenVRComponent*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(SUIOpenVRComponent, label));
}

bool SUIOpenVRComponent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIOpenVRComponent*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIOpenVRComponent*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIOpenVRComponent::operator==(const SUIOpenVRComponent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIOpenVRComponent>)
		return false;

	if (idArchetype != p_Other.idArchetype) return false;
	if (direction != p_Other.direction) return false;
	if (label != p_Other.label) return false;

	return true;
}

void SUIOpenVRComponent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUIOpenVRComponent*>(p_Object);
	s_Object->~SUIOpenVRComponent();
}

ZHMTypeInfo SUIOpenVRButtonConversion::TypeInfo = ZHMTypeInfo("SUIOpenVRButtonConversion", sizeof(SUIOpenVRButtonConversion), alignof(SUIOpenVRButtonConversion), SUIOpenVRButtonConversion::WriteSimpleJson, SUIOpenVRButtonConversion::FromSimpleJson, SUIOpenVRButtonConversion::Serialize, SUIOpenVRButtonConversion::Equals, SUIOpenVRButtonConversion::Destroy);

void SUIOpenVRButtonConversion::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOpenVRButtonConversion*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("idSource") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EUIGamepadButtonID", static_cast<int>(s_Object->idSource)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("component") << ":";
	SUIOpenVRComponent::WriteSimpleJson(&s_Object->component, p_Stream);

	p_Stream << "}";
}

void SUIOpenVRButtonConversion::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIOpenVRButtonConversion s_Object {};

	s_Object.idSource = static_cast<EUIGamepadButtonID>(ZHMEnums::GetEnumValueByName("EUIGamepadButtonID", std::string_view(p_Document["idSource"])));

	{
		SUIOpenVRComponent s_Item {};
		SUIOpenVRComponent::FromSimpleJson(p_Document["component"], &s_Item);
		s_Object.component = s_Item;
	}

	*reinterpret_cast<SUIOpenVRButtonConversion*>(p_Target) = s_Object;
}

void SUIOpenVRButtonConversion::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIOpenVRButtonConversion*>(p_Object);

	SUIOpenVRComponent::Serialize(&s_Object->component, p_Serializer, p_OwnOffset + offsetof(SUIOpenVRButtonConversion, component));
}

bool SUIOpenVRButtonConversion::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIOpenVRButtonConversion*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIOpenVRButtonConversion*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIOpenVRButtonConversion::operator==(const SUIOpenVRButtonConversion& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIOpenVRButtonConversion>)
		return false;

	if (idSource != p_Other.idSource) return false;
	if (component != p_Other.component) return false;

	return true;
}

void SUIOpenVRButtonConversion::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUIOpenVRButtonConversion*>(p_Object);
	s_Object->~SUIOpenVRButtonConversion();
}

ZHMTypeInfo SUIOptionsSaveData::TypeInfo = ZHMTypeInfo("SUIOptionsSaveData", sizeof(SUIOptionsSaveData), alignof(SUIOptionsSaveData), SUIOptionsSaveData::WriteSimpleJson, SUIOptionsSaveData::FromSimpleJson, SUIOptionsSaveData::Serialize, SUIOptionsSaveData::Equals, SUIOptionsSaveData::Destroy);

void SUIOptionsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aKeys") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aKeys.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aKeys[i];
		p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("_EUIOptionKey", static_cast<int>(s_Item0)));

		if (i < s_Object->m_aKeys.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aValues") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aValues.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aValues[i];
		SOptionValueSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aValues.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mappings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mappings.size(); ++i)
	{
		auto& s_Item0 = s_Object->mappings[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->mappings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("cbMappingNames") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->cbMappingNames.size(); ++i)
	{
		auto& s_Item0 = s_Object->cbMappingNames[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->cbMappingNames.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("cbMappings") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->cbMappings.size(); ++i)
	{
		auto& s_Item0 = s_Object->cbMappings[i];
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			SComboDeviceBinding::WriteSimpleJson(&s_Item1, p_Stream);

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}

		p_Stream << "]";

		if (i < s_Object->cbMappings.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUIOptionsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUIOptionsSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aKeys"];
	s_Object.m_aKeys.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aKeys[s_Index0++] = static_cast<_EUIOptionKey>(ZHMEnums::GetEnumValueByName("_EUIOptionKey", std::string_view(s_Item0)));
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aValues"];
	s_Object.m_aValues.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SOptionValueSaveData s_ArrayItem0;
		SOptionValueSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aValues[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["mappings"];
	s_Object.mappings.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.mappings[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["cbMappingNames"];
	s_Object.cbMappingNames.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.cbMappingNames[s_Index0++] = std::string_view(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["cbMappings"];
	s_Object.cbMappings.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TArray<SComboDeviceBinding> s_ArrayItem0;
		{
		simdjson::ondemand::array s_Array1 = s_Item0;
		s_ArrayItem0.resize(s_Array1.count_elements());
		size_t s_Index1 = 0;

		for (simdjson::ondemand::value s_Item1 : s_Array1)
		{
			SComboDeviceBinding s_ArrayItem1;
			SComboDeviceBinding::FromSimpleJson(s_Item1, &s_ArrayItem1);
			s_ArrayItem0[s_Index1++] = s_ArrayItem1;
		}
		}
		s_Object.cbMappings[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SUIOptionsSaveData*>(p_Target) = s_Object;
}

void SUIOptionsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);

	TArray<_EUIOptionKey>::Serialize(&s_Object->m_aKeys, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, m_aKeys));
	TArray<SOptionValueSaveData>::Serialize(&s_Object->m_aValues, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, m_aValues));
	TArray<uint32>::Serialize(&s_Object->mappings, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, mappings));
	TArray<ZString>::Serialize(&s_Object->cbMappingNames, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, cbMappingNames));
	TArray<TArray<SComboDeviceBinding>>::Serialize(&s_Object->cbMappings, p_Serializer, p_OwnOffset + offsetof(SUIOptionsSaveData, cbMappings));
}

bool SUIOptionsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUIOptionsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SUIOptionsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUIOptionsSaveData::operator==(const SUIOptionsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUIOptionsSaveData>)
		return false;

	if (m_aKeys != p_Other.m_aKeys) return false;
	if (m_aValues != p_Other.m_aValues) return false;
	if (mappings != p_Other.mappings) return false;
	if (cbMappingNames != p_Other.cbMappingNames) return false;
	if (cbMappings != p_Other.cbMappings) return false;

	return true;
}

void SUIOptionsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUIOptionsSaveData*>(p_Object);
	s_Object->~SUIOptionsSaveData();
}

ZHMTypeInfo SUITestData_SSubSubStruct::TypeInfo = ZHMTypeInfo("SUITestData.SSubSubStruct", sizeof(SUITestData_SSubSubStruct), alignof(SUITestData_SSubSubStruct), SUITestData_SSubSubStruct::WriteSimpleJson, SUITestData_SSubSubStruct::FromSimpleJson, SUITestData_SSubSubStruct::Serialize, SUITestData_SSubSubStruct::Equals, SUITestData_SSubSubStruct::Destroy);

void SUITestData_SSubSubStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sDeepString") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sDeepString);

	p_Stream << "}";
}

void SUITestData_SSubSubStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUITestData_SSubSubStruct s_Object {};

	s_Object.sDeepString = std::string_view(p_Document["sDeepString"]);

	*reinterpret_cast<SUITestData_SSubSubStruct*>(p_Target) = s_Object;
}

void SUITestData_SSubSubStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Object);

	ZString::Serialize(&s_Object->sDeepString, p_Serializer, p_OwnOffset + offsetof(SUITestData_SSubSubStruct, sDeepString));
}

bool SUITestData_SSubSubStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData_SSubSubStruct::operator==(const SUITestData_SSubSubStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData_SSubSubStruct>)
		return false;

	if (sDeepString != p_Other.sDeepString) return false;

	return true;
}

void SUITestData_SSubSubStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubSubStruct*>(p_Object);
	s_Object->~SUITestData_SSubSubStruct();
}

ZHMTypeInfo SUITestData_SSubStruct::TypeInfo = ZHMTypeInfo("SUITestData.SSubStruct", sizeof(SUITestData_SSubStruct), alignof(SUITestData_SSubStruct), SUITestData_SSubStruct::WriteSimpleJson, SUITestData_SSubStruct::FromSimpleJson, SUITestData_SSubStruct::Serialize, SUITestData_SSubStruct::Equals, SUITestData_SSubStruct::Destroy);

void SUITestData_SSubStruct::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubStruct*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("aSubSubStructs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSubSubStructs.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSubSubStructs[i];
		SUITestData_SSubSubStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aSubSubStructs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUITestData_SSubStruct::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUITestData_SSubStruct s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["aSubSubStructs"];
	s_Object.aSubSubStructs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SUITestData_SSubSubStruct s_ArrayItem0;
		SUITestData_SSubSubStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aSubSubStructs[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SUITestData_SSubStruct*>(p_Target) = s_Object;
}

void SUITestData_SSubStruct::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubStruct*>(p_Object);

	TArray<SUITestData_SSubSubStruct>::Serialize(&s_Object->aSubSubStructs, p_Serializer, p_OwnOffset + offsetof(SUITestData_SSubStruct, aSubSubStructs));
}

bool SUITestData_SSubStruct::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData_SSubStruct*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData_SSubStruct*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData_SSubStruct::operator==(const SUITestData_SSubStruct& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData_SSubStruct>)
		return false;

	if (aSubSubStructs != p_Other.aSubSubStructs) return false;

	return true;
}

void SUITestData_SSubStruct::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUITestData_SSubStruct*>(p_Object);
	s_Object->~SUITestData_SSubStruct();
}

ZHMTypeInfo SUITestData::TypeInfo = ZHMTypeInfo("SUITestData", sizeof(SUITestData), alignof(SUITestData), SUITestData::WriteSimpleJson, SUITestData::FromSimpleJson, SUITestData::Serialize, SUITestData::Equals, SUITestData::Destroy);

void SUITestData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("nIntProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nIntProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fInt16Prop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fInt16Prop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fUInt32Prop") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fUInt32Prop);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fFloatProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fFloatProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sStringProp") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sStringProp);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("eEnumProp") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("SUITestData.ETestEnum", static_cast<int>(s_Object->eEnumProp)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ridProp") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->ridProp, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aStringArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aStringArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aStringArray[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aStringArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aSubStructArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aSubStructArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aSubStructArray[i];
		SUITestData_SSubStruct::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aSubStructArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aFixedArray") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aFixedArray.size(); ++i)
	{
		auto& s_Item0 = s_Object->aFixedArray[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aFixedArray.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SUITestData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SUITestData s_Object {};

	s_Object.nIntProp = simdjson::from_json_int32(p_Document["nIntProp"]);

	s_Object.fInt16Prop = simdjson::from_json_int16(p_Document["fInt16Prop"]);

	s_Object.fUInt32Prop = simdjson::from_json_uint32(p_Document["fUInt32Prop"]);

	s_Object.fFloatProp = simdjson::from_json_float32(p_Document["fFloatProp"]);

	s_Object.sStringProp = std::string_view(p_Document["sStringProp"]);

	s_Object.eEnumProp = static_cast<SUITestData_ETestEnum>(ZHMEnums::GetEnumValueByName("SUITestData.ETestEnum", std::string_view(p_Document["eEnumProp"])));

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["ridProp"], &s_Item);
		s_Object.ridProp = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aStringArray"];
	s_Object.aStringArray.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.aStringArray[s_Index0++] = std::string_view(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aSubStructArray"];
	s_Object.aSubStructArray.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SUITestData_SSubStruct s_ArrayItem0;
		SUITestData_SSubStruct::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aSubStructArray[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	size_t s_Index0 = 0;
	for (simdjson::ondemand::value s_Item0 : p_Document["aFixedArray"])
	{
		s_Object.aFixedArray[s_Index0] = simdjson::from_json_int32(s_Item0);
		++s_Index0;
	}
	}

	*reinterpret_cast<SUITestData*>(p_Target) = s_Object;
}

void SUITestData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);

	ZString::Serialize(&s_Object->sStringProp, p_Serializer, p_OwnOffset + offsetof(SUITestData, sStringProp));
	ZRuntimeResourceID::Serialize(&s_Object->ridProp, p_Serializer, p_OwnOffset + offsetof(SUITestData, ridProp));
	TArray<ZString>::Serialize(&s_Object->aStringArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aStringArray));
	TArray<SUITestData_SSubStruct>::Serialize(&s_Object->aSubStructArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aSubStructArray));
	TFixedArray<int32, 3>::Serialize(&s_Object->aFixedArray, p_Serializer, p_OwnOffset + offsetof(SUITestData, aFixedArray));
}

bool SUITestData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SUITestData*>(p_Left);
	auto* s_Right = reinterpret_cast<SUITestData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SUITestData::operator==(const SUITestData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SUITestData>)
		return false;

	if (nIntProp != p_Other.nIntProp) return false;
	if (fInt16Prop != p_Other.fInt16Prop) return false;
	if (fUInt32Prop != p_Other.fUInt32Prop) return false;
	if (fFloatProp != p_Other.fFloatProp) return false;
	if (sStringProp != p_Other.sStringProp) return false;
	if (eEnumProp != p_Other.eEnumProp) return false;
	if (ridProp != p_Other.ridProp) return false;
	if (aStringArray != p_Other.aStringArray) return false;
	if (aSubStructArray != p_Other.aSubStructArray) return false;
	if (aFixedArray != p_Other.aFixedArray) return false;

	return true;
}

void SUITestData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SUITestData*>(p_Object);
	s_Object->~SUITestData();
}

ZHMTypeInfo SVRConfigCameraComponent::TypeInfo = ZHMTypeInfo("SVRConfigCameraComponent", sizeof(SVRConfigCameraComponent), alignof(SVRConfigCameraComponent), SVRConfigCameraComponent::WriteSimpleJson, SVRConfigCameraComponent::FromSimpleJson, SVRConfigCameraComponent::Serialize, SVRConfigCameraComponent::Equals, SVRConfigCameraComponent::Destroy);

void SVRConfigCameraComponent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVRConfigCameraComponent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eHeadAnchorMode") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EVRConfigHeadAnchorMode", static_cast<int>(s_Object->m_eHeadAnchorMode)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_uRecenterRequestCounter") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_uRecenterRequestCounter);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fVRUserInputWeight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fVRUserInputWeight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fGridSize") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fGridSize);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCapsuleHeadAttacherOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCapsuleHeadAttacherOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCapsuleHeadAttacherOffsetSneaking") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCapsuleHeadAttacherOffsetSneaking);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fHeadBoneAttacherOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fHeadBoneAttacherOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vAnchorPosOffset") << ":";
	float4::WriteSimpleJson(&s_Object->m_vAnchorPosOffset, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mAnchorRotOffset") << ":";
	SMatrix::WriteSimpleJson(&s_Object->m_mAnchorRotOffset, p_Stream);

	p_Stream << "}";
}

void SVRConfigCameraComponent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVRConfigCameraComponent s_Object {};

	s_Object.m_eHeadAnchorMode = static_cast<EVRConfigHeadAnchorMode>(ZHMEnums::GetEnumValueByName("EVRConfigHeadAnchorMode", std::string_view(p_Document["m_eHeadAnchorMode"])));

	s_Object.m_uRecenterRequestCounter = simdjson::from_json_uint32(p_Document["m_uRecenterRequestCounter"]);

	s_Object.m_fVRUserInputWeight = simdjson::from_json_float32(p_Document["m_fVRUserInputWeight"]);

	s_Object.m_fGridSize = simdjson::from_json_float32(p_Document["m_fGridSize"]);

	s_Object.m_fCapsuleHeadAttacherOffset = simdjson::from_json_float32(p_Document["m_fCapsuleHeadAttacherOffset"]);

	s_Object.m_fCapsuleHeadAttacherOffsetSneaking = simdjson::from_json_float32(p_Document["m_fCapsuleHeadAttacherOffsetSneaking"]);

	s_Object.m_fHeadBoneAttacherOffset = simdjson::from_json_float32(p_Document["m_fHeadBoneAttacherOffset"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vAnchorPosOffset"], &s_Item);
		s_Object.m_vAnchorPosOffset = s_Item;
	}

	{
		SMatrix s_Item {};
		SMatrix::FromSimpleJson(p_Document["m_mAnchorRotOffset"], &s_Item);
		s_Object.m_mAnchorRotOffset = s_Item;
	}

	*reinterpret_cast<SVRConfigCameraComponent*>(p_Target) = s_Object;
}

void SVRConfigCameraComponent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVRConfigCameraComponent*>(p_Object);

	float4::Serialize(&s_Object->m_vAnchorPosOffset, p_Serializer, p_OwnOffset + offsetof(SVRConfigCameraComponent, m_vAnchorPosOffset));
	SMatrix::Serialize(&s_Object->m_mAnchorRotOffset, p_Serializer, p_OwnOffset + offsetof(SVRConfigCameraComponent, m_mAnchorRotOffset));
}

bool SVRConfigCameraComponent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVRConfigCameraComponent*>(p_Left);
	auto* s_Right = reinterpret_cast<SVRConfigCameraComponent*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVRConfigCameraComponent::operator==(const SVRConfigCameraComponent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVRConfigCameraComponent>)
		return false;

	if (m_eHeadAnchorMode != p_Other.m_eHeadAnchorMode) return false;
	if (m_uRecenterRequestCounter != p_Other.m_uRecenterRequestCounter) return false;
	if (m_fVRUserInputWeight != p_Other.m_fVRUserInputWeight) return false;
	if (m_fGridSize != p_Other.m_fGridSize) return false;
	if (m_fCapsuleHeadAttacherOffset != p_Other.m_fCapsuleHeadAttacherOffset) return false;
	if (m_fCapsuleHeadAttacherOffsetSneaking != p_Other.m_fCapsuleHeadAttacherOffsetSneaking) return false;
	if (m_fHeadBoneAttacherOffset != p_Other.m_fHeadBoneAttacherOffset) return false;
	if (m_vAnchorPosOffset != p_Other.m_vAnchorPosOffset) return false;
	if (m_mAnchorRotOffset != p_Other.m_mAnchorRotOffset) return false;

	return true;
}

void SVRConfigCameraComponent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVRConfigCameraComponent*>(p_Object);
	s_Object->~SVRConfigCameraComponent();
}

ZHMTypeInfo SValueBoolDelayedEntitySaveData::TypeInfo = ZHMTypeInfo("SValueBoolDelayedEntitySaveData", sizeof(SValueBoolDelayedEntitySaveData), alignof(SValueBoolDelayedEntitySaveData), SValueBoolDelayedEntitySaveData::WriteSimpleJson, SValueBoolDelayedEntitySaveData::FromSimpleJson, SValueBoolDelayedEntitySaveData::Serialize, SValueBoolDelayedEntitySaveData::Equals, SValueBoolDelayedEntitySaveData::Destroy);

void SValueBoolDelayedEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueBoolDelayedEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWaitingValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWaitingValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fTimeToNextEvent") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTimeToNextEvent);

	p_Stream << "}";
}

void SValueBoolDelayedEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueBoolDelayedEntitySaveData s_Object {};

	s_Object.m_bValue = simdjson::from_json_bool(p_Document["m_bValue"]);

	s_Object.m_bWaitingValue = simdjson::from_json_bool(p_Document["m_bWaitingValue"]);

	s_Object.m_fTimeToNextEvent = simdjson::from_json_float32(p_Document["m_fTimeToNextEvent"]);

	*reinterpret_cast<SValueBoolDelayedEntitySaveData*>(p_Target) = s_Object;
}

void SValueBoolDelayedEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueBoolDelayedEntitySaveData*>(p_Object);

}

bool SValueBoolDelayedEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueBoolDelayedEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueBoolDelayedEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueBoolDelayedEntitySaveData::operator==(const SValueBoolDelayedEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueBoolDelayedEntitySaveData>)
		return false;

	if (m_bValue != p_Other.m_bValue) return false;
	if (m_bWaitingValue != p_Other.m_bWaitingValue) return false;
	if (m_fTimeToNextEvent != p_Other.m_fTimeToNextEvent) return false;

	return true;
}

void SValueBoolDelayedEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueBoolDelayedEntitySaveData*>(p_Object);
	s_Object->~SValueBoolDelayedEntitySaveData();
}

ZHMTypeInfo SValueBoolsSaveData::TypeInfo = ZHMTypeInfo("SValueBoolsSaveData", sizeof(SValueBoolsSaveData), alignof(SValueBoolsSaveData), SValueBoolsSaveData::WriteSimpleJson, SValueBoolsSaveData::FromSimpleJson, SValueBoolsSaveData::Serialize, SValueBoolsSaveData::Equals, SValueBoolsSaveData::Destroy);

void SValueBoolsSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueBoolsSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueBoolsSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aData[s_Index0++] = simdjson::from_json_bool(s_Item0);
	}
	}

	*reinterpret_cast<SValueBoolsSaveData*>(p_Target) = s_Object;
}

void SValueBoolsSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueBoolsSaveData, m_aEntities));
	TArray<bool>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueBoolsSaveData, m_aData));
}

bool SValueBoolsSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueBoolsSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueBoolsSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueBoolsSaveData::operator==(const SValueBoolsSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueBoolsSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SValueBoolsSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueBoolsSaveData*>(p_Object);
	s_Object->~SValueBoolsSaveData();
}

ZHMTypeInfo SValueFloatSaveData::TypeInfo = ZHMTypeInfo("SValueFloatSaveData", sizeof(SValueFloatSaveData), alignof(SValueFloatSaveData), SValueFloatSaveData::WriteSimpleJson, SValueFloatSaveData::FromSimpleJson, SValueFloatSaveData::Serialize, SValueFloatSaveData::Equals, SValueFloatSaveData::Destroy);

void SValueFloatSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueFloatSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueFloatSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aData[s_Index0++] = simdjson::from_json_float32(s_Item0);
	}
	}

	*reinterpret_cast<SValueFloatSaveData*>(p_Target) = s_Object;
}

void SValueFloatSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueFloatSaveData, m_aEntities));
	TArray<float32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueFloatSaveData, m_aData));
}

bool SValueFloatSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueFloatSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueFloatSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueFloatSaveData::operator==(const SValueFloatSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueFloatSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SValueFloatSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueFloatSaveData*>(p_Object);
	s_Object->~SValueFloatSaveData();
}

ZHMTypeInfo SValueIntSaveData::TypeInfo = ZHMTypeInfo("SValueIntSaveData", sizeof(SValueIntSaveData), alignof(SValueIntSaveData), SValueIntSaveData::WriteSimpleJson, SValueIntSaveData::FromSimpleJson, SValueIntSaveData::Serialize, SValueIntSaveData::Equals, SValueIntSaveData::Destroy);

void SValueIntSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aEntities") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aEntities.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aEntities[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aEntities.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aData[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SValueIntSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueIntSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aEntities"];
	s_Object.m_aEntities.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aEntities[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aData"];
	s_Object.m_aData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aData[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<SValueIntSaveData*>(p_Target) = s_Object;
}

void SValueIntSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aEntities, p_Serializer, p_OwnOffset + offsetof(SValueIntSaveData, m_aEntities));
	TArray<int32>::Serialize(&s_Object->m_aData, p_Serializer, p_OwnOffset + offsetof(SValueIntSaveData, m_aData));
}

bool SValueIntSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueIntSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueIntSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueIntSaveData::operator==(const SValueIntSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueIntSaveData>)
		return false;

	if (m_aEntities != p_Other.m_aEntities) return false;
	if (m_aData != p_Other.m_aData) return false;

	return true;
}

void SValueIntSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueIntSaveData*>(p_Object);
	s_Object->~SValueIntSaveData();
}

ZHMTypeInfo SValueSaveData::TypeInfo = ZHMTypeInfo("SValueSaveData", sizeof(SValueSaveData), alignof(SValueSaveData), SValueSaveData::WriteSimpleJson, SValueSaveData::FromSimpleJson, SValueSaveData::Serialize, SValueSaveData::Equals, SValueSaveData::Destroy);

void SValueSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_ValueBool") << ":";
	SValueBoolsSaveData::WriteSimpleJson(&s_Object->m_ValueBool, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueFloat") << ":";
	SValueFloatSaveData::WriteSimpleJson(&s_Object->m_ValueFloat, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueInt") << ":";
	SValueIntSaveData::WriteSimpleJson(&s_Object->m_ValueInt, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_StateController") << ":";
	SStateControllerSaveData::WriteSimpleJson(&s_Object->m_StateController, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ValueColorRGB") << ":";
	SColorRGBSaveData::WriteSimpleJson(&s_Object->m_ValueColorRGB, p_Stream);

	p_Stream << "}";
}

void SValueSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SValueSaveData s_Object {};

	{
		SValueBoolsSaveData s_Item {};
		SValueBoolsSaveData::FromSimpleJson(p_Document["m_ValueBool"], &s_Item);
		s_Object.m_ValueBool = s_Item;
	}

	{
		SValueFloatSaveData s_Item {};
		SValueFloatSaveData::FromSimpleJson(p_Document["m_ValueFloat"], &s_Item);
		s_Object.m_ValueFloat = s_Item;
	}

	{
		SValueIntSaveData s_Item {};
		SValueIntSaveData::FromSimpleJson(p_Document["m_ValueInt"], &s_Item);
		s_Object.m_ValueInt = s_Item;
	}

	{
		SStateControllerSaveData s_Item {};
		SStateControllerSaveData::FromSimpleJson(p_Document["m_StateController"], &s_Item);
		s_Object.m_StateController = s_Item;
	}

	{
		SColorRGBSaveData s_Item {};
		SColorRGBSaveData::FromSimpleJson(p_Document["m_ValueColorRGB"], &s_Item);
		s_Object.m_ValueColorRGB = s_Item;
	}

	*reinterpret_cast<SValueSaveData*>(p_Target) = s_Object;
}

void SValueSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);

	SValueBoolsSaveData::Serialize(&s_Object->m_ValueBool, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueBool));
	SValueFloatSaveData::Serialize(&s_Object->m_ValueFloat, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueFloat));
	SValueIntSaveData::Serialize(&s_Object->m_ValueInt, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueInt));
	SStateControllerSaveData::Serialize(&s_Object->m_StateController, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_StateController));
	SColorRGBSaveData::Serialize(&s_Object->m_ValueColorRGB, p_Serializer, p_OwnOffset + offsetof(SValueSaveData, m_ValueColorRGB));
}

bool SValueSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SValueSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SValueSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SValueSaveData::operator==(const SValueSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SValueSaveData>)
		return false;

	if (m_ValueBool != p_Other.m_ValueBool) return false;
	if (m_ValueFloat != p_Other.m_ValueFloat) return false;
	if (m_ValueInt != p_Other.m_ValueInt) return false;
	if (m_StateController != p_Other.m_StateController) return false;
	if (m_ValueColorRGB != p_Other.m_ValueColorRGB) return false;

	return true;
}

void SValueSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SValueSaveData*>(p_Object);
	s_Object->~SValueSaveData();
}

ZHMTypeInfo SVideoDatabaseEntry::TypeInfo = ZHMTypeInfo("SVideoDatabaseEntry", sizeof(SVideoDatabaseEntry), alignof(SVideoDatabaseEntry), SVideoDatabaseEntry::WriteSimpleJson, SVideoDatabaseEntry::FromSimpleJson, SVideoDatabaseEntry::Serialize, SVideoDatabaseEntry::Equals, SVideoDatabaseEntry::Destroy);

void SVideoDatabaseEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("VideoId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->VideoId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("RuntimeLocalizedVideoRid") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->RuntimeLocalizedVideoRid, p_Stream);

	p_Stream << "}";
}

void SVideoDatabaseEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVideoDatabaseEntry s_Object {};

	s_Object.VideoId = std::string_view(p_Document["VideoId"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["RuntimeLocalizedVideoRid"], &s_Item);
		s_Object.RuntimeLocalizedVideoRid = s_Item;
	}

	*reinterpret_cast<SVideoDatabaseEntry*>(p_Target) = s_Object;
}

void SVideoDatabaseEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);

	ZString::Serialize(&s_Object->VideoId, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseEntry, VideoId));
	ZRuntimeResourceID::Serialize(&s_Object->RuntimeLocalizedVideoRid, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseEntry, RuntimeLocalizedVideoRid));
}

bool SVideoDatabaseEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVideoDatabaseEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<SVideoDatabaseEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVideoDatabaseEntry::operator==(const SVideoDatabaseEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVideoDatabaseEntry>)
		return false;

	if (VideoId != p_Other.VideoId) return false;
	if (RuntimeLocalizedVideoRid != p_Other.RuntimeLocalizedVideoRid) return false;

	return true;
}

void SVideoDatabaseEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseEntry*>(p_Object);
	s_Object->~SVideoDatabaseEntry();
}

ZHMTypeInfo SVideoDatabaseData::TypeInfo = ZHMTypeInfo("SVideoDatabaseData", sizeof(SVideoDatabaseData), alignof(SVideoDatabaseData), SVideoDatabaseData::WriteSimpleJson, SVideoDatabaseData::FromSimpleJson, SVideoDatabaseData::Serialize, SVideoDatabaseData::Equals, SVideoDatabaseData::Destroy);

void SVideoDatabaseData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Videos") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->Videos.size(); ++i)
	{
		auto& s_Item0 = s_Object->Videos[i];
		SVideoDatabaseEntry::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->Videos.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SVideoDatabaseData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVideoDatabaseData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["Videos"];
	s_Object.Videos.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SVideoDatabaseEntry s_ArrayItem0;
		SVideoDatabaseEntry::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.Videos[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SVideoDatabaseData*>(p_Target) = s_Object;
}

void SVideoDatabaseData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);

	TArray<SVideoDatabaseEntry>::Serialize(&s_Object->Videos, p_Serializer, p_OwnOffset + offsetof(SVideoDatabaseData, Videos));
}

bool SVideoDatabaseData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVideoDatabaseData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVideoDatabaseData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVideoDatabaseData::operator==(const SVideoDatabaseData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVideoDatabaseData>)
		return false;

	if (Videos != p_Other.Videos) return false;

	return true;
}

void SVideoDatabaseData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVideoDatabaseData*>(p_Object);
	s_Object->~SVideoDatabaseData();
}

ZHMTypeInfo SVisibilitySaveData::TypeInfo = ZHMTypeInfo("SVisibilitySaveData", sizeof(SVisibilitySaveData), alignof(SVisibilitySaveData), SVisibilitySaveData::WriteSimpleJson, SVisibilitySaveData::FromSimpleJson, SVisibilitySaveData::Serialize, SVisibilitySaveData::Equals, SVisibilitySaveData::Destroy);

void SVisibilitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsVisible);

	p_Stream << "}";
}

void SVisibilitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVisibilitySaveData s_Object {};

	s_Object.m_bIsVisible = simdjson::from_json_bool(p_Document["m_bIsVisible"]);

	*reinterpret_cast<SVisibilitySaveData*>(p_Target) = s_Object;
}

void SVisibilitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);

}

bool SVisibilitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVisibilitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVisibilitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVisibilitySaveData::operator==(const SVisibilitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVisibilitySaveData>)
		return false;

	if (m_bIsVisible != p_Other.m_bIsVisible) return false;

	return true;
}

void SVisibilitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVisibilitySaveData*>(p_Object);
	s_Object->~SVisibilitySaveData();
}

ZHMTypeInfo SVoidSignalEntitySaveData::TypeInfo = ZHMTypeInfo("SVoidSignalEntitySaveData", sizeof(SVoidSignalEntitySaveData), alignof(SVoidSignalEntitySaveData), SVoidSignalEntitySaveData::WriteSimpleJson, SVoidSignalEntitySaveData::FromSimpleJson, SVoidSignalEntitySaveData::Serialize, SVoidSignalEntitySaveData::Equals, SVoidSignalEntitySaveData::Destroy);

void SVoidSignalEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bSignaling") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bSignaling);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFiredAtTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFiredAtTime);

	p_Stream << "}";
}

void SVoidSignalEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SVoidSignalEntitySaveData s_Object {};

	s_Object.m_bSignaling = simdjson::from_json_bool(p_Document["m_bSignaling"]);

	s_Object.m_fFiredAtTime = simdjson::from_json_float32(p_Document["m_fFiredAtTime"]);

	*reinterpret_cast<SVoidSignalEntitySaveData*>(p_Target) = s_Object;
}

void SVoidSignalEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);

}

bool SVoidSignalEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SVoidSignalEntitySaveData::operator==(const SVoidSignalEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SVoidSignalEntitySaveData>)
		return false;

	if (m_bSignaling != p_Other.m_bSignaling) return false;
	if (m_fFiredAtTime != p_Other.m_fFiredAtTime) return false;

	return true;
}

void SVoidSignalEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SVoidSignalEntitySaveData*>(p_Object);
	s_Object->~SVoidSignalEntitySaveData();
}

ZHMTypeInfo SWaveformGeneratorSaveData::TypeInfo = ZHMTypeInfo("SWaveformGeneratorSaveData", sizeof(SWaveformGeneratorSaveData), alignof(SWaveformGeneratorSaveData), SWaveformGeneratorSaveData::WriteSimpleJson, SWaveformGeneratorSaveData::FromSimpleJson, SWaveformGeneratorSaveData::Serialize, SWaveformGeneratorSaveData::Equals, SWaveformGeneratorSaveData::Destroy);

void SWaveformGeneratorSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFrequency") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFrequency);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fOffset") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fOffset);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fScale") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fScale);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStartTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStartTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCount);

	p_Stream << "}";
}

void SWaveformGeneratorSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWaveformGeneratorSaveData s_Object {};

	s_Object.m_fTime = simdjson::from_json_float32(p_Document["m_fTime"]);

	s_Object.m_fFrequency = simdjson::from_json_float32(p_Document["m_fFrequency"]);

	s_Object.m_fOffset = simdjson::from_json_float32(p_Document["m_fOffset"]);

	s_Object.m_fScale = simdjson::from_json_float32(p_Document["m_fScale"]);

	s_Object.m_fStartTime = simdjson::from_json_float32(p_Document["m_fStartTime"]);

	s_Object.m_nCount = simdjson::from_json_uint32(p_Document["m_nCount"]);

	*reinterpret_cast<SWaveformGeneratorSaveData*>(p_Target) = s_Object;
}

void SWaveformGeneratorSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);

}

bool SWaveformGeneratorSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWaveformGeneratorSaveData::operator==(const SWaveformGeneratorSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWaveformGeneratorSaveData>)
		return false;

	if (m_fTime != p_Other.m_fTime) return false;
	if (m_fFrequency != p_Other.m_fFrequency) return false;
	if (m_fOffset != p_Other.m_fOffset) return false;
	if (m_fScale != p_Other.m_fScale) return false;
	if (m_fStartTime != p_Other.m_fStartTime) return false;
	if (m_nCount != p_Other.m_nCount) return false;

	return true;
}

void SWaveformGeneratorSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorSaveData*>(p_Object);
	s_Object->~SWaveformGeneratorSaveData();
}

ZHMTypeInfo SWaveformGeneratorManagerSaveData::TypeInfo = ZHMTypeInfo("SWaveformGeneratorManagerSaveData", sizeof(SWaveformGeneratorManagerSaveData), alignof(SWaveformGeneratorManagerSaveData), SWaveformGeneratorManagerSaveData::WriteSimpleJson, SWaveformGeneratorManagerSaveData::FromSimpleJson, SWaveformGeneratorManagerSaveData::Serialize, SWaveformGeneratorManagerSaveData::Equals, SWaveformGeneratorManagerSaveData::Destroy);

void SWaveformGeneratorManagerSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aGenerators") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGenerators.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGenerators[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aGenerators.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aGeneratorData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aGeneratorData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aGeneratorData[i];
		SWaveformGeneratorSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aGeneratorData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SWaveformGeneratorManagerSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWaveformGeneratorManagerSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGenerators"];
	s_Object.m_aGenerators.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aGenerators[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aGeneratorData"];
	s_Object.m_aGeneratorData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SWaveformGeneratorSaveData s_ArrayItem0;
		SWaveformGeneratorSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aGeneratorData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Target) = s_Object;
}

void SWaveformGeneratorManagerSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);

	TArray<uint32>::Serialize(&s_Object->m_aGenerators, p_Serializer, p_OwnOffset + offsetof(SWaveformGeneratorManagerSaveData, m_aGenerators));
	TArray<SWaveformGeneratorSaveData>::Serialize(&s_Object->m_aGeneratorData, p_Serializer, p_OwnOffset + offsetof(SWaveformGeneratorManagerSaveData, m_aGeneratorData));
}

bool SWaveformGeneratorManagerSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWaveformGeneratorManagerSaveData::operator==(const SWaveformGeneratorManagerSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWaveformGeneratorManagerSaveData>)
		return false;

	if (m_aGenerators != p_Other.m_aGenerators) return false;
	if (m_aGeneratorData != p_Other.m_aGeneratorData) return false;

	return true;
}

void SWaveformGeneratorManagerSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWaveformGeneratorManagerSaveData*>(p_Object);
	s_Object->~SWaveformGeneratorManagerSaveData();
}

ZHMTypeInfo SWeaponCustomControlSaveData::TypeInfo = ZHMTypeInfo("SWeaponCustomControlSaveData", sizeof(SWeaponCustomControlSaveData), alignof(SWeaponCustomControlSaveData), SWeaponCustomControlSaveData::WriteSimpleJson, SWeaponCustomControlSaveData::FromSimpleJson, SWeaponCustomControlSaveData::Serialize, SWeaponCustomControlSaveData::Equals, SWeaponCustomControlSaveData::Destroy);

void SWeaponCustomControlSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponCustomControlSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetRegistered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetRegistered);

	p_Stream << "}";
}

void SWeaponCustomControlSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWeaponCustomControlSaveData s_Object {};

	s_Object.m_rActor = simdjson::from_json_uint32(p_Document["m_rActor"]);

	s_Object.m_rItem = simdjson::from_json_uint32(p_Document["m_rItem"]);

	s_Object.m_bTargetRegistered = simdjson::from_json_bool(p_Document["m_bTargetRegistered"]);

	*reinterpret_cast<SWeaponCustomControlSaveData*>(p_Target) = s_Object;
}

void SWeaponCustomControlSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWeaponCustomControlSaveData*>(p_Object);

}

bool SWeaponCustomControlSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWeaponCustomControlSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWeaponCustomControlSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWeaponCustomControlSaveData::operator==(const SWeaponCustomControlSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWeaponCustomControlSaveData>)
		return false;

	if (m_rActor != p_Other.m_rActor) return false;
	if (m_rItem != p_Other.m_rItem) return false;
	if (m_bTargetRegistered != p_Other.m_bTargetRegistered) return false;

	return true;
}

void SWeaponCustomControlSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWeaponCustomControlSaveData*>(p_Object);
	s_Object->~SWeaponCustomControlSaveData();
}

ZHMTypeInfo SWeaponStatusUIData::TypeInfo = ZHMTypeInfo("SWeaponStatusUIData", sizeof(SWeaponStatusUIData), alignof(SWeaponStatusUIData), SWeaponStatusUIData::WriteSimpleJson, SWeaponStatusUIData::FromSimpleJson, SWeaponStatusUIData::Serialize, SWeaponStatusUIData::Equals, SWeaponStatusUIData::Destroy);

void SWeaponStatusUIData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWeaponStatusUIData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedIcon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->containedIcon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sWeaponName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sWeaponName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sContainedItemName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sContainedItemName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nItemHUDType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nItemHUDType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSilenced") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSilenced);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsFirearm") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsFirearm);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHolstered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHolstered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bCannotBeHolstered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bCannotBeHolstered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bHasItemToShow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bHasItemToShow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bCanReload") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bCanReload);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsReloading") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsReloading);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fReloadDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fReloadDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInfiniteAmmo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInfiniteAmmo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsContainer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsContainer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bContainsItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bContainsItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nContainedItemHUDType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nContainedItemHUDType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bContainedItemIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bContainedItemIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bContainedItemSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bContainedItemSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bContainedItemDetectedDuringFrisk") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bContainedItemDetectedDuringFrisk);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fLastBulletFiredTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fLastBulletFiredTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("fTimeBetweenBullets") << ":";
	p_Stream << simdjson::as_json_string(s_Object->fTimeBetweenBullets);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aPerks") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aPerks.size(); ++i)
	{
		auto& s_Item0 = s_Object->aPerks[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aPerks.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aAmmoTypes") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aAmmoTypes.size(); ++i)
	{
		auto& s_Item0 = s_Object->aAmmoTypes[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aAmmoTypes.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nCurrentAmmoType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nCurrentAmmoType);

	p_Stream << "}";
}

void SWeaponStatusUIData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWeaponStatusUIData s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["containedIcon"], &s_Item);
		s_Object.containedIcon = s_Item;
	}

	s_Object.sWeaponName = std::string_view(p_Document["sWeaponName"]);

	s_Object.sContainedItemName = std::string_view(p_Document["sContainedItemName"]);

	s_Object.nWeaponType = simdjson::from_json_int32(p_Document["nWeaponType"]);

	s_Object.nItemHUDType = simdjson::from_json_int32(p_Document["nItemHUDType"]);

	s_Object.nAmmoRemaining = simdjson::from_json_int32(p_Document["nAmmoRemaining"]);

	s_Object.nAmmoTotal = simdjson::from_json_int32(p_Document["nAmmoTotal"]);

	s_Object.nAmmoInClip = simdjson::from_json_int32(p_Document["nAmmoInClip"]);

	s_Object.bSilenced = simdjson::from_json_bool(p_Document["bSilenced"]);

	s_Object.bIsFirearm = simdjson::from_json_bool(p_Document["bIsFirearm"]);

	s_Object.bHolstered = simdjson::from_json_bool(p_Document["bHolstered"]);

	s_Object.bCannotBeHolstered = simdjson::from_json_bool(p_Document["bCannotBeHolstered"]);

	s_Object.bHasItemToShow = simdjson::from_json_bool(p_Document["bHasItemToShow"]);

	s_Object.bSuspicious = simdjson::from_json_bool(p_Document["bSuspicious"]);

	s_Object.bIllegal = simdjson::from_json_bool(p_Document["bIllegal"]);

	s_Object.bCanReload = simdjson::from_json_bool(p_Document["bCanReload"]);

	s_Object.bIsReloading = simdjson::from_json_bool(p_Document["bIsReloading"]);

	s_Object.fReloadDuration = simdjson::from_json_float32(p_Document["fReloadDuration"]);

	s_Object.bInfiniteAmmo = simdjson::from_json_bool(p_Document["bInfiniteAmmo"]);

	s_Object.bIsContainer = simdjson::from_json_bool(p_Document["bIsContainer"]);

	s_Object.bContainsItem = simdjson::from_json_bool(p_Document["bContainsItem"]);

	s_Object.nContainedItemHUDType = simdjson::from_json_int32(p_Document["nContainedItemHUDType"]);

	s_Object.bContainedItemIllegal = simdjson::from_json_bool(p_Document["bContainedItemIllegal"]);

	s_Object.bContainedItemSuspicious = simdjson::from_json_bool(p_Document["bContainedItemSuspicious"]);

	s_Object.bContainedItemDetectedDuringFrisk = simdjson::from_json_bool(p_Document["bContainedItemDetectedDuringFrisk"]);

	s_Object.fLastBulletFiredTime = simdjson::from_json_float32(p_Document["fLastBulletFiredTime"]);

	s_Object.fTimeBetweenBullets = simdjson::from_json_float32(p_Document["fTimeBetweenBullets"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aPerks"];
	s_Object.aPerks.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.aPerks[s_Index0++] = std::string_view(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["aAmmoTypes"];
	s_Object.aAmmoTypes.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.aAmmoTypes[s_Index0++] = std::string_view(s_Item0);
	}
	}

	s_Object.nCurrentAmmoType = simdjson::from_json_uint32(p_Document["nCurrentAmmoType"]);

	*reinterpret_cast<SWeaponStatusUIData*>(p_Target) = s_Object;
}

void SWeaponStatusUIData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWeaponStatusUIData*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, icon));
	ZRuntimeResourceID::Serialize(&s_Object->containedIcon, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, containedIcon));
	ZString::Serialize(&s_Object->sWeaponName, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, sWeaponName));
	ZString::Serialize(&s_Object->sContainedItemName, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, sContainedItemName));
	TArray<ZString>::Serialize(&s_Object->aPerks, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, aPerks));
	TArray<ZString>::Serialize(&s_Object->aAmmoTypes, p_Serializer, p_OwnOffset + offsetof(SWeaponStatusUIData, aAmmoTypes));
}

bool SWeaponStatusUIData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWeaponStatusUIData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWeaponStatusUIData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWeaponStatusUIData::operator==(const SWeaponStatusUIData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWeaponStatusUIData>)
		return false;

	if (icon != p_Other.icon) return false;
	if (containedIcon != p_Other.containedIcon) return false;
	if (sWeaponName != p_Other.sWeaponName) return false;
	if (sContainedItemName != p_Other.sContainedItemName) return false;
	if (nWeaponType != p_Other.nWeaponType) return false;
	if (nItemHUDType != p_Other.nItemHUDType) return false;
	if (nAmmoRemaining != p_Other.nAmmoRemaining) return false;
	if (nAmmoTotal != p_Other.nAmmoTotal) return false;
	if (nAmmoInClip != p_Other.nAmmoInClip) return false;
	if (bSilenced != p_Other.bSilenced) return false;
	if (bIsFirearm != p_Other.bIsFirearm) return false;
	if (bHolstered != p_Other.bHolstered) return false;
	if (bCannotBeHolstered != p_Other.bCannotBeHolstered) return false;
	if (bHasItemToShow != p_Other.bHasItemToShow) return false;
	if (bSuspicious != p_Other.bSuspicious) return false;
	if (bIllegal != p_Other.bIllegal) return false;
	if (bCanReload != p_Other.bCanReload) return false;
	if (bIsReloading != p_Other.bIsReloading) return false;
	if (fReloadDuration != p_Other.fReloadDuration) return false;
	if (bInfiniteAmmo != p_Other.bInfiniteAmmo) return false;
	if (bIsContainer != p_Other.bIsContainer) return false;
	if (bContainsItem != p_Other.bContainsItem) return false;
	if (nContainedItemHUDType != p_Other.nContainedItemHUDType) return false;
	if (bContainedItemIllegal != p_Other.bContainedItemIllegal) return false;
	if (bContainedItemSuspicious != p_Other.bContainedItemSuspicious) return false;
	if (bContainedItemDetectedDuringFrisk != p_Other.bContainedItemDetectedDuringFrisk) return false;
	if (fLastBulletFiredTime != p_Other.fLastBulletFiredTime) return false;
	if (fTimeBetweenBullets != p_Other.fTimeBetweenBullets) return false;
	if (aPerks != p_Other.aPerks) return false;
	if (aAmmoTypes != p_Other.aAmmoTypes) return false;
	if (nCurrentAmmoType != p_Other.nCurrentAmmoType) return false;

	return true;
}

void SWeaponStatusUIData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWeaponStatusUIData*>(p_Object);
	s_Object->~SWeaponStatusUIData();
}

ZHMTypeInfo SWorldInventoryInstanceSaveData::TypeInfo = ZHMTypeInfo("SWorldInventoryInstanceSaveData", sizeof(SWorldInventoryInstanceSaveData), alignof(SWorldInventoryInstanceSaveData), SWorldInventoryInstanceSaveData::WriteSimpleJson, SWorldInventoryInstanceSaveData::FromSimpleJson, SWorldInventoryInstanceSaveData::Serialize, SWorldInventoryInstanceSaveData::Equals, SWorldInventoryInstanceSaveData::Destroy);

void SWorldInventoryInstanceSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aItemInstanceSaveData") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aItemInstanceSaveData.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aItemInstanceSaveData[i];
		SItemInstanceSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aItemInstanceSaveData.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void SWorldInventoryInstanceSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SWorldInventoryInstanceSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aItemInstanceSaveData"];
	s_Object.m_aItemInstanceSaveData.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SItemInstanceSaveData s_ArrayItem0;
		SItemInstanceSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aItemInstanceSaveData[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Target) = s_Object;
}

void SWorldInventoryInstanceSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Object);

	TArray<SItemInstanceSaveData>::Serialize(&s_Object->m_aItemInstanceSaveData, p_Serializer, p_OwnOffset + offsetof(SWorldInventoryInstanceSaveData, m_aItemInstanceSaveData));
}

bool SWorldInventoryInstanceSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SWorldInventoryInstanceSaveData::operator==(const SWorldInventoryInstanceSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SWorldInventoryInstanceSaveData>)
		return false;

	if (m_aItemInstanceSaveData != p_Other.m_aItemInstanceSaveData) return false;

	return true;
}

void SWorldInventoryInstanceSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SWorldInventoryInstanceSaveData*>(p_Object);
	s_Object->~SWorldInventoryInstanceSaveData();
}

ZHMTypeInfo SZHUDIgnoreVisibilitySaveData::TypeInfo = ZHMTypeInfo("SZHUDIgnoreVisibilitySaveData", sizeof(SZHUDIgnoreVisibilitySaveData), alignof(SZHUDIgnoreVisibilitySaveData), SZHUDIgnoreVisibilitySaveData::WriteSimpleJson, SZHUDIgnoreVisibilitySaveData::FromSimpleJson, SZHUDIgnoreVisibilitySaveData::Serialize, SZHUDIgnoreVisibilitySaveData::Equals, SZHUDIgnoreVisibilitySaveData::Destroy);

void SZHUDIgnoreVisibilitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<SZHUDIgnoreVisibilitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("alpha") << ":";
	p_Stream << simdjson::as_json_string(s_Object->alpha);

	p_Stream << "}";
}

void SZHUDIgnoreVisibilitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	SZHUDIgnoreVisibilitySaveData s_Object {};

	s_Object.alpha = simdjson::from_json_float32(p_Document["alpha"]);

	*reinterpret_cast<SZHUDIgnoreVisibilitySaveData*>(p_Target) = s_Object;
}

void SZHUDIgnoreVisibilitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<SZHUDIgnoreVisibilitySaveData*>(p_Object);

}

bool SZHUDIgnoreVisibilitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<SZHUDIgnoreVisibilitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<SZHUDIgnoreVisibilitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool SZHUDIgnoreVisibilitySaveData::operator==(const SZHUDIgnoreVisibilitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<SZHUDIgnoreVisibilitySaveData>)
		return false;

	if (alpha != p_Other.alpha) return false;

	return true;
}

void SZHUDIgnoreVisibilitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<SZHUDIgnoreVisibilitySaveData*>(p_Object);
	s_Object->~SZHUDIgnoreVisibilitySaveData();
}

ZHMTypeInfo ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::TypeInfo = ZHMTypeInfo("ZAISetpieceDistractionContextEntity.SAIDistractionContextEntitySaveData", sizeof(ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData), alignof(ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData), ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::WriteSimpleJson, ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::FromSimpleJson, ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::Serialize, ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::Equals, ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::Destroy);

void ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_DistractedActor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_DistractedActor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_CooldownExpirationTimestamp") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_CooldownExpirationTimestamp, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_DistractionIsActive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_DistractionIsActive);

	p_Stream << "}";
}

void ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData s_Object {};

	s_Object.m_DistractedActor = simdjson::from_json_uint32(p_Document["m_DistractedActor"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_CooldownExpirationTimestamp"], &s_Item);
		s_Object.m_CooldownExpirationTimestamp = s_Item;
	}

	s_Object.m_DistractionIsActive = simdjson::from_json_bool(p_Document["m_DistractionIsActive"]);

	*reinterpret_cast<ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData*>(p_Target) = s_Object;
}

void ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_CooldownExpirationTimestamp, p_Serializer, p_OwnOffset + offsetof(ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData, m_CooldownExpirationTimestamp));
}

bool ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::operator==(const ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData>)
		return false;

	if (m_DistractedActor != p_Other.m_DistractedActor) return false;
	if (m_CooldownExpirationTimestamp != p_Other.m_CooldownExpirationTimestamp) return false;
	if (m_DistractionIsActive != p_Other.m_DistractionIsActive) return false;

	return true;
}

void ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData*>(p_Object);
	s_Object->~ZAISetpieceDistractionContextEntity_SAIDistractionContextEntitySaveData();
}

ZHMTypeInfo ZAMDEvent::TypeInfo = ZHMTypeInfo("ZAMDEvent", sizeof(ZAMDEvent), alignof(ZAMDEvent), ZAMDEvent::WriteSimpleJson, ZAMDEvent::FromSimpleJson, ZAMDEvent::Serialize, ZAMDEvent::Equals, ZAMDEvent::Destroy);

void ZAMDEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStartFraction") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStartFraction);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_customData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_customData, p_Stream);

	p_Stream << "}";
}

void ZAMDEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAMDEvent s_Object {};

	s_Object.m_nEventID = simdjson::from_json_uint32(p_Document["m_nEventID"]);

	s_Object.m_fStartFraction = simdjson::from_json_float32(p_Document["m_fStartFraction"]);

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_customData"], &s_Item);
		s_Object.m_customData = s_Item;
	}

	*reinterpret_cast<ZAMDEvent*>(p_Target) = s_Object;
}

void ZAMDEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);

	ZVariant::Serialize(&s_Object->m_customData, p_Serializer, p_OwnOffset + offsetof(ZAMDEvent, m_customData));
}

bool ZAMDEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDEvent::operator==(const ZAMDEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDEvent>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;
	if (m_fStartFraction != p_Other.m_fStartFraction) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_customData != p_Other.m_customData) return false;

	return true;
}

void ZAMDEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAMDEvent*>(p_Object);
	s_Object->~ZAMDEvent();
}

ZHMTypeInfo ZAMDEventTrack::TypeInfo = ZHMTypeInfo("ZAMDEventTrack", sizeof(ZAMDEventTrack), alignof(ZAMDEventTrack), ZAMDEventTrack::WriteSimpleJson, ZAMDEventTrack::FromSimpleJson, ZAMDEventTrack::Serialize, ZAMDEventTrack::Equals, ZAMDEventTrack::Destroy);

void ZAMDEventTrack::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_events") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_events.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_events[i];
		ZAMDEvent::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_events.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZAMDEventTrack::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAMDEventTrack s_Object {};

	s_Object.m_sName = std::string_view(p_Document["m_sName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_events"];
	s_Object.m_events.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZAMDEvent s_ArrayItem0;
		ZAMDEvent::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_events[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZAMDEventTrack*>(p_Target) = s_Object;
}

void ZAMDEventTrack::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);

	ZString::Serialize(&s_Object->m_sName, p_Serializer, p_OwnOffset + offsetof(ZAMDEventTrack, m_sName));
	TArray<ZAMDEvent>::Serialize(&s_Object->m_events, p_Serializer, p_OwnOffset + offsetof(ZAMDEventTrack, m_events));
}

bool ZAMDEventTrack::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDEventTrack*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDEventTrack*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDEventTrack::operator==(const ZAMDEventTrack& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDEventTrack>)
		return false;

	if (m_sName != p_Other.m_sName) return false;
	if (m_events != p_Other.m_events) return false;

	return true;
}

void ZAMDEventTrack::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAMDEventTrack*>(p_Object);
	s_Object->~ZAMDEventTrack();
}

ZHMTypeInfo ZAMDTake::TypeInfo = ZHMTypeInfo("ZAMDTake", sizeof(ZAMDTake), alignof(ZAMDTake), ZAMDTake::WriteSimpleJson, ZAMDTake::FromSimpleJson, ZAMDTake::Serialize, ZAMDTake::Equals, ZAMDTake::Destroy);

void ZAMDTake::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eventTracks") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_eventTracks.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_eventTracks[i];
		ZAMDEventTrack::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_eventTracks.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_customData") << ":";
	ZVariant::WriteSimpleJson(&s_Object->m_customData, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSyncTrackIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSyncTrackIndex);

	p_Stream << "}";
}

void ZAMDTake::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAMDTake s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_eventTracks"];
	s_Object.m_eventTracks.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZAMDEventTrack s_ArrayItem0;
		ZAMDEventTrack::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_eventTracks[s_Index0++] = s_ArrayItem0;
	}
	}

	{
		ZVariant s_Item {};
		ZVariant::FromSimpleJson(p_Document["m_customData"], &s_Item);
		s_Object.m_customData = s_Item;
	}

	s_Object.m_nSyncTrackIndex = simdjson::from_json_int32(p_Document["m_nSyncTrackIndex"]);

	*reinterpret_cast<ZAMDTake*>(p_Target) = s_Object;
}

void ZAMDTake::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);

	TArray<ZAMDEventTrack>::Serialize(&s_Object->m_eventTracks, p_Serializer, p_OwnOffset + offsetof(ZAMDTake, m_eventTracks));
	ZVariant::Serialize(&s_Object->m_customData, p_Serializer, p_OwnOffset + offsetof(ZAMDTake, m_customData));
}

bool ZAMDTake::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAMDTake*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAMDTake*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAMDTake::operator==(const ZAMDTake& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAMDTake>)
		return false;

	if (m_eventTracks != p_Other.m_eventTracks) return false;
	if (m_customData != p_Other.m_customData) return false;
	if (m_nSyncTrackIndex != p_Other.m_nSyncTrackIndex) return false;

	return true;
}

void ZAMDTake::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAMDTake*>(p_Object);
	s_Object->~ZAMDTake();
}

ZHMTypeInfo ZAT2Controller_SEventPreviewInfo::TypeInfo = ZHMTypeInfo("ZAT2Controller.SEventPreviewInfo", sizeof(ZAT2Controller_SEventPreviewInfo), alignof(ZAT2Controller_SEventPreviewInfo), ZAT2Controller_SEventPreviewInfo::WriteSimpleJson, ZAT2Controller_SEventPreviewInfo::FromSimpleJson, ZAT2Controller_SEventPreviewInfo::Serialize, ZAT2Controller_SEventPreviewInfo::Equals, ZAT2Controller_SEventPreviewInfo::Destroy);

void ZAT2Controller_SEventPreviewInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEventID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEventID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sConsumerID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sConsumerID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fDuration);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExtraDataTypeName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExtraDataTypeName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_extraDataProperties") << ":";
	TMap<ZString,ZVariant>::WriteSimpleJson(&s_Object->m_extraDataProperties, p_Stream);

	p_Stream << "}";
}

void ZAT2Controller_SEventPreviewInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAT2Controller_SEventPreviewInfo s_Object {};

	s_Object.m_nEventID = simdjson::from_json_int32(p_Document["m_nEventID"]);

	s_Object.m_sConsumerID = std::string_view(p_Document["m_sConsumerID"]);

	s_Object.m_fDuration = simdjson::from_json_float32(p_Document["m_fDuration"]);

	s_Object.m_sExtraDataTypeName = std::string_view(p_Document["m_sExtraDataTypeName"]);

	{
		TMap<ZString,ZVariant> s_Item {};
		TMap<ZString,ZVariant>::FromSimpleJson(p_Document["m_extraDataProperties"], &s_Item);
		s_Object.m_extraDataProperties = s_Item;
	}

	*reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Target) = s_Object;
}

void ZAT2Controller_SEventPreviewInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Object);

	ZString::Serialize(&s_Object->m_sConsumerID, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller_SEventPreviewInfo, m_sConsumerID));
	ZString::Serialize(&s_Object->m_sExtraDataTypeName, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller_SEventPreviewInfo, m_sExtraDataTypeName));
	TMap<ZString,ZVariant>::Serialize(&s_Object->m_extraDataProperties, p_Serializer, p_OwnOffset + offsetof(ZAT2Controller_SEventPreviewInfo, m_extraDataProperties));
}

bool ZAT2Controller_SEventPreviewInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAT2Controller_SEventPreviewInfo::operator==(const ZAT2Controller_SEventPreviewInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAT2Controller_SEventPreviewInfo>)
		return false;

	if (m_nEventID != p_Other.m_nEventID) return false;
	if (m_sConsumerID != p_Other.m_sConsumerID) return false;
	if (m_fDuration != p_Other.m_fDuration) return false;
	if (m_sExtraDataTypeName != p_Other.m_sExtraDataTypeName) return false;
	if (m_extraDataProperties != p_Other.m_extraDataProperties) return false;

	return true;
}

void ZAT2Controller_SEventPreviewInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SEventPreviewInfo*>(p_Object);
	s_Object->~ZAT2Controller_SEventPreviewInfo();
}

ZHMTypeInfo ZAT2Controller_SGeneratedFootstepEvent::TypeInfo = ZHMTypeInfo("ZAT2Controller.SGeneratedFootstepEvent", sizeof(ZAT2Controller_SGeneratedFootstepEvent), alignof(ZAT2Controller_SGeneratedFootstepEvent), ZAT2Controller_SGeneratedFootstepEvent::WriteSimpleJson, ZAT2Controller_SGeneratedFootstepEvent::FromSimpleJson, ZAT2Controller_SGeneratedFootstepEvent::Serialize, ZAT2Controller_SGeneratedFootstepEvent::Equals, ZAT2Controller_SGeneratedFootstepEvent::Destroy);

void ZAT2Controller_SGeneratedFootstepEvent::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFoot") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZAT2Controller.EFoot", static_cast<int>(s_Object->m_eFoot)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFrame") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFrame);

	p_Stream << "}";
}

void ZAT2Controller_SGeneratedFootstepEvent::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAT2Controller_SGeneratedFootstepEvent s_Object {};

	s_Object.m_eFoot = static_cast<ZAT2Controller_EFoot>(ZHMEnums::GetEnumValueByName("ZAT2Controller.EFoot", std::string_view(p_Document["m_eFoot"])));

	s_Object.m_fFrame = simdjson::from_json_float32(p_Document["m_fFrame"]);

	*reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Target) = s_Object;
}

void ZAT2Controller_SGeneratedFootstepEvent::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Object);

}

bool ZAT2Controller_SGeneratedFootstepEvent::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAT2Controller_SGeneratedFootstepEvent::operator==(const ZAT2Controller_SGeneratedFootstepEvent& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAT2Controller_SGeneratedFootstepEvent>)
		return false;

	if (m_eFoot != p_Other.m_eFoot) return false;
	if (m_fFrame != p_Other.m_fFrame) return false;

	return true;
}

void ZAT2Controller_SGeneratedFootstepEvent::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAT2Controller_SGeneratedFootstepEvent*>(p_Object);
	s_Object->~ZAT2Controller_SGeneratedFootstepEvent();
}

ZHMTypeInfo ZApproachOrder_SApproachOrderSaveData::TypeInfo = ZHMTypeInfo("ZApproachOrder.SApproachOrderSaveData", sizeof(ZApproachOrder_SApproachOrderSaveData), alignof(ZApproachOrder_SApproachOrderSaveData), ZApproachOrder_SApproachOrderSaveData::WriteSimpleJson, ZApproachOrder_SApproachOrderSaveData::FromSimpleJson, ZApproachOrder_SApproachOrderSaveData::Serialize, ZApproachOrder_SApproachOrderSaveData::Equals, ZApproachOrder_SApproachOrderSaveData::Destroy);

void ZApproachOrder_SApproachOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_style") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZApproachOrder.EApproachStyle", static_cast<int>(s_Object->m_style)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceStand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceStand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);

	p_Stream << "}";
}

void ZApproachOrder_SApproachOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZApproachOrder_SApproachOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Item);
		s_Object.m_vStopDirection = s_Item;
	}

	s_Object.m_style = static_cast<ZApproachOrder_EApproachStyle>(ZHMEnums::GetEnumValueByName("ZApproachOrder.EApproachStyle", std::string_view(p_Document["m_style"])));

	s_Object.m_bForceStand = simdjson::from_json_bool(p_Document["m_bForceStand"]);

	s_Object.m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

	*reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Target) = s_Object;
}

void ZApproachOrder_SApproachOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZApproachOrder_SApproachOrderSaveData, m_vStopDirection));
}

bool ZApproachOrder_SApproachOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZApproachOrder_SApproachOrderSaveData::operator==(const ZApproachOrder_SApproachOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZApproachOrder_SApproachOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_style != p_Other.m_style) return false;
	if (m_bForceStand != p_Other.m_bForceStand) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;

	return true;
}

void ZApproachOrder_SApproachOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZApproachOrder_SApproachOrderSaveData*>(p_Object);
	s_Object->~ZApproachOrder_SApproachOrderSaveData();
}

ZHMTypeInfo ZAutoNullEntityRef::TypeInfo = ZHMTypeInfo("ZAutoNullEntityRef", sizeof(ZAutoNullEntityRef), alignof(ZAutoNullEntityRef), ZAutoNullEntityRef::WriteSimpleJson, ZAutoNullEntityRef::FromSimpleJson, ZAutoNullEntityRef::Serialize, ZAutoNullEntityRef::Equals, ZAutoNullEntityRef::Destroy);

void ZAutoNullEntityRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZAutoNullEntityRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAutoNullEntityRef s_Object {};

	*reinterpret_cast<ZAutoNullEntityRef*>(p_Target) = s_Object;
}

void ZAutoNullEntityRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);

}

bool ZAutoNullEntityRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAutoNullEntityRef*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAutoNullEntityRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAutoNullEntityRef::operator==(const ZAutoNullEntityRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAutoNullEntityRef>)
		return false;


	return true;
}

void ZAutoNullEntityRef::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAutoNullEntityRef*>(p_Object);
	s_Object->~ZAutoNullEntityRef();
}

ZHMTypeInfo ZAvoidDangerousAreaSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZAvoidDangerousAreaSituation.SSituationSaveData", sizeof(ZAvoidDangerousAreaSituation_SSituationSaveData), alignof(ZAvoidDangerousAreaSituation_SSituationSaveData), ZAvoidDangerousAreaSituation_SSituationSaveData::WriteSimpleJson, ZAvoidDangerousAreaSituation_SSituationSaveData::FromSimpleJson, ZAvoidDangerousAreaSituation_SSituationSaveData::Serialize, ZAvoidDangerousAreaSituation_SSituationSaveData::Equals, ZAvoidDangerousAreaSituation_SSituationSaveData::Destroy);

void ZAvoidDangerousAreaSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerousAreaGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerousAreaGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerousAreaGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerousAreaGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZAvoidDangerousAreaSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZAvoidDangerousAreaSituation_SSituationSaveData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAvoidDangerousAreaGroups"];
	s_Object.m_aAvoidDangerousAreaGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aAvoidDangerousAreaGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZAvoidDangerousAreaSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerousAreaGroups, p_Serializer, p_OwnOffset + offsetof(ZAvoidDangerousAreaSituation_SSituationSaveData, m_aAvoidDangerousAreaGroups));
}

bool ZAvoidDangerousAreaSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZAvoidDangerousAreaSituation_SSituationSaveData::operator==(const ZAvoidDangerousAreaSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZAvoidDangerousAreaSituation_SSituationSaveData>)
		return false;

	if (m_aAvoidDangerousAreaGroups != p_Other.m_aAvoidDangerousAreaGroups) return false;

	return true;
}

void ZAvoidDangerousAreaSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZAvoidDangerousAreaSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZAvoidDangerousAreaSituation_SSituationSaveData();
}

ZHMTypeInfo ZComponentCreator::TypeInfo = ZHMTypeInfo("ZComponentCreator", sizeof(ZComponentCreator), alignof(ZComponentCreator), ZComponentCreator::WriteSimpleJson, ZComponentCreator::FromSimpleJson, ZComponentCreator::Serialize, ZComponentCreator::Equals, ZComponentCreator::Destroy);

void ZComponentCreator::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sComponentName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sComponentName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aArgs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aArgs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aArgs[i];
		ZVariant::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aArgs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZComponentCreator::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZComponentCreator s_Object {};

	s_Object.m_sComponentName = std::string_view(p_Document["m_sComponentName"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aArgs"];
	s_Object.m_aArgs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZVariant s_ArrayItem0;
		ZVariant::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aArgs[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZComponentCreator*>(p_Target) = s_Object;
}

void ZComponentCreator::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);

	ZString::Serialize(&s_Object->m_sComponentName, p_Serializer, p_OwnOffset + offsetof(ZComponentCreator, m_sComponentName));
	TArray<ZVariant>::Serialize(&s_Object->m_aArgs, p_Serializer, p_OwnOffset + offsetof(ZComponentCreator, m_aArgs));
}

bool ZComponentCreator::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZComponentCreator*>(p_Left);
	auto* s_Right = reinterpret_cast<ZComponentCreator*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZComponentCreator::operator==(const ZComponentCreator& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZComponentCreator>)
		return false;

	if (m_sComponentName != p_Other.m_sComponentName) return false;
	if (m_aArgs != p_Other.m_aArgs) return false;

	return true;
}

void ZComponentCreator::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZComponentCreator*>(p_Object);
	s_Object->~ZComponentCreator();
}

ZHMTypeInfo ZContractEvaluationContext::TypeInfo = ZHMTypeInfo("ZContractEvaluationContext", sizeof(ZContractEvaluationContext), alignof(ZContractEvaluationContext), ZContractEvaluationContext::WriteSimpleJson, ZContractEvaluationContext::FromSimpleJson, ZContractEvaluationContext::Serialize, ZContractEvaluationContext::Equals, ZContractEvaluationContext::Destroy);

void ZContractEvaluationContext::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZContractEvaluationContext::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZContractEvaluationContext s_Object {};

	*reinterpret_cast<ZContractEvaluationContext*>(p_Target) = s_Object;
}

void ZContractEvaluationContext::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);

}

bool ZContractEvaluationContext::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZContractEvaluationContext*>(p_Left);
	auto* s_Right = reinterpret_cast<ZContractEvaluationContext*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZContractEvaluationContext::operator==(const ZContractEvaluationContext& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZContractEvaluationContext>)
		return false;


	return true;
}

void ZContractEvaluationContext::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZContractEvaluationContext*>(p_Object);
	s_Object->~ZContractEvaluationContext();
}

ZHMTypeInfo ZCurve::TypeInfo = ZHMTypeInfo("ZCurve", sizeof(ZCurve), alignof(ZCurve), ZCurve::WriteSimpleJson, ZCurve::FromSimpleJson, ZCurve::Serialize, ZCurve::Equals, ZCurve::Destroy);

void ZCurve::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("data") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->data.size(); ++i)
	{
		auto& s_Item0 = s_Object->data[i];
		p_Stream << "[";
		for (size_t i = 0; i < s_Item0.size(); ++i)
		{
			auto& s_Item1 = s_Item0[i];
			p_Stream << simdjson::as_json_string(s_Item1);

			if (i < s_Item0.size() - 1)
				p_Stream << ",";
		}

		p_Stream << "]";

		if (i < s_Object->data.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZCurve::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZCurve s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["data"];
	s_Object.data.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		TFixedArray<float32, 8> s_ArrayItem0;
		{
		size_t s_Index1 = 0;
		for (simdjson::ondemand::value s_Item1 : s_Item0)
		{
			s_ArrayItem0[s_Index1] = simdjson::from_json_float32(s_Item1);
			++s_Index1;
		}
		}
		s_Object.data[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZCurve*>(p_Target) = s_Object;
}

void ZCurve::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);

	TArray<TFixedArray<float32, 8>>::Serialize(&s_Object->data, p_Serializer, p_OwnOffset + offsetof(ZCurve, data));
}

bool ZCurve::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZCurve*>(p_Left);
	auto* s_Right = reinterpret_cast<ZCurve*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZCurve::operator==(const ZCurve& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZCurve>)
		return false;

	if (data != p_Other.data) return false;

	return true;
}

void ZCurve::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZCurve*>(p_Object);
	s_Object->~ZCurve();
}

ZHMTypeInfo ZDeadBodySituation_SIncidentSaveData::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SIncidentSaveData", sizeof(ZDeadBodySituation_SIncidentSaveData), alignof(ZDeadBodySituation_SIncidentSaveData), ZDeadBodySituation_SIncidentSaveData::WriteSimpleJson, ZDeadBodySituation_SIncidentSaveData::FromSimpleJson, ZDeadBodySituation_SIncidentSaveData::Serialize, ZDeadBodySituation_SIncidentSaveData::Equals, ZDeadBodySituation_SIncidentSaveData::Destroy);

void ZDeadBodySituation_SIncidentSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_body") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_body);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAccident") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAccident);

	p_Stream << "}";
}

void ZDeadBodySituation_SIncidentSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDeadBodySituation_SIncidentSaveData s_Object {};

	s_Object.m_body = simdjson::from_json_uint32(p_Document["m_body"]);

	s_Object.m_bAccident = simdjson::from_json_bool(p_Document["m_bAccident"]);

	*reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Target) = s_Object;
}

void ZDeadBodySituation_SIncidentSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Object);

}

bool ZDeadBodySituation_SIncidentSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation_SIncidentSaveData::operator==(const ZDeadBodySituation_SIncidentSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation_SIncidentSaveData>)
		return false;

	if (m_body != p_Other.m_body) return false;
	if (m_bAccident != p_Other.m_bAccident) return false;

	return true;
}

void ZDeadBodySituation_SIncidentSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SIncidentSaveData*>(p_Object);
	s_Object->~ZDeadBodySituation_SIncidentSaveData();
}

ZHMTypeInfo ZDeadBodySituation_SState::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SState", sizeof(ZDeadBodySituation_SState), alignof(ZDeadBodySituation_SState), ZDeadBodySituation_SState::WriteSimpleJson, ZDeadBodySituation_SState::FromSimpleJson, ZDeadBodySituation_SState::Serialize, ZDeadBodySituation_SState::Equals, ZDeadBodySituation_SState::Destroy);

void ZDeadBodySituation_SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eFlavor") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZDeadBodySituation.ESituationFlavor", static_cast<int>(s_Object->m_eFlavor)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastEscalateOrder") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastEscalateOrder, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNextStanddownTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNextStanddownTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nSuspiciousDeaths") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nSuspiciousDeaths);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAcknowledged") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAcknowledged);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bInspected") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bInspected);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAccidentsResolved") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAccidentsResolved);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStanddownComplete") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStanddownComplete);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStandDownUnconscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandDownUnconscious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalateUnconscious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalateUnconscious);

	p_Stream << "}";
}

void ZDeadBodySituation_SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDeadBodySituation_SState s_Object {};

	s_Object.m_eFlavor = static_cast<ZDeadBodySituation_ESituationFlavor>(ZHMEnums::GetEnumValueByName("ZDeadBodySituation.ESituationFlavor", std::string_view(p_Document["m_eFlavor"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastEscalateOrder"], &s_Item);
		s_Object.m_tLastEscalateOrder = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tNextStanddownTime"], &s_Item);
		s_Object.m_tNextStanddownTime = s_Item;
	}

	s_Object.m_nSuspiciousDeaths = simdjson::from_json_int32(p_Document["m_nSuspiciousDeaths"]);

	s_Object.m_bAcknowledged = simdjson::from_json_bool(p_Document["m_bAcknowledged"]);

	s_Object.m_bInspected = simdjson::from_json_bool(p_Document["m_bInspected"]);

	s_Object.m_bAccidentsResolved = simdjson::from_json_bool(p_Document["m_bAccidentsResolved"]);

	s_Object.m_bStanddownComplete = simdjson::from_json_bool(p_Document["m_bStanddownComplete"]);

	s_Object.m_bStandDownUnconscious = simdjson::from_json_bool(p_Document["m_bStandDownUnconscious"]);

	s_Object.m_bEscalateUnconscious = simdjson::from_json_bool(p_Document["m_bEscalateUnconscious"]);

	*reinterpret_cast<ZDeadBodySituation_SState*>(p_Target) = s_Object;
}

void ZDeadBodySituation_SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tLastEscalateOrder, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation_SState, m_tLastEscalateOrder));
	ZGameTime::Serialize(&s_Object->m_tNextStanddownTime, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation_SState, m_tNextStanddownTime));
}

bool ZDeadBodySituation_SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation_SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation_SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation_SState::operator==(const ZDeadBodySituation_SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation_SState>)
		return false;

	if (m_eFlavor != p_Other.m_eFlavor) return false;
	if (m_tLastEscalateOrder != p_Other.m_tLastEscalateOrder) return false;
	if (m_tNextStanddownTime != p_Other.m_tNextStanddownTime) return false;
	if (m_nSuspiciousDeaths != p_Other.m_nSuspiciousDeaths) return false;
	if (m_bAcknowledged != p_Other.m_bAcknowledged) return false;
	if (m_bInspected != p_Other.m_bInspected) return false;
	if (m_bAccidentsResolved != p_Other.m_bAccidentsResolved) return false;
	if (m_bStanddownComplete != p_Other.m_bStanddownComplete) return false;
	if (m_bStandDownUnconscious != p_Other.m_bStandDownUnconscious) return false;
	if (m_bEscalateUnconscious != p_Other.m_bEscalateUnconscious) return false;

	return true;
}

void ZDeadBodySituation_SState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SState*>(p_Object);
	s_Object->~ZDeadBodySituation_SState();
}

ZHMTypeInfo ZDeadBodySituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDeadBodySituation.SSituationSaveData", sizeof(ZDeadBodySituation_SSituationSaveData), alignof(ZDeadBodySituation_SSituationSaveData), ZDeadBodySituation_SSituationSaveData::WriteSimpleJson, ZDeadBodySituation_SSituationSaveData::FromSimpleJson, ZDeadBodySituation_SSituationSaveData::Serialize, ZDeadBodySituation_SSituationSaveData::Equals, ZDeadBodySituation_SSituationSaveData::Destroy);

void ZDeadBodySituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZDeadBodySituation_SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aIncidents") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aIncidents.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aIncidents[i];
		ZDeadBodySituation_SIncidentSaveData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aIncidents.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pObserversGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pObserversGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pCivilianObserversGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pCivilianObserversGroup);

	p_Stream << "}";
}

void ZDeadBodySituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDeadBodySituation_SSituationSaveData s_Object {};

	{
		ZDeadBodySituation_SState s_Item {};
		ZDeadBodySituation_SState::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aIncidents"];
	s_Object.m_aIncidents.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZDeadBodySituation_SIncidentSaveData s_ArrayItem0;
		ZDeadBodySituation_SIncidentSaveData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aIncidents[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	s_Object.m_pObserversGroup = simdjson::from_json_int32(p_Document["m_pObserversGroup"]);

	s_Object.m_pCivilianObserversGroup = simdjson::from_json_int32(p_Document["m_pCivilianObserversGroup"]);

	*reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZDeadBodySituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Object);

	ZDeadBodySituation_SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation_SSituationSaveData, m_State));
	TArray<ZDeadBodySituation_SIncidentSaveData>::Serialize(&s_Object->m_aIncidents, p_Serializer, p_OwnOffset + offsetof(ZDeadBodySituation_SSituationSaveData, m_aIncidents));
}

bool ZDeadBodySituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDeadBodySituation_SSituationSaveData::operator==(const ZDeadBodySituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDeadBodySituation_SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_aIncidents != p_Other.m_aIncidents) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_pObserversGroup != p_Other.m_pObserversGroup) return false;
	if (m_pCivilianObserversGroup != p_Other.m_pCivilianObserversGroup) return false;

	return true;
}

void ZDeadBodySituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDeadBodySituation_SSituationSaveData*>(p_Object);
	s_Object->~ZDeadBodySituation_SSituationSaveData();
}

ZHMTypeInfo ZDetectedInPrivateSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDetectedInPrivateSituation.SSituationSaveData", sizeof(ZDetectedInPrivateSituation_SSituationSaveData), alignof(ZDetectedInPrivateSituation_SSituationSaveData), ZDetectedInPrivateSituation_SSituationSaveData::WriteSimpleJson, ZDetectedInPrivateSituation_SSituationSaveData::FromSimpleJson, ZDetectedInPrivateSituation_SSituationSaveData::Serialize, ZDetectedInPrivateSituation_SSituationSaveData::Equals, ZDetectedInPrivateSituation_SSituationSaveData::Destroy);

void ZDetectedInPrivateSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pDetectedInPrivateGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pDetectedInPrivateGroup);

	p_Stream << "}";
}

void ZDetectedInPrivateSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDetectedInPrivateSituation_SSituationSaveData s_Object {};

	s_Object.m_pDetectedInPrivateGroup = simdjson::from_json_int32(p_Document["m_pDetectedInPrivateGroup"]);

	*reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZDetectedInPrivateSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Object);

}

bool ZDetectedInPrivateSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDetectedInPrivateSituation_SSituationSaveData::operator==(const ZDetectedInPrivateSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDetectedInPrivateSituation_SSituationSaveData>)
		return false;

	if (m_pDetectedInPrivateGroup != p_Other.m_pDetectedInPrivateGroup) return false;

	return true;
}

void ZDetectedInPrivateSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDetectedInPrivateSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZDetectedInPrivateSituation_SSituationSaveData();
}

ZHMTypeInfo ZDialogEventItemTypedIndex::TypeInfo = ZHMTypeInfo("ZDialogEventItemTypedIndex", sizeof(ZDialogEventItemTypedIndex), alignof(ZDialogEventItemTypedIndex), ZDialogEventItemTypedIndex::WriteSimpleJson, ZDialogEventItemTypedIndex::FromSimpleJson, ZDialogEventItemTypedIndex::Serialize, ZDialogEventItemTypedIndex::Equals, ZDialogEventItemTypedIndex::Destroy);

void ZDialogEventItemTypedIndex::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZDialogEventItemTypedIndex::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDialogEventItemTypedIndex s_Object {};

	*reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Target) = s_Object;
}

void ZDialogEventItemTypedIndex::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);

}

bool ZDialogEventItemTypedIndex::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDialogEventItemTypedIndex::operator==(const ZDialogEventItemTypedIndex& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDialogEventItemTypedIndex>)
		return false;


	return true;
}

void ZDialogEventItemTypedIndex::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDialogEventItemTypedIndex*>(p_Object);
	s_Object->~ZDialogEventItemTypedIndex();
}

ZHMTypeInfo ZDisguiseSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZDisguiseSituation.SSituationSaveData", sizeof(ZDisguiseSituation_SSituationSaveData), alignof(ZDisguiseSituation_SSituationSaveData), ZDisguiseSituation_SSituationSaveData::WriteSimpleJson, ZDisguiseSituation_SSituationSaveData::FromSimpleJson, ZDisguiseSituation_SSituationSaveData::Serialize, ZDisguiseSituation_SSituationSaveData::Equals, ZDisguiseSituation_SSituationSaveData::Destroy);

void ZDisguiseSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pLeader") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pLeader);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aInvestigateDisguiseGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aInvestigateDisguiseGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aInvestigateDisguiseGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aInvestigateDisguiseGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eEventSetOnEscalation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EAISharedEventType", static_cast<int>(s_Object->m_eEventSetOnEscalation)));

	p_Stream << "}";
}

void ZDisguiseSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDisguiseSituation_SSituationSaveData s_Object {};

	s_Object.m_pLeader = simdjson::from_json_uint32(p_Document["m_pLeader"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aInvestigateDisguiseGroups"];
	s_Object.m_aInvestigateDisguiseGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aInvestigateDisguiseGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	s_Object.m_eEventSetOnEscalation = static_cast<EAISharedEventType>(ZHMEnums::GetEnumValueByName("EAISharedEventType", std::string_view(p_Document["m_eEventSetOnEscalation"])));

	*reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZDisguiseSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aInvestigateDisguiseGroups, p_Serializer, p_OwnOffset + offsetof(ZDisguiseSituation_SSituationSaveData, m_aInvestigateDisguiseGroups));
}

bool ZDisguiseSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDisguiseSituation_SSituationSaveData::operator==(const ZDisguiseSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDisguiseSituation_SSituationSaveData>)
		return false;

	if (m_pLeader != p_Other.m_pLeader) return false;
	if (m_aInvestigateDisguiseGroups != p_Other.m_aInvestigateDisguiseGroups) return false;
	if (m_eEventSetOnEscalation != p_Other.m_eEventSetOnEscalation) return false;

	return true;
}

void ZDisguiseSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDisguiseSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZDisguiseSituation_SSituationSaveData();
}

ZHMTypeInfo ZDynamicObject_SArrayTypesRegistrar::TypeInfo = ZHMTypeInfo("ZDynamicObject.SArrayTypesRegistrar", sizeof(ZDynamicObject_SArrayTypesRegistrar), alignof(ZDynamicObject_SArrayTypesRegistrar), ZDynamicObject_SArrayTypesRegistrar::WriteSimpleJson, ZDynamicObject_SArrayTypesRegistrar::FromSimpleJson, ZDynamicObject_SArrayTypesRegistrar::Serialize, ZDynamicObject_SArrayTypesRegistrar::Equals, ZDynamicObject_SArrayTypesRegistrar::Destroy);

void ZDynamicObject_SArrayTypesRegistrar::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("_dummy") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->_dummy.size(); ++i)
	{
		auto& s_Item0 = s_Object->_dummy[i];
		SDynamicObjectKeyValuePair::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->_dummy.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("_dummy2") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->_dummy2.size(); ++i)
	{
		auto& s_Item0 = s_Object->_dummy2[i];
		ZDynamicObject::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->_dummy2.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZDynamicObject_SArrayTypesRegistrar::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZDynamicObject_SArrayTypesRegistrar s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["_dummy"];
	s_Object._dummy.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SDynamicObjectKeyValuePair s_ArrayItem0;
		SDynamicObjectKeyValuePair::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object._dummy[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["_dummy2"];
	s_Object._dummy2.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZDynamicObject s_ArrayItem0;
		ZDynamicObject::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object._dummy2[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Target) = s_Object;
}

void ZDynamicObject_SArrayTypesRegistrar::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Object);

	TArray<SDynamicObjectKeyValuePair>::Serialize(&s_Object->_dummy, p_Serializer, p_OwnOffset + offsetof(ZDynamicObject_SArrayTypesRegistrar, _dummy));
	TArray<ZDynamicObject>::Serialize(&s_Object->_dummy2, p_Serializer, p_OwnOffset + offsetof(ZDynamicObject_SArrayTypesRegistrar, _dummy2));
}

bool ZDynamicObject_SArrayTypesRegistrar::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Left);
	auto* s_Right = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZDynamicObject_SArrayTypesRegistrar::operator==(const ZDynamicObject_SArrayTypesRegistrar& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZDynamicObject_SArrayTypesRegistrar>)
		return false;

	if (_dummy != p_Other._dummy) return false;
	if (_dummy2 != p_Other._dummy2) return false;

	return true;
}

void ZDynamicObject_SArrayTypesRegistrar::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZDynamicObject_SArrayTypesRegistrar*>(p_Object);
	s_Object->~ZDynamicObject_SArrayTypesRegistrar();
}

ZHMTypeInfo ZER64::TypeInfo = ZHMTypeInfo("ZER64", sizeof(ZER64), alignof(ZER64), ZER64::WriteSimpleJson, ZER64::FromSimpleJson, ZER64::Serialize, ZER64::Equals, ZER64::Destroy);

void ZER64::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEntityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nEntityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);

	p_Stream << "}";
}

void ZER64::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZER64 s_Object {};

	s_Object.m_nEntityID = simdjson::from_json_uint64(p_Document["m_nEntityID"]);

	s_Object.m_sExposedEntity = std::string_view(p_Document["m_sExposedEntity"]);

	*reinterpret_cast<ZER64*>(p_Target) = s_Object;
}

void ZER64::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);

	ZString::Serialize(&s_Object->m_sExposedEntity, p_Serializer, p_OwnOffset + offsetof(ZER64, m_sExposedEntity));
}

bool ZER64::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZER64*>(p_Left);
	auto* s_Right = reinterpret_cast<ZER64*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZER64::operator==(const ZER64& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZER64>)
		return false;

	if (m_nEntityID != p_Other.m_nEntityID) return false;
	if (m_sExposedEntity != p_Other.m_sExposedEntity) return false;

	return true;
}

void ZER64::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZER64*>(p_Object);
	s_Object->~ZER64();
}

ZHMTypeInfo ZEntityID::TypeInfo = ZHMTypeInfo("ZEntityID", sizeof(ZEntityID), alignof(ZEntityID), ZEntityID::WriteSimpleJson, ZEntityID::FromSimpleJson, ZEntityID::Serialize, ZEntityID::Equals, ZEntityID::Destroy);

void ZEntityID::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sStr") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sStr);

	p_Stream << "}";
}

void ZEntityID::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityID s_Object {};

	s_Object.m_sStr = std::string_view(p_Document["m_sStr"]);

	*reinterpret_cast<ZEntityID*>(p_Target) = s_Object;
}

void ZEntityID::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);

	ZString::Serialize(&s_Object->m_sStr, p_Serializer, p_OwnOffset + offsetof(ZEntityID, m_sStr));
}

bool ZEntityID::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityID*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityID*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityID::operator==(const ZEntityID& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityID>)
		return false;

	if (m_sStr != p_Other.m_sStr) return false;

	return true;
}

void ZEntityID::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEntityID*>(p_Object);
	s_Object->~ZEntityID();
}

ZHMTypeInfo ZEntityPath::TypeInfo = ZHMTypeInfo("ZEntityPath", sizeof(ZEntityPath), alignof(ZEntityPath), ZEntityPath::WriteSimpleJson, ZEntityPath::FromSimpleJson, ZEntityPath::Serialize, ZEntityPath::Equals, ZEntityPath::Destroy);

void ZEntityPath::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityPath*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZEntityPath::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityPath s_Object {};

	*reinterpret_cast<ZEntityPath*>(p_Target) = s_Object;
}

void ZEntityPath::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityPath*>(p_Object);

}

bool ZEntityPath::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityPath*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityPath*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityPath::operator==(const ZEntityPath& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityPath>)
		return false;


	return true;
}

void ZEntityPath::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEntityPath*>(p_Object);
	s_Object->~ZEntityPath();
}

ZHMTypeInfo ZEntityRef::TypeInfo = ZHMTypeInfo("ZEntityRef", sizeof(ZEntityRef), alignof(ZEntityRef), ZEntityRef::WriteSimpleJson, ZEntityRef::FromSimpleJson, ZEntityRef::Serialize, ZEntityRef::Equals, ZEntityRef::Destroy);

void ZEntityRef::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZEntityRef::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityRef s_Object {};

	*reinterpret_cast<ZEntityRef*>(p_Target) = s_Object;
}

void ZEntityRef::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);

}

bool ZEntityRef::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityRef*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityRef*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityRef::operator==(const ZEntityRef& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityRef>)
		return false;


	return true;
}

void ZEntityRef::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEntityRef*>(p_Object);
	s_Object->~ZEntityRef();
}

ZHMTypeInfo ZEntityReference::TypeInfo = ZHMTypeInfo("ZEntityReference", sizeof(ZEntityReference), alignof(ZEntityReference), ZEntityReference::WriteSimpleJson, ZEntityReference::FromSimpleJson, ZEntityReference::Serialize, ZEntityReference::Equals, ZEntityReference::Destroy);

void ZEntityReference::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_EntityID") << ":";
	ZEntityID::WriteSimpleJson(&s_Object->m_EntityID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sExposedEntity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sExposedEntity);

	p_Stream << "}";
}

void ZEntityReference::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEntityReference s_Object {};

	{
		ZEntityID s_Item {};
		ZEntityID::FromSimpleJson(p_Document["m_EntityID"], &s_Item);
		s_Object.m_EntityID = s_Item;
	}

	s_Object.m_sExposedEntity = std::string_view(p_Document["m_sExposedEntity"]);

	*reinterpret_cast<ZEntityReference*>(p_Target) = s_Object;
}

void ZEntityReference::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);

	ZEntityID::Serialize(&s_Object->m_EntityID, p_Serializer, p_OwnOffset + offsetof(ZEntityReference, m_EntityID));
	ZString::Serialize(&s_Object->m_sExposedEntity, p_Serializer, p_OwnOffset + offsetof(ZEntityReference, m_sExposedEntity));
}

bool ZEntityReference::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEntityReference*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEntityReference*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEntityReference::operator==(const ZEntityReference& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEntityReference>)
		return false;

	if (m_EntityID != p_Other.m_EntityID) return false;
	if (m_sExposedEntity != p_Other.m_sExposedEntity) return false;

	return true;
}

void ZEntityReference::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEntityReference*>(p_Object);
	s_Object->~ZEntityReference();
}

ZHMTypeInfo ZEvergreenCampaignActivatorDataProvider_STerritoryData::TypeInfo = ZHMTypeInfo("ZEvergreenCampaignActivatorDataProvider.STerritoryData", sizeof(ZEvergreenCampaignActivatorDataProvider_STerritoryData), alignof(ZEvergreenCampaignActivatorDataProvider_STerritoryData), ZEvergreenCampaignActivatorDataProvider_STerritoryData::WriteSimpleJson, ZEvergreenCampaignActivatorDataProvider_STerritoryData::FromSimpleJson, ZEvergreenCampaignActivatorDataProvider_STerritoryData::Serialize, ZEvergreenCampaignActivatorDataProvider_STerritoryData::Equals, ZEvergreenCampaignActivatorDataProvider_STerritoryData::Destroy);

void ZEvergreenCampaignActivatorDataProvider_STerritoryData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_STerritoryData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("lstrDestinationCity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrDestinationCity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrDestinationCountry") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrDestinationCountry);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrDestinationFullName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrDestinationFullName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nSuppliers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSuppliers);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nMules") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nMules);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nSafes") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSafes);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nTargets") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nTargets);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isAlerted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isAlerted);

	p_Stream << "}";
}

void ZEvergreenCampaignActivatorDataProvider_STerritoryData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEvergreenCampaignActivatorDataProvider_STerritoryData s_Object {};

	s_Object.lstrDestinationCity = std::string_view(p_Document["lstrDestinationCity"]);

	s_Object.lstrDestinationCountry = std::string_view(p_Document["lstrDestinationCountry"]);

	s_Object.lstrDestinationFullName = std::string_view(p_Document["lstrDestinationFullName"]);

	s_Object.nSuppliers = simdjson::from_json_int32(p_Document["nSuppliers"]);

	s_Object.nMules = simdjson::from_json_int32(p_Document["nMules"]);

	s_Object.nSafes = simdjson::from_json_int32(p_Document["nSafes"]);

	s_Object.nTargets = simdjson::from_json_int32(p_Document["nTargets"]);

	s_Object.isAlerted = simdjson::from_json_bool(p_Document["isAlerted"]);

	*reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_STerritoryData*>(p_Target) = s_Object;
}

void ZEvergreenCampaignActivatorDataProvider_STerritoryData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_STerritoryData*>(p_Object);

	ZString::Serialize(&s_Object->lstrDestinationCity, p_Serializer, p_OwnOffset + offsetof(ZEvergreenCampaignActivatorDataProvider_STerritoryData, lstrDestinationCity));
	ZString::Serialize(&s_Object->lstrDestinationCountry, p_Serializer, p_OwnOffset + offsetof(ZEvergreenCampaignActivatorDataProvider_STerritoryData, lstrDestinationCountry));
	ZString::Serialize(&s_Object->lstrDestinationFullName, p_Serializer, p_OwnOffset + offsetof(ZEvergreenCampaignActivatorDataProvider_STerritoryData, lstrDestinationFullName));
}

bool ZEvergreenCampaignActivatorDataProvider_STerritoryData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_STerritoryData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_STerritoryData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEvergreenCampaignActivatorDataProvider_STerritoryData::operator==(const ZEvergreenCampaignActivatorDataProvider_STerritoryData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEvergreenCampaignActivatorDataProvider_STerritoryData>)
		return false;

	if (lstrDestinationCity != p_Other.lstrDestinationCity) return false;
	if (lstrDestinationCountry != p_Other.lstrDestinationCountry) return false;
	if (lstrDestinationFullName != p_Other.lstrDestinationFullName) return false;
	if (nSuppliers != p_Other.nSuppliers) return false;
	if (nMules != p_Other.nMules) return false;
	if (nSafes != p_Other.nSafes) return false;
	if (nTargets != p_Other.nTargets) return false;
	if (isAlerted != p_Other.isAlerted) return false;

	return true;
}

void ZEvergreenCampaignActivatorDataProvider_STerritoryData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_STerritoryData*>(p_Object);
	s_Object->~ZEvergreenCampaignActivatorDataProvider_STerritoryData();
}

ZHMTypeInfo ZEvergreenCampaignActivatorDataProvider_SCampaignData::TypeInfo = ZHMTypeInfo("ZEvergreenCampaignActivatorDataProvider.SCampaignData", sizeof(ZEvergreenCampaignActivatorDataProvider_SCampaignData), alignof(ZEvergreenCampaignActivatorDataProvider_SCampaignData), ZEvergreenCampaignActivatorDataProvider_SCampaignData::WriteSimpleJson, ZEvergreenCampaignActivatorDataProvider_SCampaignData::FromSimpleJson, ZEvergreenCampaignActivatorDataProvider_SCampaignData::Serialize, ZEvergreenCampaignActivatorDataProvider_SCampaignData::Equals, ZEvergreenCampaignActivatorDataProvider_SCampaignData::Destroy);

void ZEvergreenCampaignActivatorDataProvider_SCampaignData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_SCampaignData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("lstrCampaignName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrCampaignName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrFactionLieutenantCodename") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrFactionLieutenantCodename);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrBiography") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrBiography);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ridCampaignIcon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->ridCampaignIcon, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nDifficultyRank") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nDifficultyRank);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mercesDeposit") << ":";
	p_Stream << simdjson::as_json_string(s_Object->mercesDeposit);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mercesPayoutBase") << ":";
	p_Stream << simdjson::as_json_string(s_Object->mercesPayoutBase);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("territories") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->territories.size(); ++i)
	{
		auto& s_Item0 = s_Object->territories[i];
		ZEvergreenCampaignActivatorDataProvider_STerritoryData::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->territories.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZEvergreenCampaignActivatorDataProvider_SCampaignData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEvergreenCampaignActivatorDataProvider_SCampaignData s_Object {};

	s_Object.lstrCampaignName = std::string_view(p_Document["lstrCampaignName"]);

	s_Object.lstrFactionLieutenantCodename = std::string_view(p_Document["lstrFactionLieutenantCodename"]);

	s_Object.lstrBiography = std::string_view(p_Document["lstrBiography"]);

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["ridCampaignIcon"], &s_Item);
		s_Object.ridCampaignIcon = s_Item;
	}

	s_Object.nDifficultyRank = simdjson::from_json_int32(p_Document["nDifficultyRank"]);

	s_Object.mercesDeposit = simdjson::from_json_int32(p_Document["mercesDeposit"]);

	s_Object.mercesPayoutBase = simdjson::from_json_int32(p_Document["mercesPayoutBase"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["territories"];
	s_Object.territories.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZEvergreenCampaignActivatorDataProvider_STerritoryData s_ArrayItem0;
		ZEvergreenCampaignActivatorDataProvider_STerritoryData::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.territories[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_SCampaignData*>(p_Target) = s_Object;
}

void ZEvergreenCampaignActivatorDataProvider_SCampaignData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_SCampaignData*>(p_Object);

	ZString::Serialize(&s_Object->lstrCampaignName, p_Serializer, p_OwnOffset + offsetof(ZEvergreenCampaignActivatorDataProvider_SCampaignData, lstrCampaignName));
	ZString::Serialize(&s_Object->lstrFactionLieutenantCodename, p_Serializer, p_OwnOffset + offsetof(ZEvergreenCampaignActivatorDataProvider_SCampaignData, lstrFactionLieutenantCodename));
	ZString::Serialize(&s_Object->lstrBiography, p_Serializer, p_OwnOffset + offsetof(ZEvergreenCampaignActivatorDataProvider_SCampaignData, lstrBiography));
	ZRuntimeResourceID::Serialize(&s_Object->ridCampaignIcon, p_Serializer, p_OwnOffset + offsetof(ZEvergreenCampaignActivatorDataProvider_SCampaignData, ridCampaignIcon));
	TArray<ZEvergreenCampaignActivatorDataProvider_STerritoryData>::Serialize(&s_Object->territories, p_Serializer, p_OwnOffset + offsetof(ZEvergreenCampaignActivatorDataProvider_SCampaignData, territories));
}

bool ZEvergreenCampaignActivatorDataProvider_SCampaignData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_SCampaignData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_SCampaignData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEvergreenCampaignActivatorDataProvider_SCampaignData::operator==(const ZEvergreenCampaignActivatorDataProvider_SCampaignData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEvergreenCampaignActivatorDataProvider_SCampaignData>)
		return false;

	if (lstrCampaignName != p_Other.lstrCampaignName) return false;
	if (lstrFactionLieutenantCodename != p_Other.lstrFactionLieutenantCodename) return false;
	if (lstrBiography != p_Other.lstrBiography) return false;
	if (ridCampaignIcon != p_Other.ridCampaignIcon) return false;
	if (nDifficultyRank != p_Other.nDifficultyRank) return false;
	if (mercesDeposit != p_Other.mercesDeposit) return false;
	if (mercesPayoutBase != p_Other.mercesPayoutBase) return false;
	if (territories != p_Other.territories) return false;

	return true;
}

void ZEvergreenCampaignActivatorDataProvider_SCampaignData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEvergreenCampaignActivatorDataProvider_SCampaignData*>(p_Object);
	s_Object->~ZEvergreenCampaignActivatorDataProvider_SCampaignData();
}

ZHMTypeInfo ZEvergreenMenuController_SPromptsData::TypeInfo = ZHMTypeInfo("ZEvergreenMenuController.SPromptsData", sizeof(ZEvergreenMenuController_SPromptsData), alignof(ZEvergreenMenuController_SPromptsData), ZEvergreenMenuController_SPromptsData::WriteSimpleJson, ZEvergreenMenuController_SPromptsData::FromSimpleJson, ZEvergreenMenuController_SPromptsData::Serialize, ZEvergreenMenuController_SPromptsData::Equals, ZEvergreenMenuController_SPromptsData::Destroy);

void ZEvergreenMenuController_SPromptsData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEvergreenMenuController_SPromptsData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("buttonprompts") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->buttonprompts.size(); ++i)
	{
		auto& s_Item0 = s_Object->buttonprompts[i];
		SEvergreenMenuPromptDesc::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->buttonprompts.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZEvergreenMenuController_SPromptsData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEvergreenMenuController_SPromptsData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["buttonprompts"];
	s_Object.buttonprompts.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		SEvergreenMenuPromptDesc s_ArrayItem0;
		SEvergreenMenuPromptDesc::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.buttonprompts[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZEvergreenMenuController_SPromptsData*>(p_Target) = s_Object;
}

void ZEvergreenMenuController_SPromptsData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEvergreenMenuController_SPromptsData*>(p_Object);

	TArray<SEvergreenMenuPromptDesc>::Serialize(&s_Object->buttonprompts, p_Serializer, p_OwnOffset + offsetof(ZEvergreenMenuController_SPromptsData, buttonprompts));
}

bool ZEvergreenMenuController_SPromptsData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEvergreenMenuController_SPromptsData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEvergreenMenuController_SPromptsData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEvergreenMenuController_SPromptsData::operator==(const ZEvergreenMenuController_SPromptsData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEvergreenMenuController_SPromptsData>)
		return false;

	if (buttonprompts != p_Other.buttonprompts) return false;

	return true;
}

void ZEvergreenMenuController_SPromptsData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEvergreenMenuController_SPromptsData*>(p_Object);
	s_Object->~ZEvergreenMenuController_SPromptsData();
}

ZHMTypeInfo ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::TypeInfo = ZHMTypeInfo("ZEvergreenWorldMapTerritoryDataProvider.SBonusRequirement", sizeof(ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement), alignof(ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement), ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::WriteSimpleJson, ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::FromSimpleJson, ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::Serialize, ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::Equals, ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::Destroy);

void ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("lstrTitle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrTitle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("icon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->icon);

	p_Stream << "}";
}

void ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement s_Object {};

	s_Object.lstrTitle = std::string_view(p_Document["lstrTitle"]);

	s_Object.icon = std::string_view(p_Document["icon"]);

	*reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement*>(p_Target) = s_Object;
}

void ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement*>(p_Object);

	ZString::Serialize(&s_Object->lstrTitle, p_Serializer, p_OwnOffset + offsetof(ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement, lstrTitle));
	ZString::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement, icon));
}

bool ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::operator==(const ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement>)
		return false;

	if (lstrTitle != p_Other.lstrTitle) return false;
	if (icon != p_Other.icon) return false;

	return true;
}

void ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement*>(p_Object);
	s_Object->~ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement();
}

ZHMTypeInfo ZEvergreenWorldMapTerritoryDataProvider_SData::TypeInfo = ZHMTypeInfo("ZEvergreenWorldMapTerritoryDataProvider.SData", sizeof(ZEvergreenWorldMapTerritoryDataProvider_SData), alignof(ZEvergreenWorldMapTerritoryDataProvider_SData), ZEvergreenWorldMapTerritoryDataProvider_SData::WriteSimpleJson, ZEvergreenWorldMapTerritoryDataProvider_SData::FromSimpleJson, ZEvergreenWorldMapTerritoryDataProvider_SData::Serialize, ZEvergreenWorldMapTerritoryDataProvider_SData::Equals, ZEvergreenWorldMapTerritoryDataProvider_SData::Destroy);

void ZEvergreenWorldMapTerritoryDataProvider_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("isInCampaign") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isInCampaign);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isSelectedInMenu") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isSelectedInMenu);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isMenuZoomedIn") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isMenuZoomedIn);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrDestinationCity") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrDestinationCity);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrDestinationCountry") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrDestinationCountry);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrDestinationFullName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrDestinationFullName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("mercesPayout") << ":";
	p_Stream << simdjson::as_json_string(s_Object->mercesPayout);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nSuppliers") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSuppliers);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nMules") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nMules);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nSafes") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nSafes);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nTargets") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nTargets);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isAlerted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isAlerted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("visited") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZEvergreenWorldMapTerritoryDataProvider.EVisited", static_cast<int>(s_Object->visited)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isHotMission") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isHotMission);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isThisSelectedToTravelNext") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isThisSelectedToTravelNext);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isAnotherSelectedToTravelNext") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isAnotherSelectedToTravelNext);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bonusRequirements") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->bonusRequirements.size(); ++i)
	{
		auto& s_Item0 = s_Object->bonusRequirements[i];
		ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->bonusRequirements.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZEvergreenWorldMapTerritoryDataProvider_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZEvergreenWorldMapTerritoryDataProvider_SData s_Object {};

	s_Object.isInCampaign = simdjson::from_json_bool(p_Document["isInCampaign"]);

	s_Object.isSelectedInMenu = simdjson::from_json_bool(p_Document["isSelectedInMenu"]);

	s_Object.isMenuZoomedIn = simdjson::from_json_bool(p_Document["isMenuZoomedIn"]);

	s_Object.lstrDestinationCity = std::string_view(p_Document["lstrDestinationCity"]);

	s_Object.lstrDestinationCountry = std::string_view(p_Document["lstrDestinationCountry"]);

	s_Object.lstrDestinationFullName = std::string_view(p_Document["lstrDestinationFullName"]);

	s_Object.mercesPayout = simdjson::from_json_int32(p_Document["mercesPayout"]);

	s_Object.nSuppliers = simdjson::from_json_int32(p_Document["nSuppliers"]);

	s_Object.nMules = simdjson::from_json_int32(p_Document["nMules"]);

	s_Object.nSafes = simdjson::from_json_int32(p_Document["nSafes"]);

	s_Object.nTargets = simdjson::from_json_int32(p_Document["nTargets"]);

	s_Object.isAlerted = simdjson::from_json_bool(p_Document["isAlerted"]);

	s_Object.visited = static_cast<ZEvergreenWorldMapTerritoryDataProvider_EVisited>(ZHMEnums::GetEnumValueByName("ZEvergreenWorldMapTerritoryDataProvider.EVisited", std::string_view(p_Document["visited"])));

	s_Object.isHotMission = simdjson::from_json_bool(p_Document["isHotMission"]);

	s_Object.isThisSelectedToTravelNext = simdjson::from_json_bool(p_Document["isThisSelectedToTravelNext"]);

	s_Object.isAnotherSelectedToTravelNext = simdjson::from_json_bool(p_Document["isAnotherSelectedToTravelNext"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["bonusRequirements"];
	s_Object.bonusRequirements.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement s_ArrayItem0;
		ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.bonusRequirements[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SData*>(p_Target) = s_Object;
}

void ZEvergreenWorldMapTerritoryDataProvider_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SData*>(p_Object);

	ZString::Serialize(&s_Object->lstrDestinationCity, p_Serializer, p_OwnOffset + offsetof(ZEvergreenWorldMapTerritoryDataProvider_SData, lstrDestinationCity));
	ZString::Serialize(&s_Object->lstrDestinationCountry, p_Serializer, p_OwnOffset + offsetof(ZEvergreenWorldMapTerritoryDataProvider_SData, lstrDestinationCountry));
	ZString::Serialize(&s_Object->lstrDestinationFullName, p_Serializer, p_OwnOffset + offsetof(ZEvergreenWorldMapTerritoryDataProvider_SData, lstrDestinationFullName));
	TArray<ZEvergreenWorldMapTerritoryDataProvider_SBonusRequirement>::Serialize(&s_Object->bonusRequirements, p_Serializer, p_OwnOffset + offsetof(ZEvergreenWorldMapTerritoryDataProvider_SData, bonusRequirements));
}

bool ZEvergreenWorldMapTerritoryDataProvider_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZEvergreenWorldMapTerritoryDataProvider_SData::operator==(const ZEvergreenWorldMapTerritoryDataProvider_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZEvergreenWorldMapTerritoryDataProvider_SData>)
		return false;

	if (isInCampaign != p_Other.isInCampaign) return false;
	if (isSelectedInMenu != p_Other.isSelectedInMenu) return false;
	if (isMenuZoomedIn != p_Other.isMenuZoomedIn) return false;
	if (lstrDestinationCity != p_Other.lstrDestinationCity) return false;
	if (lstrDestinationCountry != p_Other.lstrDestinationCountry) return false;
	if (lstrDestinationFullName != p_Other.lstrDestinationFullName) return false;
	if (mercesPayout != p_Other.mercesPayout) return false;
	if (nSuppliers != p_Other.nSuppliers) return false;
	if (nMules != p_Other.nMules) return false;
	if (nSafes != p_Other.nSafes) return false;
	if (nTargets != p_Other.nTargets) return false;
	if (isAlerted != p_Other.isAlerted) return false;
	if (visited != p_Other.visited) return false;
	if (isHotMission != p_Other.isHotMission) return false;
	if (isThisSelectedToTravelNext != p_Other.isThisSelectedToTravelNext) return false;
	if (isAnotherSelectedToTravelNext != p_Other.isAnotherSelectedToTravelNext) return false;
	if (bonusRequirements != p_Other.bonusRequirements) return false;

	return true;
}

void ZEvergreenWorldMapTerritoryDataProvider_SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZEvergreenWorldMapTerritoryDataProvider_SData*>(p_Object);
	s_Object->~ZEvergreenWorldMapTerritoryDataProvider_SData();
}

ZHMTypeInfo ZFormationMoveOrder_SFormationMoveOrderSaveData::TypeInfo = ZHMTypeInfo("ZFormationMoveOrder.SFormationMoveOrderSaveData", sizeof(ZFormationMoveOrder_SFormationMoveOrderSaveData), alignof(ZFormationMoveOrder_SFormationMoveOrderSaveData), ZFormationMoveOrder_SFormationMoveOrderSaveData::WriteSimpleJson, ZFormationMoveOrder_SFormationMoveOrderSaveData::FromSimpleJson, ZFormationMoveOrder_SFormationMoveOrderSaveData::Serialize, ZFormationMoveOrder_SFormationMoveOrderSaveData::Equals, ZFormationMoveOrder_SFormationMoveOrderSaveData::Destroy);

void ZFormationMoveOrder_SFormationMoveOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleBlockageFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleBlockageFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EMoveSpeed", static_cast<int>(s_Object->m_eMoveSpeed)));

	p_Stream << "}";
}

void ZFormationMoveOrder_SFormationMoveOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZFormationMoveOrder_SFormationMoveOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Item);
		s_Object.m_vStopDirection = s_Item;
	}

	s_Object.m_nObstacleBlockageFlags = simdjson::from_json_uint32(p_Document["m_nObstacleBlockageFlags"]);

	s_Object.m_eMoveSpeed = static_cast<EMoveSpeed>(ZHMEnums::GetEnumValueByName("EMoveSpeed", std::string_view(p_Document["m_eMoveSpeed"])));

	*reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Target) = s_Object;
}

void ZFormationMoveOrder_SFormationMoveOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZFormationMoveOrder_SFormationMoveOrderSaveData, m_vStopDirection));
}

bool ZFormationMoveOrder_SFormationMoveOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZFormationMoveOrder_SFormationMoveOrderSaveData::operator==(const ZFormationMoveOrder_SFormationMoveOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZFormationMoveOrder_SFormationMoveOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_nObstacleBlockageFlags != p_Other.m_nObstacleBlockageFlags) return false;
	if (m_eMoveSpeed != p_Other.m_eMoveSpeed) return false;

	return true;
}

void ZFormationMoveOrder_SFormationMoveOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZFormationMoveOrder_SFormationMoveOrderSaveData*>(p_Object);
	s_Object->~ZFormationMoveOrder_SFormationMoveOrderSaveData();
}

ZHMTypeInfo ZGfxValueWrapper::TypeInfo = ZHMTypeInfo("ZGfxValueWrapper", sizeof(ZGfxValueWrapper), alignof(ZGfxValueWrapper), ZGfxValueWrapper::WriteSimpleJson, ZGfxValueWrapper::FromSimpleJson, ZGfxValueWrapper::Serialize, ZGfxValueWrapper::Equals, ZGfxValueWrapper::Destroy);

void ZGfxValueWrapper::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZGfxValueWrapper::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGfxValueWrapper s_Object {};

	*reinterpret_cast<ZGfxValueWrapper*>(p_Target) = s_Object;
}

void ZGfxValueWrapper::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);

}

bool ZGfxValueWrapper::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGfxValueWrapper*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGfxValueWrapper*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGfxValueWrapper::operator==(const ZGfxValueWrapper& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGfxValueWrapper>)
		return false;


	return true;
}

void ZGfxValueWrapper::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGfxValueWrapper*>(p_Object);
	s_Object->~ZGfxValueWrapper();
}

ZHMTypeInfo ZGridFloatField::TypeInfo = ZHMTypeInfo("ZGridFloatField", sizeof(ZGridFloatField), alignof(ZGridFloatField), ZGridFloatField::WriteSimpleJson, ZGridFloatField::FromSimpleJson, ZGridFloatField::Serialize, ZGridFloatField::Equals, ZGridFloatField::Destroy);

void ZGridFloatField::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_fInitialValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fInitialValue);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_field") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_field.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_field[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_field.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZGridFloatField::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGridFloatField s_Object {};

	s_Object.m_fInitialValue = simdjson::from_json_float32(p_Document["m_fInitialValue"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_field"];
	s_Object.m_field.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_field[s_Index0++] = simdjson::from_json_float32(s_Item0);
	}
	}

	*reinterpret_cast<ZGridFloatField*>(p_Target) = s_Object;
}

void ZGridFloatField::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);

	TArray<float32>::Serialize(&s_Object->m_field, p_Serializer, p_OwnOffset + offsetof(ZGridFloatField, m_field));
}

bool ZGridFloatField::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGridFloatField*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGridFloatField*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGridFloatField::operator==(const ZGridFloatField& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGridFloatField>)
		return false;

	if (m_fInitialValue != p_Other.m_fInitialValue) return false;
	if (m_field != p_Other.m_field) return false;

	return true;
}

void ZGridFloatField::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGridFloatField*>(p_Object);
	s_Object->~ZGridFloatField();
}

ZHMTypeInfo ZGuidString::TypeInfo = ZHMTypeInfo("ZGuidString", sizeof(ZGuidString), alignof(ZGuidString), ZGuidString::WriteSimpleJson, ZGuidString::FromSimpleJson, ZGuidString::Serialize, ZGuidString::Equals, ZGuidString::Destroy);

void ZGuidString::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZGuidString*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZGuidString::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZGuidString s_Object {};

	*reinterpret_cast<ZGuidString*>(p_Target) = s_Object;
}

void ZGuidString::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZGuidString*>(p_Object);

}

bool ZGuidString::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZGuidString*>(p_Left);
	auto* s_Right = reinterpret_cast<ZGuidString*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZGuidString::operator==(const ZGuidString& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZGuidString>)
		return false;


	return true;
}

void ZGuidString::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZGuidString*>(p_Object);
	s_Object->~ZGuidString();
}

ZHMTypeInfo ZHM5AgilityEventConsumer_SAgilityEventData::TypeInfo = ZHMTypeInfo("ZHM5AgilityEventConsumer.SAgilityEventData", sizeof(ZHM5AgilityEventConsumer_SAgilityEventData), alignof(ZHM5AgilityEventConsumer_SAgilityEventData), ZHM5AgilityEventConsumer_SAgilityEventData::WriteSimpleJson, ZHM5AgilityEventConsumer_SAgilityEventData::FromSimpleJson, ZHM5AgilityEventConsumer_SAgilityEventData::Serialize, ZHM5AgilityEventConsumer_SAgilityEventData::Equals, ZHM5AgilityEventConsumer_SAgilityEventData::Destroy);

void ZHM5AgilityEventConsumer_SAgilityEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5AgilityEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5AgilityEventConsumer_SAgilityEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5AgilityEventConsumer_SAgilityEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5AgilityEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5AgilityEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Target) = s_Object;
}

void ZHM5AgilityEventConsumer_SAgilityEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Object);

}

bool ZHM5AgilityEventConsumer_SAgilityEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5AgilityEventConsumer_SAgilityEventData::operator==(const ZHM5AgilityEventConsumer_SAgilityEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5AgilityEventConsumer_SAgilityEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5AgilityEventConsumer_SAgilityEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5AgilityEventConsumer_SAgilityEventData*>(p_Object);
	s_Object->~ZHM5AgilityEventConsumer_SAgilityEventData();
}

ZHMTypeInfo ZResourcePtr::TypeInfo = ZHMTypeInfo("ZResourcePtr", sizeof(ZResourcePtr), alignof(ZResourcePtr), ZResourcePtr::WriteSimpleJson, ZResourcePtr::FromSimpleJson, ZResourcePtr::Serialize, ZResourcePtr::Equals, ZResourcePtr::Destroy);

void ZResourcePtr::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZResourcePtr::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZResourcePtr s_Object {};

	*reinterpret_cast<ZResourcePtr*>(p_Target) = s_Object;
}

void ZResourcePtr::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);

}

bool ZResourcePtr::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZResourcePtr*>(p_Left);
	auto* s_Right = reinterpret_cast<ZResourcePtr*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZResourcePtr::operator==(const ZResourcePtr& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZResourcePtr>)
		return false;


	return true;
}

void ZResourcePtr::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZResourcePtr*>(p_Object);
	s_Object->~ZResourcePtr();
}

ZHMTypeInfo ZHM5AudioEventConsumer_SAudioAnimationEventData::TypeInfo = ZHMTypeInfo("ZHM5AudioEventConsumer.SAudioAnimationEventData", sizeof(ZHM5AudioEventConsumer_SAudioAnimationEventData), alignof(ZHM5AudioEventConsumer_SAudioAnimationEventData), ZHM5AudioEventConsumer_SAudioAnimationEventData::WriteSimpleJson, ZHM5AudioEventConsumer_SAudioAnimationEventData::FromSimpleJson, ZHM5AudioEventConsumer_SAudioAnimationEventData::Serialize, ZHM5AudioEventConsumer_SAudioAnimationEventData::Equals, ZHM5AudioEventConsumer_SAudioAnimationEventData::Destroy);

void ZHM5AudioEventConsumer_SAudioAnimationEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pAudioEventRes") << ":";
	ZResourcePtr::WriteSimpleJson(&s_Object->m_pAudioEventRes, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5AudioEventConsumer_SAudioAnimationEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5AudioEventConsumer_SAudioAnimationEventData s_Object {};

	{
		ZResourcePtr s_Item {};
		ZResourcePtr::FromSimpleJson(p_Document["m_pAudioEventRes"], &s_Item);
		s_Object.m_pAudioEventRes = s_Item;
	}

	s_Object.m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object.m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

	*reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Target) = s_Object;
}

void ZHM5AudioEventConsumer_SAudioAnimationEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Object);

	ZResourcePtr::Serialize(&s_Object->m_pAudioEventRes, p_Serializer, p_OwnOffset + offsetof(ZHM5AudioEventConsumer_SAudioAnimationEventData, m_pAudioEventRes));
}

bool ZHM5AudioEventConsumer_SAudioAnimationEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5AudioEventConsumer_SAudioAnimationEventData::operator==(const ZHM5AudioEventConsumer_SAudioAnimationEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5AudioEventConsumer_SAudioAnimationEventData>)
		return false;

	if (m_pAudioEventRes != p_Other.m_pAudioEventRes) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

void ZHM5AudioEventConsumer_SAudioAnimationEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5AudioEventConsumer_SAudioAnimationEventData*>(p_Object);
	s_Object->~ZHM5AudioEventConsumer_SAudioAnimationEventData();
}

ZHMTypeInfo ZHM5BodySoundEventConsumer_SBodySoundEventData::TypeInfo = ZHMTypeInfo("ZHM5BodySoundEventConsumer.SBodySoundEventData", sizeof(ZHM5BodySoundEventConsumer_SBodySoundEventData), alignof(ZHM5BodySoundEventConsumer_SBodySoundEventData), ZHM5BodySoundEventConsumer_SBodySoundEventData::WriteSimpleJson, ZHM5BodySoundEventConsumer_SBodySoundEventData::FromSimpleJson, ZHM5BodySoundEventConsumer_SBodySoundEventData::Serialize, ZHM5BodySoundEventConsumer_SBodySoundEventData::Equals, ZHM5BodySoundEventConsumer_SBodySoundEventData::Destroy);

void ZHM5BodySoundEventConsumer_SBodySoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5BodySoundEventConsumer.EAnimSoundBody", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5BodySoundEventConsumer_SBodySoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5BodySoundEventConsumer_SBodySoundEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5BodySoundEventConsumer_EAnimSoundBody>(ZHMEnums::GetEnumValueByName("ZHM5BodySoundEventConsumer.EAnimSoundBody", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Target) = s_Object;
}

void ZHM5BodySoundEventConsumer_SBodySoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Object);

}

bool ZHM5BodySoundEventConsumer_SBodySoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5BodySoundEventConsumer_SBodySoundEventData::operator==(const ZHM5BodySoundEventConsumer_SBodySoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5BodySoundEventConsumer_SBodySoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5BodySoundEventConsumer_SBodySoundEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5BodySoundEventConsumer_SBodySoundEventData*>(p_Object);
	s_Object->~ZHM5BodySoundEventConsumer_SBodySoundEventData();
}

ZHMTypeInfo ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5CloseCombatEventConsumer.SCloseCombatSoundEventData", sizeof(ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData), alignof(ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData), ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::WriteSimpleJson, ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::FromSimpleJson, ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Serialize, ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Equals, ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Destroy);

void ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHM5SoundCloseCombatEvent", static_cast<int>(s_Object->m_nEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData s_Object {};

	s_Object.m_nEvent = static_cast<EHM5SoundCloseCombatEvent>(ZHMEnums::GetEnumValueByName("EHM5SoundCloseCombatEvent", std::string_view(p_Document["m_nEvent"])));

	s_Object.m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object.m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

	*reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Target) = s_Object;
}

void ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Object);

}

bool ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::operator==(const ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

void ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData*>(p_Object);
	s_Object->~ZHM5CloseCombatEventConsumer_SCloseCombatSoundEventData();
}

ZHMTypeInfo ZHM5CrowdEventConsumer_SCrowdSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5CrowdEventConsumer.SCrowdSoundEventData", sizeof(ZHM5CrowdEventConsumer_SCrowdSoundEventData), alignof(ZHM5CrowdEventConsumer_SCrowdSoundEventData), ZHM5CrowdEventConsumer_SCrowdSoundEventData::WriteSimpleJson, ZHM5CrowdEventConsumer_SCrowdSoundEventData::FromSimpleJson, ZHM5CrowdEventConsumer_SCrowdSoundEventData::Serialize, ZHM5CrowdEventConsumer_SCrowdSoundEventData::Equals, ZHM5CrowdEventConsumer_SCrowdSoundEventData::Destroy);

void ZHM5CrowdEventConsumer_SCrowdSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_pAudioEventRes") << ":";
	ZResourcePtr::WriteSimpleJson(&s_Object->m_pAudioEventRes, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fAttenuation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fAttenuation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPitch") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPitch);

	p_Stream << "}";
}

void ZHM5CrowdEventConsumer_SCrowdSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5CrowdEventConsumer_SCrowdSoundEventData s_Object {};

	{
		ZResourcePtr s_Item {};
		ZResourcePtr::FromSimpleJson(p_Document["m_pAudioEventRes"], &s_Item);
		s_Object.m_pAudioEventRes = s_Item;
	}

	s_Object.m_fAttenuation = simdjson::from_json_float32(p_Document["m_fAttenuation"]);

	s_Object.m_fPitch = simdjson::from_json_float32(p_Document["m_fPitch"]);

	*reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Target) = s_Object;
}

void ZHM5CrowdEventConsumer_SCrowdSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Object);

	ZResourcePtr::Serialize(&s_Object->m_pAudioEventRes, p_Serializer, p_OwnOffset + offsetof(ZHM5CrowdEventConsumer_SCrowdSoundEventData, m_pAudioEventRes));
}

bool ZHM5CrowdEventConsumer_SCrowdSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CrowdEventConsumer_SCrowdSoundEventData::operator==(const ZHM5CrowdEventConsumer_SCrowdSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CrowdEventConsumer_SCrowdSoundEventData>)
		return false;

	if (m_pAudioEventRes != p_Other.m_pAudioEventRes) return false;
	if (m_fAttenuation != p_Other.m_fAttenuation) return false;
	if (m_fPitch != p_Other.m_fPitch) return false;

	return true;
}

void ZHM5CrowdEventConsumer_SCrowdSoundEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdEventConsumer_SCrowdSoundEventData*>(p_Object);
	s_Object->~ZHM5CrowdEventConsumer_SCrowdSoundEventData();
}

ZHMTypeInfo ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::TypeInfo = ZHMTypeInfo("ZHM5CrowdGenericEventConsumer.SCrowdSoundGenericEventData", sizeof(ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData), alignof(ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData), ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::WriteSimpleJson, ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::FromSimpleJson, ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Serialize, ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Equals, ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Destroy);

void ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5CrowdGenericEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5CrowdGenericEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5CrowdGenericEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Target) = s_Object;
}

void ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Object);

}

bool ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::operator==(const ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData*>(p_Object);
	s_Object->~ZHM5CrowdGenericEventConsumer_SCrowdSoundGenericEventData();
}

ZHMTypeInfo ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::TypeInfo = ZHMTypeInfo("ZHM5FaceFXReactionEventConsumer.SFaceFXEventData", sizeof(ZHM5FaceFXReactionEventConsumer_SFaceFXEventData), alignof(ZHM5FaceFXReactionEventConsumer_SFaceFXEventData), ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::WriteSimpleJson, ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::FromSimpleJson, ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Serialize, ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Equals, ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Destroy);

void ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5FaceFXReactionEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5FaceFXReactionEventConsumer_SFaceFXEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5FaceFXReactionEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5FaceFXReactionEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Target) = s_Object;
}

void ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Object);

}

bool ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::operator==(const ZHM5FaceFXReactionEventConsumer_SFaceFXEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5FaceFXReactionEventConsumer_SFaceFXEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXReactionEventConsumer_SFaceFXEventData*>(p_Object);
	s_Object->~ZHM5FaceFXReactionEventConsumer_SFaceFXEventData();
}

ZHMTypeInfo ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::TypeInfo = ZHMTypeInfo("ZHM5FaceFXSpecificEventConsumer.SFaceFXEventData", sizeof(ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData), alignof(ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData), ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::WriteSimpleJson, ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::FromSimpleJson, ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Serialize, ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Equals, ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Destroy);

void ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5FaceFXSpecificEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sFaceExpression") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sFaceExpression);

	p_Stream << "}";
}

void ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5FaceFXSpecificEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5FaceFXSpecificEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	s_Object.m_sFaceExpression = std::string_view(p_Document["m_sFaceExpression"]);

	*reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Target) = s_Object;
}

void ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Object);

	ZString::Serialize(&s_Object->m_sFaceExpression, p_Serializer, p_OwnOffset + offsetof(ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData, m_sFaceExpression));
}

bool ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::operator==(const ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;
	if (m_sFaceExpression != p_Other.m_sFaceExpression) return false;

	return true;
}

void ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData*>(p_Object);
	s_Object->~ZHM5FaceFXSpecificEventConsumer_SFaceFXEventData();
}

ZHMTypeInfo ZHM5FootstepEventConsumer_SFootstepSoundEventData::TypeInfo = ZHMTypeInfo("ZHM5FootstepEventConsumer.SFootstepSoundEventData", sizeof(ZHM5FootstepEventConsumer_SFootstepSoundEventData), alignof(ZHM5FootstepEventConsumer_SFootstepSoundEventData), ZHM5FootstepEventConsumer_SFootstepSoundEventData::WriteSimpleJson, ZHM5FootstepEventConsumer_SFootstepSoundEventData::FromSimpleJson, ZHM5FootstepEventConsumer_SFootstepSoundEventData::Serialize, ZHM5FootstepEventConsumer_SFootstepSoundEventData::Equals, ZHM5FootstepEventConsumer_SFootstepSoundEventData::Destroy);

void ZHM5FootstepEventConsumer_SFootstepSoundEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EHM5SoundFootstepEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5FootstepEventConsumer_SFootstepSoundEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5FootstepEventConsumer_SFootstepSoundEventData s_Object {};

	s_Object.m_nEvent = static_cast<EHM5SoundFootstepEvent>(ZHMEnums::GetEnumValueByName("EHM5SoundFootstepEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Target) = s_Object;
}

void ZHM5FootstepEventConsumer_SFootstepSoundEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Object);

}

bool ZHM5FootstepEventConsumer_SFootstepSoundEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5FootstepEventConsumer_SFootstepSoundEventData::operator==(const ZHM5FootstepEventConsumer_SFootstepSoundEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5FootstepEventConsumer_SFootstepSoundEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5FootstepEventConsumer_SFootstepSoundEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5FootstepEventConsumer_SFootstepSoundEventData*>(p_Object);
	s_Object->~ZHM5FootstepEventConsumer_SFootstepSoundEventData();
}

ZHMTypeInfo ZHM5GenericEventConsumer_SGenericEventData::TypeInfo = ZHMTypeInfo("ZHM5GenericEventConsumer.SGenericEventData", sizeof(ZHM5GenericEventConsumer_SGenericEventData), alignof(ZHM5GenericEventConsumer_SGenericEventData), ZHM5GenericEventConsumer_SGenericEventData::WriteSimpleJson, ZHM5GenericEventConsumer_SGenericEventData::FromSimpleJson, ZHM5GenericEventConsumer_SGenericEventData::Serialize, ZHM5GenericEventConsumer_SGenericEventData::Equals, ZHM5GenericEventConsumer_SGenericEventData::Destroy);

void ZHM5GenericEventConsumer_SGenericEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5GenericEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5GenericEventConsumer_SGenericEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5GenericEventConsumer_SGenericEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5GenericEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZHM5GenericEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Target) = s_Object;
}

void ZHM5GenericEventConsumer_SGenericEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Object);

}

bool ZHM5GenericEventConsumer_SGenericEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5GenericEventConsumer_SGenericEventData::operator==(const ZHM5GenericEventConsumer_SGenericEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5GenericEventConsumer_SGenericEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5GenericEventConsumer_SGenericEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5GenericEventConsumer_SGenericEventData*>(p_Object);
	s_Object->~ZHM5GenericEventConsumer_SGenericEventData();
}

ZHMTypeInfo ZHM5HIKEventConsumer_SZHM5HIKEventData::TypeInfo = ZHMTypeInfo("ZHM5HIKEventConsumer.SZHM5HIKEventData", sizeof(ZHM5HIKEventConsumer_SZHM5HIKEventData), alignof(ZHM5HIKEventConsumer_SZHM5HIKEventData), ZHM5HIKEventConsumer_SZHM5HIKEventData::WriteSimpleJson, ZHM5HIKEventConsumer_SZHM5HIKEventData::FromSimpleJson, ZHM5HIKEventConsumer_SZHM5HIKEventData::Serialize, ZHM5HIKEventConsumer_SZHM5HIKEventData::Equals, ZHM5HIKEventConsumer_SZHM5HIKEventData::Destroy);

void ZHM5HIKEventConsumer_SZHM5HIKEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEffector") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5HIKEventConsumer.EEffector", static_cast<int>(s_Object->m_nEffector)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nBlend") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5HIKEventConsumer.EBlend", static_cast<int>(s_Object->m_nBlend)));

	p_Stream << "}";
}

void ZHM5HIKEventConsumer_SZHM5HIKEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5HIKEventConsumer_SZHM5HIKEventData s_Object {};

	s_Object.m_nEffector = static_cast<ZHM5HIKEventConsumer_EEffector>(ZHMEnums::GetEnumValueByName("ZHM5HIKEventConsumer.EEffector", std::string_view(p_Document["m_nEffector"])));

	s_Object.m_nBlend = static_cast<ZHM5HIKEventConsumer_EBlend>(ZHMEnums::GetEnumValueByName("ZHM5HIKEventConsumer.EBlend", std::string_view(p_Document["m_nBlend"])));

	*reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Target) = s_Object;
}

void ZHM5HIKEventConsumer_SZHM5HIKEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Object);

}

bool ZHM5HIKEventConsumer_SZHM5HIKEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5HIKEventConsumer_SZHM5HIKEventData::operator==(const ZHM5HIKEventConsumer_SZHM5HIKEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5HIKEventConsumer_SZHM5HIKEventData>)
		return false;

	if (m_nEffector != p_Other.m_nEffector) return false;
	if (m_nBlend != p_Other.m_nBlend) return false;

	return true;
}

void ZHM5HIKEventConsumer_SZHM5HIKEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5HIKEventConsumer_SZHM5HIKEventData*>(p_Object);
	s_Object->~ZHM5HIKEventConsumer_SZHM5HIKEventData();
}

ZHMTypeInfo ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::TypeInfo = ZHMTypeInfo("ZHM5ItemInteractionEventConsumer.SItemInteractionEventData", sizeof(ZHM5ItemInteractionEventConsumer_SItemInteractionEventData), alignof(ZHM5ItemInteractionEventConsumer_SItemInteractionEventData), ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::WriteSimpleJson, ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::FromSimpleJson, ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Serialize, ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Equals, ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Destroy);

void ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5ItemInteractionEventConsumer.EHM5SoundItemInteractionEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5ItemInteractionEventConsumer_SItemInteractionEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent>(ZHMEnums::GetEnumValueByName("ZHM5ItemInteractionEventConsumer.EHM5SoundItemInteractionEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Target) = s_Object;
}

void ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Object);

}

bool ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::operator==(const ZHM5ItemInteractionEventConsumer_SItemInteractionEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5ItemInteractionEventConsumer_SItemInteractionEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5ItemInteractionEventConsumer_SItemInteractionEventData*>(p_Object);
	s_Object->~ZHM5ItemInteractionEventConsumer_SItemInteractionEventData();
}

ZHMTypeInfo ZHM5WeaponEventConsumer_SWeaponEventData::TypeInfo = ZHMTypeInfo("ZHM5WeaponEventConsumer.SWeaponEventData", sizeof(ZHM5WeaponEventConsumer_SWeaponEventData), alignof(ZHM5WeaponEventConsumer_SWeaponEventData), ZHM5WeaponEventConsumer_SWeaponEventData::WriteSimpleJson, ZHM5WeaponEventConsumer_SWeaponEventData::FromSimpleJson, ZHM5WeaponEventConsumer_SWeaponEventData::Serialize, ZHM5WeaponEventConsumer_SWeaponEventData::Equals, ZHM5WeaponEventConsumer_SWeaponEventData::Destroy);

void ZHM5WeaponEventConsumer_SWeaponEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZHM5WeaponEventConsumer.EAnimWeapon", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZHM5WeaponEventConsumer_SWeaponEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHM5WeaponEventConsumer_SWeaponEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZHM5WeaponEventConsumer_EAnimWeapon>(ZHMEnums::GetEnumValueByName("ZHM5WeaponEventConsumer.EAnimWeapon", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Target) = s_Object;
}

void ZHM5WeaponEventConsumer_SWeaponEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Object);

}

bool ZHM5WeaponEventConsumer_SWeaponEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHM5WeaponEventConsumer_SWeaponEventData::operator==(const ZHM5WeaponEventConsumer_SWeaponEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHM5WeaponEventConsumer_SWeaponEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZHM5WeaponEventConsumer_SWeaponEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHM5WeaponEventConsumer_SWeaponEventData*>(p_Object);
	s_Object->~ZHM5WeaponEventConsumer_SWeaponEventData();
}

ZHMTypeInfo ZHUDAIGuide_SData::TypeInfo = ZHMTypeInfo("ZHUDAIGuide.SData", sizeof(ZHUDAIGuide_SData), alignof(ZHUDAIGuide_SData), ZHUDAIGuide_SData::WriteSimpleJson, ZHUDAIGuide_SData::FromSimpleJson, ZHUDAIGuide_SData::Serialize, ZHUDAIGuide_SData::Equals, ZHUDAIGuide_SData::Destroy);

void ZHUDAIGuide_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("bDisguiseBroken") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDisguiseBroken);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bInsideAreaBeingInvestigated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bInsideAreaBeingInvestigated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bNearDeadBody") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bNearDeadBody);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bVisiblyArmed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bVisiblyArmed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDisguiseSuspicious") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDisguiseSuspicious);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDeepTrespassing") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDeepTrespassing);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG);

	p_Stream << "}";
}

void ZHUDAIGuide_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDAIGuide_SData s_Object {};

	s_Object.bDisguiseBroken = simdjson::from_json_bool(p_Document["bDisguiseBroken"]);

	s_Object.bTrespassing = simdjson::from_json_bool(p_Document["bTrespassing"]);

	s_Object.bInsideAreaBeingInvestigated = simdjson::from_json_bool(p_Document["bInsideAreaBeingInvestigated"]);

	s_Object.bNearDeadBody = simdjson::from_json_bool(p_Document["bNearDeadBody"]);

	s_Object.bVisiblyArmed = simdjson::from_json_bool(p_Document["bVisiblyArmed"]);

	s_Object.bDisguiseSuspicious = simdjson::from_json_bool(p_Document["bDisguiseSuspicious"]);

	s_Object.bDeepTrespassing = simdjson::from_json_bool(p_Document["bDeepTrespassing"]);

	s_Object.bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG = simdjson::from_json_bool(p_Document["bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG"]);

	*reinterpret_cast<ZHUDAIGuide_SData*>(p_Target) = s_Object;
}

void ZHUDAIGuide_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide_SData*>(p_Object);

}

bool ZHUDAIGuide_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDAIGuide_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDAIGuide_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDAIGuide_SData::operator==(const ZHUDAIGuide_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDAIGuide_SData>)
		return false;

	if (bDisguiseBroken != p_Other.bDisguiseBroken) return false;
	if (bTrespassing != p_Other.bTrespassing) return false;
	if (bInsideAreaBeingInvestigated != p_Other.bInsideAreaBeingInvestigated) return false;
	if (bNearDeadBody != p_Other.bNearDeadBody) return false;
	if (bVisiblyArmed != p_Other.bVisiblyArmed) return false;
	if (bDisguiseSuspicious != p_Other.bDisguiseSuspicious) return false;
	if (bDeepTrespassing != p_Other.bDeepTrespassing) return false;
	if (bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG != p_Other.bDeepTrespassingNOTUSEDBUTNECESSARYBECAUSEOFREALLYSTRANGEPROPERTYPARSERBUG) return false;

	return true;
}

void ZHUDAIGuide_SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDAIGuide_SData*>(p_Object);
	s_Object->~ZHUDAIGuide_SData();
}

ZHMTypeInfo ZHUDCamera3DControllerEntity_SEyeToPlane::TypeInfo = ZHMTypeInfo("ZHUDCamera3DControllerEntity.SEyeToPlane", sizeof(ZHUDCamera3DControllerEntity_SEyeToPlane), alignof(ZHUDCamera3DControllerEntity_SEyeToPlane), ZHUDCamera3DControllerEntity_SEyeToPlane::WriteSimpleJson, ZHUDCamera3DControllerEntity_SEyeToPlane::FromSimpleJson, ZHUDCamera3DControllerEntity_SEyeToPlane::Serialize, ZHUDCamera3DControllerEntity_SEyeToPlane::Equals, ZHUDCamera3DControllerEntity_SEyeToPlane::Destroy);

void ZHUDCamera3DControllerEntity_SEyeToPlane::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDCamera3DControllerEntity_SEyeToPlane*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("posCharacter") << ":";
	float4::WriteSimpleJson(&s_Object->posCharacter, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("udirTowardsPlane") << ":";
	float4::WriteSimpleJson(&s_Object->udirTowardsPlane, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("udirAnchor") << ":";
	float4::WriteSimpleJson(&s_Object->udirAnchor, p_Stream);

	p_Stream << "}";
}

void ZHUDCamera3DControllerEntity_SEyeToPlane::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDCamera3DControllerEntity_SEyeToPlane s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["posCharacter"], &s_Item);
		s_Object.posCharacter = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["udirTowardsPlane"], &s_Item);
		s_Object.udirTowardsPlane = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["udirAnchor"], &s_Item);
		s_Object.udirAnchor = s_Item;
	}

	*reinterpret_cast<ZHUDCamera3DControllerEntity_SEyeToPlane*>(p_Target) = s_Object;
}

void ZHUDCamera3DControllerEntity_SEyeToPlane::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDCamera3DControllerEntity_SEyeToPlane*>(p_Object);

	float4::Serialize(&s_Object->posCharacter, p_Serializer, p_OwnOffset + offsetof(ZHUDCamera3DControllerEntity_SEyeToPlane, posCharacter));
	float4::Serialize(&s_Object->udirTowardsPlane, p_Serializer, p_OwnOffset + offsetof(ZHUDCamera3DControllerEntity_SEyeToPlane, udirTowardsPlane));
	float4::Serialize(&s_Object->udirAnchor, p_Serializer, p_OwnOffset + offsetof(ZHUDCamera3DControllerEntity_SEyeToPlane, udirAnchor));
}

bool ZHUDCamera3DControllerEntity_SEyeToPlane::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDCamera3DControllerEntity_SEyeToPlane*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDCamera3DControllerEntity_SEyeToPlane*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDCamera3DControllerEntity_SEyeToPlane::operator==(const ZHUDCamera3DControllerEntity_SEyeToPlane& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDCamera3DControllerEntity_SEyeToPlane>)
		return false;

	if (posCharacter != p_Other.posCharacter) return false;
	if (udirTowardsPlane != p_Other.udirTowardsPlane) return false;
	if (udirAnchor != p_Other.udirAnchor) return false;

	return true;
}

void ZHUDCamera3DControllerEntity_SEyeToPlane::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDCamera3DControllerEntity_SEyeToPlane*>(p_Object);
	s_Object->~ZHUDCamera3DControllerEntity_SEyeToPlane();
}

ZHMTypeInfo ZHUDHintController_SData::TypeInfo = ZHMTypeInfo("ZHUDHintController.SData", sizeof(ZHUDHintController_SData), alignof(ZHUDHintController_SData), ZHUDHintController_SData::WriteSimpleJson, ZHUDHintController_SData::FromSimpleJson, ZHUDHintController_SData::Serialize, ZHUDHintController_SData::Equals, ZHUDHintController_SData::Destroy);

void ZHUDHintController_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sTitleText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sTitleText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyText);

	p_Stream << "}";
}

void ZHUDHintController_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDHintController_SData s_Object {};

	s_Object.m_sTitleText = std::string_view(p_Document["m_sTitleText"]);

	s_Object.m_sBodyText = std::string_view(p_Document["m_sBodyText"]);

	*reinterpret_cast<ZHUDHintController_SData*>(p_Target) = s_Object;
}

void ZHUDHintController_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController_SData*>(p_Object);

	ZString::Serialize(&s_Object->m_sTitleText, p_Serializer, p_OwnOffset + offsetof(ZHUDHintController_SData, m_sTitleText));
	ZString::Serialize(&s_Object->m_sBodyText, p_Serializer, p_OwnOffset + offsetof(ZHUDHintController_SData, m_sBodyText));
}

bool ZHUDHintController_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDHintController_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDHintController_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDHintController_SData::operator==(const ZHUDHintController_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDHintController_SData>)
		return false;

	if (m_sTitleText != p_Other.m_sTitleText) return false;
	if (m_sBodyText != p_Other.m_sBodyText) return false;

	return true;
}

void ZHUDHintController_SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDHintController_SData*>(p_Object);
	s_Object->~ZHUDHintController_SData();
}

ZHMTypeInfo ZHUDInventoryNotificationController_SData::TypeInfo = ZHMTypeInfo("ZHUDInventoryNotificationController.SData", sizeof(ZHUDInventoryNotificationController_SData), alignof(ZHUDInventoryNotificationController_SData), ZHUDInventoryNotificationController_SData::WriteSimpleJson, ZHUDInventoryNotificationController_SData::FromSimpleJson, ZHUDInventoryNotificationController_SData::Serialize, ZHUDInventoryNotificationController_SData::Equals, ZHUDInventoryNotificationController_SData::Destroy);

void ZHUDInventoryNotificationController_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDInventoryNotificationController_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_sTitleText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sTitleText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_sBodyText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_sBodyText);

	p_Stream << "}";
}

void ZHUDInventoryNotificationController_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDInventoryNotificationController_SData s_Object {};

	s_Object.m_sTitleText = std::string_view(p_Document["m_sTitleText"]);

	s_Object.m_sBodyText = std::string_view(p_Document["m_sBodyText"]);

	*reinterpret_cast<ZHUDInventoryNotificationController_SData*>(p_Target) = s_Object;
}

void ZHUDInventoryNotificationController_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDInventoryNotificationController_SData*>(p_Object);

	ZString::Serialize(&s_Object->m_sTitleText, p_Serializer, p_OwnOffset + offsetof(ZHUDInventoryNotificationController_SData, m_sTitleText));
	ZString::Serialize(&s_Object->m_sBodyText, p_Serializer, p_OwnOffset + offsetof(ZHUDInventoryNotificationController_SData, m_sBodyText));
}

bool ZHUDInventoryNotificationController_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDInventoryNotificationController_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDInventoryNotificationController_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDInventoryNotificationController_SData::operator==(const ZHUDInventoryNotificationController_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDInventoryNotificationController_SData>)
		return false;

	if (m_sTitleText != p_Other.m_sTitleText) return false;
	if (m_sBodyText != p_Other.m_sBodyText) return false;

	return true;
}

void ZHUDInventoryNotificationController_SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDInventoryNotificationController_SData*>(p_Object);
	s_Object->~ZHUDInventoryNotificationController_SData();
}

ZHMTypeInfo ZHUDOccluderTriggerEntity_SBoneTestSetup::TypeInfo = ZHMTypeInfo("ZHUDOccluderTriggerEntity.SBoneTestSetup", sizeof(ZHUDOccluderTriggerEntity_SBoneTestSetup), alignof(ZHUDOccluderTriggerEntity_SBoneTestSetup), ZHUDOccluderTriggerEntity_SBoneTestSetup::WriteSimpleJson, ZHUDOccluderTriggerEntity_SBoneTestSetup::FromSimpleJson, ZHUDOccluderTriggerEntity_SBoneTestSetup::Serialize, ZHUDOccluderTriggerEntity_SBoneTestSetup::Equals, ZHUDOccluderTriggerEntity_SBoneTestSetup::Destroy);

void ZHUDOccluderTriggerEntity_SBoneTestSetup::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDOccluderTriggerEntity_SBoneTestSetup*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("boneId") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("BoneId.Enum", static_cast<int>(s_Object->boneId)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("localOffset") << ":";
	SVector3::WriteSimpleJson(&s_Object->localOffset, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("radius") << ":";
	p_Stream << simdjson::as_json_string(s_Object->radius);

	p_Stream << "}";
}

void ZHUDOccluderTriggerEntity_SBoneTestSetup::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDOccluderTriggerEntity_SBoneTestSetup s_Object {};

	s_Object.boneId = static_cast<BoneId_Enum>(ZHMEnums::GetEnumValueByName("BoneId.Enum", std::string_view(p_Document["boneId"])));

	{
		SVector3 s_Item {};
		SVector3::FromSimpleJson(p_Document["localOffset"], &s_Item);
		s_Object.localOffset = s_Item;
	}

	s_Object.radius = simdjson::from_json_float32(p_Document["radius"]);

	*reinterpret_cast<ZHUDOccluderTriggerEntity_SBoneTestSetup*>(p_Target) = s_Object;
}

void ZHUDOccluderTriggerEntity_SBoneTestSetup::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDOccluderTriggerEntity_SBoneTestSetup*>(p_Object);

	SVector3::Serialize(&s_Object->localOffset, p_Serializer, p_OwnOffset + offsetof(ZHUDOccluderTriggerEntity_SBoneTestSetup, localOffset));
}

bool ZHUDOccluderTriggerEntity_SBoneTestSetup::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDOccluderTriggerEntity_SBoneTestSetup*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDOccluderTriggerEntity_SBoneTestSetup*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDOccluderTriggerEntity_SBoneTestSetup::operator==(const ZHUDOccluderTriggerEntity_SBoneTestSetup& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDOccluderTriggerEntity_SBoneTestSetup>)
		return false;

	if (boneId != p_Other.boneId) return false;
	if (localOffset != p_Other.localOffset) return false;
	if (radius != p_Other.radius) return false;

	return true;
}

void ZHUDOccluderTriggerEntity_SBoneTestSetup::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDOccluderTriggerEntity_SBoneTestSetup*>(p_Object);
	s_Object->~ZHUDOccluderTriggerEntity_SBoneTestSetup();
}

ZHMTypeInfo ZHUDUIControllerEntity_SIntelData::TypeInfo = ZHMTypeInfo("ZHUDUIControllerEntity.SIntelData", sizeof(ZHUDUIControllerEntity_SIntelData), alignof(ZHUDUIControllerEntity_SIntelData), ZHUDUIControllerEntity_SIntelData::WriteSimpleJson, ZHUDUIControllerEntity_SIntelData::FromSimpleJson, ZHUDUIControllerEntity_SIntelData::Serialize, ZHUDUIControllerEntity_SIntelData::Equals, ZHUDUIControllerEntity_SIntelData::Destroy);

void ZHUDUIControllerEntity_SIntelData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("groupId") << ":";
	p_Stream << simdjson::as_json_string(s_Object->groupId);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intelHeadline") << ":";
	p_Stream << simdjson::as_json_string(s_Object->intelHeadline);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("repoID") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->repoID, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("intelType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->intelType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("showDuration") << ":";
	p_Stream << simdjson::as_json_string(s_Object->showDuration);

	p_Stream << "}";
}

void ZHUDUIControllerEntity_SIntelData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDUIControllerEntity_SIntelData s_Object {};

	s_Object.groupId = std::string_view(p_Document["groupId"]);

	s_Object.intelHeadline = std::string_view(p_Document["intelHeadline"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["repoID"], &s_Item);
		s_Object.repoID = s_Item;
	}

	s_Object.intelType = simdjson::from_json_int32(p_Document["intelType"]);

	s_Object.showDuration = simdjson::from_json_float32(p_Document["showDuration"]);

	*reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Target) = s_Object;
}

void ZHUDUIControllerEntity_SIntelData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Object);

	ZString::Serialize(&s_Object->groupId, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SIntelData, groupId));
	ZString::Serialize(&s_Object->intelHeadline, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SIntelData, intelHeadline));
	ZRepositoryID::Serialize(&s_Object->repoID, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SIntelData, repoID));
}

bool ZHUDUIControllerEntity_SIntelData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDUIControllerEntity_SIntelData::operator==(const ZHUDUIControllerEntity_SIntelData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDUIControllerEntity_SIntelData>)
		return false;

	if (groupId != p_Other.groupId) return false;
	if (intelHeadline != p_Other.intelHeadline) return false;
	if (repoID != p_Other.repoID) return false;
	if (intelType != p_Other.intelType) return false;
	if (showDuration != p_Other.showDuration) return false;

	return true;
}

void ZHUDUIControllerEntity_SIntelData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SIntelData*>(p_Object);
	s_Object->~ZHUDUIControllerEntity_SIntelData();
}

ZHMTypeInfo ZHUDUIControllerEntity_SWeaponViewData::TypeInfo = ZHMTypeInfo("ZHUDUIControllerEntity.SWeaponViewData", sizeof(ZHUDUIControllerEntity_SWeaponViewData), alignof(ZHUDUIControllerEntity_SWeaponViewData), ZHUDUIControllerEntity_SWeaponViewData::WriteSimpleJson, ZHUDUIControllerEntity_SWeaponViewData::FromSimpleJson, ZHUDUIControllerEntity_SWeaponViewData::Serialize, ZHUDUIControllerEntity_SWeaponViewData::Equals, ZHUDUIControllerEntity_SWeaponViewData::Destroy);

void ZHUDUIControllerEntity_SWeaponViewData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("weaponStatus") << ":";
	SWeaponStatusUIData::WriteSimpleJson(&s_Object->weaponStatus, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemLeftHandStatus") << ":";
	SItemLeftHandUIData::WriteSimpleJson(&s_Object->itemLeftHandStatus, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemOnBackStatus") << ":";
	SItemOnBackUIData::WriteSimpleJson(&s_Object->itemOnBackStatus, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bShowHolstered") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bShowHolstered);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nDisplayMode") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nDisplayMode);

	p_Stream << "}";
}

void ZHUDUIControllerEntity_SWeaponViewData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHUDUIControllerEntity_SWeaponViewData s_Object {};

	{
		SWeaponStatusUIData s_Item {};
		SWeaponStatusUIData::FromSimpleJson(p_Document["weaponStatus"], &s_Item);
		s_Object.weaponStatus = s_Item;
	}

	{
		SItemLeftHandUIData s_Item {};
		SItemLeftHandUIData::FromSimpleJson(p_Document["itemLeftHandStatus"], &s_Item);
		s_Object.itemLeftHandStatus = s_Item;
	}

	{
		SItemOnBackUIData s_Item {};
		SItemOnBackUIData::FromSimpleJson(p_Document["itemOnBackStatus"], &s_Item);
		s_Object.itemOnBackStatus = s_Item;
	}

	s_Object.bShowHolstered = simdjson::from_json_bool(p_Document["bShowHolstered"]);

	s_Object.nDisplayMode = simdjson::from_json_int32(p_Document["nDisplayMode"]);

	*reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Target) = s_Object;
}

void ZHUDUIControllerEntity_SWeaponViewData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Object);

	SWeaponStatusUIData::Serialize(&s_Object->weaponStatus, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SWeaponViewData, weaponStatus));
	SItemLeftHandUIData::Serialize(&s_Object->itemLeftHandStatus, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SWeaponViewData, itemLeftHandStatus));
	SItemOnBackUIData::Serialize(&s_Object->itemOnBackStatus, p_Serializer, p_OwnOffset + offsetof(ZHUDUIControllerEntity_SWeaponViewData, itemOnBackStatus));
}

bool ZHUDUIControllerEntity_SWeaponViewData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHUDUIControllerEntity_SWeaponViewData::operator==(const ZHUDUIControllerEntity_SWeaponViewData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHUDUIControllerEntity_SWeaponViewData>)
		return false;

	if (weaponStatus != p_Other.weaponStatus) return false;
	if (itemLeftHandStatus != p_Other.itemLeftHandStatus) return false;
	if (itemOnBackStatus != p_Other.itemOnBackStatus) return false;
	if (bShowHolstered != p_Other.bShowHolstered) return false;
	if (nDisplayMode != p_Other.nDisplayMode) return false;

	return true;
}

void ZHUDUIControllerEntity_SWeaponViewData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHUDUIControllerEntity_SWeaponViewData*>(p_Object);
	s_Object->~ZHUDUIControllerEntity_SWeaponViewData();
}

ZHMTypeInfo ZHttpUrl::TypeInfo = ZHMTypeInfo("ZHttpUrl", sizeof(ZHttpUrl), alignof(ZHttpUrl), ZHttpUrl::WriteSimpleJson, ZHttpUrl::FromSimpleJson, ZHttpUrl::Serialize, ZHttpUrl::Equals, ZHttpUrl::Destroy);

void ZHttpUrl::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZHttpUrl::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZHttpUrl s_Object {};

	*reinterpret_cast<ZHttpUrl*>(p_Target) = s_Object;
}

void ZHttpUrl::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);

}

bool ZHttpUrl::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZHttpUrl*>(p_Left);
	auto* s_Right = reinterpret_cast<ZHttpUrl*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZHttpUrl::operator==(const ZHttpUrl& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZHttpUrl>)
		return false;


	return true;
}

void ZHttpUrl::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZHttpUrl*>(p_Object);
	s_Object->~ZHttpUrl();
}

ZHMTypeInfo ZInfectedSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZInfectedSituation.SSituationSaveData", sizeof(ZInfectedSituation_SSituationSaveData), alignof(ZInfectedSituation_SSituationSaveData), ZInfectedSituation_SSituationSaveData::WriteSimpleJson, ZInfectedSituation_SSituationSaveData::FromSimpleJson, ZInfectedSituation_SSituationSaveData::Serialize, ZInfectedSituation_SSituationSaveData::Equals, ZInfectedSituation_SSituationSaveData::Destroy);

void ZInfectedSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInfectedSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStandingDown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandingDown);

	p_Stream << "}";
}

void ZInfectedSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInfectedSituation_SSituationSaveData s_Object {};

	s_Object.m_bStandingDown = simdjson::from_json_bool(p_Document["m_bStandingDown"]);

	*reinterpret_cast<ZInfectedSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZInfectedSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInfectedSituation_SSituationSaveData*>(p_Object);

}

bool ZInfectedSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInfectedSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInfectedSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInfectedSituation_SSituationSaveData::operator==(const ZInfectedSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInfectedSituation_SSituationSaveData>)
		return false;

	if (m_bStandingDown != p_Other.m_bStandingDown) return false;

	return true;
}

void ZInfectedSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInfectedSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZInfectedSituation_SSituationSaveData();
}

ZHMTypeInfo ZInteractionData::TypeInfo = ZHMTypeInfo("ZInteractionData", sizeof(ZInteractionData), alignof(ZInteractionData), ZInteractionData::WriteSimpleJson, ZInteractionData::FromSimpleJson, ZInteractionData::Serialize, ZInteractionData::Equals, ZInteractionData::Destroy);

void ZInteractionData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInteractionData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInteractionData s_Object {};

	*reinterpret_cast<ZInteractionData*>(p_Target) = s_Object;
}

void ZInteractionData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);

}

bool ZInteractionData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionData::operator==(const ZInteractionData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionData>)
		return false;


	return true;
}

void ZInteractionData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInteractionData*>(p_Object);
	s_Object->~ZInteractionData();
}

ZHMTypeInfo ZInteractionEventConsumer_SInteractionEventData::TypeInfo = ZHMTypeInfo("ZInteractionEventConsumer.SInteractionEventData", sizeof(ZInteractionEventConsumer_SInteractionEventData), alignof(ZInteractionEventConsumer_SInteractionEventData), ZInteractionEventConsumer_SInteractionEventData::WriteSimpleJson, ZInteractionEventConsumer_SInteractionEventData::FromSimpleJson, ZInteractionEventConsumer_SInteractionEventData::Serialize, ZInteractionEventConsumer_SInteractionEventData::Equals, ZInteractionEventConsumer_SInteractionEventData::Destroy);

void ZInteractionEventConsumer_SInteractionEventData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nEvent") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZInteractionEventConsumer.EEvent", static_cast<int>(s_Object->m_nEvent)));

	p_Stream << "}";
}

void ZInteractionEventConsumer_SInteractionEventData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInteractionEventConsumer_SInteractionEventData s_Object {};

	s_Object.m_nEvent = static_cast<ZInteractionEventConsumer_EEvent>(ZHMEnums::GetEnumValueByName("ZInteractionEventConsumer.EEvent", std::string_view(p_Document["m_nEvent"])));

	*reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Target) = s_Object;
}

void ZInteractionEventConsumer_SInteractionEventData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Object);

}

bool ZInteractionEventConsumer_SInteractionEventData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionEventConsumer_SInteractionEventData::operator==(const ZInteractionEventConsumer_SInteractionEventData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionEventConsumer_SInteractionEventData>)
		return false;

	if (m_nEvent != p_Other.m_nEvent) return false;

	return true;
}

void ZInteractionEventConsumer_SInteractionEventData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInteractionEventConsumer_SInteractionEventData*>(p_Object);
	s_Object->~ZInteractionEventConsumer_SInteractionEventData();
}

ZHMTypeInfo ZInteractionGuideData::TypeInfo = ZHMTypeInfo("ZInteractionGuideData", sizeof(ZInteractionGuideData), alignof(ZInteractionGuideData), ZInteractionGuideData::WriteSimpleJson, ZInteractionGuideData::FromSimpleJson, ZInteractionGuideData::Serialize, ZInteractionGuideData::Equals, ZInteractionGuideData::Destroy);

void ZInteractionGuideData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZInteractionGuideData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInteractionGuideData s_Object {};

	*reinterpret_cast<ZInteractionGuideData*>(p_Target) = s_Object;
}

void ZInteractionGuideData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);

}

bool ZInteractionGuideData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInteractionGuideData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInteractionGuideData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInteractionGuideData::operator==(const ZInteractionGuideData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInteractionGuideData>)
		return false;


	return true;
}

void ZInteractionGuideData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInteractionGuideData*>(p_Object);
	s_Object->~ZInteractionGuideData();
}

ZHMTypeInfo ZInvestigateWeaponSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZInvestigateWeaponSituation.SSituationSaveData", sizeof(ZInvestigateWeaponSituation_SSituationSaveData), alignof(ZInvestigateWeaponSituation_SSituationSaveData), ZInvestigateWeaponSituation_SSituationSaveData::WriteSimpleJson, ZInvestigateWeaponSituation_SSituationSaveData::FromSimpleJson, ZInvestigateWeaponSituation_SSituationSaveData::Serialize, ZInvestigateWeaponSituation_SSituationSaveData::Equals, ZInvestigateWeaponSituation_SSituationSaveData::Destroy);

void ZInvestigateWeaponSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nCurrentState") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nCurrentState);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mainStateStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_mainStateStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nActiveInvestigationGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nActiveInvestigationGroup);

	p_Stream << "}";
}

void ZInvestigateWeaponSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZInvestigateWeaponSituation_SSituationSaveData s_Object {};

	s_Object.m_nCurrentState = simdjson::from_json_int32(p_Document["m_nCurrentState"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_mainStateStartTime"], &s_Item);
		s_Object.m_mainStateStartTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastStandDown"], &s_Item);
		s_Object.m_tLastStandDown = s_Item;
	}

	s_Object.m_nActiveInvestigationGroup = simdjson::from_json_int32(p_Document["m_nActiveInvestigationGroup"]);

	*reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZInvestigateWeaponSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_mainStateStartTime, p_Serializer, p_OwnOffset + offsetof(ZInvestigateWeaponSituation_SSituationSaveData, m_mainStateStartTime));
	ZGameTime::Serialize(&s_Object->m_tLastStandDown, p_Serializer, p_OwnOffset + offsetof(ZInvestigateWeaponSituation_SSituationSaveData, m_tLastStandDown));
}

bool ZInvestigateWeaponSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZInvestigateWeaponSituation_SSituationSaveData::operator==(const ZInvestigateWeaponSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZInvestigateWeaponSituation_SSituationSaveData>)
		return false;

	if (m_nCurrentState != p_Other.m_nCurrentState) return false;
	if (m_mainStateStartTime != p_Other.m_mainStateStartTime) return false;
	if (m_tLastStandDown != p_Other.m_tLastStandDown) return false;
	if (m_nActiveInvestigationGroup != p_Other.m_nActiveInvestigationGroup) return false;

	return true;
}

void ZInvestigateWeaponSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZInvestigateWeaponSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZInvestigateWeaponSituation_SSituationSaveData();
}

ZHMTypeInfo ZJumpToOrder_SJumpToOrderSaveData::TypeInfo = ZHMTypeInfo("ZJumpToOrder.SJumpToOrderSaveData", sizeof(ZJumpToOrder_SJumpToOrderSaveData), alignof(ZJumpToOrder_SJumpToOrderSaveData), ZJumpToOrder_SJumpToOrderSaveData::WriteSimpleJson, ZJumpToOrder_SJumpToOrderSaveData::FromSimpleJson, ZJumpToOrder_SJumpToOrderSaveData::Serialize, ZJumpToOrder_SJumpToOrderSaveData::Equals, ZJumpToOrder_SJumpToOrderSaveData::Destroy);

void ZJumpToOrder_SJumpToOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vTargetPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vTargetPosition, p_Stream);

	p_Stream << "}";
}

void ZJumpToOrder_SJumpToOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZJumpToOrder_SJumpToOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Item);
		s_Object.m_vStopDirection = s_Item;
	}

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vTargetPosition"], &s_Item);
		s_Object.m_vTargetPosition = s_Item;
	}

	*reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Target) = s_Object;
}

void ZJumpToOrder_SJumpToOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZJumpToOrder_SJumpToOrderSaveData, m_vStopDirection));
	float4::Serialize(&s_Object->m_vTargetPosition, p_Serializer, p_OwnOffset + offsetof(ZJumpToOrder_SJumpToOrderSaveData, m_vTargetPosition));
}

bool ZJumpToOrder_SJumpToOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZJumpToOrder_SJumpToOrderSaveData::operator==(const ZJumpToOrder_SJumpToOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZJumpToOrder_SJumpToOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_vTargetPosition != p_Other.m_vTargetPosition) return false;

	return true;
}

void ZJumpToOrder_SJumpToOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZJumpToOrder_SJumpToOrderSaveData*>(p_Object);
	s_Object->~ZJumpToOrder_SJumpToOrderSaveData();
}

ZHMTypeInfo ZKeywordCalculator_SCollection::TypeInfo = ZHMTypeInfo("ZKeywordCalculator.SCollection", sizeof(ZKeywordCalculator_SCollection), alignof(ZKeywordCalculator_SCollection), ZKeywordCalculator_SCollection::WriteSimpleJson, ZKeywordCalculator_SCollection::FromSimpleJson, ZKeywordCalculator_SCollection::Serialize, ZKeywordCalculator_SCollection::Equals, ZKeywordCalculator_SCollection::Destroy);

void ZKeywordCalculator_SCollection::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZKeywordCalculator_SCollection*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("aKeywords") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aKeywords.size(); ++i)
	{
		auto& s_Item0 = s_Object->aKeywords[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->aKeywords.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZKeywordCalculator_SCollection::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZKeywordCalculator_SCollection s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["aKeywords"];
	s_Object.aKeywords.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.aKeywords[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<ZKeywordCalculator_SCollection*>(p_Target) = s_Object;
}

void ZKeywordCalculator_SCollection::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZKeywordCalculator_SCollection*>(p_Object);

	TArray<int32>::Serialize(&s_Object->aKeywords, p_Serializer, p_OwnOffset + offsetof(ZKeywordCalculator_SCollection, aKeywords));
}

bool ZKeywordCalculator_SCollection::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZKeywordCalculator_SCollection*>(p_Left);
	auto* s_Right = reinterpret_cast<ZKeywordCalculator_SCollection*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZKeywordCalculator_SCollection::operator==(const ZKeywordCalculator_SCollection& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZKeywordCalculator_SCollection>)
		return false;

	if (aKeywords != p_Other.aKeywords) return false;

	return true;
}

void ZKeywordCalculator_SCollection::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZKeywordCalculator_SCollection*>(p_Object);
	s_Object->~ZKeywordCalculator_SCollection();
}

ZHMTypeInfo ZMoveToOrder_SMoveToOrderSaveData::TypeInfo = ZHMTypeInfo("ZMoveToOrder.SMoveToOrderSaveData", sizeof(ZMoveToOrder_SMoveToOrderSaveData), alignof(ZMoveToOrder_SMoveToOrderSaveData), ZMoveToOrder_SMoveToOrderSaveData::WriteSimpleJson, ZMoveToOrder_SMoveToOrderSaveData::FromSimpleJson, ZMoveToOrder_SMoveToOrderSaveData::Serialize, ZMoveToOrder_SMoveToOrderSaveData::Equals, ZMoveToOrder_SMoveToOrderSaveData::Destroy);

void ZMoveToOrder_SMoveToOrderSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vStopDirection") << ":";
	float4::WriteSimpleJson(&s_Object->m_vStopDirection, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStopDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStopDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fWalkDistance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fWalkDistance);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nObstacleBlockageFlags") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nObstacleBlockageFlags);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eMoveSpeed") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZMoveToOrder.EMoveSpeed", static_cast<int>(s_Object->m_eMoveSpeed)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIgnoreEndCollision") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIgnoreEndCollision);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPrecisePositioning") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPrecisePositioning);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bForceStand") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bForceStand);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLookAtTargetMustBeInSight") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLookAtTargetMustBeInSight);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUseKnownPosition") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUseKnownPosition);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopActFast") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopActFast);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStrafe") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStrafe);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEndStanding") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEndStanding);

	p_Stream << "}";
}

void ZMoveToOrder_SMoveToOrderSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZMoveToOrder_SMoveToOrderSaveData s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vStopDirection"], &s_Item);
		s_Object.m_vStopDirection = s_Item;
	}

	s_Object.m_fStopDistance = simdjson::from_json_float32(p_Document["m_fStopDistance"]);

	s_Object.m_fWalkDistance = simdjson::from_json_float32(p_Document["m_fWalkDistance"]);

	s_Object.m_nObstacleBlockageFlags = simdjson::from_json_uint32(p_Document["m_nObstacleBlockageFlags"]);

	s_Object.m_eMoveSpeed = static_cast<ZMoveToOrder_EMoveSpeed>(ZHMEnums::GetEnumValueByName("ZMoveToOrder.EMoveSpeed", std::string_view(p_Document["m_eMoveSpeed"])));

	s_Object.m_bIgnoreEndCollision = simdjson::from_json_bool(p_Document["m_bIgnoreEndCollision"]);

	s_Object.m_bPrecisePositioning = simdjson::from_json_bool(p_Document["m_bPrecisePositioning"]);

	s_Object.m_bForceStand = simdjson::from_json_bool(p_Document["m_bForceStand"]);

	s_Object.m_bLookAtTargetMustBeInSight = simdjson::from_json_bool(p_Document["m_bLookAtTargetMustBeInSight"]);

	s_Object.m_bUseKnownPosition = simdjson::from_json_bool(p_Document["m_bUseKnownPosition"]);

	s_Object.m_bStopActFast = simdjson::from_json_bool(p_Document["m_bStopActFast"]);

	s_Object.m_bStrafe = simdjson::from_json_bool(p_Document["m_bStrafe"]);

	s_Object.m_bEndStanding = simdjson::from_json_bool(p_Document["m_bEndStanding"]);

	*reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Target) = s_Object;
}

void ZMoveToOrder_SMoveToOrderSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Object);

	float4::Serialize(&s_Object->m_vStopDirection, p_Serializer, p_OwnOffset + offsetof(ZMoveToOrder_SMoveToOrderSaveData, m_vStopDirection));
}

bool ZMoveToOrder_SMoveToOrderSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZMoveToOrder_SMoveToOrderSaveData::operator==(const ZMoveToOrder_SMoveToOrderSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZMoveToOrder_SMoveToOrderSaveData>)
		return false;

	if (m_vStopDirection != p_Other.m_vStopDirection) return false;
	if (m_fStopDistance != p_Other.m_fStopDistance) return false;
	if (m_fWalkDistance != p_Other.m_fWalkDistance) return false;
	if (m_nObstacleBlockageFlags != p_Other.m_nObstacleBlockageFlags) return false;
	if (m_eMoveSpeed != p_Other.m_eMoveSpeed) return false;
	if (m_bIgnoreEndCollision != p_Other.m_bIgnoreEndCollision) return false;
	if (m_bPrecisePositioning != p_Other.m_bPrecisePositioning) return false;
	if (m_bForceStand != p_Other.m_bForceStand) return false;
	if (m_bLookAtTargetMustBeInSight != p_Other.m_bLookAtTargetMustBeInSight) return false;
	if (m_bUseKnownPosition != p_Other.m_bUseKnownPosition) return false;
	if (m_bStopActFast != p_Other.m_bStopActFast) return false;
	if (m_bStrafe != p_Other.m_bStrafe) return false;
	if (m_bEndStanding != p_Other.m_bEndStanding) return false;

	return true;
}

void ZMoveToOrder_SMoveToOrderSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZMoveToOrder_SMoveToOrderSaveData*>(p_Object);
	s_Object->~ZMoveToOrder_SMoveToOrderSaveData();
}

ZHMTypeInfo ZPhotoModeMenuDataProvider_SPrompt::TypeInfo = ZHMTypeInfo("ZPhotoModeMenuDataProvider.SPrompt", sizeof(ZPhotoModeMenuDataProvider_SPrompt), alignof(ZPhotoModeMenuDataProvider_SPrompt), ZPhotoModeMenuDataProvider_SPrompt::WriteSimpleJson, ZPhotoModeMenuDataProvider_SPrompt::FromSimpleJson, ZPhotoModeMenuDataProvider_SPrompt::Serialize, ZPhotoModeMenuDataProvider_SPrompt::Equals, ZPhotoModeMenuDataProvider_SPrompt::Destroy);

void ZPhotoModeMenuDataProvider_SPrompt::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SPrompt*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("aIcons") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aIcons.size(); ++i)
	{
		auto& s_Item0 = s_Object->aIcons[i];
		ZVariant::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aIcons.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsEnabled);

	p_Stream << "}";
}

void ZPhotoModeMenuDataProvider_SPrompt::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPhotoModeMenuDataProvider_SPrompt s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["aIcons"];
	s_Object.aIcons.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZVariant s_ArrayItem0;
		ZVariant::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aIcons[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.sLabel = std::string_view(p_Document["sLabel"]);

	s_Object.bIsEnabled = simdjson::from_json_bool(p_Document["bIsEnabled"]);

	*reinterpret_cast<ZPhotoModeMenuDataProvider_SPrompt*>(p_Target) = s_Object;
}

void ZPhotoModeMenuDataProvider_SPrompt::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SPrompt*>(p_Object);

	TArray<ZVariant>::Serialize(&s_Object->aIcons, p_Serializer, p_OwnOffset + offsetof(ZPhotoModeMenuDataProvider_SPrompt, aIcons));
	ZString::Serialize(&s_Object->sLabel, p_Serializer, p_OwnOffset + offsetof(ZPhotoModeMenuDataProvider_SPrompt, sLabel));
}

bool ZPhotoModeMenuDataProvider_SPrompt::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPhotoModeMenuDataProvider_SPrompt*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPhotoModeMenuDataProvider_SPrompt*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPhotoModeMenuDataProvider_SPrompt::operator==(const ZPhotoModeMenuDataProvider_SPrompt& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPhotoModeMenuDataProvider_SPrompt>)
		return false;

	if (aIcons != p_Other.aIcons) return false;
	if (sLabel != p_Other.sLabel) return false;
	if (bIsEnabled != p_Other.bIsEnabled) return false;

	return true;
}

void ZPhotoModeMenuDataProvider_SPrompt::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SPrompt*>(p_Object);
	s_Object->~ZPhotoModeMenuDataProvider_SPrompt();
}

ZHMTypeInfo ZPhotoModeMenuDataProvider_SData::TypeInfo = ZHMTypeInfo("ZPhotoModeMenuDataProvider.SData", sizeof(ZPhotoModeMenuDataProvider_SData), alignof(ZPhotoModeMenuDataProvider_SData), ZPhotoModeMenuDataProvider_SData::WriteSimpleJson, ZPhotoModeMenuDataProvider_SData::FromSimpleJson, ZPhotoModeMenuDataProvider_SData::Serialize, ZPhotoModeMenuDataProvider_SData::Equals, ZPhotoModeMenuDataProvider_SData::Destroy);

void ZPhotoModeMenuDataProvider_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("bIsVisible") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsVisible);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aMenuEntries") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aMenuEntries.size(); ++i)
	{
		auto& s_Item0 = s_Object->aMenuEntries[i];
		ZVariant::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aMenuEntries.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sInputPlatform") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sInputPlatform);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("aPrompts") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->aPrompts.size(); ++i)
	{
		auto& s_Item0 = s_Object->aPrompts[i];
		ZPhotoModeMenuDataProvider_SPrompt::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->aPrompts.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZPhotoModeMenuDataProvider_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPhotoModeMenuDataProvider_SData s_Object {};

	s_Object.bIsVisible = simdjson::from_json_bool(p_Document["bIsVisible"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aMenuEntries"];
	s_Object.aMenuEntries.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZVariant s_ArrayItem0;
		ZVariant::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aMenuEntries[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.sInputPlatform = std::string_view(p_Document["sInputPlatform"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["aPrompts"];
	s_Object.aPrompts.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZPhotoModeMenuDataProvider_SPrompt s_ArrayItem0;
		ZPhotoModeMenuDataProvider_SPrompt::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.aPrompts[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZPhotoModeMenuDataProvider_SData*>(p_Target) = s_Object;
}

void ZPhotoModeMenuDataProvider_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SData*>(p_Object);

	TArray<ZVariant>::Serialize(&s_Object->aMenuEntries, p_Serializer, p_OwnOffset + offsetof(ZPhotoModeMenuDataProvider_SData, aMenuEntries));
	ZString::Serialize(&s_Object->sInputPlatform, p_Serializer, p_OwnOffset + offsetof(ZPhotoModeMenuDataProvider_SData, sInputPlatform));
	TArray<ZPhotoModeMenuDataProvider_SPrompt>::Serialize(&s_Object->aPrompts, p_Serializer, p_OwnOffset + offsetof(ZPhotoModeMenuDataProvider_SData, aPrompts));
}

bool ZPhotoModeMenuDataProvider_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPhotoModeMenuDataProvider_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPhotoModeMenuDataProvider_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPhotoModeMenuDataProvider_SData::operator==(const ZPhotoModeMenuDataProvider_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPhotoModeMenuDataProvider_SData>)
		return false;

	if (bIsVisible != p_Other.bIsVisible) return false;
	if (aMenuEntries != p_Other.aMenuEntries) return false;
	if (sInputPlatform != p_Other.sInputPlatform) return false;
	if (aPrompts != p_Other.aPrompts) return false;

	return true;
}

void ZPhotoModeMenuDataProvider_SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SData*>(p_Object);
	s_Object->~ZPhotoModeMenuDataProvider_SData();
}

ZHMTypeInfo ZPhotoModeMenuDataProvider_SMenuEntry::TypeInfo = ZHMTypeInfo("ZPhotoModeMenuDataProvider.SMenuEntry", sizeof(ZPhotoModeMenuDataProvider_SMenuEntry), alignof(ZPhotoModeMenuDataProvider_SMenuEntry), ZPhotoModeMenuDataProvider_SMenuEntry::WriteSimpleJson, ZPhotoModeMenuDataProvider_SMenuEntry::FromSimpleJson, ZPhotoModeMenuDataProvider_SMenuEntry::Serialize, ZPhotoModeMenuDataProvider_SMenuEntry::Equals, ZPhotoModeMenuDataProvider_SMenuEntry::Destroy);

void ZPhotoModeMenuDataProvider_SMenuEntry::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SMenuEntry*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("sLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsEnabled);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bIsHighlighted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bIsHighlighted);

	p_Stream << "}";
}

void ZPhotoModeMenuDataProvider_SMenuEntry::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPhotoModeMenuDataProvider_SMenuEntry s_Object {};

	s_Object.sLabel = std::string_view(p_Document["sLabel"]);

	s_Object.bIsEnabled = simdjson::from_json_bool(p_Document["bIsEnabled"]);

	s_Object.bIsHighlighted = simdjson::from_json_bool(p_Document["bIsHighlighted"]);

	*reinterpret_cast<ZPhotoModeMenuDataProvider_SMenuEntry*>(p_Target) = s_Object;
}

void ZPhotoModeMenuDataProvider_SMenuEntry::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SMenuEntry*>(p_Object);

	ZString::Serialize(&s_Object->sLabel, p_Serializer, p_OwnOffset + offsetof(ZPhotoModeMenuDataProvider_SMenuEntry, sLabel));
}

bool ZPhotoModeMenuDataProvider_SMenuEntry::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPhotoModeMenuDataProvider_SMenuEntry*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPhotoModeMenuDataProvider_SMenuEntry*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPhotoModeMenuDataProvider_SMenuEntry::operator==(const ZPhotoModeMenuDataProvider_SMenuEntry& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPhotoModeMenuDataProvider_SMenuEntry>)
		return false;

	if (sLabel != p_Other.sLabel) return false;
	if (bIsEnabled != p_Other.bIsEnabled) return false;
	if (bIsHighlighted != p_Other.bIsHighlighted) return false;

	return true;
}

void ZPhotoModeMenuDataProvider_SMenuEntry::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZPhotoModeMenuDataProvider_SMenuEntry*>(p_Object);
	s_Object->~ZPhotoModeMenuDataProvider_SMenuEntry();
}

ZHMTypeInfo ZPlanningObjectiveInfoBuilder::TypeInfo = ZHMTypeInfo("ZPlanningObjectiveInfoBuilder", sizeof(ZPlanningObjectiveInfoBuilder), alignof(ZPlanningObjectiveInfoBuilder), ZPlanningObjectiveInfoBuilder::WriteSimpleJson, ZPlanningObjectiveInfoBuilder::FromSimpleJson, ZPlanningObjectiveInfoBuilder::Serialize, ZPlanningObjectiveInfoBuilder::Equals, ZPlanningObjectiveInfoBuilder::Destroy);

void ZPlanningObjectiveInfoBuilder::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZPlanningObjectiveInfoBuilder::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPlanningObjectiveInfoBuilder s_Object {};

	*reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Target) = s_Object;
}

void ZPlanningObjectiveInfoBuilder::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);

}

bool ZPlanningObjectiveInfoBuilder::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPlanningObjectiveInfoBuilder::operator==(const ZPlanningObjectiveInfoBuilder& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPlanningObjectiveInfoBuilder>)
		return false;


	return true;
}

void ZPlanningObjectiveInfoBuilder::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZPlanningObjectiveInfoBuilder*>(p_Object);
	s_Object->~ZPlanningObjectiveInfoBuilder();
}

ZHMTypeInfo ZPostfilterGraphBaseNode::TypeInfo = ZHMTypeInfo("ZPostfilterGraphBaseNode", sizeof(ZPostfilterGraphBaseNode), alignof(ZPostfilterGraphBaseNode), ZPostfilterGraphBaseNode::WriteSimpleJson, ZPostfilterGraphBaseNode::FromSimpleJson, ZPostfilterGraphBaseNode::Serialize, ZPostfilterGraphBaseNode::Equals, ZPostfilterGraphBaseNode::Destroy);

void ZPostfilterGraphBaseNode::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZPostfilterGraphBaseNode::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZPostfilterGraphBaseNode s_Object {};

	*reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Target) = s_Object;
}

void ZPostfilterGraphBaseNode::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);

}

bool ZPostfilterGraphBaseNode::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Left);
	auto* s_Right = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZPostfilterGraphBaseNode::operator==(const ZPostfilterGraphBaseNode& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZPostfilterGraphBaseNode>)
		return false;


	return true;
}

void ZPostfilterGraphBaseNode::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZPostfilterGraphBaseNode*>(p_Object);
	s_Object->~ZPostfilterGraphBaseNode();
}

ZHMTypeInfo ZRayQueryInput::TypeInfo = ZHMTypeInfo("ZRayQueryInput", sizeof(ZRayQueryInput), alignof(ZRayQueryInput), ZRayQueryInput::WriteSimpleJson, ZRayQueryInput::FromSimpleJson, ZRayQueryInput::Serialize, ZRayQueryInput::Equals, ZRayQueryInput::Destroy);

void ZRayQueryInput::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZRayQueryInput::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRayQueryInput s_Object {};

	*reinterpret_cast<ZRayQueryInput*>(p_Target) = s_Object;
}

void ZRayQueryInput::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);

}

bool ZRayQueryInput::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRayQueryInput*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRayQueryInput*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRayQueryInput::operator==(const ZRayQueryInput& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRayQueryInput>)
		return false;


	return true;
}

void ZRayQueryInput::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZRayQueryInput*>(p_Object);
	s_Object->~ZRayQueryInput();
}

ZHMTypeInfo ZRecoverUnconsciousSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZRecoverUnconsciousSituation.SSituationSaveData", sizeof(ZRecoverUnconsciousSituation_SSituationSaveData), alignof(ZRecoverUnconsciousSituation_SSituationSaveData), ZRecoverUnconsciousSituation_SSituationSaveData::WriteSimpleJson, ZRecoverUnconsciousSituation_SSituationSaveData::FromSimpleJson, ZRecoverUnconsciousSituation_SSituationSaveData::Serialize, ZRecoverUnconsciousSituation_SSituationSaveData::Equals, ZRecoverUnconsciousSituation_SSituationSaveData::Destroy);

void ZRecoverUnconsciousSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rVictim") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rVictim);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pInvestigateDisguiseGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pInvestigateDisguiseGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pRecoverUnconsciousGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pRecoverUnconsciousGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pObserversGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pObserversGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bEscalate") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bEscalate);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bVictimPacified") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bVictimPacified);

	p_Stream << "}";
}

void ZRecoverUnconsciousSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRecoverUnconsciousSituation_SSituationSaveData s_Object {};

	s_Object.m_rVictim = simdjson::from_json_uint32(p_Document["m_rVictim"]);

	s_Object.m_pInvestigateDisguiseGroup = simdjson::from_json_int32(p_Document["m_pInvestigateDisguiseGroup"]);

	s_Object.m_pRecoverUnconsciousGroup = simdjson::from_json_int32(p_Document["m_pRecoverUnconsciousGroup"]);

	s_Object.m_pObserversGroup = simdjson::from_json_int32(p_Document["m_pObserversGroup"]);

	s_Object.m_bEscalate = simdjson::from_json_bool(p_Document["m_bEscalate"]);

	s_Object.m_bVictimPacified = simdjson::from_json_bool(p_Document["m_bVictimPacified"]);

	*reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZRecoverUnconsciousSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Object);

}

bool ZRecoverUnconsciousSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRecoverUnconsciousSituation_SSituationSaveData::operator==(const ZRecoverUnconsciousSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRecoverUnconsciousSituation_SSituationSaveData>)
		return false;

	if (m_rVictim != p_Other.m_rVictim) return false;
	if (m_pInvestigateDisguiseGroup != p_Other.m_pInvestigateDisguiseGroup) return false;
	if (m_pRecoverUnconsciousGroup != p_Other.m_pRecoverUnconsciousGroup) return false;
	if (m_pObserversGroup != p_Other.m_pObserversGroup) return false;
	if (m_bEscalate != p_Other.m_bEscalate) return false;
	if (m_bVictimPacified != p_Other.m_bVictimPacified) return false;

	return true;
}

void ZRecoverUnconsciousSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZRecoverUnconsciousSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZRecoverUnconsciousSituation_SSituationSaveData();
}

ZHMTypeInfo ZRuntimePinConDesc::TypeInfo = ZHMTypeInfo("ZRuntimePinConDesc", sizeof(ZRuntimePinConDesc), alignof(ZRuntimePinConDesc), ZRuntimePinConDesc::WriteSimpleJson, ZRuntimePinConDesc::FromSimpleJson, ZRuntimePinConDesc::Serialize, ZRuntimePinConDesc::Equals, ZRuntimePinConDesc::Destroy);

void ZRuntimePinConDesc::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZRuntimePinConDesc*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nFromEntityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFromEntityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nToEntityID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nToEntityID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nFromPinID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nFromPinID);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nToPinID") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nToPinID);

	p_Stream << "}";
}

void ZRuntimePinConDesc::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZRuntimePinConDesc s_Object {};

	s_Object.m_nFromEntityID = simdjson::from_json_uint64(p_Document["m_nFromEntityID"]);

	s_Object.m_nToEntityID = simdjson::from_json_uint64(p_Document["m_nToEntityID"]);

	s_Object.m_nFromPinID = simdjson::from_json_uint32(p_Document["m_nFromPinID"]);

	s_Object.m_nToPinID = simdjson::from_json_uint32(p_Document["m_nToPinID"]);

	*reinterpret_cast<ZRuntimePinConDesc*>(p_Target) = s_Object;
}

void ZRuntimePinConDesc::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZRuntimePinConDesc*>(p_Object);

}

bool ZRuntimePinConDesc::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZRuntimePinConDesc*>(p_Left);
	auto* s_Right = reinterpret_cast<ZRuntimePinConDesc*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZRuntimePinConDesc::operator==(const ZRuntimePinConDesc& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZRuntimePinConDesc>)
		return false;

	if (m_nFromEntityID != p_Other.m_nFromEntityID) return false;
	if (m_nToEntityID != p_Other.m_nToEntityID) return false;
	if (m_nFromPinID != p_Other.m_nFromPinID) return false;
	if (m_nToPinID != p_Other.m_nToPinID) return false;

	return true;
}

void ZRuntimePinConDesc::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZRuntimePinConDesc*>(p_Object);
	s_Object->~ZRuntimePinConDesc();
}

ZHMTypeInfo ZScopedER64::TypeInfo = ZHMTypeInfo("ZScopedER64", sizeof(ZScopedER64), alignof(ZScopedER64), ZScopedER64::WriteSimpleJson, ZScopedER64::FromSimpleJson, ZScopedER64::Serialize, ZScopedER64::Equals, ZScopedER64::Destroy);

void ZScopedER64::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_er64") << ":";
	ZER64::WriteSimpleJson(&s_Object->m_er64, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aScopePath") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aScopePath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aScopePath[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aScopePath.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZScopedER64::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZScopedER64 s_Object {};

	{
		ZER64 s_Item {};
		ZER64::FromSimpleJson(p_Document["m_er64"], &s_Item);
		s_Object.m_er64 = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aScopePath"];
	s_Object.m_aScopePath.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aScopePath[s_Index0++] = simdjson::from_json_uint64(s_Item0);
	}
	}

	*reinterpret_cast<ZScopedER64*>(p_Target) = s_Object;
}

void ZScopedER64::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);

	ZER64::Serialize(&s_Object->m_er64, p_Serializer, p_OwnOffset + offsetof(ZScopedER64, m_er64));
	TArray<uint64>::Serialize(&s_Object->m_aScopePath, p_Serializer, p_OwnOffset + offsetof(ZScopedER64, m_aScopePath));
}

bool ZScopedER64::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZScopedER64*>(p_Left);
	auto* s_Right = reinterpret_cast<ZScopedER64*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZScopedER64::operator==(const ZScopedER64& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZScopedER64>)
		return false;

	if (m_er64 != p_Other.m_er64) return false;
	if (m_aScopePath != p_Other.m_aScopePath) return false;

	return true;
}

void ZScopedER64::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZScopedER64*>(p_Object);
	s_Object->~ZScopedER64();
}

ZHMTypeInfo ZScopedRuntimePinConDesc::TypeInfo = ZHMTypeInfo("ZScopedRuntimePinConDesc", sizeof(ZScopedRuntimePinConDesc), alignof(ZScopedRuntimePinConDesc), ZScopedRuntimePinConDesc::WriteSimpleJson, ZScopedRuntimePinConDesc::FromSimpleJson, ZScopedRuntimePinConDesc::Serialize, ZScopedRuntimePinConDesc::Equals, ZScopedRuntimePinConDesc::Destroy);

void ZScopedRuntimePinConDesc::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZScopedRuntimePinConDesc*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_aScopePath") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aScopePath.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aScopePath[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aScopePath.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_PinConDesc") << ":";
	ZRuntimePinConDesc::WriteSimpleJson(&s_Object->m_PinConDesc, p_Stream);

	p_Stream << "}";
}

void ZScopedRuntimePinConDesc::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZScopedRuntimePinConDesc s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aScopePath"];
	s_Object.m_aScopePath.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aScopePath[s_Index0++] = simdjson::from_json_uint64(s_Item0);
	}
	}

	{
		ZRuntimePinConDesc s_Item {};
		ZRuntimePinConDesc::FromSimpleJson(p_Document["m_PinConDesc"], &s_Item);
		s_Object.m_PinConDesc = s_Item;
	}

	*reinterpret_cast<ZScopedRuntimePinConDesc*>(p_Target) = s_Object;
}

void ZScopedRuntimePinConDesc::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZScopedRuntimePinConDesc*>(p_Object);

	TArray<uint64>::Serialize(&s_Object->m_aScopePath, p_Serializer, p_OwnOffset + offsetof(ZScopedRuntimePinConDesc, m_aScopePath));
	ZRuntimePinConDesc::Serialize(&s_Object->m_PinConDesc, p_Serializer, p_OwnOffset + offsetof(ZScopedRuntimePinConDesc, m_PinConDesc));
}

bool ZScopedRuntimePinConDesc::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZScopedRuntimePinConDesc*>(p_Left);
	auto* s_Right = reinterpret_cast<ZScopedRuntimePinConDesc*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZScopedRuntimePinConDesc::operator==(const ZScopedRuntimePinConDesc& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZScopedRuntimePinConDesc>)
		return false;

	if (m_aScopePath != p_Other.m_aScopePath) return false;
	if (m_PinConDesc != p_Other.m_PinConDesc) return false;

	return true;
}

void ZScopedRuntimePinConDesc::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZScopedRuntimePinConDesc*>(p_Object);
	s_Object->~ZScopedRuntimePinConDesc();
}

ZHMTypeInfo ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::TypeInfo = ZHMTypeInfo("ZSecuritySystemCameraConfiguration.SDeadBodyVisibleEscalationRule", sizeof(ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule), alignof(ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule), ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::WriteSimpleJson, ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::FromSimpleJson, ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Serialize, ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Equals, ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Destroy);

void ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_NrGuardsToSend") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_NrGuardsToSend);

	p_Stream << "}";
}

void ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule s_Object {};

	s_Object.m_NrGuardsToSend = simdjson::from_json_int32(p_Document["m_NrGuardsToSend"]);

	*reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Target) = s_Object;
}

void ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Object);

}

bool ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::operator==(const ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule>)
		return false;

	if (m_NrGuardsToSend != p_Other.m_NrGuardsToSend) return false;

	return true;
}

void ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule*>(p_Object);
	s_Object->~ZSecuritySystemCameraConfiguration_SDeadBodyVisibleEscalationRule();
}

ZHMTypeInfo ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::TypeInfo = ZHMTypeInfo("ZSecuritySystemCameraConfiguration.SHitmanVisibleEscalationRule", sizeof(ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule), alignof(ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule), ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::WriteSimpleJson, ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::FromSimpleJson, ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Serialize, ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Equals, ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Destroy);

void ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_NrGuardsToSend") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_NrGuardsToSend);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_Situation") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSecuritySystemCameraConfiguration.ECameraEscalationSituations", static_cast<int>(s_Object->m_Situation)));

	p_Stream << "}";
}

void ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule s_Object {};

	s_Object.m_NrGuardsToSend = simdjson::from_json_int32(p_Document["m_NrGuardsToSend"]);

	s_Object.m_Situation = static_cast<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations>(ZHMEnums::GetEnumValueByName("ZSecuritySystemCameraConfiguration.ECameraEscalationSituations", std::string_view(p_Document["m_Situation"])));

	*reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Target) = s_Object;
}

void ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Object);

}

bool ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::operator==(const ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule>)
		return false;

	if (m_NrGuardsToSend != p_Other.m_NrGuardsToSend) return false;
	if (m_Situation != p_Other.m_Situation) return false;

	return true;
}

void ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule*>(p_Object);
	s_Object->~ZSecuritySystemCameraConfiguration_SHitmanVisibleEscalationRule();
}

ZHMTypeInfo ZSetPieceIconEntity_SIconData::TypeInfo = ZHMTypeInfo("ZSetPieceIconEntity.SIconData", sizeof(ZSetPieceIconEntity_SIconData), alignof(ZSetPieceIconEntity_SIconData), ZSetPieceIconEntity_SIconData::WriteSimpleJson, ZSetPieceIconEntity_SIconData::FromSimpleJson, ZSetPieceIconEntity_SIconData::Serialize, ZSetPieceIconEntity_SIconData::Equals, ZSetPieceIconEntity_SIconData::Destroy);

void ZSetPieceIconEntity_SIconData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("iCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction1") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction1);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction2") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction2);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("iInteraction3") << ":";
	p_Stream << simdjson::as_json_string(s_Object->iInteraction3);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sMissingToolText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sMissingToolText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("bShowMissingTool") << ":";
	p_Stream << simdjson::as_json_string(s_Object->bShowMissingTool);

	p_Stream << "}";
}

void ZSetPieceIconEntity_SIconData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSetPieceIconEntity_SIconData s_Object {};

	s_Object.iCategory = std::string_view(p_Document["iCategory"]);

	s_Object.iInteraction1 = std::string_view(p_Document["iInteraction1"]);

	s_Object.iInteraction2 = std::string_view(p_Document["iInteraction2"]);

	s_Object.iInteraction3 = std::string_view(p_Document["iInteraction3"]);

	s_Object.sMissingToolText = std::string_view(p_Document["sMissingToolText"]);

	s_Object.bShowMissingTool = simdjson::from_json_bool(p_Document["bShowMissingTool"]);

	*reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Target) = s_Object;
}

void ZSetPieceIconEntity_SIconData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Object);

	ZString::Serialize(&s_Object->iCategory, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, iCategory));
	ZString::Serialize(&s_Object->iInteraction1, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, iInteraction1));
	ZString::Serialize(&s_Object->iInteraction2, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, iInteraction2));
	ZString::Serialize(&s_Object->iInteraction3, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, iInteraction3));
	ZString::Serialize(&s_Object->sMissingToolText, p_Serializer, p_OwnOffset + offsetof(ZSetPieceIconEntity_SIconData, sMissingToolText));
}

bool ZSetPieceIconEntity_SIconData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSetPieceIconEntity_SIconData::operator==(const ZSetPieceIconEntity_SIconData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSetPieceIconEntity_SIconData>)
		return false;

	if (iCategory != p_Other.iCategory) return false;
	if (iInteraction1 != p_Other.iInteraction1) return false;
	if (iInteraction2 != p_Other.iInteraction2) return false;
	if (iInteraction3 != p_Other.iInteraction3) return false;
	if (sMissingToolText != p_Other.sMissingToolText) return false;
	if (bShowMissingTool != p_Other.bShowMissingTool) return false;

	return true;
}

void ZSetPieceIconEntity_SIconData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSetPieceIconEntity_SIconData*>(p_Object);
	s_Object->~ZSetPieceIconEntity_SIconData();
}

ZHMTypeInfo ZSharedSensorDef_SVisibilitySetting::TypeInfo = ZHMTypeInfo("ZSharedSensorDef.SVisibilitySetting", sizeof(ZSharedSensorDef_SVisibilitySetting), alignof(ZSharedSensorDef_SVisibilitySetting), ZSharedSensorDef_SVisibilitySetting::WriteSimpleJson, ZSharedSensorDef_SVisibilitySetting::FromSimpleJson, ZSharedSensorDef_SVisibilitySetting::Serialize, ZSharedSensorDef_SVisibilitySetting::Equals, ZSharedSensorDef_SVisibilitySetting::Destroy);

void ZSharedSensorDef_SVisibilitySetting::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSensitivity") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EActorPerceptionSensitivity", static_cast<int>(s_Object->m_eSensitivity)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fCloseRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fCloseRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralAngleWhileMoving") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralAngleWhileMoving);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralHigh") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralHigh);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fPeripheralLow") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fPeripheralLow);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeWidthAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeWidthAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeHeightAngle") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeHeightAngle);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fFocusConeBackWidth") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fFocusConeBackWidth);

	p_Stream << "}";
}

void ZSharedSensorDef_SVisibilitySetting::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSharedSensorDef_SVisibilitySetting s_Object {};

	s_Object.m_eSensitivity = static_cast<EActorPerceptionSensitivity>(ZHMEnums::GetEnumValueByName("EActorPerceptionSensitivity", std::string_view(p_Document["m_eSensitivity"])));

	s_Object.m_fCloseRange = simdjson::from_json_float32(p_Document["m_fCloseRange"]);

	s_Object.m_fPeripheralAngle = simdjson::from_json_float32(p_Document["m_fPeripheralAngle"]);

	s_Object.m_fPeripheralAngleWhileMoving = simdjson::from_json_float32(p_Document["m_fPeripheralAngleWhileMoving"]);

	s_Object.m_fPeripheralHigh = simdjson::from_json_float32(p_Document["m_fPeripheralHigh"]);

	s_Object.m_fPeripheralLow = simdjson::from_json_float32(p_Document["m_fPeripheralLow"]);

	s_Object.m_fFocusConeWidthAngle = simdjson::from_json_float32(p_Document["m_fFocusConeWidthAngle"]);

	s_Object.m_fFocusConeHeightAngle = simdjson::from_json_float32(p_Document["m_fFocusConeHeightAngle"]);

	s_Object.m_fFocusConeRange = simdjson::from_json_float32(p_Document["m_fFocusConeRange"]);

	s_Object.m_fFocusConeBackWidth = simdjson::from_json_float32(p_Document["m_fFocusConeBackWidth"]);

	*reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Target) = s_Object;
}

void ZSharedSensorDef_SVisibilitySetting::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);

}

bool ZSharedSensorDef_SVisibilitySetting::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSharedSensorDef_SVisibilitySetting::operator==(const ZSharedSensorDef_SVisibilitySetting& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSharedSensorDef_SVisibilitySetting>)
		return false;

	if (m_eSensitivity != p_Other.m_eSensitivity) return false;
	if (m_fCloseRange != p_Other.m_fCloseRange) return false;
	if (m_fPeripheralAngle != p_Other.m_fPeripheralAngle) return false;
	if (m_fPeripheralAngleWhileMoving != p_Other.m_fPeripheralAngleWhileMoving) return false;
	if (m_fPeripheralHigh != p_Other.m_fPeripheralHigh) return false;
	if (m_fPeripheralLow != p_Other.m_fPeripheralLow) return false;
	if (m_fFocusConeWidthAngle != p_Other.m_fFocusConeWidthAngle) return false;
	if (m_fFocusConeHeightAngle != p_Other.m_fFocusConeHeightAngle) return false;
	if (m_fFocusConeRange != p_Other.m_fFocusConeRange) return false;
	if (m_fFocusConeBackWidth != p_Other.m_fFocusConeBackWidth) return false;

	return true;
}

void ZSharedSensorDef_SVisibilitySetting::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSharedSensorDef_SVisibilitySetting*>(p_Object);
	s_Object->~ZSharedSensorDef_SVisibilitySetting();
}

ZHMTypeInfo ZSituationGroup::TypeInfo = ZHMTypeInfo("ZSituationGroup", sizeof(ZSituationGroup), alignof(ZSituationGroup), ZSituationGroup::WriteSimpleJson, ZSituationGroup::FromSimpleJson, ZSituationGroup::Serialize, ZSituationGroup::Equals, ZSituationGroup::Destroy);

void ZSituationGroup::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSituationGroup::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSituationGroup s_Object {};

	*reinterpret_cast<ZSituationGroup*>(p_Target) = s_Object;
}

void ZSituationGroup::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);

}

bool ZSituationGroup::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSituationGroup*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSituationGroup*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSituationGroup::operator==(const ZSituationGroup& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSituationGroup>)
		return false;


	return true;
}

void ZSituationGroup::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSituationGroup*>(p_Object);
	s_Object->~ZSituationGroup();
}

ZHMTypeInfo ZSituationOrder::TypeInfo = ZHMTypeInfo("ZSituationOrder", sizeof(ZSituationOrder), alignof(ZSituationOrder), ZSituationOrder::WriteSimpleJson, ZSituationOrder::FromSimpleJson, ZSituationOrder::Serialize, ZSituationOrder::Equals, ZSituationOrder::Destroy);

void ZSituationOrder::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSituationOrder::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSituationOrder s_Object {};

	*reinterpret_cast<ZSituationOrder*>(p_Target) = s_Object;
}

void ZSituationOrder::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);

}

bool ZSituationOrder::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSituationOrder*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSituationOrder*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSituationOrder::operator==(const ZSituationOrder& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSituationOrder>)
		return false;


	return true;
}

void ZSituationOrder::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSituationOrder*>(p_Object);
	s_Object->~ZSituationOrder();
}

ZHMTypeInfo ZSniperCombatSituation_SSniperSuspiciousArea::TypeInfo = ZHMTypeInfo("ZSniperCombatSituation.SSniperSuspiciousArea", sizeof(ZSniperCombatSituation_SSniperSuspiciousArea), alignof(ZSniperCombatSituation_SSniperSuspiciousArea), ZSniperCombatSituation_SSniperSuspiciousArea::WriteSimpleJson, ZSniperCombatSituation_SSniperSuspiciousArea::FromSimpleJson, ZSniperCombatSituation_SSniperSuspiciousArea::Serialize, ZSniperCombatSituation_SSniperSuspiciousArea::Equals, ZSniperCombatSituation_SSniperSuspiciousArea::Destroy);

void ZSniperCombatSituation_SSniperSuspiciousArea::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_vPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRange") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRange);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bIsIslandEntrance") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bIsIslandEntrance);

	p_Stream << "}";
}

void ZSniperCombatSituation_SSniperSuspiciousArea::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSniperCombatSituation_SSniperSuspiciousArea s_Object {};

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vPosition"], &s_Item);
		s_Object.m_vPosition = s_Item;
	}

	s_Object.m_fRange = simdjson::from_json_float32(p_Document["m_fRange"]);

	s_Object.m_bIsIslandEntrance = simdjson::from_json_bool(p_Document["m_bIsIslandEntrance"]);

	*reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Target) = s_Object;
}

void ZSniperCombatSituation_SSniperSuspiciousArea::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Object);

	float4::Serialize(&s_Object->m_vPosition, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSniperSuspiciousArea, m_vPosition));
}

bool ZSniperCombatSituation_SSniperSuspiciousArea::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSniperCombatSituation_SSniperSuspiciousArea::operator==(const ZSniperCombatSituation_SSniperSuspiciousArea& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSniperCombatSituation_SSniperSuspiciousArea>)
		return false;

	if (m_vPosition != p_Other.m_vPosition) return false;
	if (m_fRange != p_Other.m_fRange) return false;
	if (m_bIsIslandEntrance != p_Other.m_bIsIslandEntrance) return false;

	return true;
}

void ZSniperCombatSituation_SSniperSuspiciousArea::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSniperSuspiciousArea*>(p_Object);
	s_Object->~ZSniperCombatSituation_SSniperSuspiciousArea();
}

ZHMTypeInfo ZSniperCombatSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZSniperCombatSituation.SSituationSaveData", sizeof(ZSniperCombatSituation_SSituationSaveData), alignof(ZSniperCombatSituation_SSituationSaveData), ZSniperCombatSituation_SSituationSaveData::WriteSimpleJson, ZSniperCombatSituation_SSituationSaveData::FromSimpleJson, ZSniperCombatSituation_SSituationSaveData::Serialize, ZSniperCombatSituation_SSituationSaveData::Equals, ZSniperCombatSituation_SSituationSaveData::Destroy);

void ZSniperCombatSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_rSniperLocation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rSniperLocation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSniperCombatGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSniperCombatGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSniperCombatGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aSniperCombatGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bAggressive") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bAggressive);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bKiller") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bKiller);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rIsland") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rIsland);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aSuspiciousAreas") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aSuspiciousAreas.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aSuspiciousAreas[i];
		ZSniperCombatSituation_SSniperSuspiciousArea::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->m_aSuspiciousAreas.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aWaitingGuards") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aWaitingGuards.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aWaitingGuards[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aWaitingGuards.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aFleeCandidates") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aFleeCandidates.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aFleeCandidates[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aFleeCandidates.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHasFailed") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHasFailed);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZSniperCombatSituation.ESituationState", static_cast<int>(s_Object->m_eState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGuards") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGuards);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSniperCombatSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSniperCombatSituation_SSituationSaveData s_Object {};

	s_Object.m_rSniperLocation = simdjson::from_json_uint32(p_Document["m_rSniperLocation"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSniperCombatGroups"];
	s_Object.m_aSniperCombatGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aSniperCombatGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	s_Object.m_bAggressive = simdjson::from_json_bool(p_Document["m_bAggressive"]);

	s_Object.m_bKiller = simdjson::from_json_bool(p_Document["m_bKiller"]);

	s_Object.m_rIsland = simdjson::from_json_uint32(p_Document["m_rIsland"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aSuspiciousAreas"];
	s_Object.m_aSuspiciousAreas.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZSniperCombatSituation_SSniperSuspiciousArea s_ArrayItem0;
		ZSniperCombatSituation_SSniperSuspiciousArea::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.m_aSuspiciousAreas[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aWaitingGuards"];
	s_Object.m_aWaitingGuards.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aWaitingGuards[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aFleeCandidates"];
	s_Object.m_aFleeCandidates.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aFleeCandidates[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	s_Object.m_bHasFailed = simdjson::from_json_bool(p_Document["m_bHasFailed"]);

	s_Object.m_eState = static_cast<ZSniperCombatSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZSniperCombatSituation.ESituationState", std::string_view(p_Document["m_eState"])));

	s_Object.m_nGuards = simdjson::from_json_uint32(p_Document["m_nGuards"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAvoidDangerGroups"];
	s_Object.m_aAvoidDangerGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aAvoidDangerGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZSniperCombatSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aSniperCombatGroups, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aSniperCombatGroups));
	TArray<ZSniperCombatSituation_SSniperSuspiciousArea>::Serialize(&s_Object->m_aSuspiciousAreas, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aSuspiciousAreas));
	TArray<uint32>::Serialize(&s_Object->m_aWaitingGuards, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aWaitingGuards));
	TArray<uint32>::Serialize(&s_Object->m_aFleeCandidates, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aFleeCandidates));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(ZSniperCombatSituation_SSituationSaveData, m_aAvoidDangerGroups));
}

bool ZSniperCombatSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSniperCombatSituation_SSituationSaveData::operator==(const ZSniperCombatSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSniperCombatSituation_SSituationSaveData>)
		return false;

	if (m_rSniperLocation != p_Other.m_rSniperLocation) return false;
	if (m_aSniperCombatGroups != p_Other.m_aSniperCombatGroups) return false;
	if (m_bAggressive != p_Other.m_bAggressive) return false;
	if (m_bKiller != p_Other.m_bKiller) return false;
	if (m_rIsland != p_Other.m_rIsland) return false;
	if (m_aSuspiciousAreas != p_Other.m_aSuspiciousAreas) return false;
	if (m_aWaitingGuards != p_Other.m_aWaitingGuards) return false;
	if (m_aFleeCandidates != p_Other.m_aFleeCandidates) return false;
	if (m_bHasFailed != p_Other.m_bHasFailed) return false;
	if (m_eState != p_Other.m_eState) return false;
	if (m_nGuards != p_Other.m_nGuards) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;

	return true;
}

void ZSniperCombatSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSniperCombatSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZSniperCombatSituation_SSituationSaveData();
}

ZHMTypeInfo ZSoundCollisionInfo::TypeInfo = ZHMTypeInfo("ZSoundCollisionInfo", sizeof(ZSoundCollisionInfo), alignof(ZSoundCollisionInfo), ZSoundCollisionInfo::WriteSimpleJson, ZSoundCollisionInfo::FromSimpleJson, ZSoundCollisionInfo::Serialize, ZSoundCollisionInfo::Equals, ZSoundCollisionInfo::Destroy);

void ZSoundCollisionInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZSoundCollisionInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSoundCollisionInfo s_Object {};

	*reinterpret_cast<ZSoundCollisionInfo*>(p_Target) = s_Object;
}

void ZSoundCollisionInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);

}

bool ZSoundCollisionInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSoundCollisionInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSoundCollisionInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSoundCollisionInfo::operator==(const ZSoundCollisionInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSoundCollisionInfo>)
		return false;


	return true;
}

void ZSoundCollisionInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSoundCollisionInfo*>(p_Object);
	s_Object->~ZSoundCollisionInfo();
}

ZHMTypeInfo ZSpectatorSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZSpectatorSituation.SSituationSaveData", sizeof(ZSpectatorSituation_SSituationSaveData), alignof(ZSpectatorSituation_SSituationSaveData), ZSpectatorSituation_SSituationSaveData::WriteSimpleJson, ZSpectatorSituation_SSituationSaveData::FromSimpleJson, ZSpectatorSituation_SSituationSaveData::Serialize, ZSpectatorSituation_SSituationSaveData::Equals, ZSpectatorSituation_SSituationSaveData::Destroy);

void ZSpectatorSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_bStandingDown") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStandingDown);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aObserverGroupIDs") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aObserverGroupIDs.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aObserverGroupIDs[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aObserverGroupIDs.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aNonObserverMembers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aNonObserverMembers.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aNonObserverMembers[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aNonObserverMembers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZSpectatorSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZSpectatorSituation_SSituationSaveData s_Object {};

	s_Object.m_bStandingDown = simdjson::from_json_bool(p_Document["m_bStandingDown"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aObserverGroupIDs"];
	s_Object.m_aObserverGroupIDs.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aObserverGroupIDs[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aNonObserverMembers"];
	s_Object.m_aNonObserverMembers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aNonObserverMembers[s_Index0++] = simdjson::from_json_uint32(s_Item0);
	}
	}

	*reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZSpectatorSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Object);

	TArray<int32>::Serialize(&s_Object->m_aObserverGroupIDs, p_Serializer, p_OwnOffset + offsetof(ZSpectatorSituation_SSituationSaveData, m_aObserverGroupIDs));
	TArray<uint32>::Serialize(&s_Object->m_aNonObserverMembers, p_Serializer, p_OwnOffset + offsetof(ZSpectatorSituation_SSituationSaveData, m_aNonObserverMembers));
}

bool ZSpectatorSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZSpectatorSituation_SSituationSaveData::operator==(const ZSpectatorSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZSpectatorSituation_SSituationSaveData>)
		return false;

	if (m_bStandingDown != p_Other.m_bStandingDown) return false;
	if (m_aObserverGroupIDs != p_Other.m_aObserverGroupIDs) return false;
	if (m_aNonObserverMembers != p_Other.m_aNonObserverMembers) return false;

	return true;
}

void ZSpectatorSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZSpectatorSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZSpectatorSituation_SSituationSaveData();
}

ZHMTypeInfo ZStandOffSituation_SState::TypeInfo = ZHMTypeInfo("ZStandOffSituation.SState", sizeof(ZStandOffSituation_SState), alignof(ZStandOffSituation_SState), ZStandOffSituation_SState::WriteSimpleJson, ZStandOffSituation_SState::FromSimpleJson, ZStandOffSituation_SState::Serialize, ZStandOffSituation_SState::Equals, ZStandOffSituation_SState::Destroy);

void ZStandOffSituation_SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZStandOffSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eArrestReason") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("EDisturbanceType", static_cast<int>(s_Object->m_eArrestReason)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningPriority") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningPriority);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TargetHasWeaponEquipped") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_TargetHasWeaponEquipped);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_ImmediateWarningDialog") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_ImmediateWarningDialog);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nResetCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nResetCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bArrestReasonStated") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bArrestReasonStated);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetOnStairs") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetOnStairs);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bUpdateApproachPositions") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bUpdateApproachPositions);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHelpOrderAssigned") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHelpOrderAssigned);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bCivilianTransferredKnowledge") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bCivilianTransferredKnowledge);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTargetLost") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTargetLost);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bGetHelpGroupStarted") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bGetHelpGroupStarted);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bHandlerHasLOS") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bHandlerHasLOS);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vLastKnownPosition") << ":";
	float4::WriteSimpleJson(&s_Object->m_vLastKnownPosition, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fMovingTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fMovingTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fRunningTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fRunningTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fEquippedWeaponTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fEquippedWeaponTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_fStrangleTime") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_fStrangleTime);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_mainStateStartTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_mainStateStartTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeTargetLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeTargetLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeGuardHadLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeGuardHadLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tNextCivBark") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tNextCivBark, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartSearchCountdown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartSearchCountdown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_eDialogState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZStandOffSituation.EDialogState", static_cast<int>(s_Object->m_eDialogState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nWarningCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nWarningCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bWarning3Given") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bWarning3Given);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopWarningGiven") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopWarningGiven);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_reportedTarget") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_reportedTarget);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bTriggeredBySecurityCameras") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bTriggeredBySecurityCameras);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bLOSMemberWantsToKill") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bLOSMemberWantsToKill);

	p_Stream << "}";
}

void ZStandOffSituation_SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZStandOffSituation_SState s_Object {};

	s_Object.m_eSituationState = static_cast<ZStandOffSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZStandOffSituation.ESituationState", std::string_view(p_Document["m_eSituationState"])));

	s_Object.m_eArrestReason = static_cast<EDisturbanceType>(ZHMEnums::GetEnumValueByName("EDisturbanceType", std::string_view(p_Document["m_eArrestReason"])));

	s_Object.m_nWarningPriority = simdjson::from_json_uint32(p_Document["m_nWarningPriority"]);

	s_Object.m_TargetHasWeaponEquipped = simdjson::from_json_bool(p_Document["m_TargetHasWeaponEquipped"]);

	s_Object.m_ImmediateWarningDialog = simdjson::from_json_bool(p_Document["m_ImmediateWarningDialog"]);

	s_Object.m_nResetCount = simdjson::from_json_int32(p_Document["m_nResetCount"]);

	s_Object.m_bArrestReasonStated = simdjson::from_json_bool(p_Document["m_bArrestReasonStated"]);

	s_Object.m_bTargetOnStairs = simdjson::from_json_bool(p_Document["m_bTargetOnStairs"]);

	s_Object.m_bUpdateApproachPositions = simdjson::from_json_bool(p_Document["m_bUpdateApproachPositions"]);

	s_Object.m_bHelpOrderAssigned = simdjson::from_json_bool(p_Document["m_bHelpOrderAssigned"]);

	s_Object.m_bCivilianTransferredKnowledge = simdjson::from_json_bool(p_Document["m_bCivilianTransferredKnowledge"]);

	s_Object.m_bTargetLost = simdjson::from_json_bool(p_Document["m_bTargetLost"]);

	s_Object.m_bGetHelpGroupStarted = simdjson::from_json_bool(p_Document["m_bGetHelpGroupStarted"]);

	s_Object.m_bHandlerHasLOS = simdjson::from_json_bool(p_Document["m_bHandlerHasLOS"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vLastKnownPosition"], &s_Item);
		s_Object.m_vLastKnownPosition = s_Item;
	}

	s_Object.m_fMovingTime = simdjson::from_json_float32(p_Document["m_fMovingTime"]);

	s_Object.m_fRunningTime = simdjson::from_json_float32(p_Document["m_fRunningTime"]);

	s_Object.m_fEquippedWeaponTime = simdjson::from_json_float32(p_Document["m_fEquippedWeaponTime"]);

	s_Object.m_fStrangleTime = simdjson::from_json_float32(p_Document["m_fStrangleTime"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_mainStateStartTime"], &s_Item);
		s_Object.m_mainStateStartTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTimeTargetLOS"], &s_Item);
		s_Object.m_tLastTimeTargetLOS = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTimeGuardHadLOS"], &s_Item);
		s_Object.m_tLastTimeGuardHadLOS = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tNextCivBark"], &s_Item);
		s_Object.m_tNextCivBark = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStartSearchCountdown"], &s_Item);
		s_Object.m_tStartSearchCountdown = s_Item;
	}

	s_Object.m_eDialogState = static_cast<ZStandOffSituation_EDialogState>(ZHMEnums::GetEnumValueByName("ZStandOffSituation.EDialogState", std::string_view(p_Document["m_eDialogState"])));

	s_Object.m_nWarningCount = simdjson::from_json_int32(p_Document["m_nWarningCount"]);

	s_Object.m_bWarning3Given = simdjson::from_json_bool(p_Document["m_bWarning3Given"]);

	s_Object.m_bStopWarningGiven = simdjson::from_json_bool(p_Document["m_bStopWarningGiven"]);

	s_Object.m_reportedTarget = simdjson::from_json_bool(p_Document["m_reportedTarget"]);

	s_Object.m_bTriggeredBySecurityCameras = simdjson::from_json_bool(p_Document["m_bTriggeredBySecurityCameras"]);

	s_Object.m_bLOSMemberWantsToKill = simdjson::from_json_bool(p_Document["m_bLOSMemberWantsToKill"]);

	*reinterpret_cast<ZStandOffSituation_SState*>(p_Target) = s_Object;
}

void ZStandOffSituation_SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SState*>(p_Object);

	float4::Serialize(&s_Object->m_vLastKnownPosition, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_vLastKnownPosition));
	ZGameTime::Serialize(&s_Object->m_mainStateStartTime, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_mainStateStartTime));
	ZGameTime::Serialize(&s_Object->m_tLastTimeTargetLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_tLastTimeTargetLOS));
	ZGameTime::Serialize(&s_Object->m_tLastTimeGuardHadLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_tLastTimeGuardHadLOS));
	ZGameTime::Serialize(&s_Object->m_tNextCivBark, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_tNextCivBark));
	ZGameTime::Serialize(&s_Object->m_tStartSearchCountdown, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SState, m_tStartSearchCountdown));
}

bool ZStandOffSituation_SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZStandOffSituation_SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZStandOffSituation_SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZStandOffSituation_SState::operator==(const ZStandOffSituation_SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZStandOffSituation_SState>)
		return false;

	if (m_eSituationState != p_Other.m_eSituationState) return false;
	if (m_eArrestReason != p_Other.m_eArrestReason) return false;
	if (m_nWarningPriority != p_Other.m_nWarningPriority) return false;
	if (m_TargetHasWeaponEquipped != p_Other.m_TargetHasWeaponEquipped) return false;
	if (m_ImmediateWarningDialog != p_Other.m_ImmediateWarningDialog) return false;
	if (m_nResetCount != p_Other.m_nResetCount) return false;
	if (m_bArrestReasonStated != p_Other.m_bArrestReasonStated) return false;
	if (m_bTargetOnStairs != p_Other.m_bTargetOnStairs) return false;
	if (m_bUpdateApproachPositions != p_Other.m_bUpdateApproachPositions) return false;
	if (m_bHelpOrderAssigned != p_Other.m_bHelpOrderAssigned) return false;
	if (m_bCivilianTransferredKnowledge != p_Other.m_bCivilianTransferredKnowledge) return false;
	if (m_bTargetLost != p_Other.m_bTargetLost) return false;
	if (m_bGetHelpGroupStarted != p_Other.m_bGetHelpGroupStarted) return false;
	if (m_bHandlerHasLOS != p_Other.m_bHandlerHasLOS) return false;
	if (m_vLastKnownPosition != p_Other.m_vLastKnownPosition) return false;
	if (m_fMovingTime != p_Other.m_fMovingTime) return false;
	if (m_fRunningTime != p_Other.m_fRunningTime) return false;
	if (m_fEquippedWeaponTime != p_Other.m_fEquippedWeaponTime) return false;
	if (m_fStrangleTime != p_Other.m_fStrangleTime) return false;
	if (m_mainStateStartTime != p_Other.m_mainStateStartTime) return false;
	if (m_tLastTimeTargetLOS != p_Other.m_tLastTimeTargetLOS) return false;
	if (m_tLastTimeGuardHadLOS != p_Other.m_tLastTimeGuardHadLOS) return false;
	if (m_tNextCivBark != p_Other.m_tNextCivBark) return false;
	if (m_tStartSearchCountdown != p_Other.m_tStartSearchCountdown) return false;
	if (m_eDialogState != p_Other.m_eDialogState) return false;
	if (m_nWarningCount != p_Other.m_nWarningCount) return false;
	if (m_bWarning3Given != p_Other.m_bWarning3Given) return false;
	if (m_bStopWarningGiven != p_Other.m_bStopWarningGiven) return false;
	if (m_reportedTarget != p_Other.m_reportedTarget) return false;
	if (m_bTriggeredBySecurityCameras != p_Other.m_bTriggeredBySecurityCameras) return false;
	if (m_bLOSMemberWantsToKill != p_Other.m_bLOSMemberWantsToKill) return false;

	return true;
}

void ZStandOffSituation_SState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SState*>(p_Object);
	s_Object->~ZStandOffSituation_SState();
}

ZHMTypeInfo ZStandOffSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZStandOffSituation.SSituationSaveData", sizeof(ZStandOffSituation_SSituationSaveData), alignof(ZStandOffSituation_SSituationSaveData), ZStandOffSituation_SSituationSaveData::WriteSimpleJson, ZStandOffSituation_SSituationSaveData::FromSimpleJson, ZStandOffSituation_SSituationSaveData::Serialize, ZStandOffSituation_SSituationSaveData::Equals, ZStandOffSituation_SSituationSaveData::Destroy);

void ZStandOffSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZStandOffSituation_SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pArrestor") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pArrestor);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pSpeaker") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pSpeaker);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_TargetWeaponItem") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_TargetWeaponItem);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_IllegalWeaponSeen") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_IllegalWeaponSeen);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_pGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_pGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rIsland") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rIsland);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTimeTargetLOS") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTimeTargetLOS, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_aAvoidDangerGroups") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->m_aAvoidDangerGroups.size(); ++i)
	{
		auto& s_Item0 = s_Object->m_aAvoidDangerGroups[i];
		p_Stream << simdjson::as_json_string(s_Item0);

		if (i < s_Object->m_aAvoidDangerGroups.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZStandOffSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZStandOffSituation_SSituationSaveData s_Object {};

	{
		ZStandOffSituation_SState s_Item {};
		ZStandOffSituation_SState::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	s_Object.m_pArrestor = simdjson::from_json_uint32(p_Document["m_pArrestor"]);

	s_Object.m_pSpeaker = simdjson::from_json_uint32(p_Document["m_pSpeaker"]);

	s_Object.m_TargetWeaponItem = simdjson::from_json_uint32(p_Document["m_TargetWeaponItem"]);

	s_Object.m_IllegalWeaponSeen = simdjson::from_json_uint32(p_Document["m_IllegalWeaponSeen"]);

	s_Object.m_pGetHelpGroup = simdjson::from_json_int32(p_Document["m_pGetHelpGroup"]);

	s_Object.m_rIsland = simdjson::from_json_uint32(p_Document["m_rIsland"]);

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTimeTargetLOS"], &s_Item);
		s_Object.m_tLastTimeTargetLOS = s_Item;
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["m_aAvoidDangerGroups"];
	s_Object.m_aAvoidDangerGroups.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		s_Object.m_aAvoidDangerGroups[s_Index0++] = simdjson::from_json_int32(s_Item0);
	}
	}

	*reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZStandOffSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Object);

	ZStandOffSituation_SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SSituationSaveData, m_State));
	ZGameTime::Serialize(&s_Object->m_tLastTimeTargetLOS, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SSituationSaveData, m_tLastTimeTargetLOS));
	TArray<int32>::Serialize(&s_Object->m_aAvoidDangerGroups, p_Serializer, p_OwnOffset + offsetof(ZStandOffSituation_SSituationSaveData, m_aAvoidDangerGroups));
}

bool ZStandOffSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZStandOffSituation_SSituationSaveData::operator==(const ZStandOffSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZStandOffSituation_SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_pArrestor != p_Other.m_pArrestor) return false;
	if (m_pSpeaker != p_Other.m_pSpeaker) return false;
	if (m_TargetWeaponItem != p_Other.m_TargetWeaponItem) return false;
	if (m_IllegalWeaponSeen != p_Other.m_IllegalWeaponSeen) return false;
	if (m_pGetHelpGroup != p_Other.m_pGetHelpGroup) return false;
	if (m_rIsland != p_Other.m_rIsland) return false;
	if (m_tLastTimeTargetLOS != p_Other.m_tLastTimeTargetLOS) return false;
	if (m_aAvoidDangerGroups != p_Other.m_aAvoidDangerGroups) return false;

	return true;
}

void ZStandOffSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZStandOffSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZStandOffSituation_SSituationSaveData();
}

ZHMTypeInfo ZTime::TypeInfo = ZHMTypeInfo("ZTime", sizeof(ZTime), alignof(ZTime), ZTime::WriteSimpleJson, ZTime::FromSimpleJson, ZTime::Serialize, ZTime::Equals, ZTime::Destroy);

void ZTime::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_nValue") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nValue);

	p_Stream << "}";
}

void ZTime::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZTime s_Object {};

	s_Object.m_nValue = simdjson::from_json_uint64(p_Document["m_nValue"]);

	*reinterpret_cast<ZTime*>(p_Target) = s_Object;
}

void ZTime::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);

}

bool ZTime::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTime*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTime*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTime::operator==(const ZTime& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTime>)
		return false;

	if (m_nValue != p_Other.m_nValue) return false;

	return true;
}

void ZTime::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZTime*>(p_Object);
	s_Object->~ZTime();
}

ZHMTypeInfo ZTrespassingSituation_SState::TypeInfo = ZHMTypeInfo("ZTrespassingSituation.SState", sizeof(ZTrespassingSituation_SState), alignof(ZTrespassingSituation_SState), ZTrespassingSituation_SState::WriteSimpleJson, ZTrespassingSituation_SState::FromSimpleJson, ZTrespassingSituation_SState::Serialize, ZTrespassingSituation_SState::Equals, ZTrespassingSituation_SState::Destroy);

void ZTrespassingSituation_SState::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SState*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_eSituationState") << ":";
	p_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName("ZTrespassingSituation.ESituationState", static_cast<int>(s_Object->m_eSituationState)));
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tDeepTrespassingTime") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tDeepTrespassingTime, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tStartStandDown") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tStartStandDown, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_tLastTargetVisible") << ":";
	ZGameTime::WriteSimpleJson(&s_Object->m_tLastTargetVisible, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bStopWarningGiven") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bStopWarningGiven);

	p_Stream << "}";
}

void ZTrespassingSituation_SState::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZTrespassingSituation_SState s_Object {};

	s_Object.m_eSituationState = static_cast<ZTrespassingSituation_ESituationState>(ZHMEnums::GetEnumValueByName("ZTrespassingSituation.ESituationState", std::string_view(p_Document["m_eSituationState"])));

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tDeepTrespassingTime"], &s_Item);
		s_Object.m_tDeepTrespassingTime = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tStartStandDown"], &s_Item);
		s_Object.m_tStartStandDown = s_Item;
	}

	{
		ZGameTime s_Item {};
		ZGameTime::FromSimpleJson(p_Document["m_tLastTargetVisible"], &s_Item);
		s_Object.m_tLastTargetVisible = s_Item;
	}

	s_Object.m_bStopWarningGiven = simdjson::from_json_bool(p_Document["m_bStopWarningGiven"]);

	*reinterpret_cast<ZTrespassingSituation_SState*>(p_Target) = s_Object;
}

void ZTrespassingSituation_SState::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SState*>(p_Object);

	ZGameTime::Serialize(&s_Object->m_tDeepTrespassingTime, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SState, m_tDeepTrespassingTime));
	ZGameTime::Serialize(&s_Object->m_tStartStandDown, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SState, m_tStartStandDown));
	ZGameTime::Serialize(&s_Object->m_tLastTargetVisible, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SState, m_tLastTargetVisible));
}

bool ZTrespassingSituation_SState::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTrespassingSituation_SState*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTrespassingSituation_SState*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTrespassingSituation_SState::operator==(const ZTrespassingSituation_SState& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTrespassingSituation_SState>)
		return false;

	if (m_eSituationState != p_Other.m_eSituationState) return false;
	if (m_tDeepTrespassingTime != p_Other.m_tDeepTrespassingTime) return false;
	if (m_tStartStandDown != p_Other.m_tStartStandDown) return false;
	if (m_tLastTargetVisible != p_Other.m_tLastTargetVisible) return false;
	if (m_bStopWarningGiven != p_Other.m_bStopWarningGiven) return false;

	return true;
}

void ZTrespassingSituation_SState::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SState*>(p_Object);
	s_Object->~ZTrespassingSituation_SState();
}

ZHMTypeInfo ZTrespassingSituation_SSituationSaveData::TypeInfo = ZHMTypeInfo("ZTrespassingSituation.SSituationSaveData", sizeof(ZTrespassingSituation_SSituationSaveData), alignof(ZTrespassingSituation_SSituationSaveData), ZTrespassingSituation_SSituationSaveData::WriteSimpleJson, ZTrespassingSituation_SSituationSaveData::FromSimpleJson, ZTrespassingSituation_SSituationSaveData::Serialize, ZTrespassingSituation_SSituationSaveData::Equals, ZTrespassingSituation_SSituationSaveData::Destroy);

void ZTrespassingSituation_SSituationSaveData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("m_State") << ":";
	ZTrespassingSituation_SState::WriteSimpleJson(&s_Object->m_State, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rEscortingMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rEscortingMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_rHelpingGuardMember") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_rHelpingGuardMember);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_vEscortOutExitLocation") << ":";
	float4::WriteSimpleJson(&s_Object->m_vEscortOutExitLocation, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_nGetHelpGroup") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_nGetHelpGroup);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("m_bPropagationEnabled") << ":";
	p_Stream << simdjson::as_json_string(s_Object->m_bPropagationEnabled);

	p_Stream << "}";
}

void ZTrespassingSituation_SSituationSaveData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZTrespassingSituation_SSituationSaveData s_Object {};

	{
		ZTrespassingSituation_SState s_Item {};
		ZTrespassingSituation_SState::FromSimpleJson(p_Document["m_State"], &s_Item);
		s_Object.m_State = s_Item;
	}

	s_Object.m_rEscortingMember = simdjson::from_json_uint32(p_Document["m_rEscortingMember"]);

	s_Object.m_rHelpingGuardMember = simdjson::from_json_uint32(p_Document["m_rHelpingGuardMember"]);

	{
		float4 s_Item {};
		float4::FromSimpleJson(p_Document["m_vEscortOutExitLocation"], &s_Item);
		s_Object.m_vEscortOutExitLocation = s_Item;
	}

	s_Object.m_nGetHelpGroup = simdjson::from_json_int32(p_Document["m_nGetHelpGroup"]);

	s_Object.m_bPropagationEnabled = simdjson::from_json_bool(p_Document["m_bPropagationEnabled"]);

	*reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Target) = s_Object;
}

void ZTrespassingSituation_SSituationSaveData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Object);

	ZTrespassingSituation_SState::Serialize(&s_Object->m_State, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SSituationSaveData, m_State));
	float4::Serialize(&s_Object->m_vEscortOutExitLocation, p_Serializer, p_OwnOffset + offsetof(ZTrespassingSituation_SSituationSaveData, m_vEscortOutExitLocation));
}

bool ZTrespassingSituation_SSituationSaveData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZTrespassingSituation_SSituationSaveData::operator==(const ZTrespassingSituation_SSituationSaveData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZTrespassingSituation_SSituationSaveData>)
		return false;

	if (m_State != p_Other.m_State) return false;
	if (m_rEscortingMember != p_Other.m_rEscortingMember) return false;
	if (m_rHelpingGuardMember != p_Other.m_rHelpingGuardMember) return false;
	if (m_vEscortOutExitLocation != p_Other.m_vEscortOutExitLocation) return false;
	if (m_nGetHelpGroup != p_Other.m_nGetHelpGroup) return false;
	if (m_bPropagationEnabled != p_Other.m_bPropagationEnabled) return false;

	return true;
}

void ZTrespassingSituation_SSituationSaveData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZTrespassingSituation_SSituationSaveData*>(p_Object);
	s_Object->~ZTrespassingSituation_SSituationSaveData();
}

ZHMTypeInfo ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::TypeInfo = ZHMTypeInfo("ZUIActionSelectorNavigationInventoryEntity.SActionSelectorSlotDisplayInfo", sizeof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo), alignof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo), ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Serialize, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Equals, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Destroy);

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("silencer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->silencer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("count") << ":";
	p_Stream << simdjson::as_json_string(s_Object->count);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ammo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ammo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("id") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("weaponCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->weaponCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategoryLKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategoryLKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inventoryCategoryIcon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->inventoryCategoryIcon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("sPoisonType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->sPoisonType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("notininventory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->notininventory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("actionName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->actionName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("longDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->longDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("missingText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->missingText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("warningText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->warningText);

	p_Stream << "}";
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo s_Object {};

	s_Object.label = std::string_view(p_Document["label"]);

	s_Object.silencer = simdjson::from_json_bool(p_Document["silencer"]);

	s_Object.count = simdjson::from_json_int32(p_Document["count"]);

	s_Object.ammo = simdjson::from_json_int32(p_Document["ammo"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["id"], &s_Item);
		s_Object.id = s_Item;
	}

	s_Object.weaponCategory = std::string_view(p_Document["weaponCategory"]);

	s_Object.nAmmoRemaining = simdjson::from_json_int32(p_Document["nAmmoRemaining"]);

	s_Object.nAmmoTotal = simdjson::from_json_int32(p_Document["nAmmoTotal"]);

	s_Object.nAmmoInClip = simdjson::from_json_int32(p_Document["nAmmoInClip"]);

	s_Object.nWeaponType = simdjson::from_json_int32(p_Document["nWeaponType"]);

	s_Object.itemCategory = std::string_view(p_Document["itemCategory"]);

	s_Object.itemCategoryLKey = std::string_view(p_Document["itemCategoryLKey"]);

	s_Object.inventoryCategoryIcon = std::string_view(p_Document["inventoryCategoryIcon"]);

	s_Object.sPoisonType = std::string_view(p_Document["sPoisonType"]);

	s_Object.notininventory = simdjson::from_json_bool(p_Document["notininventory"]);

	s_Object.isIllegal = simdjson::from_json_bool(p_Document["isIllegal"]);

	s_Object.actionName = std::string_view(p_Document["actionName"]);

	s_Object.longDescription = std::string_view(p_Document["longDescription"]);

	s_Object.missingText = std::string_view(p_Document["missingText"]);

	s_Object.warningText = std::string_view(p_Document["warningText"]);

	*reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Target) = s_Object;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, label));
	ZRepositoryID::Serialize(&s_Object->id, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, id));
	ZString::Serialize(&s_Object->weaponCategory, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, weaponCategory));
	ZString::Serialize(&s_Object->itemCategory, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, itemCategory));
	ZString::Serialize(&s_Object->itemCategoryLKey, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, itemCategoryLKey));
	ZString::Serialize(&s_Object->inventoryCategoryIcon, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, inventoryCategoryIcon));
	ZString::Serialize(&s_Object->sPoisonType, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, sPoisonType));
	ZString::Serialize(&s_Object->actionName, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, actionName));
	ZString::Serialize(&s_Object->longDescription, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, longDescription));
	ZString::Serialize(&s_Object->missingText, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, missingText));
	ZString::Serialize(&s_Object->warningText, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo, warningText));
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::operator==(const ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo>)
		return false;

	if (label != p_Other.label) return false;
	if (silencer != p_Other.silencer) return false;
	if (count != p_Other.count) return false;
	if (ammo != p_Other.ammo) return false;
	if (id != p_Other.id) return false;
	if (weaponCategory != p_Other.weaponCategory) return false;
	if (nAmmoRemaining != p_Other.nAmmoRemaining) return false;
	if (nAmmoTotal != p_Other.nAmmoTotal) return false;
	if (nAmmoInClip != p_Other.nAmmoInClip) return false;
	if (nWeaponType != p_Other.nWeaponType) return false;
	if (itemCategory != p_Other.itemCategory) return false;
	if (itemCategoryLKey != p_Other.itemCategoryLKey) return false;
	if (inventoryCategoryIcon != p_Other.inventoryCategoryIcon) return false;
	if (sPoisonType != p_Other.sPoisonType) return false;
	if (notininventory != p_Other.notininventory) return false;
	if (isIllegal != p_Other.isIllegal) return false;
	if (actionName != p_Other.actionName) return false;
	if (longDescription != p_Other.longDescription) return false;
	if (missingText != p_Other.missingText) return false;
	if (warningText != p_Other.warningText) return false;

	return true;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo*>(p_Object);
	s_Object->~ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo();
}

ZHMTypeInfo ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::TypeInfo = ZHMTypeInfo("ZUIActionSelectorNavigationInventoryEntity.SActionSelectorDataCache", sizeof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache), alignof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache), ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::WriteSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::FromSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::Serialize, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::Equals, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::Destroy);

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mainslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslots[i];
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->mainslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->otherslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->otherslots[i];
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->otherslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["mainslots"];
	s_Object.mainslots.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo s_ArrayItem0;
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.mainslots[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["otherslots"];
	s_Object.otherslots.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo s_ArrayItem0;
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.otherslots[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache*>(p_Target) = s_Object;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache*>(p_Object);

	TArray<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo>::Serialize(&s_Object->mainslots, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache, mainslots));
	TArray<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfo>::Serialize(&s_Object->otherslots, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache, otherslots));
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::operator==(const ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache>)
		return false;

	if (mainslots != p_Other.mainslots) return false;
	if (otherslots != p_Other.otherslots) return false;

	return true;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache*>(p_Object);
	s_Object->~ZUIActionSelectorNavigationInventoryEntity_SActionSelectorDataCache();
}

ZHMTypeInfo ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::TypeInfo = ZHMTypeInfo("ZUIActionSelectorNavigationInventoryEntity.SActionSelectorSlotDisplayInfoSlim", sizeof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim), alignof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim), ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::WriteSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::FromSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::Serialize, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::Equals, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::Destroy);

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);

	p_Stream << "}";
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	*reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Target) = s_Object;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim, icon));
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::operator==(const ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim>)
		return false;

	if (icon != p_Other.icon) return false;

	return true;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Object);
	s_Object->~ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim();
}

ZHMTypeInfo ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::TypeInfo = ZHMTypeInfo("ZUIActionSelectorNavigationInventoryEntity.SActionSelectorInvokeData", sizeof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData), alignof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData), ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::WriteSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::FromSimpleJson, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Serialize, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Equals, ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Destroy);

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mainslotsSlim") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslotsSlim.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslotsSlim[i];
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->mainslotsSlim.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslotsCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->otherslotsCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selectedIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->selectedIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isActionInventory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isActionInventory);

	p_Stream << "}";
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["mainslotsSlim"];
	s_Object.mainslotsSlim.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim s_ArrayItem0;
		ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.mainslotsSlim[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.otherslotsCount = simdjson::from_json_int32(p_Document["otherslotsCount"]);

	s_Object.selectedIndex = simdjson::from_json_int32(p_Document["selectedIndex"]);

	s_Object.isActionInventory = simdjson::from_json_bool(p_Document["isActionInventory"]);

	*reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Target) = s_Object;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Object);

	TArray<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorSlotDisplayInfoSlim>::Serialize(&s_Object->mainslotsSlim, p_Serializer, p_OwnOffset + offsetof(ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData, mainslotsSlim));
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::operator==(const ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData>)
		return false;

	if (mainslotsSlim != p_Other.mainslotsSlim) return false;
	if (otherslotsCount != p_Other.otherslotsCount) return false;
	if (selectedIndex != p_Other.selectedIndex) return false;
	if (isActionInventory != p_Other.isActionInventory) return false;

	return true;
}

void ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData*>(p_Object);
	s_Object->~ZUIActionSelectorNavigationInventoryEntity_SActionSelectorInvokeData();
}

ZHMTypeInfo ZUIDataProvider::TypeInfo = ZHMTypeInfo("ZUIDataProvider", sizeof(ZUIDataProvider), alignof(ZUIDataProvider), ZUIDataProvider::WriteSimpleJson, ZUIDataProvider::FromSimpleJson, ZUIDataProvider::Serialize, ZUIDataProvider::Equals, ZUIDataProvider::Destroy);

void ZUIDataProvider::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZUIDataProvider::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIDataProvider s_Object {};

	*reinterpret_cast<ZUIDataProvider*>(p_Target) = s_Object;
}

void ZUIDataProvider::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);

}

bool ZUIDataProvider::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIDataProvider*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIDataProvider*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIDataProvider::operator==(const ZUIDataProvider& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIDataProvider>)
		return false;


	return true;
}

void ZUIDataProvider::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIDataProvider*>(p_Object);
	s_Object->~ZUIDataProvider();
}

ZHMTypeInfo ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::TypeInfo = ZHMTypeInfo("ZUIEmoteSelectorNavigationEntity.SActionSelectorSlotDisplayInfo", sizeof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo), alignof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo), ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson, ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson, ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::Serialize, ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::Equals, ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::Destroy);

void ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("label") << ":";
	p_Stream << simdjson::as_json_string(s_Object->label);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("containedLabel") << ":";
	p_Stream << simdjson::as_json_string(s_Object->containedLabel);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("silencer") << ":";
	p_Stream << simdjson::as_json_string(s_Object->silencer);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("count") << ":";
	p_Stream << simdjson::as_json_string(s_Object->count);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("ammo") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ammo);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("id") << ":";
	ZRepositoryID::WriteSimpleJson(&s_Object->id, p_Stream);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("weaponCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->weaponCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoRemaining") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoRemaining);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoTotal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoTotal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nAmmoInClip") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nAmmoInClip);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("nWeaponType") << ":";
	p_Stream << simdjson::as_json_string(s_Object->nWeaponType);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("itemCategoryLKey") << ":";
	p_Stream << simdjson::as_json_string(s_Object->itemCategoryLKey);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("inventoryCategoryIcon") << ":";
	p_Stream << simdjson::as_json_string(s_Object->inventoryCategoryIcon);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("notininventory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->notininventory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isIllegal") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isIllegal);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("actionName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->actionName);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("longDescription") << ":";
	p_Stream << simdjson::as_json_string(s_Object->longDescription);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("missingText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->missingText);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("warningText") << ":";
	p_Stream << simdjson::as_json_string(s_Object->warningText);

	p_Stream << "}";
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo s_Object {};

	s_Object.label = std::string_view(p_Document["label"]);

	s_Object.containedLabel = std::string_view(p_Document["containedLabel"]);

	s_Object.silencer = simdjson::from_json_bool(p_Document["silencer"]);

	s_Object.count = simdjson::from_json_int32(p_Document["count"]);

	s_Object.ammo = simdjson::from_json_int32(p_Document["ammo"]);

	{
		ZRepositoryID s_Item {};
		ZRepositoryID::FromSimpleJson(p_Document["id"], &s_Item);
		s_Object.id = s_Item;
	}

	s_Object.weaponCategory = std::string_view(p_Document["weaponCategory"]);

	s_Object.nAmmoRemaining = simdjson::from_json_int32(p_Document["nAmmoRemaining"]);

	s_Object.nAmmoTotal = simdjson::from_json_int32(p_Document["nAmmoTotal"]);

	s_Object.nAmmoInClip = simdjson::from_json_int32(p_Document["nAmmoInClip"]);

	s_Object.nWeaponType = simdjson::from_json_int32(p_Document["nWeaponType"]);

	s_Object.itemCategory = std::string_view(p_Document["itemCategory"]);

	s_Object.itemCategoryLKey = std::string_view(p_Document["itemCategoryLKey"]);

	s_Object.inventoryCategoryIcon = std::string_view(p_Document["inventoryCategoryIcon"]);

	s_Object.notininventory = simdjson::from_json_bool(p_Document["notininventory"]);

	s_Object.isIllegal = simdjson::from_json_bool(p_Document["isIllegal"]);

	s_Object.actionName = std::string_view(p_Document["actionName"]);

	s_Object.longDescription = std::string_view(p_Document["longDescription"]);

	s_Object.missingText = std::string_view(p_Document["missingText"]);

	s_Object.warningText = std::string_view(p_Document["warningText"]);

	*reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo*>(p_Target) = s_Object;
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo*>(p_Object);

	ZString::Serialize(&s_Object->label, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, label));
	ZString::Serialize(&s_Object->containedLabel, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, containedLabel));
	ZRepositoryID::Serialize(&s_Object->id, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, id));
	ZString::Serialize(&s_Object->weaponCategory, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, weaponCategory));
	ZString::Serialize(&s_Object->itemCategory, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, itemCategory));
	ZString::Serialize(&s_Object->itemCategoryLKey, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, itemCategoryLKey));
	ZString::Serialize(&s_Object->inventoryCategoryIcon, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, inventoryCategoryIcon));
	ZString::Serialize(&s_Object->actionName, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, actionName));
	ZString::Serialize(&s_Object->longDescription, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, longDescription));
	ZString::Serialize(&s_Object->missingText, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, missingText));
	ZString::Serialize(&s_Object->warningText, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo, warningText));
}

bool ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::operator==(const ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo>)
		return false;

	if (label != p_Other.label) return false;
	if (containedLabel != p_Other.containedLabel) return false;
	if (silencer != p_Other.silencer) return false;
	if (count != p_Other.count) return false;
	if (ammo != p_Other.ammo) return false;
	if (id != p_Other.id) return false;
	if (weaponCategory != p_Other.weaponCategory) return false;
	if (nAmmoRemaining != p_Other.nAmmoRemaining) return false;
	if (nAmmoTotal != p_Other.nAmmoTotal) return false;
	if (nAmmoInClip != p_Other.nAmmoInClip) return false;
	if (nWeaponType != p_Other.nWeaponType) return false;
	if (itemCategory != p_Other.itemCategory) return false;
	if (itemCategoryLKey != p_Other.itemCategoryLKey) return false;
	if (inventoryCategoryIcon != p_Other.inventoryCategoryIcon) return false;
	if (notininventory != p_Other.notininventory) return false;
	if (isIllegal != p_Other.isIllegal) return false;
	if (actionName != p_Other.actionName) return false;
	if (longDescription != p_Other.longDescription) return false;
	if (missingText != p_Other.missingText) return false;
	if (warningText != p_Other.warningText) return false;

	return true;
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo*>(p_Object);
	s_Object->~ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo();
}

ZHMTypeInfo ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::TypeInfo = ZHMTypeInfo("ZUIEmoteSelectorNavigationEntity.SActionSelectorDataCache", sizeof(ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache), alignof(ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache), ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::WriteSimpleJson, ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::FromSimpleJson, ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::Serialize, ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::Equals, ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::Destroy);

void ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mainslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslots[i];
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->mainslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslots") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->otherslots.size(); ++i)
	{
		auto& s_Item0 = s_Object->otherslots[i];
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->otherslots.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["mainslots"];
	s_Object.mainslots.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo s_ArrayItem0;
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.mainslots[s_Index0++] = s_ArrayItem0;
	}
	}

	{
	simdjson::ondemand::array s_Array0 = p_Document["otherslots"];
	s_Object.otherslots.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo s_ArrayItem0;
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.otherslots[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache*>(p_Target) = s_Object;
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache*>(p_Object);

	TArray<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo>::Serialize(&s_Object->mainslots, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache, mainslots));
	TArray<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfo>::Serialize(&s_Object->otherslots, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache, otherslots));
}

bool ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::operator==(const ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache>)
		return false;

	if (mainslots != p_Other.mainslots) return false;
	if (otherslots != p_Other.otherslots) return false;

	return true;
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache*>(p_Object);
	s_Object->~ZUIEmoteSelectorNavigationEntity_SActionSelectorDataCache();
}

ZHMTypeInfo ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::TypeInfo = ZHMTypeInfo("ZUIEmoteSelectorNavigationEntity.SActionSelectorSlotDisplayInfoSlim", sizeof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim), alignof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim), ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::WriteSimpleJson, ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::FromSimpleJson, ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::Serialize, ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::Equals, ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::Destroy);

void ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("icon") << ":";
	ZRuntimeResourceID::WriteSimpleJson(&s_Object->icon, p_Stream);

	p_Stream << "}";
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim s_Object {};

	{
		ZRuntimeResourceID s_Item {};
		ZRuntimeResourceID::FromSimpleJson(p_Document["icon"], &s_Item);
		s_Object.icon = s_Item;
	}

	*reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Target) = s_Object;
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Object);

	ZRuntimeResourceID::Serialize(&s_Object->icon, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim, icon));
}

bool ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::operator==(const ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim>)
		return false;

	if (icon != p_Other.icon) return false;

	return true;
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim*>(p_Object);
	s_Object->~ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim();
}

ZHMTypeInfo ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::TypeInfo = ZHMTypeInfo("ZUIEmoteSelectorNavigationEntity.SActionSelectorInvokeData", sizeof(ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData), alignof(ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData), ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::WriteSimpleJson, ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::FromSimpleJson, ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::Serialize, ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::Equals, ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::Destroy);

void ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("mainslotsSlim") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->mainslotsSlim.size(); ++i)
	{
		auto& s_Item0 = s_Object->mainslotsSlim[i];
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->mainslotsSlim.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("otherslotsCount") << ":";
	p_Stream << simdjson::as_json_string(s_Object->otherslotsCount);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("selectedIndex") << ":";
	p_Stream << simdjson::as_json_string(s_Object->selectedIndex);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("isActionInventory") << ":";
	p_Stream << simdjson::as_json_string(s_Object->isActionInventory);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("noItemsMessage") << ":";
	p_Stream << simdjson::as_json_string(s_Object->noItemsMessage);

	p_Stream << "}";
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData s_Object {};

	{
	simdjson::ondemand::array s_Array0 = p_Document["mainslotsSlim"];
	s_Object.mainslotsSlim.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim s_ArrayItem0;
		ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.mainslotsSlim[s_Index0++] = s_ArrayItem0;
	}
	}

	s_Object.otherslotsCount = simdjson::from_json_int32(p_Document["otherslotsCount"]);

	s_Object.selectedIndex = simdjson::from_json_int32(p_Document["selectedIndex"]);

	s_Object.isActionInventory = simdjson::from_json_bool(p_Document["isActionInventory"]);

	s_Object.noItemsMessage = std::string_view(p_Document["noItemsMessage"]);

	*reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData*>(p_Target) = s_Object;
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData*>(p_Object);

	TArray<ZUIEmoteSelectorNavigationEntity_SActionSelectorSlotDisplayInfoSlim>::Serialize(&s_Object->mainslotsSlim, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData, mainslotsSlim));
	ZString::Serialize(&s_Object->noItemsMessage, p_Serializer, p_OwnOffset + offsetof(ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData, noItemsMessage));
}

bool ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::operator==(const ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData>)
		return false;

	if (mainslotsSlim != p_Other.mainslotsSlim) return false;
	if (otherslotsCount != p_Other.otherslotsCount) return false;
	if (selectedIndex != p_Other.selectedIndex) return false;
	if (isActionInventory != p_Other.isActionInventory) return false;
	if (noItemsMessage != p_Other.noItemsMessage) return false;

	return true;
}

void ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData*>(p_Object);
	s_Object->~ZUIEmoteSelectorNavigationEntity_SActionSelectorInvokeData();
}

ZHMTypeInfo ZUIMapLegendDataProvider_SLegendTracker::TypeInfo = ZHMTypeInfo("ZUIMapLegendDataProvider.SLegendTracker", sizeof(ZUIMapLegendDataProvider_SLegendTracker), alignof(ZUIMapLegendDataProvider_SLegendTracker), ZUIMapLegendDataProvider_SLegendTracker::WriteSimpleJson, ZUIMapLegendDataProvider_SLegendTracker::FromSimpleJson, ZUIMapLegendDataProvider_SLegendTracker::Serialize, ZUIMapLegendDataProvider_SLegendTracker::Equals, ZUIMapLegendDataProvider_SLegendTracker::Destroy);

void ZUIMapLegendDataProvider_SLegendTracker::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIMapLegendDataProvider_SLegendTracker*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("ControlName") << ":";
	p_Stream << simdjson::as_json_string(s_Object->ControlName);

	p_Stream << "}";
}

void ZUIMapLegendDataProvider_SLegendTracker::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIMapLegendDataProvider_SLegendTracker s_Object {};

	s_Object.ControlName = std::string_view(p_Document["ControlName"]);

	*reinterpret_cast<ZUIMapLegendDataProvider_SLegendTracker*>(p_Target) = s_Object;
}

void ZUIMapLegendDataProvider_SLegendTracker::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIMapLegendDataProvider_SLegendTracker*>(p_Object);

	ZString::Serialize(&s_Object->ControlName, p_Serializer, p_OwnOffset + offsetof(ZUIMapLegendDataProvider_SLegendTracker, ControlName));
}

bool ZUIMapLegendDataProvider_SLegendTracker::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIMapLegendDataProvider_SLegendTracker*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIMapLegendDataProvider_SLegendTracker*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIMapLegendDataProvider_SLegendTracker::operator==(const ZUIMapLegendDataProvider_SLegendTracker& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIMapLegendDataProvider_SLegendTracker>)
		return false;

	if (ControlName != p_Other.ControlName) return false;

	return true;
}

void ZUIMapLegendDataProvider_SLegendTracker::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIMapLegendDataProvider_SLegendTracker*>(p_Object);
	s_Object->~ZUIMapLegendDataProvider_SLegendTracker();
}

ZHMTypeInfo ZUIMapLegendDataProvider_SData::TypeInfo = ZHMTypeInfo("ZUIMapLegendDataProvider.SData", sizeof(ZUIMapLegendDataProvider_SData), alignof(ZUIMapLegendDataProvider_SData), ZUIMapLegendDataProvider_SData::WriteSimpleJson, ZUIMapLegendDataProvider_SData::FromSimpleJson, ZUIMapLegendDataProvider_SData::Serialize, ZUIMapLegendDataProvider_SData::Equals, ZUIMapLegendDataProvider_SData::Destroy);

void ZUIMapLegendDataProvider_SData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZUIMapLegendDataProvider_SData*>(p_Object);

	p_Stream << "{";

	p_Stream << simdjson::as_json_string("Location") << ":";
	p_Stream << simdjson::as_json_string(s_Object->Location);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("lstrLocation") << ":";
	p_Stream << simdjson::as_json_string(s_Object->lstrLocation);
	p_Stream << ",";

	p_Stream << simdjson::as_json_string("LegendTrackers") << ":";
	p_Stream << "[";
	for (size_t i = 0; i < s_Object->LegendTrackers.size(); ++i)
	{
		auto& s_Item0 = s_Object->LegendTrackers[i];
		ZUIMapLegendDataProvider_SLegendTracker::WriteSimpleJson(&s_Item0, p_Stream);

		if (i < s_Object->LegendTrackers.size() - 1)
			p_Stream << ",";
	}

	p_Stream << "]";

	p_Stream << "}";
}

void ZUIMapLegendDataProvider_SData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZUIMapLegendDataProvider_SData s_Object {};

	s_Object.Location = std::string_view(p_Document["Location"]);

	s_Object.lstrLocation = std::string_view(p_Document["lstrLocation"]);

	{
	simdjson::ondemand::array s_Array0 = p_Document["LegendTrackers"];
	s_Object.LegendTrackers.resize(s_Array0.count_elements());
	size_t s_Index0 = 0;

	for (simdjson::ondemand::value s_Item0 : s_Array0)
	{
		ZUIMapLegendDataProvider_SLegendTracker s_ArrayItem0;
		ZUIMapLegendDataProvider_SLegendTracker::FromSimpleJson(s_Item0, &s_ArrayItem0);
		s_Object.LegendTrackers[s_Index0++] = s_ArrayItem0;
	}
	}

	*reinterpret_cast<ZUIMapLegendDataProvider_SData*>(p_Target) = s_Object;
}

void ZUIMapLegendDataProvider_SData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZUIMapLegendDataProvider_SData*>(p_Object);

	ZString::Serialize(&s_Object->Location, p_Serializer, p_OwnOffset + offsetof(ZUIMapLegendDataProvider_SData, Location));
	ZString::Serialize(&s_Object->lstrLocation, p_Serializer, p_OwnOffset + offsetof(ZUIMapLegendDataProvider_SData, lstrLocation));
	TArray<ZUIMapLegendDataProvider_SLegendTracker>::Serialize(&s_Object->LegendTrackers, p_Serializer, p_OwnOffset + offsetof(ZUIMapLegendDataProvider_SData, LegendTrackers));
}

bool ZUIMapLegendDataProvider_SData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZUIMapLegendDataProvider_SData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZUIMapLegendDataProvider_SData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZUIMapLegendDataProvider_SData::operator==(const ZUIMapLegendDataProvider_SData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZUIMapLegendDataProvider_SData>)
		return false;

	if (Location != p_Other.Location) return false;
	if (lstrLocation != p_Other.lstrLocation) return false;
	if (LegendTrackers != p_Other.LegendTrackers) return false;

	return true;
}

void ZUIMapLegendDataProvider_SData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZUIMapLegendDataProvider_SData*>(p_Object);
	s_Object->~ZUIMapLegendDataProvider_SData();
}

ZHMTypeInfo ZWorldMapMetaData::TypeInfo = ZHMTypeInfo("ZWorldMapMetaData", sizeof(ZWorldMapMetaData), alignof(ZWorldMapMetaData), ZWorldMapMetaData::WriteSimpleJson, ZWorldMapMetaData::FromSimpleJson, ZWorldMapMetaData::Serialize, ZWorldMapMetaData::Equals, ZWorldMapMetaData::Destroy);

void ZWorldMapMetaData::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);

	p_Stream << "{";

	p_Stream << "}";
}

void ZWorldMapMetaData::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)
{
	ZWorldMapMetaData s_Object {};

	*reinterpret_cast<ZWorldMapMetaData*>(p_Target) = s_Object;
}

void ZWorldMapMetaData::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);

}

bool ZWorldMapMetaData::Equals(void* p_Left, void* p_Right)
{
	auto* s_Left = reinterpret_cast<ZWorldMapMetaData*>(p_Left);
	auto* s_Right = reinterpret_cast<ZWorldMapMetaData*>(p_Right);

	return *s_Left == *s_Right;
}

bool ZWorldMapMetaData::operator==(const ZWorldMapMetaData& p_Other) const
{
	if constexpr (!ZHMTypeSupportsEquality_v<ZWorldMapMetaData>)
		return false;


	return true;
}

void ZWorldMapMetaData::Destroy(void* p_Object)
{
	auto* s_Object = reinterpret_cast<ZWorldMapMetaData*>(p_Object);
	s_Object->~ZWorldMapMetaData();
}

