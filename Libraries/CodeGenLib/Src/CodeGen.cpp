#include "CodeGen.h"

#include "ZHMReflection.h"

#include <sstream>
#include <iostream>
#include <fstream>
#include <unordered_set>
#include <algorithm>
#include <functional>

#include "HMAData.h"
#include "RTTI/Image.h"
#include "RTTI/VTableFinder.h"

#include <Windows.h>
#include <DbgHelp.h>
#include <queue>
#include <ranges>
#include <regex>

extern "C" char *__unDName(char*, const char*, int, void*, void*, int);

void CodeGen::WriteFileHeader(std::ostream& p_Stream)
{
	p_Stream << "/*" << std::endl;
	p_Stream << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	p_Stream << " *" << std::endl;
	p_Stream << " * If you wish to regenerate this file because of a game update use the ZHMTools CodeGen tool:" << std::endl;
	p_Stream << " * https://github.com/OrfeasZ/ZHMTools/releases" << std::endl;
	p_Stream << " */" << std::endl;
	p_Stream << std::endl;
}


void CodeGen::Generate(ZTypeRegistry* p_Registry, const std::filesystem::path& p_OutputPath)
{
	m_PropertyNames.clear();

	printf("Generating code for types...\n");
	
	// Open our output files.
	m_SDKHeader.open(p_OutputPath / "ZHMSdkGen.h", std::ofstream::out);

	m_ReflectiveClassesHeaderFile.open(p_OutputPath / "ZHMGen.h", std::ofstream::out);
	m_ReflectiveClassesSourceFile.open(p_OutputPath / "ZHMGen.cpp", std::ofstream::out);

	m_PropertyNamesHeaderFile.open(p_OutputPath / "ZHMProperties.h", std::ofstream::out);
	m_PropertyNamesSourceFile.open(p_OutputPath / "ZHMProperties.cpp", std::ofstream::out);
	m_PropertyNamesTextFile.open(p_OutputPath / "ZHMProperties.txt", std::ofstream::out);

	m_EnumsHeaderFile.open(p_OutputPath / "ZHMEnums.h", std::ofstream::out);
	m_EnumsSourceFile.open(p_OutputPath / "ZHMEnums.cpp", std::ofstream::out);

	WriteFileHeader(m_SDKHeader);
	// TODO: Fix imports for SDK use.
	m_SDKHeader << "#pragma once" << std::endl;
	m_SDKHeader << std::endl;
	m_SDKHeader << "#include <cstdint>" << std::endl;
	m_SDKHeader << std::endl;

	WriteFileHeader(m_ReflectiveClassesHeaderFile);
	m_ReflectiveClassesHeaderFile << "#pragma once" << std::endl;
	m_ReflectiveClassesHeaderFile << std::endl;
	m_ReflectiveClassesHeaderFile << "#include <ZHM/ZHMPrimitives.h>" << std::endl;
	m_ReflectiveClassesHeaderFile << "#include <ZHM/ZHMTypeInfo.h>" << std::endl;
	m_ReflectiveClassesHeaderFile << std::endl;
	m_ReflectiveClassesHeaderFile << "class ZHMTypeInfo;" << std::endl;
	m_ReflectiveClassesHeaderFile << std::endl;
	m_ReflectiveClassesHeaderFile << "#pragma pack(push, 1)" << std::endl;
	m_ReflectiveClassesHeaderFile << std::endl;

	WriteFileHeader(m_ReflectiveClassesSourceFile);
	m_ReflectiveClassesSourceFile << "#include \"ZHMGen.h\"" << std::endl;
	m_ReflectiveClassesSourceFile << "#include \"ZHMProperties.h\"" << std::endl;
	m_ReflectiveClassesSourceFile << "#include \"ZHMEnums.h\"" << std::endl;
	m_ReflectiveClassesSourceFile << "#include <External/simdjson_helpers.h>" << std::endl;
	m_ReflectiveClassesSourceFile << "#include <utility>" << std::endl;
	m_ReflectiveClassesSourceFile << std::endl;

	printf("Registry has %zd types.\n", p_Registry->m_types.size());

	// Look for RTTI information.
	Image s_Image;
	RttiMsvc s_RTTI;
	VTablesMsvc s_VTables;

	FindMsvcVTables(s_Image, s_VTables, s_RTTI);

	// Build RTTI lookup table by demangled name
	for (auto &s_VTable: s_VTables | std::views::values)
	{
		if (!s_VTable.Rtti || !s_VTable.Rtti->TypeDescriptor)
			continue;

		if (auto s_DemangledName = DemangleRTTIName(s_VTable.Rtti->TypeDescriptor->Name); !s_DemangledName.empty())
		{
			m_RttiByTypeName[s_DemangledName] = &s_VTable;
		}
	}

	printf("Built RTTI lookup table with %llu entries.\n", m_RttiByTypeName.size());

	for (auto& [_, s_Type] : p_Registry->m_types)
	{
		if (!s_Type->typeInfo())
			continue;

		m_TypeDataByName[s_Type->typeInfo()->m_pTypeName] = s_Type;
	}

	CollectAllRttiTypes();
	BuildTypeTree(p_Registry);
	//PrintTypeTree(m_TypeTreeRoot);

	for (auto& s_Node : m_TypeTreeRoot->SortedChildren) {
		GenerateCode(s_Node, "");
	}

	GeneratePropertyNamesFiles();
	GenerateEnumsFiles();

	m_ReflectiveClassesHeaderFile << "#pragma pack(pop)" << std::endl;

	m_ReflectiveClassesHeaderFile.close();
	m_ReflectiveClassesSourceFile.close();

	m_PropertyNamesHeaderFile.close();
	m_PropertyNamesSourceFile.close();
	m_PropertyNamesTextFile.close();

	m_EnumsHeaderFile.close();
	m_EnumsSourceFile.close();

	m_SDKHeader.close();

	printf("Finished generating code.\n");
}

void CodeGen::CollectAllRttiTypes()
{
	// Collect all RTTI type names (including names from base classes) and add them to m_RttiTypes.
	for (const auto &s_VTable: m_RttiByTypeName | std::views::values)
	{
		if (!s_VTable || !s_VTable->Rtti || !s_VTable->Rtti->ClassDescriptor)
			continue;

		for (const auto& s_BaseClass : s_VTable->Rtti->ClassDescriptor->BaseClasses)
		{
			if (!s_BaseClass || !s_BaseClass->TypeDescriptor)
				continue;

			std::string s_DemangledName = DemangleRTTIName(s_BaseClass->TypeDescriptor->Name);
			
			if (!s_DemangledName.empty())
			{
				m_RttiTypes.insert(s_DemangledName);
			}
		}
	}

	printf("Collected %zd RTTI types.\n", m_RttiTypes.size());
}

void CodeGen::BuildTypeTree(ZTypeRegistry* p_Registry)
{
	m_TypeTreeRoot = std::make_shared<TreeNode>();
	m_TypeTreeRoot->Name = "";
	m_TypeTreeRoot->Type = TreeNode::ENodeType::Namespace;

	for (auto& s_Pair : p_Registry->m_types)
	{
		std::string s_TypeName = s_Pair.first.c_str();

		// Ignore templated types.
		if (s_TypeName.find('<') != std::string::npos)
			continue;

		auto s_TypeData = s_Pair.second;

		std::shared_ptr<TreeNode> s_CurrentNode = m_TypeTreeRoot;
		
		size_t s_Start = 0;
		size_t s_End = s_TypeName.find('.');

		while (s_End != std::string::npos)
		{
			std::string s_Part = s_TypeName.substr(s_Start, s_End - s_Start);

			if (!s_CurrentNode->Children.contains(s_Part))
			{
				auto s_NewNode = std::make_shared<TreeNode>();
				s_NewNode->Name = s_Part;
				s_NewNode->Parent = s_CurrentNode;
				s_NewNode->Type = m_RttiTypes.contains(s_NewNode->TypeName()) ? TreeNode::ENodeType::Type : TreeNode::ENodeType::Namespace;
				s_CurrentNode->Children[s_Part] = s_NewNode;
				m_TypeNodesByName[s_NewNode->TypeName()] = s_NewNode;
			}
			
			s_CurrentNode = s_CurrentNode->Children[s_Part];
			s_Start = s_End + 1;
			s_End = s_TypeName.find('.', s_Start);
		}

		std::string s_LeafName = s_TypeName.substr(s_Start);

		if (!s_CurrentNode->Children.contains(s_LeafName))
		{
			auto s_NewNode = std::make_shared<TreeNode>();
			s_NewNode->Name = s_LeafName;
			s_NewNode->Parent = s_CurrentNode;
			s_NewNode->Type = m_RttiTypes.contains(s_NewNode->TypeName()) ? TreeNode::ENodeType::Type : TreeNode::ENodeType::Namespace;
			s_CurrentNode->Children[s_LeafName] = s_NewNode;
			m_TypeNodesByName[s_NewNode->TypeName()] = s_NewNode;
		}

		s_CurrentNode = s_CurrentNode->Children[s_LeafName];
		s_CurrentNode->Type = TreeNode::ENodeType::Type;
		s_CurrentNode->TypeData = s_TypeData;

		// Collect dependencies for this type.
		const auto [s_Deps, s_RlType] = CollectDependencies(s_TypeData);
		s_CurrentNode->Dependencies = s_Deps;
		s_CurrentNode->ResourceLibType = s_RlType;
	}

	// Walk through the tree and get RTTI information for each type.
	// Then, insert nodes for each base class we're missing in the tree.
	std::queue<std::shared_ptr<TreeNode>> s_Queue;
	s_Queue.push(m_TypeTreeRoot);

	while (!s_Queue.empty())
	{
		auto s_Node = s_Queue.front();
		s_Queue.pop();

		if (s_Node->Type == TreeNode::ENodeType::Type && s_Node->TypeData)
		{
			auto s_TypeData = s_Node->TypeData;
			auto s_RttiIt = m_RttiByTypeName.find(s_TypeData->typeInfo()->m_pTypeName);
			if (s_RttiIt == m_RttiByTypeName.end())
				continue;

			auto s_VTable = s_RttiIt->second;
			if (!s_VTable || !s_VTable->Rtti || !s_VTable->Rtti->ClassDescriptor)
				continue;

			for (const auto& s_BaseClass : s_VTable->Rtti->ClassDescriptor->BaseClasses)
			{
				if (!s_BaseClass || !s_BaseClass->TypeDescriptor)
					continue;

				std::string s_BaseName = DemangleRTTIName(s_BaseClass->TypeDescriptor->Name);
				if (s_BaseName.empty())
					continue;

				// Check if this base class already exists in the tree (by full type name).
				if (m_TypeNodesByName.contains(s_BaseName))
					continue;

				// Split the base name on '.' and create the proper hierarchy.
				std::shared_ptr<TreeNode> s_CurrentNode = m_TypeTreeRoot;
				size_t s_Start = 0;
				size_t s_End = s_BaseName.find('.');

				while (s_End != std::string::npos)
				{
					std::string s_Part = s_BaseName.substr(s_Start, s_End - s_Start);

					if (!s_CurrentNode->Children.contains(s_Part))
					{
						auto s_NewNode = std::make_shared<TreeNode>();
						s_NewNode->Name = s_Part;
						s_NewNode->Parent = s_CurrentNode;
						s_NewNode->Type = m_RttiTypes.contains(s_NewNode->TypeName()) ? TreeNode::ENodeType::Type : TreeNode::ENodeType::Namespace;
						s_CurrentNode->Children[s_Part] = s_NewNode;
						m_TypeNodesByName[s_NewNode->TypeName()] = s_NewNode;
					}

					s_CurrentNode = s_CurrentNode->Children[s_Part];
					s_Start = s_End + 1;
					s_End = s_BaseName.find('.', s_Start);
				}

				std::string s_LeafName = s_BaseName.substr(s_Start);

				if (!s_CurrentNode->Children.contains(s_LeafName))
				{
					auto s_NewNode = std::make_shared<TreeNode>();
					s_NewNode->Name = s_LeafName;
					s_NewNode->Parent = s_CurrentNode;
					s_NewNode->Type = TreeNode::ENodeType::Type;
					s_CurrentNode->Children[s_LeafName] = s_NewNode;
					m_TypeNodesByName[s_NewNode->TypeName()] = s_NewNode;
				}
			}
		}

		for (auto& s_Child : s_Node->Children)
		{
			s_Queue.push(s_Child.second);
		}
	}

	// Remove some known "bad" types from the tree.
	m_TypeTreeRoot->Children["ZDynamicObject"]->Children.erase("SArrayTypesRegistrar"); // Has circular dependencies.

	std::unordered_set<std::shared_ptr<TreeNode>> s_Visited;
	for (auto& s_Child : m_TypeTreeRoot->Children)
	{
		SortTypeTree(s_Child.second, s_Visited);
	}

	printf("Built Type Tree.\n");
}

std::vector<std::string> SplitString(const std::string& p_String, char p_Delimiter)
{
	std::vector<std::string> s_Parts;

	std::stringstream s_Stream(p_String);
	std::string s_Part;

	while (std::getline(s_Stream, s_Part, p_Delimiter))
		s_Parts.push_back(s_Part);

	return s_Parts;
}

struct MaybeTemplateType
{
	std::string Name;
	std::vector<MaybeTemplateType> TemplateTypes;

	std::string FullName() const
	{
		std::string s_Result = Name;

		if (!TemplateTypes.empty())
		{
			s_Result += "<";

			for (size_t i = 0; i < TemplateTypes.size(); ++i)
			{
				s_Result += TemplateTypes[i].FullName();

				if (i < TemplateTypes.size() - 1)
					s_Result += ", ";
			}

			s_Result += ">";
		}

		return s_Result;
	}
};

// Parse a C++ type name that's possibly templated (e.g. "TPair<int16, TPair<int32, int64>>").
MaybeTemplateType ParseTemplateType(std::string p_Type)
{
	MaybeTemplateType s_Result;

	// Trim whitespace
	auto s_Start = p_Type.find_first_not_of(" \t");
	auto s_End = p_Type.find_last_not_of(" \t");
	if (s_Start == std::string::npos)
		return s_Result;
	p_Type = p_Type.substr(s_Start, s_End - s_Start + 1);

	auto s_Open = p_Type.find('<');
	if (s_Open == std::string::npos)
	{
		s_Result.Name = p_Type;
		return s_Result;
	}

	s_Result.Name = p_Type.substr(0, s_Open);

	// Parse template arguments between '<' and matching '>'
	const std::string s_Args = p_Type.substr(s_Open + 1, p_Type.rfind('>') - s_Open - 1);
	for (size_t i = 0, s_Depth = 0, s_ArgStart = 0; i <= s_Args.size(); ++i)
	{
		char c = (i < s_Args.size()) ? s_Args[i] : ',';
		if (c == '<') ++s_Depth;
		else if (c == '>') --s_Depth;
		else if (c == ',' && s_Depth == 0)
		{
			s_Result.TemplateTypes.push_back(ParseTemplateType(s_Args.substr(s_ArgStart, i - s_ArgStart)));
			s_ArgStart = i + 1;
		}
	}

	return s_Result;
};

std::unordered_set<std::string> GetDependenciesFromTemplateType(const MaybeTemplateType& p_Type)
{
	static const std::vector<std::string> c_TypesToExplode = {
		"TArray", "TFixedArray", "TPair", "TMap", "TMultiMap", "TEntityRef", "TResourcePtr"
	};

	std::unordered_set<std::string> s_Dependencies;

	if (std::ranges::find(c_TypesToExplode, p_Type.Name) != c_TypesToExplode.end())
	{
		for (const auto& s_TemplateType : p_Type.TemplateTypes)
		{
			for (const auto& s_Dependency : GetDependenciesFromTemplateType(s_TemplateType))
				s_Dependencies.insert(s_Dependency);
		}
	}
	else
	{
		s_Dependencies.insert(p_Type.FullName());
	}

	return s_Dependencies;
};

std::pair<std::unordered_set<std::string>, bool> CodeGen::CollectDependencies(STypeID* p_Type)
{
	// Grab dependencies from RTTI and properties.
	std::unordered_set<std::string> s_Dependencies;

	if (!p_Type->typeInfo())
		return { s_Dependencies, false };

	bool s_IsRlType = true;

	// Go through properties first.
	if (p_Type->typeInfo()->isClass())
	{
		auto s_ClassType = reinterpret_cast<IClassType*>(p_Type->typeInfo());

		for (uint16_t i = 0; i < s_ClassType->m_nPropertyCount; ++i)
		{
			auto s_Prop = s_ClassType->m_pProperties[i];

			if (!s_Prop.m_pType->typeInfo())
			{
				s_IsRlType = false;
				continue;
			}

			if (std::string(s_Prop.m_pType->typeInfo()->m_pTypeName) == "TArray")
			{
				s_IsRlType = false;
				continue;
			}

			const auto s_PropType = ParseTemplateType(s_Prop.m_pType->typeInfo()->m_pTypeName);

			for (const auto& s_Dependency : GetDependenciesFromTemplateType(s_PropType))
			{
				s_Dependencies.insert(s_Dependency);

				// If any of the collected types are in RTTI or if they have any inheritance, this can't be an RL type.
				if (m_RttiByTypeName.contains(s_Dependency))
					s_IsRlType = false;

				if (const auto it = m_TypeDataByName.find(s_Dependency); it != m_TypeDataByName.end())
				{
					if (it->second->typeInfo()->isClass())
					{
						auto s_ClassDesc = reinterpret_cast<IClassType*>(it->second->typeInfo());

						if (s_ClassDesc->m_nBaseClassCount > 0 || s_ClassDesc->m_nInterfaceCount > 0)
							s_IsRlType = false;
					}
				}
			}
		}
	}

	// And now through RTTI info.
	auto s_RttiIt = m_RttiByTypeName.find(p_Type->typeInfo()->m_pTypeName);

	if (s_RttiIt != m_RttiByTypeName.end() && s_RttiIt->second && s_RttiIt->second->Rtti && s_RttiIt->second->Rtti->ClassDescriptor)
	{
		auto s_ClassDesc = s_RttiIt->second->Rtti->ClassDescriptor;
		for (size_t i = 1; i < s_ClassDesc->BaseClasses.size(); )
		{
			auto s_Base = s_ClassDesc->BaseClasses[i];
			if (!s_Base || !s_Base->TypeDescriptor)
			{
				i++;
				continue;
			}

			std::string s_BaseName = DemangleRTTIName(s_Base->TypeDescriptor->Name);
			if (s_BaseName.empty())
			{
				i++;
				continue;
			}

			s_Dependencies.insert(s_BaseName);

			// Skip over this base's ancestors (they're not direct bases of our class)
			i += 1 + s_Base->NumContainedBases;
		}
	}

	// Remove own type from dependencies if it's there.
	s_Dependencies.erase(p_Type->typeInfo()->m_pTypeName);

	return { s_Dependencies, s_IsRlType };
}

bool IsPrimitive(const std::string& p_TypeName)
{
	return p_TypeName == "int8" ||
		p_TypeName == "uint8" ||
		p_TypeName == "int16" ||
		p_TypeName == "uint16" ||
		p_TypeName == "int32" ||
		p_TypeName == "uint32" ||
		p_TypeName == "int64" ||
		p_TypeName == "uint64" ||
		p_TypeName == "float32" ||
		p_TypeName == "float64" ||
		p_TypeName == "bool" ||
		p_TypeName == "ZVariant" ||
		p_TypeName == "TypeID" ||
		p_TypeName == "ZRepositoryID" ||
		p_TypeName == "TResourcePtr" ||
		p_TypeName == "ZString";
}

// Perform topologic sort on the type tree.
void CodeGen::SortTypeTree(const std::shared_ptr<TreeNode>& p_Node, std::unordered_set<std::shared_ptr<TreeNode>>& p_Visited)
{
	if (!p_Visited.contains(p_Node))
	{
		p_Visited.insert(p_Node);

		for (auto& s_Dependency : p_Node->AllDependencies())
		{
			if (auto it = m_TypeNodesByName.find(s_Dependency); it != m_TypeNodesByName.end())
			{
				auto s_DepNode = it->second;

				// If the dependency is a nested type, we need to ensure its parent is sorted first.
				// Walk up the parent chain until we reach a node whose parent is the root.
				auto s_TopLevelAncestor = s_DepNode;
				while (s_TopLevelAncestor->Parent && s_TopLevelAncestor->Parent->Parent && !s_TopLevelAncestor->Parent->Name.empty())
				{
					s_TopLevelAncestor = s_TopLevelAncestor->Parent;
				}

				// If the dependency has a top-level ancestor different from itself, sort that first.
				if (s_TopLevelAncestor != s_DepNode)
				{
					SortTypeTree(s_TopLevelAncestor, p_Visited);

					if (s_TopLevelAncestor->ShouldSkip)
					{
						printf("Dependency '%s' (via ancestor '%s') for type '%s' should be skipped. Skipping.\n",
							s_Dependency.c_str(), s_TopLevelAncestor->Name.c_str(), p_Node->Name.c_str());
						p_Node->ShouldSkip = true;
						break;
					}
				}

				// Recurse to ensure the dependency itself is fully processed.
				SortTypeTree(s_DepNode, p_Visited);

				// After recursion, check if the dependency should be skipped.
				if (s_DepNode->ShouldSkip)
				{
					printf("Dependency '%s' for type '%s' should be skipped. Skipping.\n", s_Dependency.c_str(), p_Node->Name.c_str());
					p_Node->ShouldSkip = true;
					break;
				}
			}
			else if (IsPrimitive(s_Dependency))
			{
				// Primitive dependencies are always fine.
			}
			else if (m_RttiByTypeName.contains(s_Dependency))
			{
				// If the dependency exists in RTTI, it's fine.
			}
			else
			{
				// Could not find a dependency for this type. Skip.
				printf("Could not find dependency '%s' for type '%s'. Skipping.\n", s_Dependency.c_str(), p_Node->Name.c_str());
				p_Node->ShouldSkip = true;
				break;
			}
		}

		p_Node->Parent->SortedChildren.push_back(p_Node);
	}
	else if (std::ranges::find(p_Node->Parent->SortedChildren, p_Node) == p_Node->Parent->SortedChildren.end())
	{
		//printf("Circular dependency for node %s UwU.\n", p_Node->Name.c_str());
	}

	for (auto& s_Child : p_Node->Children)
	{
		SortTypeTree(s_Child.second, p_Visited);
	}
}

void CodeGen::PrintTypeTree(const std::shared_ptr<TreeNode>& p_Node, int p_Depth)
{
	std::string s_Indentation(p_Depth * 2, ' ');
	
	printf("%s%s", s_Indentation.c_str(), p_Node->Name.c_str());

	if (p_Node->Type == TreeNode::ENodeType::Type)
		printf(" [type]");
	else
		printf(" [ns]");

	// Print dependencies
	if (!p_Node->Dependencies.empty())
	{
		printf(" (deps: ");

		for (const auto& s_Dependency : p_Node->Dependencies)
			printf("%s, ", s_Dependency.c_str());

		printf(")");
	}
	
	printf("\n");

	if (p_Node->SortedChildren.empty())
	{
		for (auto& s_Child : p_Node->Children)
			PrintTypeTree(s_Child.second, p_Depth + 1);
	}
	else
	{
		for (auto& s_Child : p_Node->SortedChildren)
			PrintTypeTree(s_Child, p_Depth + 1);
	}
}

std::string NormalizeTypeName(const std::string& p_TypeName)
{
	// Replace dots with double colons.
	return std::regex_replace(p_TypeName, std::regex("\\."), "::");
}

std::string NormalizeName(STypeID* p_Type)
{
	std::string s_TypeName = p_Type->typeInfo()->m_pTypeName;

	if (s_TypeName == "TArray")
		return s_TypeName;

	if (p_Type->typeInfo()->isFixedArray())
	{
		auto s_ElementType = reinterpret_cast<IArrayType*>(p_Type->typeInfo())->m_pArrayElementType;
		return "TFixedArray<" + NormalizeName(s_ElementType) + ", " + std::to_string(reinterpret_cast<IArrayType*>(p_Type->typeInfo())->fixedArraySize()) + ">";
	}

	if (p_Type->typeInfo()->isArray())
	{
		auto s_ElementType = reinterpret_cast<IArrayType*>(p_Type->typeInfo())->m_pArrayElementType;
		return "TArray<" + NormalizeName(s_ElementType) + ">";
	}

	return NormalizeTypeName(s_TypeName);
}

std::string GetEnumUnderlyingType(STypeID* p_Type)
{
	switch (p_Type->typeInfo()->m_nTypeSize) {
		case 1:
			return "int8_t";

		case 2:
			return "int16_t";

		case 4:
			return "int32_t";

		default:
			printf("Unsupported enum size %d for type %s. Defaulting to int32_t.\n", p_Type->typeInfo()->m_nTypeSize, p_Type->typeInfo()->m_pTypeName);
			return "int32_t";
	}
}

void GenerateArraySimpleJsonWriter(STypeID* p_ElementType, std::ostream& p_Stream, const std::string& p_ValueName, int p_Depth = 0, const std::string& p_Indentation = "")
{
	p_Stream << p_Indentation << "\tp_Stream << \"[\";" << std::endl;
	p_Stream << p_Indentation << "\tfor (size_t i = 0; i < " << p_ValueName << ".size(); ++i)" << std::endl;
	p_Stream << p_Indentation << "\t{" << std::endl;
	p_Stream << p_Indentation << "\t\tauto& s_Item" << p_Depth << " = " << p_ValueName << "[i];" << std::endl;

	auto s_ArrayType = reinterpret_cast<IArrayType*>(p_ElementType->typeInfo());
	auto s_ArrayTypeName = std::string(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName);

	if (s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName == std::string("ZString"))
	{
		p_Stream << p_Indentation << "\t\tp_Stream << simdjson::as_json_string(s_Item" << p_Depth << ");" << std::endl;
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->isEnum())
	{
		p_Stream << p_Indentation << "\t\tp_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName(\"" << s_ArrayTypeName << "\", static_cast<int>(s_Item" << p_Depth << ")));" << std::endl;
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->isArray() || s_ArrayType->m_pArrayElementType->typeInfo()->isFixedArray())
	{
		GenerateArraySimpleJsonWriter(s_ArrayType->m_pArrayElementType, p_Stream, "s_Item" + std::to_string(p_Depth), p_Depth + 1, p_Indentation + "\t");
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->isPrimitive())
	{
		p_Stream << p_Indentation << "\t\tp_Stream << simdjson::as_json_string(s_Item" << p_Depth << ");" << std::endl;
	}
	else
	{
		p_Stream << p_Indentation << "\t\t" << NormalizeName(s_ArrayType->m_pArrayElementType) << "::WriteSimpleJson(&s_Item" << p_Depth << ", p_Stream);" << std::endl;
	}

	p_Stream << std::endl;
	p_Stream << p_Indentation << "\t\tif (i < " << p_ValueName << ".size() - 1)" << std::endl;
	p_Stream << p_Indentation << "\t\t\tp_Stream << \",\";" << std::endl;

	p_Stream << p_Indentation << "\t}" << std::endl;
	p_Stream << std::endl;
	p_Stream << p_Indentation << "\tp_Stream << \"]\";" << std::endl;
}

void GenerateArraySimpleJsonReader(STypeID* p_ElementType, std::ostream& p_Stream, const std::string& p_ValueName, const std::string& p_ArrayName, int p_Depth = 0, const std::string& p_Indentation = "")
{
	auto s_ArrayType = reinterpret_cast<IArrayType*>(p_ElementType->typeInfo());
	auto s_ArrayTypeName = std::string(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName);
	auto s_NormalizedArrayType = NormalizeName(s_ArrayType->m_pArrayElementType);

	if (s_ArrayType->isFixedArray())
	{
		p_Stream << p_Indentation << "\t{" << std::endl;
		p_Stream << p_Indentation << "\tsize_t s_Index" << p_Depth << " = 0;" << std::endl;
		p_Stream << p_Indentation << "\tfor (simdjson::ondemand::value s_Item" << p_Depth << " : " << p_ArrayName << ")" << std::endl;
		p_Stream << p_Indentation << "\t{" << std::endl;

		if (s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = std::string_view(s_Item" << p_Depth << ");" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isEnum())
		{
			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = static_cast<" << s_NormalizedArrayType << ">(ZHMEnums::GetEnumValueByName(\"" << s_ArrayTypeName << "\", std::string_view(s_Item" << p_Depth << ")));" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isArray() || s_ArrayType->m_pArrayElementType->typeInfo()->isFixedArray())
		{
			GenerateArraySimpleJsonReader(
				s_ArrayType->m_pArrayElementType,
				p_Stream,
				p_ValueName + "[s_Index" + std::to_string(p_Depth) + "]",
				"s_Item" + std::to_string(p_Depth),
				p_Depth + 1,
				p_Indentation + "\t"
			);
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isPrimitive())
		{
			if (s_ArrayTypeName == "char")
				s_ArrayTypeName = "int8";

			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = simdjson::from_json_" << s_ArrayTypeName << "(s_Item" << p_Depth << ");" << std::endl;
		}
		else
		{
			p_Stream << p_Indentation << "\t\t" << s_NormalizedArrayType << "::FromSimpleJson(s_Item" << p_Depth << ", &" << p_ValueName << "[s_Index" << p_Depth << "]);" << std::endl;
		}

		p_Stream << p_Indentation << "\t\t++s_Index" << p_Depth << ";" << std::endl;

		p_Stream << p_Indentation << "\t}" << std::endl;
		p_Stream << p_Indentation << "\t}" << std::endl;
	}
	else
	{
		p_Stream << p_Indentation << "\t{" << std::endl;
		p_Stream << p_Indentation << "\tsimdjson::ondemand::array s_Array" << p_Depth << " = " << p_ArrayName << ";" << std::endl;
		p_Stream << p_Indentation << "\t" << p_ValueName << ".resize(s_Array" << p_Depth << ".count_elements());" << std::endl;
		p_Stream << p_Indentation << "\tsize_t s_Index" << p_Depth << " = 0;" << std::endl;
		p_Stream << std::endl;
		p_Stream << p_Indentation << "\tfor (simdjson::ondemand::value s_Item" << p_Depth << " : s_Array" << p_Depth << ")" << std::endl;
		p_Stream << p_Indentation << "\t{" << std::endl;

		if (s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = std::string_view(s_Item" << p_Depth << ");" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isEnum())
		{
			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = static_cast<" << s_NormalizedArrayType << ">(ZHMEnums::GetEnumValueByName(\"" << s_ArrayTypeName << "\", std::string_view(s_Item" << p_Depth << ")));" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isArray() || s_ArrayType->m_pArrayElementType->typeInfo()->isFixedArray())
		{
			GenerateArraySimpleJsonReader(
				s_ArrayType->m_pArrayElementType,
				p_Stream,
				p_ValueName + "[s_Index" + std::to_string(p_Depth) + "]",
				"s_Item" + std::to_string(p_Depth),
				p_Depth + 1,
				p_Indentation + "\t"
			);
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isPrimitive())
		{
			if (s_ArrayTypeName == "char")
				s_ArrayTypeName = "int8";

			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = simdjson::from_json_" << s_ArrayTypeName << "(s_Item" << p_Depth << ");" << std::endl;
		}
		else
		{
			p_Stream << p_Indentation << "\t\t" << s_NormalizedArrayType << "::FromSimpleJson(s_Item" << p_Depth << ", &" << p_ValueName << "[s_Index" << p_Depth << "]);" << std::endl;
		}

		p_Stream << p_Indentation << "\t\t++s_Index" << p_Depth << ";" << std::endl;

		p_Stream << p_Indentation << "\t}" << std::endl;
		p_Stream << p_Indentation << "\t}" << std::endl;
	}
}

void CodeGen::GeneratePropertyNamesFiles()
{
	WriteFileHeader(m_PropertyNamesHeaderFile);
	m_PropertyNamesHeaderFile << "#pragma once" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "#include <cstdint>" << std::endl;
	m_PropertyNamesHeaderFile << "#include <unordered_map>" << std::endl;
	m_PropertyNamesHeaderFile << "#include <vector>" << std::endl;
	m_PropertyNamesHeaderFile << "#include <string>" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "#include <ZHM/Hash.h>" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "struct ZHMPropertyRegistrar;" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "class ZHMProperties" << std::endl;
	m_PropertyNamesHeaderFile << "{" << std::endl;
	m_PropertyNamesHeaderFile << "public:" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic std::string PropertyToString(uint32_t p_PropertyId);" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic std::string_view PropertyToStringView(uint32_t p_PropertyId);" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "private:" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic void RegisterProperties();" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic std::unordered_map<uint32_t, std::string_view>* g_Properties;" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic const uint8_t g_PropertiesData[];" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic const size_t g_PropertiesDataSize;" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic const size_t g_PropertiesCount;" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic const uint8_t g_CustomPropertiesData[];" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic const size_t g_CustomPropertiesDataSize;" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic const size_t g_CustomPropertiesCount;" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "\tfriend class ZHMPropertyRegistrar;" << std::endl;
	m_PropertyNamesHeaderFile << "};" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "struct ZHMPropertyRegistrar" << std::endl;
	m_PropertyNamesHeaderFile << "{" << std::endl;
	m_PropertyNamesHeaderFile << "\tZHMPropertyRegistrar()" << std::endl;
	m_PropertyNamesHeaderFile << "\t{" << std::endl;
	m_PropertyNamesHeaderFile << "\t\tZHMProperties::RegisterProperties();" << std::endl;
	m_PropertyNamesHeaderFile << "\t}" << std::endl;
	m_PropertyNamesHeaderFile << "};" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "extern ZHMPropertyRegistrar g_PropertyRegistrar;" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;

	WriteFileHeader(m_PropertyNamesSourceFile);
	m_PropertyNamesSourceFile << "#include \"ZHMProperties.h\"" << std::endl;
	m_PropertyNamesSourceFile << "#include <Util/BinaryStreamReader.h>" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "std::unordered_map<uint32_t, std::string_view>* ZHMProperties::g_Properties = nullptr;" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "std::string ZHMProperties::PropertyToString(uint32_t p_PropertyId)" << std::endl;
	m_PropertyNamesSourceFile << "{" << std::endl;
	m_PropertyNamesSourceFile << "\tauto it = g_Properties->find(p_PropertyId);" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\tif (it == g_Properties->end())" << std::endl;
	m_PropertyNamesSourceFile << "\t\treturn \"\";" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\treturn std::string(it->second);" << std::endl;
	m_PropertyNamesSourceFile << "}" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "std::string_view ZHMProperties::PropertyToStringView(uint32_t p_PropertyId)" << std::endl;
	m_PropertyNamesSourceFile << "{" << std::endl;
	m_PropertyNamesSourceFile << "\tauto it = g_Properties->find(p_PropertyId);" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\tif (it == g_Properties->end())" << std::endl;
	m_PropertyNamesSourceFile << "\t\treturn \"\";" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\treturn it->second;" << std::endl;
	m_PropertyNamesSourceFile << "}" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "void ZHMProperties::RegisterProperties()" << std::endl;
	m_PropertyNamesSourceFile << "{" << std::endl;
	m_PropertyNamesSourceFile << "\tg_Properties = new std::unordered_map<uint32_t, std::string_view>();" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\tBinaryStreamReader s_PropertyReader(g_PropertiesData, g_PropertiesDataSize);" << std::endl;
	m_PropertyNamesSourceFile << "\tBinaryStreamReader s_CustomPropertyReader(g_CustomPropertiesData, g_CustomPropertiesDataSize);" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\tfor (size_t i = 0; i < g_PropertiesCount; ++i)" << std::endl;
	m_PropertyNamesSourceFile << "\t{" << std::endl;
	m_PropertyNamesSourceFile << "\t\tconst auto s_PropertyId = s_PropertyReader.Read<uint32_t>();" << std::endl;
	m_PropertyNamesSourceFile << "\t\t(*g_Properties)[s_PropertyId] = s_PropertyReader.ReadShortStringView();" << std::endl;
	m_PropertyNamesSourceFile << "\t}" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\tfor (size_t i = 0; i < g_CustomPropertiesCount; ++i)" << std::endl;
	m_PropertyNamesSourceFile << "\t{" << std::endl;
	m_PropertyNamesSourceFile << "\t\tconst auto s_PropertyId = s_CustomPropertyReader.Read<uint32_t>();" << std::endl;
	m_PropertyNamesSourceFile << "\t\t(*g_Properties)[s_PropertyId] = s_CustomPropertyReader.ReadShortStringView();" << std::endl;
	m_PropertyNamesSourceFile << "\t}" << std::endl;
	m_PropertyNamesSourceFile << "}" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "ZHMPropertyRegistrar g_PropertyRegistrar = ZHMPropertyRegistrar();" << std::endl;
	m_PropertyNamesSourceFile << std::endl;

	for (auto& s_Property : m_PropertyNames)
	{
		m_PropertyNamesTextFile << s_Property << std::endl;
	}
}

void CodeGen::GenerateEnumsFiles()
{
	WriteFileHeader(m_EnumsHeaderFile);
	m_EnumsHeaderFile << "#pragma once" << std::endl;
	m_EnumsHeaderFile << std::endl;
	m_EnumsHeaderFile << "#include <cstdint>" << std::endl;
	m_EnumsHeaderFile << "#include <unordered_map>" << std::endl;
	m_EnumsHeaderFile << "#include <string>" << std::endl;
	m_EnumsHeaderFile << std::endl;
	m_EnumsHeaderFile << "class ZHMEnums" << std::endl;
	m_EnumsHeaderFile << "{" << std::endl;
	m_EnumsHeaderFile << "private:" << std::endl;
	m_EnumsHeaderFile << "\tstruct EnumRegistrar { EnumRegistrar() { RegisterEnums(); } };" << std::endl;
	m_EnumsHeaderFile << "\tstatic std::unordered_map<std::string, std::unordered_map<int32_t, std::string>>* g_Enums;" << std::endl;
	m_EnumsHeaderFile << "\tstatic EnumRegistrar g_Registrar;" << std::endl;
	m_EnumsHeaderFile << "\tstatic void RegisterEnums();" << std::endl;
	m_EnumsHeaderFile << std::endl;
	m_EnumsHeaderFile << "public:" << std::endl;
	m_EnumsHeaderFile << "\tstatic std::string GetEnumValueName(const std::string& p_TypeName, int32_t p_Value);" << std::endl;
	m_EnumsHeaderFile << "\tstatic int32_t GetEnumValueByName(const std::string& p_TypeName, std::string_view p_Name);" << std::endl;
	m_EnumsHeaderFile << "\tstatic bool IsTypeNameEnum(const std::string& p_TypeName);" << std::endl;
	m_EnumsHeaderFile << "};" << std::endl;

	WriteFileHeader(m_EnumsSourceFile);
	m_EnumsSourceFile << "#include \"ZHMEnums.h\"" << std::endl;
	m_EnumsSourceFile << "#include <ZHM/ZHMTypeInfo.h>" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "std::unordered_map<std::string, std::unordered_map<int32_t, std::string>>* ZHMEnums::g_Enums = nullptr;" << std::endl;
	m_EnumsSourceFile << "ZHMEnums::EnumRegistrar ZHMEnums::g_Registrar;" << std::endl;
	m_EnumsSourceFile << std::endl;

	m_EnumsSourceFile << "std::string ZHMEnums::GetEnumValueName(const std::string& p_TypeName, int32_t p_Value)" << std::endl;
	m_EnumsSourceFile << "{" << std::endl;
	m_EnumsSourceFile << "\tauto s_EnumIt = g_Enums->find(p_TypeName);" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tif (s_EnumIt == g_Enums->end())" << std::endl;
	m_EnumsSourceFile << "\t\treturn \"\";" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tauto s_ValueIt = s_EnumIt->second.find(p_Value);" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tif (s_ValueIt == s_EnumIt->second.end())" << std::endl;
	m_EnumsSourceFile << "\t\treturn \"\";" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\treturn s_ValueIt->second;" << std::endl;
	m_EnumsSourceFile << "}" << std::endl;
	m_EnumsSourceFile << std::endl;

	m_EnumsSourceFile << "int32_t ZHMEnums::GetEnumValueByName(const std::string& p_TypeName, std::string_view p_Name)" << std::endl;
	m_EnumsSourceFile << "{" << std::endl;
	m_EnumsSourceFile << "\tauto s_EnumIt = g_Enums->find(p_TypeName);" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tif (s_EnumIt == g_Enums->end())" << std::endl;
	m_EnumsSourceFile << "\t\treturn 0;" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tfor (auto s_Pair : s_EnumIt->second)" << std::endl;
	m_EnumsSourceFile << "\t\tif (s_Pair.second == p_Name)" << std::endl;
	m_EnumsSourceFile << "\t\t\treturn s_Pair.first;" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\treturn 0;" << std::endl;
	m_EnumsSourceFile << "}" << std::endl;
	m_EnumsSourceFile << std::endl;

	m_EnumsSourceFile << "bool ZHMEnums::IsTypeNameEnum(const std::string& p_TypeName)" << std::endl;
	m_EnumsSourceFile << "{" << std::endl;
	m_EnumsSourceFile << "\treturn g_Enums->find(p_TypeName) != g_Enums->end();" << std::endl;
	m_EnumsSourceFile << "}" << std::endl;
	m_EnumsSourceFile << std::endl;

	m_EnumsSourceFile << "void ZHMEnums::RegisterEnums()" << std::endl;
	m_EnumsSourceFile << "{" << std::endl;
	m_EnumsSourceFile << "\tg_Enums = new std::unordered_map<std::string, std::unordered_map<int32_t, std::string>>();" << std::endl;
	m_EnumsSourceFile << std::endl;

	for (auto& s_Enum : m_Enums)
	{
		m_EnumsSourceFile << "\t(*g_Enums)[\"" << s_Enum.first << "\"] = {" << std::endl;

		for (auto& s_Value : s_Enum.second)
		{
			m_EnumsSourceFile << "\t\t{ " << std::to_string(s_Value.first) << ", \"" << s_Value.second << "\" }," << std::endl;
		}

		m_EnumsSourceFile << "\t};" << std::endl;
		m_EnumsSourceFile << std::endl;
	}

	m_EnumsSourceFile << "}" << std::endl;
	m_EnumsSourceFile << std::endl;
}

std::string CodeGen::DemangleRTTIName(const std::string& p_MangledName)
{
	if (p_MangledName.empty())
		return "";

	// MSVC mangled names start with a decoration character (usually '.')
	// Skip it before demangling
	const char* s_NameToDemangle = p_MangledName.c_str();
	if (s_NameToDemangle[0] == '.' || s_NameToDemangle[0] == '?')
		s_NameToDemangle++;

	char s_Buffer[4096];
	__unDName(s_Buffer, s_NameToDemangle, sizeof(s_Buffer), malloc, free, 0x2800);

	std::string s_Result(s_Buffer);

	// Strip common prefixes from demangled output
	if (s_Result.substr(0, 6) == "class ")
		s_Result = s_Result.substr(6);
	else if (s_Result.substr(0, 7) == "struct ")
		s_Result = s_Result.substr(7);
	else if (s_Result.substr(0, 5) == "enum ")
		s_Result = s_Result.substr(5);

	// Convert C++ namespace separator (::) to ZHM dot separator (.)
	size_t s_Pos = 0;
	while ((s_Pos = s_Result.find("::", s_Pos)) != std::string::npos)
	{
		s_Result.replace(s_Pos, 2, ".");
		s_Pos += 1;
	}

	return s_Result;
}

void CodeGen::GenerateRlClassHeader(const std::shared_ptr<TreeNode>& p_Node, const std::string& p_Indent)
{
	// If this is not a RL type, just print a dummy instead.
	// We also do that if any of our dependencies are not RL types.
	bool s_IsRlType = p_Node->ResourceLibType;

	if (s_IsRlType)
	{
		for (const auto& s_Dependency : p_Node->Dependencies)
		{
			if (m_TypeNodesByName.contains(s_Dependency) && !m_TypeNodesByName[s_Dependency]->ResourceLibType)
			{
				s_IsRlType = false;
				break;
			}
		}
	}

	if (!s_IsRlType)
	{
		GenerateDummyClass(p_Node, p_Indent, EOutputTarget::RlOnly);
		return;
	}

	auto s_Type = reinterpret_cast<IClassType*>(p_Node->TypeData->typeInfo());

	// We only care about struct types basically.
	// But we still need to generate a dummy class for types with interfaces/base classes
	// so that nested types (like enums) are still written.
	if (s_Type->m_nInterfaceCount > 0 || s_Type->m_nBaseClassCount > 0)
	{
		GenerateDummyClass(p_Node, p_Indent, EOutputTarget::RlOnly);
		return;
	}

	auto& s_HeaderStream = m_ReflectiveClassesHeaderFile;

	std::string s_TypeName = s_Type->m_pTypeName;

	// We skip this since it uses map types that I don't feel like implementing and it doesn't
	// exist in game data anyway. Probably tool-only.
	/*if (s_TypeName == "SEntityPropertyDescriptor" || s_TypeName == "SEntityTypeDescriptor")
		return;*/

	if (s_TypeName.find_first_of('<') != std::string::npos)
	{
		printf("Tried generating code for a templated type %s. Skipping.\n", s_TypeName.c_str());
		return;
	}

	// Make sure we have typeinfo for all properties.
	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		if (!s_Type->m_pProperties[i].m_pType->typeInfo())
		{
			printf("Could not get typeinfo for property %s in type %s.\n", s_Type->m_pProperties[i].m_pName, s_TypeName.c_str());
			return;
		}

		if (s_Type->m_pProperties[i].m_pType->typeInfo()->m_pTypeName == std::string("TArray"))
		{
			printf("TArray property %s in type %s.\n", s_Type->m_pProperties[i].m_pName, s_TypeName.c_str());
			return;
		}
	}

	GenerateRlClassSource(p_Node);

	s_HeaderStream << p_Indent << "// Size: 0x" << std::hex << std::uppercase << s_Type->m_nTypeSize << std::dec << std::endl;
	s_HeaderStream << p_Indent << "class /*alignas(" << static_cast<int>(s_Type->m_nTypeAlignment) << ")*/ " << p_Node->Name;
	s_HeaderStream << p_Indent << "{" << std::endl;
	s_HeaderStream << p_Indent << "public:" << std::endl;

	for (auto& s_Node : p_Node->SortedChildren)
	{
		GenerateCode(s_Node, p_Indent + "\t", EOutputTarget::RlOnly);
	}

	if (!p_Node->SortedChildren.empty())
	{
		s_HeaderStream << std::endl;
		s_HeaderStream << p_Indent << "public:" << std::endl;
	}

	s_HeaderStream << p_Indent << "\tstatic ZHMTypeInfo TypeInfo;" << std::endl;
	s_HeaderStream << p_Indent << "\tstatic void WriteSimpleJson(void* p_Object, std::ostream& p_Stream);" << std::endl;
	s_HeaderStream << p_Indent << "\tstatic void FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target);" << std::endl;
	s_HeaderStream << p_Indent << "\tstatic void Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset);" << std::endl;
	s_HeaderStream << p_Indent << "\tstatic bool Equals(void* p_Left, void* p_Right);" << std::endl;
	s_HeaderStream << p_Indent << "\tstatic void Destroy(void* p_Object);" << std::endl;
	s_HeaderStream << std::endl;
	s_HeaderStream << p_Indent << "\tbool operator==(const " << p_Node->Name << "& p_Other) const;" << std::endl;
	s_HeaderStream << p_Indent << "\tbool operator!=(const " << p_Node->Name << "& p_Other) const { return !(*this == p_Other); }" << std::endl;
	s_HeaderStream << std::endl;

	uintptr_t s_CurrentOffset = 0;

	if (s_Type->m_nPropertyCount > 0)
		s_CurrentOffset = s_Type->m_pProperties[0].m_nOffset;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];

		std::string s_PropName = s_Prop.m_pName;

		m_PropertyNames.insert(s_PropName);

		uintptr_t s_ExpectedOffset = s_Prop.m_nOffset;

		if (s_CurrentOffset < s_ExpectedOffset)
		{
			// Add padding.
			uintptr_t s_PaddingBytes = s_ExpectedOffset - s_CurrentOffset;
			s_HeaderStream << p_Indent << "\tuint8_t _pad" << std::hex << s_CurrentOffset << std::dec << "[" << s_PaddingBytes << "] {};" << std::endl;
			s_CurrentOffset = s_ExpectedOffset;
		}

		s_HeaderStream << p_Indent << "\t" << NormalizeName(s_Prop.m_pType) << " " << s_PropName << ";";
		s_HeaderStream << " // 0x" << std::hex << std::uppercase << s_Prop.m_nOffset << std::dec << std::endl;

		s_CurrentOffset += s_Prop.m_pType->typeInfo()->m_nTypeSize;
	}

	if (s_CurrentOffset < s_Type->m_nTypeSize)
	{
		// Add padding.
		uintptr_t s_PaddingBytes = s_Type->m_nTypeSize - s_CurrentOffset;
		s_HeaderStream << p_Indent << "\tuint8_t _pad" << std::hex << s_CurrentOffset << std::dec << "[" << s_PaddingBytes << "] {};" << std::endl;
		s_CurrentOffset = s_Type->m_nTypeSize;
	}

	s_HeaderStream << p_Indent << "};" << std::endl;

	s_HeaderStream << std::endl;
}

void CodeGen::GenerateRlClassSource(const std::shared_ptr<TreeNode>& p_Node)
{
	auto& s_SourceStream = m_ReflectiveClassesSourceFile;

	auto s_TypeInfo = p_Node->TypeData->typeInfo();
	auto s_Type = reinterpret_cast<IClassType*>(s_TypeInfo);

	// Ensure all properties have typeinfo;
	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		if (!s_Type->m_pProperties[i].m_pType->typeInfo())
		{
			printf("Could not get typeinfo for property %s in type %s.\n", s_Type->m_pProperties[i].m_pName, s_TypeInfo->m_pTypeName);
			return;
		}
	}

	std::string s_TypeName = s_Type->m_pTypeName;
	std::string s_NormalizedName = p_Node->FullName();

	s_SourceStream << "ZHMTypeInfo " << s_NormalizedName << "::TypeInfo = ZHMTypeInfo(\"" << s_TypeName << "\", sizeof(" << s_NormalizedName << "), alignof(" << s_NormalizedName << "), " << s_NormalizedName << "::WriteSimpleJson, " << s_NormalizedName << "::FromSimpleJson, " << s_NormalizedName << "::Serialize, " << s_NormalizedName << "::Equals, " << s_NormalizedName << "::Destroy);" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "void " << s_NormalizedName << "::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)" << std::endl;
	s_SourceStream << "{" << std::endl;

	// TODO: Support for inherited classes.

	s_SourceStream << "\tauto* s_Object = reinterpret_cast<" << s_NormalizedName << "*>(p_Object);" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "\tp_Stream << \"{\";" << std::endl;
	s_SourceStream << std::endl;

	/*s_SourceStream << "\tp_Stream << \"\\\"$id\\\":\" << simdjson::get_obj_id(s_Object)";

	if (s_Type->m_nPropertyCount > 0)
		s_SourceStream << " << \",\"";

	s_SourceStream << ";";
	s_SourceStream << std::endl;*/

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];
		auto s_PropTypeName = std::string(s_Prop.m_pType->typeInfo()->m_pTypeName);

		if (s_PropTypeName == std::string("TArray"))
			continue;

		std::string s_PropName = s_Prop.m_pName;

		s_SourceStream << "\tp_Stream << simdjson::as_json_string(\"" << s_PropName << "\") << \":\";" << std::endl;

		if (s_Prop.m_pType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			s_SourceStream << "\tp_Stream << simdjson::as_json_string(s_Object->" << s_PropName << ");" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->isEnum())
		{
			s_SourceStream << "\tp_Stream << simdjson::as_json_string(ZHMEnums::GetEnumValueName(\"" << s_PropTypeName << "\", static_cast<int>(s_Object->" << s_PropName << ")));" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->isArray() || s_Prop.m_pType->typeInfo()->isFixedArray())
		{
			GenerateArraySimpleJsonWriter(s_Prop.m_pType, s_SourceStream, "s_Object->" + s_PropName);
		}
		else if (s_Prop.m_pType->typeInfo()->isPrimitive())
		{
			if (s_PropName == "nPropertyID")
			{
				s_SourceStream << "\t{" << std::endl;
				s_SourceStream << "\t\tauto s_PropertyName = ZHMProperties::PropertyToString(s_Object->" << s_PropName << ");" << std::endl;
				s_SourceStream << std::endl;
				s_SourceStream << "\t\tif (s_PropertyName.size() == 0)" << std::endl;
				s_SourceStream << "\t\t\tp_Stream << simdjson::as_json_string(s_Object->" << s_PropName << ");" << std::endl;
				s_SourceStream << "\t\telse" << std::endl;
				s_SourceStream << "\t\t\tp_Stream << simdjson::as_json_string(s_PropertyName);" << std::endl;
				s_SourceStream << "\t}" << std::endl;
			}
			else
			{
				s_SourceStream << "\tp_Stream << simdjson::as_json_string(s_Object->" << s_PropName << ");" << std::endl;
			}
		}
		else
		{
			s_SourceStream << "\t" << NormalizeName(s_Prop.m_pType) << "::WriteSimpleJson(&s_Object->" << s_PropName << ", p_Stream);" << std::endl;
		}

		if (i < s_Type->m_nPropertyCount - 1)
		{
			s_SourceStream << "\tp_Stream << \",\";" << std::endl;
		}

		s_SourceStream << std::endl;
	}

	s_SourceStream << "\tp_Stream << \"}\";" << std::endl;

	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "void " << s_NormalizedName << "::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)" << std::endl;
	s_SourceStream << "{" << std::endl;

	s_SourceStream << "\tauto s_Object = reinterpret_cast<" << s_NormalizedName << "*>(p_Target);" << std::endl;
	s_SourceStream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];
		auto s_PropTypeName = std::string(s_Prop.m_pType->typeInfo()->m_pTypeName);

		if (s_PropTypeName == std::string("TArray"))
			continue;

		std::string s_PropName = s_Prop.m_pName;

		if (s_Prop.m_pType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			s_SourceStream << "\ts_Object->" << s_PropName << " = std::string_view(p_Document[\"" << s_PropName << "\"]);" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->isEnum())
		{
			s_SourceStream << "\ts_Object->" << s_PropName << " = static_cast<" << NormalizeName(s_Prop.m_pType) << ">(ZHMEnums::GetEnumValueByName(\"" << s_PropTypeName << "\", std::string_view(p_Document[\"" << s_PropName << "\"])));" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->isArray() || s_Prop.m_pType->typeInfo()->isFixedArray())
		{
			GenerateArraySimpleJsonReader(s_Prop.m_pType, s_SourceStream, "s_Object->" + s_PropName, "p_Document[\"" + s_PropName + "\"]");
		}
		else if (s_Prop.m_pType->typeInfo()->isPrimitive())
		{
			if (s_PropTypeName == "char")
				s_PropTypeName = "int8";

			if (s_PropName == std::string("nPropertyID"))
			{
				s_SourceStream << "\tif (p_Document[\"" << s_PropName << "\"].type() == simdjson::ondemand::json_type::string)" << std::endl;
				s_SourceStream << "\t\ts_Object->" << s_PropName << " = Hash::Crc32(std::string_view(p_Document[\"" << s_PropName << "\"]));" << std::endl;
				s_SourceStream << "\telse" << std::endl;
				s_SourceStream << "\t\ts_Object->" << s_PropName << " = simdjson::from_json_uint32(p_Document[\"" << s_PropName << "\"]);" << std::endl;
			}
			else
			{
				s_SourceStream << "\ts_Object->" << s_PropName << " = simdjson::from_json_" << s_PropTypeName << "(p_Document[\"" << s_PropName << "\"]);" << std::endl;
			}
		}
		else
		{
			s_SourceStream << "\t" << NormalizeName(s_Prop.m_pType) << "::FromSimpleJson(p_Document[\"" << s_PropName << "\"], &s_Object->" << s_PropName << ");" << std::endl;
		}

		s_SourceStream << std::endl;
	}

	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "void " << s_NormalizedName << "::Serialize(void* p_Object, ZHMSerializer& p_Serializer, zhmptr_t p_OwnOffset)" << std::endl;
	s_SourceStream << "{" << std::endl;
	s_SourceStream << "\tauto* s_Object = reinterpret_cast<" << s_NormalizedName << "*>(p_Object);" << std::endl;
	s_SourceStream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];
		auto s_PropTypeName = std::string(s_Prop.m_pType->typeInfo()->m_pTypeName);

		if (s_PropTypeName == std::string("TArray"))
			continue;

		std::string s_PropName = s_Prop.m_pName;

		if ((!s_Prop.m_pType->typeInfo()->isPrimitive() && !s_Prop.m_pType->typeInfo()->isEnum()) || s_PropTypeName == "ZString")
		{
			s_SourceStream << "\t" << NormalizeName(s_Prop.m_pType) << "::Serialize(&s_Object->" << s_PropName << ", p_Serializer, p_OwnOffset + offsetof(" << s_NormalizedName << ", " << s_PropName << "));" << std::endl;
		}
	}

	if (s_TypeName == "ZRuntimeResourceID")
		s_SourceStream << "\t" << "p_Serializer.RegisterRuntimeResourceId(p_OwnOffset);" << std::endl;

	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "bool " << s_NormalizedName << "::Equals(void* p_Left, void* p_Right)" << std::endl;
	s_SourceStream << "{" << std::endl;
	s_SourceStream << "\tauto* s_Left = reinterpret_cast<" << s_NormalizedName << "*>(p_Left);" << std::endl;
	s_SourceStream << "\tauto* s_Right = reinterpret_cast<" << s_NormalizedName << "*>(p_Right);" << std::endl;
	s_SourceStream << std::endl;
	s_SourceStream << "\treturn *s_Left == *s_Right;" << std::endl;
	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "bool " << s_NormalizedName << "::operator==(const " << s_NormalizedName << "& p_Other) const" << std::endl;
	s_SourceStream << "{" << std::endl;

	s_SourceStream << "\tif constexpr (!ZHMTypeSupportsEquality_v<" << s_NormalizedName << ">)" << std::endl;
	s_SourceStream << "\t\treturn false;" << std::endl;
	s_SourceStream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];
		auto s_PropTypeName = std::string(s_Prop.m_pType->typeInfo()->m_pTypeName);

		if (s_PropTypeName == std::string("TArray"))
			continue;

		std::string s_PropName = s_Prop.m_pName;

		s_SourceStream << "\tif (" << s_PropName << " != p_Other." << s_PropName << ") return false;" << std::endl;
	}

	s_SourceStream << std::endl;
	s_SourceStream << "\treturn true;" << std::endl;

	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "void " << s_NormalizedName << "::Destroy(void* p_Object)" << std::endl;
	s_SourceStream << "{" << std::endl;
	s_SourceStream << "\tauto* s_Object = reinterpret_cast<" << s_NormalizedName << "*>(p_Object);" << std::endl;
	s_SourceStream << "\ts_Object->~" << p_Node->Name << "();" << std::endl;
	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;
}

void CodeGen::GenerateEnum(const std::shared_ptr<TreeNode>& p_Node, const std::string& p_Indent, std::ofstream& p_Stream)
{
	auto s_Type = reinterpret_cast<IEnumType*>(p_Node->TypeData->typeInfo());
	std::map<int, std::string> s_Enum;

	p_Stream << p_Indent << "// Size: 0x" << std::hex << std::uppercase << s_Type->m_nTypeSize << std::dec << std::endl;
	p_Stream << p_Indent << "enum class " << p_Node->Name << " : " << GetEnumUnderlyingType(p_Node->TypeData) << std::endl;
	p_Stream << p_Indent << "{" << std::endl;

	// TODO: Remove this. Temporary workaround until I figure out what's going on.
	s_Type->m_entries.m_pAllocationEnd = s_Type->m_entries.m_pEnd;
	for (auto it = s_Type->m_entries.begin(); it != s_Type->m_entries.end(); ++it)
	{
		s_Enum[it->m_nValue] = it->m_pName;
		p_Stream << p_Indent << "\t" << it->m_pName << " = " << std::dec << it->m_nValue << "," << std::endl;
	}

	p_Stream << p_Indent << "};" << std::endl << std::endl;

	if (!p_Node->SortedChildren.empty()) {
		printf("Enum %s has children. This is unexpected.\n", p_Node->Name.c_str());
	}

	m_Enums[s_Type->m_pTypeName] = s_Enum;
}

void CodeGen::GenerateSdkClass(const std::shared_ptr<TreeNode>& p_Node, const std::string& p_Indent)
{
	auto s_Type = reinterpret_cast<IClassType*>(p_Node->TypeData->typeInfo());

	// Look up RTTI for this type
	auto s_RttiIt = m_RttiByTypeName.find(s_Type->m_pTypeName);

	if (s_RttiIt == m_RttiByTypeName.end())
	{
		printf("Could not find RTTI for type %s. Skipping.\n", p_Node->Name.c_str());
		return;
	}

	// TODO: Handle structs

	auto s_VTable = s_RttiIt->second;

	m_SDKHeader << p_Indent << "// Size: 0x" << std::hex << std::uppercase << s_Type->m_nTypeSize << std::dec << std::endl;
	m_SDKHeader << p_Indent << "class " << p_Node->Name;

	// Generate inheritance based on RTTI (ignore ZHM base class info)
	auto s_ClassDesc = s_VTable->Rtti->ClassDescriptor;
	bool s_HasBases = false;
	size_t s_InheritedVTableSize = 0;  // Number of inherited vtable entries

	// RTTI BaseClasses contains the full hierarchy:
	// [0] = self
	// [1] = first direct base
	// [1+1..1+NumContainedBases[1]] = ancestors of first direct base
	// [next] = second direct base (if any)
	// etc.
	// We use NumContainedBases to skip over indirect ancestors and only include direct bases.
	for (size_t i = 1; i < s_ClassDesc->BaseClasses.size(); )
	{
		auto s_Base = s_ClassDesc->BaseClasses[i];
		if (!s_Base || !s_Base->TypeDescriptor)
		{
			i++;
			continue;
		}

		std::string s_BaseName = DemangleRTTIName(s_Base->TypeDescriptor->Name);
		if (s_BaseName.empty())
		{
			i++;
			continue;
		}

		// Look up the base class's vtable to get its size (for first direct base only)
		if (!s_HasBases)
		{
			auto s_BaseRttiIt = m_RttiByTypeName.find(s_BaseName);
			if (s_BaseRttiIt != m_RttiByTypeName.end() && s_BaseRttiIt->second)
			{
				s_InheritedVTableSize = s_BaseRttiIt->second->Items.size();
			}
		}

		if (!s_HasBases)
		{
			m_SDKHeader << " :" << std::endl;
			s_HasBases = true;
		}
		else
		{
			m_SDKHeader << "," << std::endl;
		}

		// Use NormalizeTypeName for base class reference
		m_SDKHeader << p_Indent << "\tpublic " << s_BaseName;

		// Skip over this base's ancestors (they're not direct bases of our class)
		i += 1 + s_Base->NumContainedBases;
	}

	m_SDKHeader << std::endl;
	m_SDKHeader << p_Indent << "{" << std::endl;
	m_SDKHeader << p_Indent << "public:" << std::endl;

	// Write children first.
	for (auto& s_Child : p_Node->SortedChildren)
	{
		GenerateCode(s_Child, p_Indent + "\t", EOutputTarget::SdkOnly);
	}

	if (!p_Node->SortedChildren.empty())
	{
		m_SDKHeader << std::endl;
		m_SDKHeader << p_Indent << "public:" << std::endl;
	}

	// Generate placeholder virtual methods from vtable (only NEW methods, not inherited)
	for (size_t i = s_InheritedVTableSize; i < s_VTable->Items.size(); ++i)
	{
		size_t s_VTableOffset = i * sizeof(uintptr_t);
		m_SDKHeader << p_Indent << "\tvirtual void " << p_Node->Name << "_unk0x";
		m_SDKHeader << std::hex << std::uppercase << s_VTableOffset << std::dec << "() = 0;" << std::endl;
	}

	if (!s_VTable->Items.empty())
		m_SDKHeader << std::endl;

	// Generate properties using ZHM_PROPERTY macro
	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];

		if (!s_Prop.m_pType->typeInfo())
			continue;

		std::string s_PropName = s_Prop.m_pName;
		m_PropertyNames.insert(s_PropName);

		std::string s_PropTypeName = NormalizeName(s_Prop.m_pType);

		m_SDKHeader << p_Indent << "\tZHM_PROPERTY(" << s_PropTypeName << ", " << s_PropName;
		m_SDKHeader << ", 0x" << std::hex << std::uppercase << s_Prop.m_nOffset << std::dec << ");" << std::endl;
	}

	// Generate input pins using ZHM_PIN_INPUT macro
	for (uint16_t i = 0; i < s_Type->m_nInputCount; ++i)
	{
		auto s_Input = s_Type->m_pInputs[i];
		m_SDKHeader << p_Indent << "\tZHM_PIN_INPUT(0x" << std::hex << std::uppercase << s_Input.m_nPinID << std::dec << ");" << std::endl;
	}

	m_SDKHeader << p_Indent << "};" << std::endl << std::endl;
}

void CodeGen::GenerateDummyClass(const std::shared_ptr<TreeNode> &p_Node, const std::string &p_Indent, EOutputTarget p_Target)
{
	// We only write the RL code if there's children. Otherwise it's just bloat.
	const bool s_HasChildren = !p_Node->SortedChildren.empty();
	const bool s_WriteSdk = (p_Target == EOutputTarget::Both || p_Target == EOutputTarget::SdkOnly);
	const bool s_WriteRl = (p_Target == EOutputTarget::Both || p_Target == EOutputTarget::RlOnly) && s_HasChildren;

	if (s_WriteSdk)
	{
		m_SDKHeader << p_Indent << "class " << p_Node->Name << std::endl;
		m_SDKHeader << p_Indent << "{" << std::endl;
		m_SDKHeader << p_Indent << "public:" << std::endl;
	}

	if (s_WriteRl)
	{
		m_ReflectiveClassesHeaderFile << p_Indent << "class " << p_Node->Name << std::endl;
		m_ReflectiveClassesHeaderFile << p_Indent << "{" << std::endl;
		m_ReflectiveClassesHeaderFile << p_Indent << "public:" << std::endl;
	}

	if (s_HasChildren || s_WriteSdk)
	{
		for (auto& s_Child : p_Node->SortedChildren)
		{
			GenerateCode(s_Child, p_Indent + "\t", p_Target);
		}
	}

	if (s_WriteSdk)
		m_SDKHeader << p_Indent << "};" << std::endl << std::endl;

	if (s_WriteRl)
		m_ReflectiveClassesHeaderFile << p_Indent << "};" << std::endl << std::endl;
}

void CodeGen::GenerateCode(const std::shared_ptr<TreeNode>& p_Node, const std::string &p_Indent, EOutputTarget p_Target)
{
	if (p_Node->ShouldSkip || p_Node->Name == "ZRepositoryID")
	{
		printf("Skipping code generation for node %s.\n", p_Node->Name.c_str());
		return;
	}

	const bool s_WriteSdk = (p_Target == EOutputTarget::Both || p_Target == EOutputTarget::SdkOnly);
	const bool s_WriteRl = (p_Target == EOutputTarget::Both || p_Target == EOutputTarget::RlOnly);

	if (p_Node->Type == TreeNode::ENodeType::Namespace)
	{
		if (s_WriteSdk)
			m_SDKHeader << p_Indent << "namespace " << p_Node->Name << " {" << std::endl;

		if (s_WriteRl)
			m_ReflectiveClassesHeaderFile << p_Indent << "namespace " << p_Node->Name << " {" << std::endl;

		for (auto& s_Child : p_Node->SortedChildren)
		{
			GenerateCode(s_Child, p_Indent + "\t", p_Target);
		}

		if (s_WriteSdk)
			m_SDKHeader << p_Indent << "}" << std::endl << std::endl;

		if (s_WriteRl)
			m_ReflectiveClassesHeaderFile << p_Indent << "}" << std::endl << std::endl;
	}
	else
	{
		if (p_Node->TypeData)
		{
			if (p_Node->TypeData->typeInfo()->isPrimitive())
			{
				printf("Primitive type %s. Skipping generation.\n", p_Node->Name.c_str());
				return;
			}

			if (p_Node->TypeData->typeInfo()->isEnum())
			{
				if (s_WriteSdk)
					GenerateEnum(p_Node, p_Indent, m_SDKHeader);

				if (s_WriteRl)
					GenerateEnum(p_Node, p_Indent, m_ReflectiveClassesHeaderFile);

				return;
			}

			if (!p_Node->TypeData->typeInfo()->isClass()) {
				printf("Type %s is not a class. Skipping generation.\n", p_Node->Name.c_str());
				return;
			}

			if (s_WriteSdk)
				GenerateSdkClass(p_Node, p_Indent);

			if (s_WriteRl)
				GenerateRlClassHeader(p_Node, p_Indent);
		}
		else
		{
			// Generate a dummy class for this type.
			GenerateDummyClass(p_Node, p_Indent, p_Target);
		}
	}
}
